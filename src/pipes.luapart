--[[============================================================
--=
--=  Pipes
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	addDependency, getExistingDependency
	addToQueueRecursively, pokeAndQueueUnqueuedNodeIntoTree, unqueue, unqueueChildrenRecursively, replaceQueuedNode, replaceQueuedNodeAndUnqueueOldTree, cutOutPartOfNodeTree
	errorPipesAreStuck, errorPipesAreInfiniteLooping
	moveToPipe, moveToNextRelevantPipe, moveTreeToNextRelevantPipe, moveChildrenToNextRelevantPipe
	outputDependencyGraph

--============================================================]]



!local OUTPUT_DEPENDENCY_GRAPH = false
local MAX_ERRORS_MESSAGES      = !(DEBUG and 20 or 4) -- @Incomplete: Make this a compiler option.



local !struct"Dependency"{ -- @Cleanup: Rename to something with "wait"?
	{`dependent`,  nil}, -- Queued
	{`dependType`, 0},   -- DEPEND_DECLARATION|DEPEND_MEMBER_DECLARATION|DEPEND_NODE_INFERRED|DEPEND_NODE_INFERRED_FULLY|DEPEND_NODE_EMITTED|DEPEND_STRUCT_MEMBERS_READY|DEPEND_CONSTANT_READY
	{`dependOn`,   nil}, -- string|Queued  (The value depends on what dependType is.)
	{`extraData`,  nil}, -- AstScope|nil
	{`next`,       nil}, -- Dependency  (This is for chaining multiple dependencies.)
}

-- addDependency( state, dependent, DEPEND_DECLARATION,          name [, scope ] )
-- addDependency( state, dependent, DEPEND_MEMBER_DECLARATION,   name, scope )
-- addDependency( state, dependent, DEPEND_NODE_INFERRED,        astNode )
-- addDependency( state, dependent, DEPEND_NODE_INFERRED_FULLY,  astNode )
-- addDependency( state, dependent, DEPEND_NODE_EMITTED,         astNode )
-- addDependency( state, dependent, DEPEND_STRUCT_MEMBERS_READY, structInfo )
-- addDependency( state, dependent, DEPEND_CONSTANT_READY,       constant )
function _G.addDependency(state, dependent, dependType, dependOn, extraData)
	!if DEBUG then
		if dependType == !(DEPEND_DECLARATION) then
			!ASSERT `type(dependOn)  == "string"`
			!ASSERT `extraData == nil or type(extraData) == "table"`
		elseif dependType == !(DEPEND_MEMBER_DECLARATION) then
			!ASSERT `type(dependOn)  == "string"`
			!ASSERT `type(extraData) == "table"`
		elseif !!(CONST_SET{ DEPEND_NODE_INFERRED, DEPEND_NODE_INFERRED_FULLY, DEPEND_NODE_EMITTED, DEPEND_STRUCT_MEMBERS_READY, DEPEND_CONSTANT_READY })[dependType] then
			!ASSERT `type(dependOn)  == "table"`
		else
			errorInternal("%d", dependType)
		end
	!end

	--[[ WARNING: getExistingDependency() takes a lot of time to call here! @Robustness: @Optimize this into O(1) and uncomment.
	if getExistingDependency(state, dependent, dependType, dependOn) then
		!TRACE()

		!ifDEBUG `astPrint(dependent)`
		nodeMessage(io.stderr, state, dependent, "Error", "Pipes", "Internal compiler error: Trying to add dependency twice. (%s)", (DEPEND_TITLES[dependType] or "?"))

		if !!(CONST_SET{ DEPEND_NODE_INFERRED, DEPEND_NODE_INFERRED_FULLY, DEPEND_NODE_EMITTED })[dependType] then
			!ifDEBUG `astPrint(dependOn)`
			nodeMessage(io.stderr, state, dependOn, "Info", "Pipes", "...depending on this.")
		end

		exitFailure()
	end
	--]]

	dependent = dependent.queued

	if !!(CONST_SET{ DEPEND_NODE_INFERRED, DEPEND_NODE_INFERRED_FULLY, DEPEND_NODE_EMITTED })[dependType] then
		assert(dependent ~= dependOn.node)
		dependOn = dependOn.queued or errorInternal(state, dependOn)
	end

	local dependency      = Dependency()
	dependency.dependent  = dependent
	dependency.dependType = dependType
	dependency.dependOn   = dependOn
	dependency.extraData  = extraData

	local waitingOn = dependent.waitingOn
	if waitingOn then
		while waitingOn.next do
			waitingOn = waitingOn.next
		end
		waitingOn.next = dependency
	else
		dependent.waitingOn = dependency
	end

	table.insert(state.dependencies, dependency)

	!if DEBUG then
		--[[
		if debug_onlyInferTypes then
			io.stdout:write("DEPEND ")
			astPrint(dependent)

			io.stdout:write("    ON ", DEPEND_TITLES[dependType], " ")
			if dependType == !(DEPEND_DECLARATION) then
				print(dependOn)
			elseif dependType == !(DEPEND_MEMBER_DECLARATION) then
				print(dependOn)
			elseif dependType == !(DEPEND_NODE_INFERRED) then
				astPrint(dependOn.node)
			elseif dependType == !(DEPEND_NODE_INFERRED_FULLY) then
				astPrint(dependOn.node)
			elseif dependType == !(DEPEND_NODE_EMITTED) then
				astPrint(dependOn.node)
			elseif dependType == !(DEPEND_STRUCT_MEMBERS_READY) then
				print(getFriendlyTypeInfoName(dependOn))
			elseif dependType == !(DEPEND_CONSTANT_READY) then
				print(getFriendlyTypeInfoName(dependOn.valueType), tostring(dependOn.value))
			else
				print("? ("..tostring(dependOn)..")")
			end
		end
		--]]
	!end
end

!(
-- DEPEND_AND_RETURN( dependentCode, dependType, dependOnCode [, extraDataCode, valueToReturnCode ] )
function _G.DEPEND_AND_RETURN(dependentCode, dependType, dependOnCode, extraDataCode, valueToReturnCode)
	__LUA("addDependency(state, ",dependentCode,", ",toLua(dependType),", ",dependOnCode)
	if extraDataCode then
		__LUA(", ",extraDataCode)
	end
	__LUA(") ; return")
	if valueToReturnCode then
		__LUA(" ", valueToReturnCode)
	end
end
)

function _G.getExistingDependency(state, dependent, dependType, dependOn)
	dependent = dependent.queued

	if !!(CONST_SET{ DEPEND_NODE_INFERRED, DEPEND_NODE_INFERRED_FULLY, DEPEND_NODE_EMITTED })[dependType] then
		dependOn = dependOn.queued
	end

	return itemWith3(state.dependencies, "dependent",dependent, "dependType",dependType, "dependOn",dependOn)
end



local !struct"Queued"{
	{`node`,      nil}, -- AstNode
	{`container`, nil}, -- Any table.
	{`key`,       nil}, -- String or integer.
	{`pipe`,      PIPE_NONE},
	{`waitingOn`, nil}, -- Dependency
	{`unqueued`,  false},
}

-- addToQueue( state, node, container=nil, key=nil, pipe )
function _G.addToQueue(state, node, container, key, pipe)
	-- astPrint(node)
	!ASSERT `not node.queued`

	local queued     = Queued()
	queued.node      = node
	queued.container = container
	queued.key       = key
	queued.pipe      = pipe or errorInternal()

	node.queued = queued
	table.insert(state.queueActive, queued)
	table.insert(state.allQueueds,  queued)

	--[[ Make assignment targets in declaration assignment statements wait for their declaration.
	if
		node.nodeType == !(nodeTypes.AstIdentifier)
		and node.declaration
		and node.parent.nodeType == !(nodeTypes.AstAssignment)
		and node.parent.forDeclaration
		and indexOf(node.parent.targets, node)
	then
		local ident = node
		addDependency(state, ident, !(DEPEND_NODE_INFERRED), ident.declaration.name)
	end
	--]]
end

-- addToQueueRecursively( state, topNode [, containerForTopNode, keyForTopNode, pipe=PIPE_INFER ] )
-- Note: Skips AstStaticIf branches and most polymorphic nodes.
do
	local function registerNodesToAddToQueue(state, topNode, nodesToAdd)
		astVisitAllNodes(topNode, function(node)
			nodesToAdd[node] = true

			-- :SelectiveQueuing

			if node.nodeType == !(nodeTypes.AstStaticIf) then
				local staticIf = node
				registerNodesToAddToQueue(state, staticIf.condition, nodesToAdd)
				return !(VISIT_IGNORE_CHILDREN)

			elseif !!(CONST_SET{ nodeTypes.AstLambda, nodeTypes.AstStruct })[node.nodeType] and node.isPolymorphic then
				return !(VISIT_IGNORE_CHILDREN) -- We don't need to queue anything inside polymorphic functions or structs (I think).
			end
		end)
	end

	function _G.addToQueueRecursively(state, topNode, container0, key0, pipe)
		pipe = pipe or !(PIPE_INFER)

		local nodesToAdd = {}
		registerNodesToAddToQueue(state, topNode, nodesToAdd)

		astVisitAllNodesLeavesFirst(topNode, function(node, container, key)
			if nodesToAdd[node] then
				addToQueue(state, node, (container or container0), (key or key0), pipe)
			end
		end)
	end
end

-- addUnqueuedChildrenToQueueRecursively( state, topNode [, pipe=PIPE_INFER ] )
-- Note: Ignores children of already queued nodes.
-- Note: Skips AstStaticIf branches and most polymorphic nodes.
do
	local function registerNodesToAddToQueue(state, topNode, nodesToAdd)
		astVisitAllNodes(topNode, function(node)
			if node == topNode then
				-- void

			elseif node.queued then
				return !(VISIT_IGNORE_CHILDREN)

			else
				nodesToAdd[node] = true

				-- :SelectiveQueuing

				if node.nodeType == !(nodeTypes.AstStaticIf) then
					local staticIf = node
					if not staticIf.condition.queued then
						nodesToAdd[staticIf.condition] = true
						registerNodesToAddToQueue(state, staticIf.condition, nodesToAdd)
					end
					return !(VISIT_IGNORE_CHILDREN)

				elseif !!(CONST_SET{ nodeTypes.AstLambda, nodeTypes.AstStruct })[node.nodeType] and node.isPolymorphic then
					return !(VISIT_IGNORE_CHILDREN) -- We don't need to queue anything inside polymorphic functions or structs (I think).
				end
			end
		end)
	end

	function _G.addUnqueuedChildrenToQueueRecursively(state, topNode, pipe)
		pipe = pipe or !(PIPE_INFER)

		local nodesToAdd = {}
		registerNodesToAddToQueue(state, topNode, nodesToAdd)

		astVisitAllNodesLeavesFirst(topNode, function(node, container, key)
			if nodesToAdd[node] then
				addToQueue(state, node, container, key, pipe)
			end
		end)
	end
end

-- pokeAndQueueUnqueuedNodeIntoTree( state, nodeAtTargetPosition, newNode, containerInNewNode, keyInContainerInNewNode [, pipe=PIPE_INFER ] )
-- newNode will become the new parent for nodeAtTargetPosition.
function _G.pokeAndQueueUnqueuedNodeIntoTree(state, nodeAtTargetPos, newNode, containerInNewNode, keyInNewNode, pipe)
	!ASSERT `not newNode.queued`
	pipe = pipe or !(PIPE_INFER)

	addToQueue(state, newNode, nodeAtTargetPos.queued.container, nodeAtTargetPos.queued.key, pipe)

	-- Replace nodeAtTargetPos with newNode in it's parent.
	nodeAtTargetPos.queued.container[nodeAtTargetPos.queued.key] = newNode

	-- Put nodeAtTargetPos in newNode.
	containerInNewNode[keyInNewNode] = nodeAtTargetPos
	nodeAtTargetPos.parent           = newNode
	nodeAtTargetPos.queued.container = containerInNewNode
	nodeAtTargetPos.queued.key       = keyInNewNode
end

function _G.unqueue(node)
	node.queued.unqueued = true
end

function _G.unqueueChildrenRecursively(state, topNode) -- @Cleanup: Remove state argument.
	astVisitAllNodes(topNode, function(node)
		if node ~= topNode then
			node.queued.unqueued = true
		end
	end)
end

-- Note: nodeOld doesn't have to be queued right now - it just needs a Queued object.
-- Note: No node.parent is changed.
-- (@Cleanup: Sometimes we just want to make use of queued.container/key.)
function _G.replaceQueuedNode(state, nodeOld, nodeNew)
	assert(not nodeNew.queued)

	local queued   = nodeOld.queued or errorInternal()
	queued.node    = nodeNew
	nodeOld.queued = nil
	nodeNew.queued = queued

	if queued.container then
		queued.container[queued.key] = nodeNew
	end

	nodeOld.replacedBy = nodeNew
	nodeNew.replacing  = nodeOld

	!if DEBUG then
		-- [[
		if debug_onlyInferTypes then
			io.stdout:write("replace: ") ; astPrint(nodeOld)
			io.stdout:write("   with: ") ; astPrint(nodeNew)
			-- where(state, nodeOld)
			-- where(state, nodeOld.parent)
		end
		--]]
	!end
end

function _G.replaceQueuedNodeAndUnqueueOldTree(state, nodeOld, nodeNew)
	unqueueChildrenRecursively(state, nodeOld)
	replaceQueuedNode(state, nodeOld, nodeNew)
end

-- Note: We update the parent of childTreeNodeToHookIn here.
function _G.cutOutPartOfNodeTree(state, nodeToRemove, childTreeNodeToHookIn)
	astVisitAllNodes(nodeToRemove, function(node)
		if node ~= nodeToRemove          then  node.queued.unqueued = true      end
		if node == childTreeNodeToHookIn then  return !(VISIT_IGNORE_CHILDREN)  end
	end)

	childTreeNodeToHookIn.queued = nil -- This will be replaced with nodeToRemove.queued in replaceQueuedNode().
	childTreeNodeToHookIn.parent = nodeToRemove.parent

	replaceQueuedNode(state, nodeToRemove, childTreeNodeToHookIn)
end



function _G.moveToPipe(state, node, targetPipe)
	local queued = node.queued
	queued.pipe  = targetPipe
end

-- moveToNextRelevantPipe( state, node [, fromPipe=current ] )
function _G.moveToNextRelevantPipe(state, node, fromPipe)
	fromPipe = fromPipe or node.queued.pipe

	if fromPipe == !(PIPE_INFER) then
		local nodeType = node.nodeType

		if !!(CONST_SET{ nodeTypes.AstLiteral, nodeTypes.AstForeign, nodeTypes.AstTypeInfo })[nodeType] then
			moveToPipe(state, node, !(PIPE_BYTECODE))

		elseif nodeType == !(nodeTypes.AstDeclaration) then
			local decl = node
			if decl.name.inferredType.tag == !(TYPE_NAMESPACE) then
				moveToPipe(state, decl, !(PIPE_DONE))
			else
				moveToPipe(state, decl, !(PIPE_BYTECODE))
			end

		elseif nodeType == !(nodeTypes.AstLambda) then
			local lambda = node
			if lambda.isPolymorphic or lambda.captures[1] then
				moveToPipe(state, lambda, !(PIPE_DONE))
			elseif lambda.body then
				moveToPipe(state, lambda, !(PIPE_BYTECODE))
			else
				moveToPipe(state, lambda, !(PIPE_DONE))
			end

		elseif nodeType == !(nodeTypes.AstLocation) then
			local loc = node
			if loc.ofCaller then
				moveToPipe(state, loc, !(PIPE_DONE)) -- The constants are generated at the calling sites instead.
			else
				moveToPipe(state, loc, !(PIPE_BYTECODE))
			end

		elseif nodeType == !(nodeTypes.AstCall) then
			local call = node
			if call.wantLocation then
				moveToPipe(state, call, !(PIPE_BYTECODE))
			else
				moveToPipe(state, call, !(PIPE_DONE))
			end

		else
			moveToPipe(state, node, !(PIPE_DONE))
		end

	elseif fromPipe == !(PIPE_BYTECODE) then
		moveToPipe(state, node, !(PIPE_DONE))

	elseif fromPipe == !(PIPE_DONE) then
		printerr("Warning: Trying to move nodes past PIPE_DONE!")

	else
		errorInternal(state, node)
	end
end

function _G.moveTreeToNextRelevantPipe(state, topNode)
	local currentPipe = topNode.queued.pipe

	astVisitAllNodes(topNode, function(node)
		if node.queued.pipe ~= currentPipe then
			errorInternal("A child node is in an unexpected pipe. (Expected %d, was %d)", currentPipe, node.queued.pipe)
		end
		moveToNextRelevantPipe(state, node)
	end)
end

function _G.moveChildrenToNextRelevantPipe(state, topNode)
	local currentPipe = nil

	astVisitAllNodes(topNode, function(node)
		if node == topNode then  return  end

		currentPipe = currentPipe or node.queued.pipe

		if node.queued.pipe ~= currentPipe then
			errorInternal("A child node is in an unexpected pipe. (Expected %d, was %d)", currentPipe, node.queued.pipe)
		end
		moveToNextRelevantPipe(state, node)
	end)
end



function _G.errorPipesAreStuck(state)
	!TRACE()

	!if DEBUG and OUTPUT_DEPENDENCY_GRAPH then
		outputDependencyGraph(state)
		astPrintTree(state.globalScope)
	!end

	local reportCount = 0
	!local REPORT_START = trimTemplate`
		local _exitFailure = exitFailure
		reportCount = reportCount+1
		if reportCount < MAX_ERRORS_MESSAGES then  _G.exitFailure = NOOP  end -- @Robustness: This is risky - what if someone needs to legit call exitFailure() (i.e. internal errors)! :ExitFailureOverride
	`
	!local REPORT_END = trimTemplate`
		_G.exitFailure = _exitFailure
	`
	!local REPORT_FINAL = trimTemplate`
		if reportCount > 0 then  exitFailure()  end
	`

	-- queueds = findQueueds( callback [, queueds={} ] )
	local function findQueueds(cb, queueds)
		queueds = queueds or {}
		for _, queued in ipairs(state.allQueueds) do
			local dependency = not queued.unqueued and queued.waitingOn
			if dependency and cb(queued, queued.node, dependency, dependency.dependOn) then
				table.insert(queueds, queued)
			end
		end
		return queueds
	end

	-- [[ Report undeclared identifier.
	local function getDeclaredIdentifierWaitingToBeDeclaredWithName(name, queuedToIgnore) -- @Cleanup: What is this even?!?!
		for _, queued in ipairs(state.allQueueds) do
			if queued ~= queuedToIgnore and not queued.unqueued and queued.waitingOn and queued.node.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = queued.node
				if ident.parent == ident.declaration and ident.name == name then  return queued  end
			end
		end
		return nil
	end

	local generatedIdents = {}
	local namesReported   = {}

	for _, queued in ipairs(state.allQueueds) do
		local dependency = not queued.unqueued and queued.waitingOn

		if dependency and (dependency.dependType == !(DEPEND_DECLARATION) or dependency.dependType == !(DEPEND_MEMBER_DECLARATION)) then
			local name = dependency.dependOn

			if not getDeclaredIdentifierWaitingToBeDeclaredWithName(name, queued) then
				local node = queued.node

				if namesReported[name] then
					-- void

				elseif name == "..." then
					errorParsing(state, node.token, "This is not inside a vararg function.") -- Probably an internal compiler error at this point.

				elseif node.nodeType == !(nodeTypes.AstAccess) then
					local access = node

					if access.object.inferredType.tag == !(TYPE_NAMESPACE) and access.object.inferredType.scope.nodeType == !(nodeTypes.AstFileScope) then
						local fileScope = access.object.inferredType.scope
						!!(REPORT_START)
						typeError(
							state, node.member,
							"Undeclared identifier '%s' in %s '%s'.",
							name,
							fileScope.isModule and "module"             or "file",
							fileScope.isModule and fileScope.moduleName or fileScope.path
						)
						!!(REPORT_END)

					else
						local scope  = nil
						local tag    = access.object.inferredType.tag
						local ignore = false

						if tag == !(TYPE_NAMESPACE) then
							scope = access.object.inferredType.scope
						elseif tag == !(TYPE_ENUM) then
							scope = access.object.inferredType.astNode
						elseif tag == !(TYPE_STRUCT) then
							scope = access.object.inferredType.astNode
							if not access.object.inferredType.hasMembers then  ignore = true  end -- Better to report the next issue, probably.
						else
							-- What could this be?
						end

						if not ignore then
							!!(REPORT_START)
							printerr()
							typeMessage(io.stderr, state, access.member, "Error", "Undeclared identifier '%s'.", name)
							if scope then
								typeMessage(io.stderr, state, scope, "Info", "...here is the accessed scope.")
							end
							exitFailure()
							!!(REPORT_END)
						end
					end

				elseif name == "it" or name == "itIndex" then
					table.insert(generatedIdents, node)
					-- Continue, as we prefer to report on user-defined identifiers first...

				else
					!!(REPORT_START)
					typeError(state, node, "Undeclared identifier '%s'.", name)
					!!(REPORT_END)
				end

				namesReported[name] = true
			end
		end
	end

	!!(REPORT_FINAL) -- Only report generatedIdents if they are the only ones.

	for _, generatedIdent in ipairs(generatedIdents) do
		!!(REPORT_START)
		typeError(state, generatedIdent, "Undeclared identifier '%s'.", generatedIdent.name)
		!!(REPORT_END)
	end

	!!(REPORT_FINAL)
	--]]

	-- [[ Report identifier waiting for declaration to be inferred.
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return true
			and dependency.dependType  == !(DEPEND_NODE_INFERRED)
			and node.nodeType          == !(nodeTypes.AstIdentifier)
			and dependOn.node.nodeType == !(nodeTypes.AstDeclaration)
	end)
	findQueueds(function(queued, node, dependency, dependOn)
		return true
			and dependency.dependType  == !(DEPEND_NODE_INFERRED_FULLY)
			and node.nodeType          == !(nodeTypes.AstIdentifier)
			and dependOn.node.nodeType == !(nodeTypes.AstDeclaration)
	end, queueds)
	for _, queued in ipairs(queueds) do
		local decl = queued.waitingOn.dependOn.node
		!!(REPORT_START)
		printerr()
		!ifDEBUG`astPrint(decl)`
		typeMessage(io.stderr, state, decl,        "Error", "Failed inferring the type of this declaration.")
		!ifDEBUG`astPrint(queued.node)`
		typeMessage(io.stderr, state, queued.node, "Info",  "...this identifier is waiting for the above to finish.")
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	-- [[ Report about-to-be-declared identifier waiting for something.
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return true
			and dependency.dependType == !(DEPEND_NODE_INFERRED)
			and node.nodeType         == !(nodeTypes.AstIdentifier)
			and queued.node.parent    == queued.node.declaration
			and queued.node           ~= queued.node.declaration.value
	end)
	findQueueds(function(queued, node, dependency, dependOn)
		return true
			and dependency.dependType == !(DEPEND_NODE_INFERRED_FULLY)
			and node.nodeType         == !(nodeTypes.AstIdentifier)
			and queued.node.parent    == queued.node.declaration
			and queued.node           ~= queued.node.declaration.value
	end, queueds)
	for _, queued in ipairs(queueds) do
		local expr = queued.waitingOn.dependOn.node
		!!(REPORT_START)
		printerr()
		!ifDEBUG`astPrint(expr)`
		typeMessage(io.stderr, state, expr,        "Error", "Failed inferring the type of this expression.")
		!ifDEBUG`astPrint(queued.node)`
		typeMessage(io.stderr, state, queued.node, "Info",  "...this identifier is waiting for the above to finish.")
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	-- [[ Report something waiting for something else to be inferred.
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return dependency.dependType == !(DEPEND_NODE_INFERRED) or dependency.dependType == !(DEPEND_NODE_INFERRED_FULLY)
	end)
	for _, queued in ipairs(queueds) do
		local expr = queued.waitingOn.dependOn.node
		!!(REPORT_START)
		printerr()
		!ifDEBUG`astPrint(expr)`
		typeMessage(io.stderr, state, expr,        "Error", "Failed inferring the type of this expression.")
		!ifDEBUG`astPrint(queued.node)`
		typeMessage(io.stderr, state, queued.node, "Info",  "...this thing is waiting for the above to finish. (This whole error message is probably not very helpful. Sorry!)")
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	-- [[ Report things waiting for all struct members to be ready.
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return dependency.dependType == !(DEPEND_STRUCT_MEMBERS_READY)
	end)
	for _, queued in ipairs(queueds) do
		local structInfo = queued.waitingOn.dependOn
		!!(REPORT_START)
		printerr()
		!ifDEBUG`astPrint(structInfo.astNode)`
		typeMessage(io.stderr, state, structInfo.astNode, "Error", "Failed generating member info for this struct.")
		!ifDEBUG`astPrint(queued.node)`
		typeMessage(io.stderr, state, queued.node,        "Info",  "...this thing is waiting for the members to be ready.")
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	-- [[
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return dependency.dependType == !(DEPEND_CONSTANT_READY)
	end)
	for _, queued in ipairs(queueds) do
		local const = queued.waitingOn.dependOn
		!!(REPORT_START)
		printerr()
		if const.valueType.tag == !(TYPE_FUNCTION) then
			local lambda = const.value
			!ifDEBUG`astPrint(lambda)`
			typeMessage(io.stderr, state, lambda, "Error", "Failed finishing the constant for this function.")
		else
			printerr(F("Failed finishing a constant for a value of type '%s'.", getFriendlyTypeInfoName(const.valueType)))
		end
		!ifDEBUG`astPrint(queued.node)`
		typeMessage(io.stderr, state, queued.node, "Info", "...this thing is waiting for the constant to be ready.")
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	-- [[ Report something waiting for something else to emit code.
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return dependency.dependType == !(DEPEND_NODE_EMITTED)
	end)
	for _, queued in ipairs(queueds) do
		local expr = queued.waitingOn.dependOn.node
		!!(REPORT_START)
		printerr()
		astPrint(queued.node)
		bcMessage(io.stderr, state, queued.node, "Error", "Internal compiler error: Failed emitting code for %s.", AST_NODE_TYPE_NAMES[queued.node.nodeType])
		astPrint(expr)
		bcMessage(io.stderr, state, expr,        "Info",  "...it is waiting for this %s to finish.", AST_NODE_TYPE_NAMES[expr.nodeType])
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	errorInternal("Pipes are stuck. Also failed to figure out where the issue actually is. Oops...")
end

!if DEBUG then
function _G.errorPipesAreInfiniteLooping(state, finalPipe)
	-- astPrintTree(state.globalScope)

	local printCount = 0
	printerr()

	for _, queued in ipairs(state.queueWaiting) do
		if not queued.unqueued and queued.pipe <= finalPipe then
			printCount = printCount+1

			if printCount > 10 then
				printerr("(...)")
				break
			end

			local dependency = queued.waitingOn

			astPrint(queued.node)
			nodeMessage(
				io.stderr, state, queued.node, "Debug", nil,
				"pipe=%s%s",
				PIPE_TITLES[queued.pipe],
				dependency and ", waiting" or ""
			)

			if dependency and !!(CONST_SET{ DEPEND_NODE_INFERRED, DEPEND_NODE_INFERRED_FULLY, DEPEND_NODE_EMITTED })[dependency.dependType] then
				astPrint(dependency.dependOn.node)
				nodeMessage(io.stderr, state, dependency.dependOn.node, "Debug", nil, "...waiting on this.")
			end
		end
	end

	!if OUTPUT_DEPENDENCY_GRAPH then
		outputDependencyGraph(state)
	!end
	errorInternal("[DEBUG] Pipes ran for too long. (waiting:%d)", #state.queueWaiting)
end
!end



function _G.outputDependencyGraph(state)
	!if PLANTUML_PATH ~= "" then
		-- [=[ Dependency graph.
		!local PATH_UML = "local/dependencies.plantuml"
		!local PATH_PNG = "local/dependencies.png"
		!local MAX_SIZE = 8192
		local file, err = io.open(!(PATH_UML), "wb")

		if not file then
			printerr(!("Could not open '"..PATH_UML.."' for writing: ")..err)

		else
			local function writeNode(node)
				file:write("(", AST_NODE_TYPE_NAMES[node.nodeType], " ", node.s)

				if node.nodeType == !(nodeTypes.AstIdentifier) then
					file:write("\\n", node.name)
				elseif node.nodeType == !(nodeTypes.AstDeclaration) then
					file:write("\\n", node.name.name)
				elseif node.nodeType == !(nodeTypes.AstAssignment) then
					if #node.targets == 1 and node.targets[1].nodeType == !(nodeTypes.AstIdentifier) then
						file:write("\\n", node.targets[1].name)
					end
				end

				local token = node.token
				local path  = state.tokens.file[token]
				file:write("\\n@", (path:match"([^/]+)%.%w+$" or "?"), ":", state.tokens.line1[token])

				file:write(")")
			end

			file:write("@startuml\n")
			file:write(!("scale max "..MAX_SIZE.."*"..MAX_SIZE.."\n"))

			for _, queued in ipairs(state.allQueueds) do
			-- for _, queued in ipairs(state.queueWaiting) do
				local dependency = not queued.unqueued and queued.waitingOn

				if dependency then
					local known = true
					writeNode(queued.node)

					if dependency.dependType == !(DEPEND_DECLARATION) or dependency.dependType == !(DEPEND_MEMBER_DECLARATION) then
						local name = dependency.dependOn
						file:write(" --|> (Name ", name, ")")

					elseif !!(CONST_SET{ DEPEND_NODE_INFERRED, DEPEND_NODE_INFERRED_FULLY, DEPEND_NODE_EMITTED })[dependency.dependType] then
						local nodeOther = dependency.dependOn.node
						file:write(" --|> ")
						writeNode(nodeOther)

					elseif dependency.dependType == !(DEPEND_STRUCT_MEMBERS_READY) then
						local structInfo = dependency.dependOn
						file:write(" --|> ")
						writeNode(structInfo.astNode)

					elseif dependency.dependType == !(DEPEND_CONSTANT_READY) then
						local const = dependency.dependOn
						if const.valueType.tag == !(TYPE_FUNCTION) then
							local lambda = const.value
							file:write(" --|> ")
							writeNode(lambda)
						else
							file:write(" --|> (Const ", const.name, ")")
						end

					else
						known = false
					end

					if known then
						file:write(" : ", DEPEND_TITLES[dependency.dependType])
					end
					file:write("\n")
				end
			end

			file:write("@enduml\n")
			file:close()

			local cmd = !(F([["SET PLANTUML_LIMIT_SIZE=%d & SET "GRAPHVIZ_DOT=%s" & java -jar "%s" "%s""]], MAX_SIZE, GRAPHVIZ_PATH, PLANTUML_PATH, PATH_UML))
			if os.execute(cmd) ~= 0 then
				printerr("Failed running command: "..cmd)
			else
				os.execute!(F([["START "" /W "%s""]], PATH_PNG))
			end
		end
		--]=]
	!end
end


