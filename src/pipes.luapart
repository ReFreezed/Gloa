--[[============================================================
--=
--=  Pipes
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	addDependency, getExistingDependency, fulfillDependencies
	addToQueueRecursively, pokeAndQueueUnqueuedNodeIntoTree, unqueue, unqueueChildrenRecursively, replaceQueuedNode, replaceQueuedNodeAndUnqueueOldTree, cutOutPartOfNodeTree
	errorPipesAreStuck, errorPipesAreInfiniteLooping
	moveToNextRelevantPipe, moveTreeToNextRelevantPipe, moveChildrenToNextRelevantPipe
	outputDependencyGraph

--============================================================]]

!local INFINITE_LOOP_PRINT_CONTEXT = 1==0
!local OUTPUT_DEPENDENCY_GRAPH     = 1==0
local MAX_ERRORS_MESSAGES          = !(DEBUG and 20 or 4) -- @Incomplete: Make this a compiler option.



!struct"_Dependency"{ -- @Cleanup: Rename to something with "wait"?
	{`dependent`,  nil},   -- Queued
	{`dependType`, 0},     -- See addDependency().
	{`dependOn`,   nil},   -- string|Queued  The value depends on what dependType is.
	{`extraData`,  nil},   -- AstScope|nil
	{`next`,       nil},   -- Dependency  This is for chaining multiple dependencies.
	{`internal`,   false}, -- Internal dependencies are (preferably) never reported to users during errors.
	{`traceback`,  nil},   -- For debugging.
}

-- addDependency( state, dependent, isInternal, DEPEND_DECLARATION,          name [, scope ] )
-- addDependency( state, dependent, isInternal, DEPEND_MEMBER_DECLARATION,   name, scope )
-- addDependency( state, dependent, isInternal, DEPEND_HAS_DECLARATION,      identifier )
-- addDependency( state, dependent, isInternal, DEPEND_NODE_INFERRED,        astNode )
-- addDependency( state, dependent, isInternal, DEPEND_NODE_PASSED_INFER,    astNode )
-- addDependency( state, dependent, isInternal, DEPEND_NODE_PASSED_EMIT,     astNode )
-- addDependency( state, dependent, isInternal, DEPEND_STRUCT_MEMBERS_READY, structInfo )
-- addDependency( state, dependent, isInternal, DEPEND_CONSTANT_READY,       constant )
function _G.addDependency(state, dependent, isInternal, dependType, dependOn, extraData)
	!if DEBUG and 1==0 then
		if dependType == !(DEPEND_DECLARATION) then
			!ASSERT `type(dependOn)  == "string"`
			!ASSERT `extraData == nil or type(extraData) == "table"`
		elseif dependType == !(DEPEND_MEMBER_DECLARATION) then
			!ASSERT `type(dependOn)  == "string"`
			!ASSERT `type(extraData) == "table"`
		elseif !!(CONST_SET{ DEPEND_HAS_DECLARATION, DEPEND_NODE_INFERRED, DEPEND_NODE_PASSED_INFER, DEPEND_NODE_PASSED_EMIT, DEPEND_STRUCT_MEMBERS_READY, DEPEND_CONSTANT_READY })[dependType] then
			!ASSERT `type(dependOn)  == "table"`
		else
			errorInternal("%d", dependType)
		end
	!end

	local dependOnIsNode = !!(CONST_SET{ DEPEND_HAS_DECLARATION, DEPEND_NODE_INFERRED, DEPEND_NODE_PASSED_INFER, DEPEND_NODE_PASSED_EMIT })[dependType]
	local dependency     = getExistingDependency(state, dependent, dependType, dependOn)

	if dependency then
		!TRACE()

		!ifDEBUG `astPrint(dependent)`
		nodeMessage(io.stderr, state, dependent, "Error", "Pipes", "Internal compiler error: Trying to add dependency twice. (%s)", (DEPEND_TITLES[dependType] or "?"))

		if dependOnIsNode then
			!ifDEBUG `astPrint(dependOn)`
			nodeMessage(io.stderr, state, dependOn, "Info", "Pipes", "...depending on this.")
		end

		if dependency.traceback then
			io.write("Previous ")
			print(dependency.traceback)
		end

		exitFailure()
	end

	dependent = dependent.queued or errorInternal(state, dependent, "addDependency: Dependent node is not queued.")

	if dependOnIsNode then
		if dependent == dependOn.node then
			errorInternal(state, dependent, "addDependency: Node trying to depend on itself for some reason.")
		end
		dependOn = dependOn.queued or errorInternal(state, dependOn, "addDependency: Missing queued.")
		-- assert(not itemWith3(dependOn.waiters, "dependent",dependent, "dependType",dependType, "dependOn",dependOn))
	end

	dependency = !new"_Dependency"{
		`dependent`,  `dependent`,
		`dependType`, `dependType`,
		`dependOn`,   `dependOn`,
		`extraData`,  `extraData`,
		`internal`,   `isInternal`,
	}

	-- !ifDEBUG `dependency.traceback = debug.traceback("", 2)`

	local waitingOn = dependent.waitingOn
	if waitingOn then
		while waitingOn.next do
			waitingOn = waitingOn.next
		end
		waitingOn.next = dependency
	else
		dependent.waitingOn = dependency
	end

	if dependOnIsNode then
		table.insert(dependOn.waiters, dependency)
	elseif dependType == !(DEPEND_STRUCT_MEMBERS_READY) then
		table.insert(dependOn.astNode.queued.waiters, dependency)
	end

	table.insert(state.allDependencies, dependency)

	local depsForLookup = state.dependenciesForLookup[dependType]
	if not depsForLookup[dependOn] then  depsForLookup[dependOn] = {}  end
	depsForLookup[dependOn][dependent] = dependency

	!if DEBUG and 1==0 then
		if debug_onlyInferTypes then
			io.write("DEPEND ")
			astPrint(dependent)

			io.write("    ON ", DEPEND_TITLES[dependType], " ")
			if dependType == !(DEPEND_DECLARATION) then
				print(dependOn)
			elseif dependType == !(DEPEND_MEMBER_DECLARATION) then
				print(dependOn)
			elseif dependType == !(DEPEND_HAS_DECLARATION) then
				astPrint(dependOn.node)
			elseif dependType == !(DEPEND_NODE_INFERRED) then
				astPrint(dependOn.node)
			elseif dependType == !(DEPEND_NODE_PASSED_INFER) then
				astPrint(dependOn.node)
			elseif dependType == !(DEPEND_NODE_PASSED_EMIT) then
				astPrint(dependOn.node)
			elseif dependType == !(DEPEND_STRUCT_MEMBERS_READY) then
				print(getFriendlyTypeInfoName(dependOn))
			elseif dependType == !(DEPEND_CONSTANT_READY) then
				print(getFriendlyTypeInfoName(dependOn.valueType), tostring(dependOn.value))
			else
				print("? ("..tostring(dependOn)..")")
			end
		end
	!end
end

!(
-- DEPEND                    ( dependentCode, dependType, dependOnCode [, extraDataCode ] )
-- DEPEND_INTERNAL           ( dependentCode, dependType, dependOnCode [, extraDataCode ] )
-- DEPEND_AND_RETURN         ( dependentCode, dependType, dependOnCode [, extraDataCode, valueToReturnCode ] )
-- DEPEND_AND_RETURN_INTERNAL( dependentCode, dependType, dependOnCode [, extraDataCode, valueToReturnCode ] )
local function depend(dependentCode, isInternal, dependType, dependOnCode, extraDataCode)
	__LUA("addDependency(state, ",dependentCode,", ",toLua(isInternal),", ",toLua(dependType),", ",dependOnCode)
	if extraDataCode then  __LUA(", ",extraDataCode)  end
	__LUA(")")
end
local function dependAndReturn(dependentCode, isInternal, dependType, dependOnCode, extraDataCode, valueToReturnCode)
	__LUA("addDependency(state, ",dependentCode,", ",toLua(isInternal),", ",toLua(dependType),", ",dependOnCode)
	if extraDataCode then  __LUA(", ",extraDataCode)  end
	__LUA(") ; return")
	if valueToReturnCode then  __LUA(" ",valueToReturnCode)  end
end
function _G.DEPEND(dependentCode, dependType, dependOnCode, extraDataCode)
	depend(dependentCode, false, dependType, dependOnCode, extraDataCode)
end
function _G.DEPEND_INTERNAL(dependentCode, dependType, dependOnCode, extraDataCode)
	depend(dependentCode, true,  dependType, dependOnCode, extraDataCode)
end
function _G.DEPEND_AND_RETURN(dependentCode, dependType, dependOnCode, extraDataCode, valueToReturnCode)
	dependAndReturn(dependentCode, false, dependType, dependOnCode, extraDataCode, valueToReturnCode)
end
function _G.DEPEND_AND_RETURN_INTERNAL(dependentCode, dependType, dependOnCode, extraDataCode, valueToReturnCode)
	dependAndReturn(dependentCode, true,  dependType, dependOnCode, extraDataCode, valueToReturnCode)
end
)

function _G.getExistingDependency(state, dependent, dependType, dependOn)
	dependent = dependent.queued

	if !!(CONST_SET{ DEPEND_HAS_DECLARATION, DEPEND_NODE_INFERRED, DEPEND_NODE_PASSED_INFER, DEPEND_NODE_PASSED_EMIT })[dependType] then
		dependOn = dependOn.queued
	end

	local depsForLookup = state.dependenciesForLookup[dependType][dependOn]
	return depsForLookup and depsForLookup[dependent]
end

function _G.fulfillDependencies(state, queued, dependType)
	local waiters = queued.waiters
	if not waiters[1] then  return  end

	for _, dependency in ipairs(waiters) do
		if dependency.dependType == dependType then
			local dependent = dependency.dependent

			if dependent.waitingOn == dependency then
				local dependencyNext = dependency.next
				dependent.waitingOn  = dependencyNext

				if not dependencyNext then
					table.insert(state.priorityStack, dependent)
				end
			end
		end
	end

	for i, dependency in ipairsr(waiters) do
		if dependency.dependType == dependType then
			removeUnordered(waiters, i) -- @Incomplete: Keep order without being slow! (Needed?)
		end
	end
end



!struct"_Queued"{
	{`node`,      nil}, -- AstNode
	{`container`, nil}, -- Any table.
	{`key`,       nil}, -- String or integer.
	{`pipe`,      PIPE_NONE},
	{`waitingOn`, nil}, -- Dependency
	{`waiters`,   {}},  -- []Dependency  Others waiting on this.
	{`unqueued`,  false},
}

-- addToQueue( state, node, container=nil, key=nil, pipe )
function _G.addToQueue(state, node, container, key, pipe)
	-- astPrint(node)
	!ASSERT `not node.queued`

	local queued = !new"_Queued"{
		`node`,      `node`,
		`container`, `container`,
		`key`,       `key`,
		`pipe`,      `pipe or errorInternal()`,
	}

	node.queued = queued
	table.insert(state.queueActive, queued)
	table.insert(state.allQueueds,  queued)

	-- Make imperative declarations wait for their assigned value (from the assigned value's perspective).
	-- @Cleanup: This doesn't really seem to speed things up, even though declarations no longer wait for literals etc.
	local parent = node.parent
	if
		parent
		and parent.nodeType == !(AST_ASSIGNMENT)
		and parent.forDeclaration
		and container == parent.values
	then
		local decl = parent.declarations[key]
		if decl then
			-- @Robustness: Should we check that decl.name is in PIPE_INFER? (Probably not necessary.)
			addDependency(state, decl.name, false, !(DEPEND_NODE_INFERRED), node)
		end
	end

	--[[ Make assignment targets in declaration assignment statements wait for their declaration.
	if
		node.nodeType == !(AST_IDENTIFIER)
		and node.declaration
		and parent.nodeType == !(AST_ASSIGNMENT)
		and parent.forDeclaration
		and parent.declarations[indexOf(parent.targets, node)]
	then
		local ident = node
		addDependency(state, ident, false, !(DEPEND_NODE_INFERRED), ident.declaration.name)
	end
	--]]
end

-- addToQueueRecursively( state, topNode [, containerForTopNode, keyForTopNode, pipe=PIPE_INFER ] )
-- Note: Skips AstStaticIf branches and most polymorphic nodes.
do
	local function registerNodesToAddToQueue(state, topNode, nodesToAdd)
		local function registerNodesToAddToQueue_onVisit(node)
			nodesToAdd[node] = true

			-- :SelectiveQueuing
			local nodeType = node.nodeType

			if nodeType == !(AST_STATIC_IF) then
				local staticIf = node
				registerNodesToAddToQueue(state, staticIf.condition, nodesToAdd)
				return !(VISIT_IGNORE_CHILDREN)

			elseif (nodeType == !(AST_LAMBDA) or nodeType == !(AST_STRUCT)) and node.isPolymorphic then
				return !(VISIT_IGNORE_CHILDREN) -- We don't need to queue anything inside polymorphic functions or structs (I think).

			elseif nodeType == !(AST_FOR) then
				local forLoop = node
				for _, expr in ipairs(forLoop.expressions) do
					registerNodesToAddToQueue(state, expr, nodesToAdd)
				end
				for _, statement in ipairs(forLoop.statementsStatic) do
					if statement ~= forLoop.body then
						registerNodesToAddToQueue(state, statement, nodesToAdd)
					end
				end
				for _, statement in ipairs(forLoop.statementsDynamic) do
					registerNodesToAddToQueue(state, statement, nodesToAdd)
				end
				return !(VISIT_IGNORE_CHILDREN)
			end
		end

		astVisitAllNodes(topNode, registerNodesToAddToQueue_onVisit)
	end

	function _G.addToQueueRecursively(state, topNode, container0, key0, pipe)
		pipe = pipe or !(PIPE_INFER)

		local nodesToAdd = {}
		registerNodesToAddToQueue(state, topNode, nodesToAdd)

		local function add(node, container, key)
			if not nodesToAdd[node] then  return  end

			if node.nodeType == !(AST_DECLARATION) and node.assignment then
				local assignment = node.assignment
				local valueExpr  = assignment.values[node.assignmentIndex]
				if valueExpr then
					astVisitAllNodesLeavesFirst(valueExpr, add, assignment.values, node.assignmentIndex)
				end
			end

			addToQueue(state, node, (container or container0), (key or key0), pipe)
			nodesToAdd[node] = nil
		end

		astVisitAllNodesLeavesFirst(topNode, add)
	end
end

-- addUnqueuedChildrenToQueueRecursively( state, topNode [, pipe=PIPE_INFER ] )
-- Note: Ignores children of already queued nodes.
-- Note: Skips AstStaticIf branches and most polymorphic nodes.
do
	local function registerNodesToAddToQueue(state, topNode, nodesToAdd)
		local function registerNodesToAddToQueue_onVisit(node)
			if node == topNode then
				-- void

			elseif node.queued then
				return !(VISIT_IGNORE_CHILDREN)

			else
				nodesToAdd[node] = true

				-- :SelectiveQueuing
				local nodeType = node.nodeType

				if nodeType == !(AST_STATIC_IF) then
					local staticIf = node
					if not staticIf.condition.queued then
						nodesToAdd[staticIf.condition] = true
						registerNodesToAddToQueue(state, staticIf.condition, nodesToAdd)
					end
					return !(VISIT_IGNORE_CHILDREN)

				elseif (nodeType == !(AST_LAMBDA) or nodeType == !(AST_STRUCT)) and node.isPolymorphic then
					return !(VISIT_IGNORE_CHILDREN) -- We don't need to queue anything inside polymorphic functions or structs (I think).

				elseif nodeType == !(AST_FOR) then
					local forLoop = node
					for _, expr in ipairs(forLoop.expressions) do
						if not expr.queued then
							nodesToAdd[expr] = true
							registerNodesToAddToQueue(state, expr, nodesToAdd)
						end
					end
					for _, statement in ipairs(forLoop.statementsStatic) do
						if not statement.queued and statement ~= forLoop.body then
							registerNodesToAddToQueue(state, statement, nodesToAdd)
						end
					end
					for _, statement in ipairs(forLoop.statementsDynamic) do
						if not statement.queued then
							registerNodesToAddToQueue(state, statement, nodesToAdd)
						end
					end
					return !(VISIT_IGNORE_CHILDREN)
				end
			end
		end

		astVisitAllNodes(topNode, registerNodesToAddToQueue_onVisit)
	end

	function _G.addUnqueuedChildrenToQueueRecursively(state, topNode, pipe)
		pipe = pipe or !(PIPE_INFER)

		local nodesToAdd = {}
		registerNodesToAddToQueue(state, topNode, nodesToAdd)

		local function add(node, container, key)
			if not nodesToAdd[node] then  return  end

			if node.nodeType == !(AST_DECLARATION) and node.assignment then
				local assignment = node.assignment
				local valueExpr  = assignment.values[node.assignmentIndex]
				if valueExpr then
					astVisitAllNodesLeavesFirst(valueExpr, add, assignment.values, node.assignmentIndex)
				end
			end

			addToQueue(state, node, container, key, pipe)
			nodesToAdd[node] = nil
		end

		astVisitAllNodesLeavesFirst(topNode, add)
	end
end

-- pokeAndQueueUnqueuedNodeIntoTree( state, nodeAtTargetPosition, newNode, containerInNewNode, keyInContainerInNewNode [, pipe=PIPE_INFER ] )
-- newNode will become the new parent for nodeAtTargetPosition.
function _G.pokeAndQueueUnqueuedNodeIntoTree(state, nodeAtTargetPos, newNode, containerInNewNode, keyInNewNode, pipe)
	!ASSERT `not newNode.queued`
	pipe = pipe or !(PIPE_INFER)

	addToQueue(state, newNode, nodeAtTargetPos.queued.container, nodeAtTargetPos.queued.key, pipe)

	-- Replace nodeAtTargetPos with newNode in it's parent.
	nodeAtTargetPos.queued.container[nodeAtTargetPos.queued.key] = newNode

	-- Put nodeAtTargetPos in newNode.
	containerInNewNode[keyInNewNode] = nodeAtTargetPos
	nodeAtTargetPos.parent           = newNode
	nodeAtTargetPos.queued.container = containerInNewNode
	nodeAtTargetPos.queued.key       = keyInNewNode
end

function _G.unqueue(node)
	node.queued.unqueued = true
end

function _G.unqueueChildrenRecursively(state, topNode) -- @Cleanup: Remove state argument.
	local function unqueueChildrenRecursively_onVisit(node)
		if node ~= topNode then
			node.queued.unqueued = true
		end
	end
	astVisitAllNodes(topNode, unqueueChildrenRecursively_onVisit)
end

-- Note: nodeOld doesn't have to be queued right now - it just needs a Queued object.
-- Note: No node.parent is changed.
-- (@Cleanup: Sometimes we just want to make use of queued.container/key.)
function _G.replaceQueuedNode(state, nodeOld, nodeNew)
	assert(not nodeNew.queued)

	local queued   = nodeOld.queued or errorInternal()
	queued.node    = nodeNew
	nodeOld.queued = nil
	nodeNew.queued = queued

	if queued.container then
		queued.container[queued.key] = nodeNew
	end

	nodeOld.replacedBy = nodeNew
	nodeNew.replacing  = nodeOld

	!if DEBUG then
		-- [[
		if debug_onlyInferTypes then
			io.write("replace: ") ; astPrint(nodeOld)
			io.write("   with: ") ; astPrint(nodeNew)
			-- where(state, nodeOld)
			-- where(state, nodeOld.parent)
		end
		--]]
	!end
end

function _G.replaceQueuedNodeAndUnqueueOldTree(state, nodeOld, nodeNew)
	unqueueChildrenRecursively(state, nodeOld)
	replaceQueuedNode(state, nodeOld, nodeNew)
end

-- Note: We update the parent of childTreeNodeToHookIn here.
function _G.cutOutPartOfNodeTree(state, nodeToRemove, childTreeNodeToHookIn)
	local function cutOutPartOfNodeTree_onVisit(node)
		if node ~= nodeToRemove          then  node.queued.unqueued = true      end
		if node == childTreeNodeToHookIn then  return !(VISIT_IGNORE_CHILDREN)  end
	end
	astVisitAllNodes(nodeToRemove, cutOutPartOfNodeTree_onVisit)

	childTreeNodeToHookIn.queued = nil -- This will be replaced with nodeToRemove.queued in replaceQueuedNode().
	childTreeNodeToHookIn.parent = nodeToRemove.parent

	replaceQueuedNode(state, nodeToRemove, childTreeNodeToHookIn)
end



-- moveToNextRelevantPipe( state, node [, fromPipe=current ] )
function _G.moveToNextRelevantPipe(state, node, fromPipe)
	local queued = node.queued
	fromPipe     = fromPipe or queued.pipe

	if fromPipe == !(PIPE_INFER) then
		local nodeType = node.nodeType

		if nodeType == !(AST_LITERAL) or nodeType == !(AST_FOREIGN) or nodeType == !(AST_TYPE_INFO) then
			queued.pipe = !(PIPE_EMIT)

		elseif nodeType == !(AST_DECLARATION) then
			queued.pipe
				=   node.inferredType.tag == !(TYPE_NAMESPACE)
				and !(PIPE_DONE)
				or  !(PIPE_EMIT)

		elseif nodeType == !(AST_LAMBDA) then
			queued.pipe
				=   (node.isPolymorphic or not node.body or node.captures[1] or node.captureAll)
				and !(PIPE_DONE)
				or  !(PIPE_EMIT)

		elseif nodeType == !(AST_CALL) then
			queued.pipe
				=   node.wantLocation
				and !(PIPE_EMIT)
				or  !(PIPE_DONE)

		elseif nodeType == !(AST_LOCATION) then
			queued.pipe
				=   node.ofCaller
				and !(PIPE_DONE) -- The constants are generated at the calling sites instead.
				or  !(PIPE_EMIT)

		else
			queued.pipe = !(PIPE_DONE)
		end

	elseif fromPipe == !(PIPE_EMIT) then
		queued.pipe = !(PIPE_DONE)

	elseif fromPipe == !(PIPE_DONE) then
		printerr("Warning: Trying to move nodes past PIPE_DONE!")

	else
		errorInternal(state, node)
	end
end

function _G.moveTreeToNextRelevantPipe(state, topNode)
	local currentPipe = topNode.queued.pipe

	local function moveTreeToNextRelevantPipe_onVisit(node)
		if node.queued.pipe ~= currentPipe then
			errorInternal("A child node is in an unexpected pipe. (Expected %d, was %d)", currentPipe, node.queued.pipe)
		end
		moveToNextRelevantPipe(state, node)
	end
	astVisitAllNodes(topNode, moveTreeToNextRelevantPipe_onVisit)
end

function _G.moveChildrenToNextRelevantPipe(state, topNode)
	local currentPipe = nil

	local function moveChildrenToNextRelevantPipe_onVisit(node)
		if node == topNode then  return  end

		currentPipe = currentPipe or node.queued.pipe

		if node.queued.pipe ~= currentPipe then
			errorInternal("A child node is in an unexpected pipe. (Expected %d, was %d)", currentPipe, node.queued.pipe)
		end
		moveToNextRelevantPipe(state, node)
	end
	astVisitAllNodes(topNode, moveChildrenToNextRelevantPipe_onVisit)
end



function _G.errorPipesAreStuck(state)
	!TRACE()

	!if DEBUG and OUTPUT_DEPENDENCY_GRAPH then
		outputDependencyGraph(state)
		astPrintTree(state.globalScope)
	!end

	local reportCount = 0
	!local REPORT_START = trimTemplate`
		local _exitFailure = exitFailure
		reportCount = reportCount+1
		if reportCount < MAX_ERRORS_MESSAGES then  _G.exitFailure = NOOP  end -- @Robustness: This is risky - what if someone needs to legit call exitFailure() (i.e. internal errors)! :ExitFailureOverride
	`
	!local REPORT_END = trimTemplate`
		_G.exitFailure = _exitFailure
	`
	!local REPORT_FINAL = trimTemplate`
		if reportCount > 0 then  exitFailure()  end
	`

	local relevantQueueds = {}
	for _, queued in ipairs(state.allQueueds) do
		local dependency = not queued.unqueued and queued.waitingOn
		if dependency and not dependency.internal then  table.insert(relevantQueueds, queued)  end
	end
	relevantQueueds = relevantQueueds[1] and relevantQueueds or state.allQueueds

	-- queueds = findQueueds( callback [, queueds={} ] )
	local function findQueueds(cb, queueds)
		queueds = queueds or {}
		for _, queued in ipairs(relevantQueueds) do
			local dependency = not queued.unqueued and queued.waitingOn
			if dependency and cb(queued, queued.node, dependency, dependency.dependOn) then
				table.insert(queueds, queued)
			end
		end
		return queueds
	end

	-- [[ Report undeclared identifier.
	local generatedIdents = {}
	local namesReported   = {}

	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return dependency.dependType == !(DEPEND_DECLARATION) or dependency.dependType == !(DEPEND_MEMBER_DECLARATION)
	end)
	for _, queued in ipairs(queueds) do
		local name = queued.waitingOn.dependOn
		local node = queued.node

		if namesReported[name] then
			-- void

		elseif name == "..." then
			errorParsing(state, node.token, "This is not inside a vararg function.") -- Probably an internal compiler error at this point.

		elseif node.nodeType == !(AST_ACCESS) or queued.waitingOn.extraData then
			local scopeType, nameNode

			if node.nodeType == !(AST_ACCESS) then
				local access = node
				scopeType    = access.object.inferredType
				nameNode     = access.member
			else
				scopeType    = queued.waitingOn.extraData.inferredType
				nameNode     = node
			end

			if nameNode.nodeType == !(AST_TABLE) then
				-- Find what field exactly the table is waiting for. Since the node with the
				-- actual name is a string literal - not an identifier - the table never had
				-- to wait for the field key to be inferred.
				for _, tableField in ipairs(node.fields) do
					if tableField.key.nodeType == !(AST_LITERAL) and tableField.key.literalType == !(LITERAL_STRING) and tableField.key.value == name then
						nameNode = tableField.key
						break
					end
				end
			end

			if scopeType.tag == !(TYPE_NAMESPACE) and scopeType.scope.nodeType == !(AST_FILE_SCOPE) then
				local namespaceInfo = scopeType
				local scope         = namespaceInfo.scope

				!!(REPORT_START)
				if findMemberDeclaration(state, scope, name) then
					typeError(
						state, nameNode,
						"Declaration for '%s' in %s '%s' is not exported.",
						name,
						scope.isModule and "module"         or "file",
						scope.isModule and scope.moduleName or scope.path
					)
				else
					typeError(
						state, nameNode,
						"Undeclared identifier '%s' in %s '%s'.",
						name,
						scope.isModule and "module"             or "file",
						scope.isModule and scope.moduleName or scope.path
					)
				end
				!!(REPORT_END)

			else
				local scope  = nil
				local tag    = scopeType.tag
				local ignore = false

				if queued.waitingOn.extraData then
					scope = queued.waitingOn.extraData
					if scope.nodeType == !(AST_STRUCT) and not scope.representedType.hasMembers then  ignore = true  end -- Better to report the next issue, probably.
				elseif tag == !(TYPE_NAMESPACE) then
					scope = scopeType.scope
				elseif tag == !(TYPE_ENUM) then
					scope = scopeType.astNode
				elseif tag == !(TYPE_STRUCT) then
					scope = scopeType.astNode
					if not scopeType.hasMembers then  ignore = true  end -- Better to report the next issue, probably.
				else
					-- What could this be?
				end

				if not ignore then
					!!(REPORT_START)
					printerr()
					typeMessage(io.stderr, state, nameNode, "Error", "Undeclared identifier '%s'.", name)
					if scope then
						typeMessage(io.stderr, state, scope, "Info", "...here is the accessed scope.")
					end
					exitFailure()
					!!(REPORT_END)
				end
			end

		elseif name == "it" or name == "itIndex" then
			table.insert(generatedIdents, node)
			-- Continue, as we prefer to report on user-defined identifiers first...

		else
			!!(REPORT_START)
			typeError(state, node, "Undeclared identifier '%s'.", name)
			!!(REPORT_END)
		end

		namesReported[name] = true
	end

	!!(REPORT_FINAL) -- Only report generatedIdents if they are the only ones.

	for _, generatedIdent in ipairs(generatedIdents) do
		!!(REPORT_START)
		typeError(state, generatedIdent, "Undeclared identifier '%s'.", generatedIdent.name)
		!!(REPORT_END)
	end

	!!(REPORT_FINAL)
	--]]

	-- [[ Report identifier waiting for declaration to be inferred.
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return true
			and dependency.dependType  == !(DEPEND_NODE_INFERRED)
			and node.nodeType          == !(AST_IDENTIFIER)
			and dependOn.node.nodeType == !(AST_DECLARATION)
	end)
	findQueueds(function(queued, node, dependency, dependOn)
		return true
			and dependency.dependType  == !(DEPEND_NODE_PASSED_INFER)
			and node.nodeType          == !(AST_IDENTIFIER)
			and dependOn.node.nodeType == !(AST_DECLARATION)
	end, queueds)
	for _, queued in ipairs(queueds) do
		local decl = queued.waitingOn.dependOn.node
		!!(REPORT_START)
		printerr()
		!ifDEBUG`astPrint(decl)`
		typeMessage(io.stderr, state, decl,        "Error", "Failed inferring the type of this declaration.")
		!ifDEBUG`astPrint(queued.node)`
		typeMessage(io.stderr, state, queued.node, "Info",  "...this identifier is waiting for the above to finish.")
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	-- [[ Report about-to-be-declared identifier waiting for something.
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return true
			and dependency.dependType == !(DEPEND_NODE_INFERRED)
			and node.nodeType         == !(AST_IDENTIFIER)
			and queued.node.parent    == queued.node.declaration
			and queued.node           ~= queued.node.declaration.value
	end)
	findQueueds(function(queued, node, dependency, dependOn)
		return true
			and dependency.dependType == !(DEPEND_NODE_PASSED_INFER)
			and node.nodeType         == !(AST_IDENTIFIER)
			and queued.node.parent    == queued.node.declaration
			and queued.node           ~= queued.node.declaration.value
	end, queueds)
	for _, queued in ipairs(queueds) do
		local expr = queued.waitingOn.dependOn.node
		!!(REPORT_START)
		printerr()
		!ifDEBUG`astPrint(expr)`
		typeMessage(io.stderr, state, expr,        "Error", "Failed inferring the type of this expression.")
		!ifDEBUG`astPrint(queued.node)`
		typeMessage(io.stderr, state, queued.node, "Info",  "...this identifier is waiting for the above to finish.")
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	-- [[ Report something waiting for something else to be inferred.
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return dependency.dependType == !(DEPEND_NODE_INFERRED) or dependency.dependType == !(DEPEND_NODE_PASSED_INFER)
	end)
	for _, queued in ipairs(queueds) do
		local expr = queued.waitingOn.dependOn.node
		!!(REPORT_START)
		printerr()
		!ifDEBUG`astPrint(expr)`
		typeMessage(io.stderr, state, expr,        "Error", "Failed inferring the type of this expression.")
		!ifDEBUG`astPrint(queued.node)`
		typeMessage(io.stderr, state, queued.node, "Info",  "...this thing is waiting for the above to finish. (This whole error message is probably not very helpful. Sorry!)")
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	-- [[ Report things waiting for all struct members to be ready.
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return dependency.dependType == !(DEPEND_STRUCT_MEMBERS_READY)
	end)
	for _, queued in ipairs(queueds) do
		local structInfo = queued.waitingOn.dependOn
		!!(REPORT_START)
		printerr()
		!ifDEBUG`astPrint(structInfo.astNode)`
		typeMessage(io.stderr, state, structInfo.astNode, "Error", "Failed generating member info for this struct.")
		!ifDEBUG`astPrint(queued.node)`
		typeMessage(io.stderr, state, queued.node,        "Info",  "...this thing is waiting for the members to be ready.")
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	-- [[
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return dependency.dependType == !(DEPEND_CONSTANT_READY)
	end)
	for _, queued in ipairs(queueds) do
		local const = queued.waitingOn.dependOn
		!!(REPORT_START)
		printerr()
		if const.valueType.tag == !(TYPE_FUNCTION) then
			local lambda = const.value
			!ifDEBUG`astPrint(lambda)`
			typeMessage(io.stderr, state, lambda, "Error", "Failed finishing the constant for this function.")
		else
			printerr(F("Failed finishing a constant for a value of type '%s'.", getFriendlyTypeInfoName(const.valueType)))
		end
		!ifDEBUG`astPrint(queued.node)`
		typeMessage(io.stderr, state, queued.node, "Info", "...this thing is waiting for the constant to be ready.")
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	-- [[ Report something waiting for something else to emit code.
	local queueds = findQueueds(function(queued, node, dependency, dependOn)
		return dependency.dependType == !(DEPEND_NODE_PASSED_EMIT)
	end)
	for _, queued in ipairs(queueds) do
		local expr = queued.waitingOn.dependOn.node
		!!(REPORT_START)
		printerr()
		astPrint(queued.node)
		emitMessage(io.stderr, state, queued.node, "Error", "Internal compiler error: Failed emitting code for %s.", AST_NAMES[queued.node.nodeType])
		astPrint(expr)
		emitMessage(io.stderr, state, expr,        "Info",  "...it is waiting for this %s to finish.", AST_NAMES[expr.nodeType])
		exitFailure()
		!!(REPORT_END)
	end
	!!(REPORT_FINAL)
	--]]

	errorInternal("Pipes are stuck. Also failed to figure out where the issue actually is. Oops...")
end

!if DEBUG then
function _G.errorPipesAreInfiniteLooping(state, finalPipe)
	-- astPrintTree(state.globalScope)

	local printCount = 0
	printerr()

	for _, queued in ipairs(state.queueWaiting) do
		if not queued.unqueued and queued.pipe <= finalPipe then
			printCount = printCount+1

			if printCount > !(INFINITE_LOOP_PRINT_CONTEXT and 100 or 10) then
				printerr("(...)")
				break
			end

			local dependency = queued.waitingOn

			!if INFINITE_LOOP_PRINT_CONTEXT then
				astPrint(queued.node)
				nodeMessage(
					io.stderr, state, queued.node, "Debug", nil,
					"pipe=%s%s",
					PIPE_TITLES[queued.pipe],
					dependency and ", waiting" or ""
				)
			!else
				printerr(printCount..".")
				printLocation(io.stderr, state, queued.node)
				astPrint(queued.node)
			!end

			if dependency and !!(CONST_SET{ DEPEND_HAS_DECLARATION, DEPEND_NODE_INFERRED, DEPEND_NODE_PASSED_INFER, DEPEND_NODE_PASSED_EMIT })[dependency.dependType] then
				!if INFINITE_LOOP_PRINT_CONTEXT then
					astPrint(dependency.dependOn.node)
					nodeMessage(io.stderr, state, dependency.dependOn.node, "Debug", nil, "...waiting on this.")
				!else
					printLocation(io.stderr, state, dependency.dependOn.node)
					astPrint(dependency.dependOn.node)
				!end
			end
		end
	end

	!if DEBUG and OUTPUT_DEPENDENCY_GRAPH then
		outputDependencyGraph(state)
	!end
	errorInternal("[DEBUG] Pipes ran for too long. (waiting:%d)", #state.queueWaiting)
end
!end



function _G.outputDependencyGraph(state)
	!if PLANTUML_PATH ~= "" then
		-- [=[ Dependency graph.
		!local MAX_SIZE = 8192
		local PATH_UML  = COMPILER_DIRECTORY.."/temp/dependencies.plantuml"
		local PATH_PNG  = COMPILER_DIRECTORY.."/temp/dependencies.png"
		local file, err = io.open(PATH_UML, "wb")

		if not file then
			printerr(F("Could not open '%s' for writing: %s", PATH_UML, err))

		else
			local function writeNode(node)
				file:write("(", AST_NAMES[node.nodeType], " ", node.s)

				if node.nodeType == !(AST_IDENTIFIER) then
					file:write("\\n", node.name)
				elseif node.nodeType == !(AST_DECLARATION) then
					file:write("\\n", node.name.name)
				elseif node.nodeType == !(AST_ASSIGNMENT) then
					if #node.targets == 1 and node.targets[1].nodeType == !(AST_IDENTIFIER) then
						file:write("\\n", node.targets[1].name)
					end
				end

				local tok = state.tokens[node.token]
				file:write("\\n@", (tok.source.path:match"([^/]+)%.%w+$" or "?"), ":", tok.line1)

				file:write(")")
			end

			file:write("@startuml\n")
			file:write(!("scale max "..MAX_SIZE.."*"..MAX_SIZE.."\n"))

			for _, queued in ipairs(state.allQueueds) do
			-- for _, queued in ipairs(state.queueWaiting) do
				local dependency = not queued.unqueued and queued.waitingOn

				if dependency then
					local known = true
					writeNode(queued.node)

					if dependency.dependType == !(DEPEND_DECLARATION) or dependency.dependType == !(DEPEND_MEMBER_DECLARATION) then
						local name = dependency.dependOn
						file:write(" --|> (Name ", name, ")")

					elseif !!(CONST_SET{ DEPEND_HAS_DECLARATION, DEPEND_NODE_INFERRED, DEPEND_NODE_PASSED_INFER, DEPEND_NODE_PASSED_EMIT })[dependency.dependType] then
						local nodeOther = dependency.dependOn.node
						file:write(" --|> ")
						writeNode(nodeOther)

					elseif dependency.dependType == !(DEPEND_STRUCT_MEMBERS_READY) then
						local structInfo = dependency.dependOn
						file:write(" --|> ")
						writeNode(structInfo.astNode)

					elseif dependency.dependType == !(DEPEND_CONSTANT_READY) then
						local const = dependency.dependOn
						if const.valueType.tag == !(TYPE_FUNCTION) then
							local lambda = const.value
							file:write(" --|> ")
							writeNode(lambda)
						else
							file:write(" --|> (Const ", const.name, ")")
						end

					else
						known = false
					end

					if known then
						file:write(" : ", DEPEND_TITLES[dependency.dependType])
					end
					file:write("\n")
				end
			end

			file:write("@enduml\n")
			file:close()

			local cmd = F([["SET PLANTUML_LIMIT_SIZE=%d & SET "GRAPHVIZ_DOT=%s" & java -jar "%s" "%s""]], !(MAX_SIZE), !(GRAPHVIZ_PATH), !(PLANTUML_PATH), PATH_UML)
			if os.execute(cmd) ~= 0 then
				printerr("Failed running command: "..cmd)
			else
				os.execute(F([["START "" /W "%s""]], PATH_PNG))
			end
		end
		--]=]
	!end
end


