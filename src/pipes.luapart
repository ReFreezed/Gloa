--[[============================================================
--=
--=  Pipes
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	addDependency, getExistingDependency
	addToQueueRecursively, pokeAndQueueUnqueuedNodeIntoTree, unqueue, unqueueChildrenRecursively, replaceQueuedNode, replaceQueuedNodeAndUnqueueOldTree, cutOutPartOfNodeTree
	errorPipesAreStuck
	moveToPipe, moveToNextPipe, moveTreeToNextPipe, moveToNextRelevantPipe, moveTreeToNextRelevantPipe, moveChildrenToNextRelevantPipe

--============================================================]]



local !struct"Dependency"{ -- @Cleanup: Rename to something with "wait"?
	{`dependent`,  nil}, -- Queued
	{`dependType`, 0},   -- DEPEND_DECLARATION|DEPEND_NODE_INFERRED|DEPEND_NODE_EMITTED|DEPEND_STRUCT_MEMBERS_READY
	{`dependOn`,   nil}, -- string|Queued  (The value depends on what dependType is.)
	{`next`,       nil}, -- Dependency  (This is for chaining multiple dependencies.)
}

-- addDependency( state, dependent, DEPEND_DECLARATION,          name [, scope ] )
-- addDependency( state, dependent, DEPEND_NODE_INFERRED,        astNode )
-- addDependency( state, dependent, DEPEND_NODE_EMITTED,         astNode )
-- addDependency( state, dependent, DEPEND_STRUCT_MEMBERS_READY, structInfo )
function _G.addDependency(state, dependent, dependType, dependOn, extraData)
	!if DEBUG then
		if dependType == !(DEPEND_DECLARATION) then
			assert(type(dependOn) == "string")
			assert(extraData == nil or type(extraData) == "table")
		elseif isAny(dependType, !(DEPEND_NODE_INFERRED),!(DEPEND_NODE_EMITTED),!(DEPEND_STRUCT_MEMBERS_READY)) then
			assert(type(dependOn) == "table")
		else
			errorInternal("%d", dependType)
		end
	!end

	if getExistingDependency(state, dependent, dependType, dependOn) then
		printTraceback(io.stderr, 2)
		printerr()

		!ifDEBUG `astPrint(dependent)`
		nodeMessage(io.stderr, state, dependent, "Error", "Pipes", "Internal compiler error: Trying to add dependency twice.")

		if isAny(dependType, !(DEPEND_NODE_INFERRED),!(DEPEND_NODE_EMITTED)) then
			!ifDEBUG `astPrint(dependOn)`
			nodeMessage(io.stderr, state, dependOn, "Info", "Pipes", "...depending on this.")
		end

		exitFailure()
	end

	dependent = dependent.queued

	if isAny(dependType, !(DEPEND_NODE_INFERRED),!(DEPEND_NODE_EMITTED)) then
		assert(dependent ~= dependOn.node)
		dependOn = dependOn.queued
	end

	local dependency      = Dependency()
	dependency.dependent  = dependent
	dependency.dependType = dependType
	dependency.dependOn   = dependOn
	dependency.extraData  = extraData

	if dependent.waitingOn then
		dependent.waitingOn.next = dependency
	else
		dependent.waitingOn      = dependency
	end

	table.insert(state.dependencies, dependency)

	!if DEBUG then
		--[[
		if debug_onlyInferTypes then
			io.stdout:write("DEPEND ")
			astPrint(dependent)

			io.stdout:write("    ON ", DEPEND_TITLES[dependType], " ")
			if dependType == !(DEPEND_DECLARATION) then
				print(dependOn)
			elseif dependType == !(DEPEND_NODE_INFERRED) then
				astPrint(dependOn.node)
			elseif dependType == !(DEPEND_NODE_EMITTED) then
				astPrint(dependOn.node)
			elseif dependType == !(DEPEND_STRUCT_MEMBERS_READY) then
				print(getFriendlyTypeInfoName(dependOn))
			else
				print("? ("..tostring(dependOn)..")")
			end
		end
		--]]
	!end
end

!(
-- DEPEND_AND_RETURN( dependentCode, dependType, dependOnCode [, extraDataCode, valueToReturnCode ] )
function _G.DEPEND_AND_RETURN(dependentCode, dependType, dependOnCode, extraDataCode, valueToReturnCode)
	__LUA("addDependency(state, ",dependentCode,", ",toLua(dependType),", ",dependOnCode)
	if extraDataCode then
		__LUA(", ",extraDataCode)
	end
	__LUA(") ; return")
	if valueToReturnCode then
		__LUA(" ", valueToReturnCode)
	end
end
)

function _G.getExistingDependency(state, dependent, dependType, dependOn)
	dependent = dependent.queued

	if isAny(dependType, !(DEPEND_NODE_INFERRED),!(DEPEND_NODE_EMITTED)) then
		dependOn = dependOn.queued
	end

	return itemWith3(state.dependencies, "dependent",dependent, "dependType",dependType, "dependOn",dependOn)
end



local !struct"Queued"{
	{`node`,              nil},       -- AstNode
	{`container`,         nil},       -- Any table.
	{`key`,               nil},       -- String or integer.
	{`pipe`,              PIPE_NONE},
	{`pipeHighestExited`, PIPE_NONE}, -- (Not really used. @Cleanup)
	{`waitingOn`,         nil},       -- Dependency
	{`unqueued`,          false},
}

-- addToQueue( state, node, container=nil, key=nil, pipe [, pipeHighestExited=pipe-1 ] )
local function addToQueue(state, node, container, key, pipe, pipeHighestExited)
	-- astPrint(node)
	!ASSERT `not node.queued`

	local queued     = Queued()
	queued.node      = node
	queued.container = container
	queued.key       = key
	queued.pipe      = pipe
	queued.pipeHighestExited = math.max(pipeHighestExited or pipe-1, !(PIPE_NONE))

	node.queued = queued
	table.insert(state.queue, queued)

	-- Make assignment targets in declaration statements wait for their declaration.
	if
		node.nodeType == !(nodeTypes.AstIdentifier)
		and node.declaration
		and node.parent.nodeType == !(nodeTypes.AstAssignment)
		and node.parent.forDeclaration
		and indexOf(node.parent.targets, node)
	then
		local ident = node
		addDependency(state, ident, !(DEPEND_NODE_INFERRED), ident.declaration.name)
	end
end

-- addToQueueRecursively( state, topNode [, containerForTopNode, keyForTopNode, pipe=PIPE_INFER ] )
-- Note: Skips AstStaticIf branches and most polymorphic nodes.
do
	local function registerNodesToAddToQueue(state, topNode, nodesToAdd)
		astVisitAllNodes(topNode, function(node)
			nodesToAdd[node] = true

			if node.nodeType == !(nodeTypes.AstStaticIf) then
				local staticIf = node
				registerNodesToAddToQueue(state, staticIf.condition, nodesToAdd)
				return !(VISIT_IGNORE_CHILDREN)

			elseif node.nodeType == !(nodeTypes.AstLambda) and node.isPolymorphic then
				local lambda = node
				-- Do we really need to queue any children? 2020-02-02 @Speed @Cleanup
				for _, statement in ipairs(lambda.statements) do
					if statement ~= lambda.body then
						registerNodesToAddToQueue(state, statement, nodesToAdd)
					end
				end
				return !(VISIT_IGNORE_CHILDREN)

			elseif node.nodeType == !(nodeTypes.AstStruct) and node.isPolymorphic then
				return !(VISIT_IGNORE_CHILDREN) -- We don't need to queue anything inside polymorphic structs (I think).
			end
		end)
	end

	function _G.addToQueueRecursively(state, topNode, container0, key0, pipe)
		pipe = pipe or !(PIPE_INFER)

		local nodesToAdd = {}
		registerNodesToAddToQueue(state, topNode, nodesToAdd)

		astVisitAllNodesLeavesFirst(topNode, function(node, container, key)
			if nodesToAdd[node] then
				addToQueue(state, node, (container or container0), (key or key0), pipe)
			end
		end)
	end
end

-- addUnqueuedChildrenToQueueRecursively( state, topNode [, pipe=PIPE_INFER ] )
-- Note: Ignores children of already queued nodes.
-- Note: Skips AstStaticIf branches and most polymorphic nodes.
do
	local function registerNodesToAddToQueue(state, topNode, nodesToAdd)
		astVisitAllNodes(topNode, function(node)
			if node == topNode then
				-- void

			elseif node.queued then
				return !(VISIT_IGNORE_CHILDREN)

			else
				nodesToAdd[node] = true

				if node.nodeType == !(nodeTypes.AstStaticIf) then
					local staticIf = node
					if not staticIf.condition.queued then
						nodesToAdd[staticIf.condition] = true
						registerNodesToAddToQueue(state, staticIf.condition, nodesToAdd)
					end
					return !(VISIT_IGNORE_CHILDREN)

				elseif node.nodeType == !(nodeTypes.AstLambda) and node.isPolymorphic then
					local lambda = node
					-- Do we really need to add any children? 2020-02-02 @Cleanup @Speed
					for _, statement in ipairs(lambda.statements) do
						if not statement.queued and statement ~= lambda.body then
							nodesToAdd[statement] = true
							registerNodesToAddToQueue(state, statement, nodesToAdd)
						end
					end
					return !(VISIT_IGNORE_CHILDREN)

				elseif node.nodeType == !(nodeTypes.AstStruct) and node.isPolymorphic then
					return !(VISIT_IGNORE_CHILDREN) -- We don't need to queue anything inside polymorphic structs (I think).
				end
			end
		end)
	end

	function _G.addUnqueuedChildrenToQueueRecursively(state, topNode, pipe)
		pipe = pipe or !(PIPE_INFER)

		local nodesToAdd = {}
		registerNodesToAddToQueue(state, topNode, nodesToAdd)

		astVisitAllNodesLeavesFirst(topNode, function(node, container, key)
			if nodesToAdd[node] then
				addToQueue(state, node, container, key, pipe)
			end
		end)
	end
end

-- pokeAndQueueUnqueuedNodeIntoTree( state, nodeAtTargetPosition, newNode, containerInNewNode, keyInContainerInNewNode [, pipe=PIPE_INFER ] )
-- newNode will become the new parent for nodeAtTargetPosition.
function _G.pokeAndQueueUnqueuedNodeIntoTree(state, nodeAtTargetPos, newNode, containerInNewNode, keyInNewNode, pipe)
	!ASSERT `not newNode.queued`
	pipe = pipe or !(PIPE_INFER)

	addToQueue(state, newNode, nodeAtTargetPos.queued.container, nodeAtTargetPos.queued.key, pipe)

	-- Replace nodeAtTargetPos with newNode in it's parent.
	nodeAtTargetPos.queued.container[nodeAtTargetPos.queued.key] = newNode

	-- Put nodeAtTargetPos in newNode.
	containerInNewNode[keyInNewNode] = nodeAtTargetPos
	nodeAtTargetPos.parent           = newNode
	nodeAtTargetPos.queued.container = containerInNewNode
	nodeAtTargetPos.queued.key       = keyInNewNode
end

function _G.unqueue(node)
	node.queued.unqueued = true
end

function _G.unqueueChildrenRecursively(state, topNode)
	astVisitAllNodes(topNode, function(node)
		if node ~= topNode then
			node.queued.unqueued = true
		end
	end)
end

-- Note: nodeOld doesn't have to be queued right now - it just needs a Queued object.
-- Note: No node.parent is changed.
-- (@Cleanup: Sometimes we just want to make use of queued.container/key.)
function _G.replaceQueuedNode(state, nodeOld, nodeNew)
	assert(not nodeNew.queued)

	local queued   = nodeOld.queued or errorInternal()
	queued.node    = nodeNew
	nodeOld.queued = nil
	nodeNew.queued = queued

	if queued.container then
		queued.container[queued.key] = nodeNew
	end

	nodeOld.replacedBy = nodeNew
	nodeNew.replacing  = nodeOld

	!if DEBUG then
		-- [[
		if debug_onlyInferTypes then
			io.stdout:write("replace: ") ; astPrint(nodeOld)
			io.stdout:write("   with: ") ; astPrint(nodeNew)
			-- where(state, nodeOld)
			-- where(state, nodeOld.parent)
		end
		--]]
	!end
end

function _G.replaceQueuedNodeAndUnqueueOldTree(state, nodeOld, nodeNew)
	unqueueChildrenRecursively(state, nodeOld)
	replaceQueuedNode(state, nodeOld, nodeNew)
end

-- Note: We update the parent of childTreeNodeToHookIn here.
function _G.cutOutPartOfNodeTree(state, nodeToRemove, childTreeNodeToHookIn)
	astVisitAllNodes(nodeToRemove, function(node)
		if node ~= nodeToRemove          then  node.queued.unqueued = true      end
		if node == childTreeNodeToHookIn then  return !(VISIT_IGNORE_CHILDREN)  end
	end)

	childTreeNodeToHookIn.queued = nil -- This will be replaced with nodeToRemove.queued in replaceQueuedNode().
	childTreeNodeToHookIn.parent = nodeToRemove.parent

	replaceQueuedNode(state, nodeToRemove, childTreeNodeToHookIn)
end



function _G.moveToPipe(state, node, targetPipe)
	local queued             = node.queued
	queued.pipeHighestExited = math.max(queued.pipeHighestExited, queued.pipe)
	queued.pipe              = targetPipe
end

function _G.moveToNextPipe(state, node, targetPipe)
	local queued = node.queued

	if targetPipe ~= queued.pipe+1 then
		errorInternal(
			2, "Trying to move %s node from pipe %d (%s) to %d (%s).",
			AST_NODE_TYPE_NAMES[node.nodeType],
			queued.pipe, (PIPE_TITLES[queued.pipe] or "*INVALID*"),
			targetPipe,  (PIPE_TITLES[targetPipe]  or "*INVALID*")
		)
	end

	queued.pipeHighestExited = math.max(queued.pipeHighestExited, queued.pipe)
	queued.pipe              = targetPipe
end

function _G.moveTreeToNextPipe(state, topNode, targetPipe)
	astVisitAllNodes(topNode, function(node)
		moveToNextPipe(state, node, targetPipe)
	end)
end

function _G.moveToNextRelevantPipe(state, node)
	local pipe = node.queued.pipe

	if pipe == !(PIPE_INFER) then
		if isAny(node.nodeType, !(nodeTypes.AstLiteral),!(nodeTypes.AstDeclaration),!(nodeTypes.AstAccess),!(nodeTypes.AstForeign)) then
			moveToNextPipe(state, node, !(PIPE_BYTECODE))

		elseif node.nodeType == !(nodeTypes.AstLambda) then
			local lambda = node
			if lambda.isPolymorphic then
				moveToPipe(state, lambda, !(PIPE_DONE))
			elseif lambda.body then
				moveToNextPipe(state, lambda, !(PIPE_BYTECODE))
			else
				moveToPipe(state, lambda, !(PIPE_DONE))
			end

		else
			moveToPipe(state, node, !(PIPE_DONE))
		end

	elseif pipe == !(PIPE_BYTECODE) then
		moveToNextPipe(state, node, !(PIPE_DONE))

	elseif pipe == !(PIPE_DONE) then
		printerr("Warning: Trying to move nodes past PIPE_DONE!")

	else
		errorInternal()
	end
end

function _G.moveTreeToNextRelevantPipe(state, topNode)
	local currentPipe = topNode.queued.pipe

	astVisitAllNodes(topNode, function(node)
		if node.queued.pipe ~= currentPipe then
			errorInternal("A child node is in an unexpected pipe. (Expected %d, was %d)", currentPipe, node.queued.pipe)
		end
		moveToNextRelevantPipe(state, node)
	end)
end

function _G.moveChildrenToNextRelevantPipe(state, topNode)
	local currentPipe = nil

	astVisitAllNodes(topNode, function(node)
		if node == topNode then  return  end

		currentPipe = currentPipe or node.queued.pipe

		if node.queued.pipe ~= currentPipe then
			errorInternal("A child node is in an unexpected pipe. (Expected %d, was %d)", currentPipe, node.queued.pipe)
		end
		moveToNextRelevantPipe(state, node)
	end)
end



function _G.errorPipesAreStuck(state)
	-- [[ Report undeclared identifier.
	local function getDeclaredIdentifierWaitingToBeDeclaredWithName(name, queuedToIgnore) -- @Cleanup: What is this even?!?!
		for _, queued in ipairs(state.queue) do
			if queued ~= queuedToIgnore and not queued.unqueued and queued.waitingOn and queued.node.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = queued.node
				if ident.parent == ident.declaration and ident.name == name then  return queued  end
			end
		end
		return nil
	end

	for _, queued in ipairs(state.queue) do
		local dependency = not queued.unqueued and queued.waitingOn

		if dependency and dependency.dependType == !(DEPEND_DECLARATION) then
			local name = dependency.dependOn

			if not getDeclaredIdentifierWaitingToBeDeclaredWithName(name, queued) then
				local node = queued.node

				if name == "..." then
					typeError(state, node, "This is not inside a function that takes a vararg.")

				elseif node.nodeType == !(nodeTypes.AstAccess) then
					local access = node

					if access.object.inferredType.scope.nodeType == !(nodeTypes.AstFileScope) then
						local fileScope = access.object.inferredType.scope
						typeError(
							state, node.member,
							"Undeclared identifier '%s' in %s '%s'.",
							name,
							fileScope.isModule and "module"             or "the file scope of",
							fileScope.isModule and fileScope.moduleName or fileScope.path
						)
					else
						printerr()
						typeMessage(io.stderr, state, access.member,                    "Error", "Undeclared identifier '%s'.", name)
						typeMessage(io.stderr, state, access.object.inferredType.scope, "Info",  "...this is the namespace.")
						exitFailure()
					end

				else
					typeError(state, node, "Undeclared identifier '%s'.", name)
				end
			end
		end
	end
	--]]

	-- [[
	for _, queued in ipairs(state.queue) do
		local dependency = not queued.unqueued and queued.waitingOn

		if dependency and dependency.dependType == !(DEPEND_STRUCT_MEMBERS_READY) then
			local structInfo = dependency.dependOn

			printerr()
			!ifDEBUG`astPrint(structInfo.astNode)`
			typeMessage(io.stderr, state, structInfo.astNode, "Error", "Failed generating member info for this struct.")
			!ifDEBUG`astPrint(queued.node)`
			typeMessage(io.stderr, state, queued.node,        "Info",  "...this thing is waiting for the members to be ready.")
			exitFailure()
		end
	end
	--]]

	-- [[ Report identifier waiting for declaration to be inferred.
	for _, queued in ipairs(state.queue) do
		local dependency = not queued.unqueued and queued.waitingOn

		if
			dependency
			and dependency.dependType             == !(DEPEND_NODE_INFERRED)
			and queued.node.nodeType              == !(nodeTypes.AstIdentifier)
			and dependency.dependOn.node.nodeType == !(nodeTypes.AstDeclaration)
		then
			local decl = dependency.dependOn.node

			printerr()
			!ifDEBUG`astPrint(expr)`
			typeMessage(io.stderr, state, decl,        "Error", "Failed inferring the type of this declaration.")
			!ifDEBUG`astPrint(queued.node)`
			typeMessage(io.stderr, state, queued.node, "Info",  "...this identifier is waiting for the above to finish.")
			exitFailure()
		end
	end
	--]]

	-- [[ Report about-to-be-declared identifier waiting for something.
	for _, queued in ipairs(state.queue) do
		local dependency = not queued.unqueued and queued.waitingOn

		if
			dependency
			and dependency.dependType == !(DEPEND_NODE_INFERRED)
			and queued.node.nodeType  == !(nodeTypes.AstIdentifier)
			and queued.node.parent    == queued.node.declaration
		then
			local expr = dependency.dependOn.node

			printerr()
			!ifDEBUG`astPrint(expr)`
			typeMessage(io.stderr, state, expr,        "Error", "Failed inferring the type of this expression.")
			!ifDEBUG`astPrint(queued.node)`
			typeMessage(io.stderr, state, queued.node, "Info",  "...this identifier is waiting for the above to finish.")
			exitFailure()
		end
	end
	--]]

	-- [[ Report something waiting for something else to be inferred.
	for _, queued in ipairs(state.queue) do
		local dependency = not queued.unqueued and queued.waitingOn

		if dependency and dependency.dependType == !(DEPEND_NODE_INFERRED) then
			local expr = dependency.dependOn.node

			printerr()
			!ifDEBUG`astPrint(expr)`
			typeMessage(io.stderr, state, expr,        "Error", "Failed inferring the type of this expression.")
			!ifDEBUG`astPrint(queued.node)`
			typeMessage(io.stderr, state, queued.node, "Info",  "...this thing is waiting for the above to finish.")
			exitFailure()
		end
	end
	--]]

	-- [[ Report something waiting for something else to emit code.
	for _, queued in ipairs(state.queue) do
		local dependency = not queued.unqueued and queued.waitingOn

		if dependency and dependency.dependType == !(DEPEND_NODE_EMITTED) then
			local expr = dependency.dependOn.node

			printerr()
			astPrint(queued.node)
			bcMessage(io.stderr, state, queued.node, "Error", "Internal compiler error: Failed emitting code for %s.", AST_NODE_TYPE_NAMES[queued.node.nodeType])
			astPrint(expr)
			bcMessage(io.stderr, state, expr,        "Info",  "...it is waiting for this %s to finish.", AST_NODE_TYPE_NAMES[expr.nodeType])
			exitFailure()
		end
	end
	--]]

	errorInternal("Pipes are stuck. Also failed to figure out where the issue actually is. Oops...")
end


