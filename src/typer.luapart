--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	areConstantTreesEqual
	areMultipleValuesEnabledAtPosition
	checkBinaryOperation
	crawl
	createTypeNodeFromInfo
	doesImperativeBlockHaveVariableDeclarations
	findDeclaration, findPublicDeclarationInScope, findMemberDeclaration, findDynamicMemberDeclaration, canNodeSeeDeclaration, printDeclarationChain
	findInferredPreloadDeclaration
	followIdentifiersToConstantValue
	getAssignmentValue
	getDeclarationValue, isDeclarationGlobal, isDeclarationConstant, isDeclarationWritable, isDeclarationImperative, shouldDeclarationValueDefinitivelyBeConstant
	getLambda
	inferNode, queueForReinfer
	isExpressionConstant, isExpressionExactlyOneValue
	isScope, isScopeDeclarative, isScopeImperative
	isTypeSimple, isTypeNumeric, isTypeTableLike, isTypePublic, isTypeCompatibleWith, isAnyTypeCompatibleWith, doesStructInherit, adjustTypeToOne, compareIdsOfTypes
	newTypeInfo, markTypeAsReady, seeType, seeMultipleTypes, isTypeBuiltin, getTypeInfo*
	prepareToRun
	simplifyExpressionIfConstant, simplifyTypeExpression
	typeError*, typeMessage
	wrapInImplicitCast

--============================================================]]
!recordLineNumber(@file, @line)



!(
local structTypeInfo = struct
-- local function structTypeInfo(nameAndMaybeParent) return function(fields)
-- 	struct(nameAndMaybeParent)(fields)
-- end end
)

!struct"_TypeInfo"{
	{`tag`,     0}, -- This is like the "type of type" or the "type group". The word "type" is used in so many places so we call it "tag" here to make it less confusing.
	{`id`,      0},
	{`isReady`, false},
	{`seen`,    {}}, -- []TypeInfo and set of TypeInfo.
}

local !structTypeInfo"TypeInfoAny:_TypeInfo"   {_overrides={{`tag`,TYPE_ANY}}}
local !structTypeInfo"TypeInfoBool:_TypeInfo"  {_overrides={{`tag`,TYPE_BOOL}}}
local !structTypeInfo"TypeInfoInt:_TypeInfo"   {_overrides={{`tag`,TYPE_INT}}}
local !structTypeInfo"TypeInfoNone:_TypeInfo"  {_overrides={{`tag`,TYPE_NONE}}}
local !structTypeInfo"TypeInfoFloat:_TypeInfo" {_overrides={{`tag`,TYPE_FLOAT}}}
local !structTypeInfo"TypeInfoString:_TypeInfo"{_overrides={{`tag`,TYPE_STRING}}}
local !structTypeInfo"TypeInfoTable:_TypeInfo" {_overrides={{`tag`,TYPE_TABLE}}}
local !structTypeInfo"TypeInfoType:_TypeInfo"  {_overrides={{`tag`,TYPE_TYPE}}}

local !structTypeInfo"TypeInfoVoid:_TypeInfo"       {_overrides={{`tag`,TYPE_VOID}}}
local !structTypeInfo"TypeInfoPlaceholder:_TypeInfo"{_overrides={{`tag`,TYPE_PLACEHOLDER}}}

_G.SIMPLE_TYPES = !({
	-- These small type infos don't have any extra information.
	[TYPE_ANY]    = true,
	[TYPE_BOOL]   = true,
	[TYPE_INT]    = true,
	[TYPE_NONE]   = true,
	[TYPE_FLOAT]  = true,
	[TYPE_STRING] = true,
	[TYPE_TABLE]  = true,
	[TYPE_TYPE]   = true,
})

local !structTypeInfo"TypeInfoArray:_TypeInfo"{
	_overrides={{`tag`,TYPE_ARRAY}},
	{`itemType`, nil}, -- TypeInfo
}

local !structTypeInfo"TypeInfoVararg:_TypeInfo"{
	_overrides={{`tag`,TYPE_VARARG}},
	{`itemType`, nil}, -- TypeInfo
}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{ -- AKA function signature.
	_overrides={{`tag`,TYPE_FUNCTION}},
	{`argumentTypesIn`,  {}}, -- []TypeInfo  @Cleanup: Use TypeInfoList here?
	{`argumentTypesOut`, {}}, -- []TypeInfo  @Cleanup: Use TypeInfoList here?
	{`isPolymorphic`,    false},
}

local !struct"TypeInfoStructMember"{
	{`name`,     ""},
	{`typeInfo`, nil},
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	_overrides={{`tag`,TYPE_STRUCT}},

	{`astNode`,       nil},   -- AstStruct
	{`name`,          ""},    -- Filled in during definition.

	{`kind`,          STRUCT_KIND_NORMAL}, -- STRUCT_KIND_NORMAL|STRUCT_KIND_TABLE|STRUCT_KIND_ARRAY
	{`keyType`,       nil},   -- TypeInfo  Used if kind==STRUCT_KIND_TABLE.
	{`valueType`,     nil},   -- TypeInfo  Used if kind~=STRUCT_KIND_NORMAL.

	{`members`,       {}},    -- []TypeInfoStructMember
	{`hasMembers`,    false}, -- @Cleanup: Can we remove this and rely on isReady? I think so. 2021-07-29 (Or maybe not? 2021-07-30)

	{`isPolymorphic`, false},
}

local !struct"TypeInfoEnumMember"{
	{`name`, ""},
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	_overrides={{`tag`,TYPE_ENUM}},

	{`astNode`,        nil}, -- AstEnum
	{`name`,           ""},

	{`memberTypeInfo`, nil}, -- Must be one of these primitive types: int, string, Type, bool or float.

	{`members`,        {}},  -- []TypeInfoEnumMember
	{`hasMembers`,    false}, -- @Cleanup: Can we remove this and rely on isReady? I think so. 2021-07-29 (Or maybe not? 2021-07-30)
}

local !structTypeInfo"TypeInfoNamespace:_TypeInfo"{
	_overrides={{`tag`,TYPE_NAMESPACE}},
	{`scope`, nil}, -- AstScope
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	_overrides={{`tag`,TYPE_COMPOUND}},
	-- [1]=typeInfo1, ...
}

local !structTypeInfo"TypeInfoList:_TypeInfo"{ -- Special type used for returns from calls (both when sending and receiving).
	_overrides={{`tag`,TYPE_LIST}},
	-- [1]=typeInfo1, ...
}



-- typeInfo = newTypeInfo( compilationState, TypeInfoCreator )
function _G.newTypeInfo(state, TypeInfoCreator)
	!ifDEBUG `if not TypeInfoCreator then  errorInternal(2, "No TypeInfoCreator specified.")  end`

	state.lastTypeId = state.lastTypeId+1

	local typeInfo   = TypeInfoCreator()
	typeInfo.id      = state.lastTypeId

	typeInfo.seen[1]        = typeInfo
	typeInfo.seen[typeInfo] = true

	--[[
	if typeInfo.id == 22 then
		errorInternal("DEBUG")
	end
	--]]

	return typeInfo
end

function _G.markTypeAsReady(state, typeInfo)
	!ASSERT `not typeInfo.isReady`
	typeInfo.isReady = true
	if state.runnerWriter and isTypePublic(typeInfo) then
		getPublicType(state, typeInfo)
	end
end

function _G.seeType(typeInfo, seenTypeInfo)
	-- !ASSERT `typeInfo.tag`
	-- !ASSERT `seenTypeInfo.tag`

	if typeInfo.seen[seenTypeInfo] then  return  end

	typeInfo.seen[seenTypeInfo] = true
	table.insert(typeInfo.seen, seenTypeInfo)

	for _, innerSeenTypeInfo in ipairs(seenTypeInfo.seen) do
		seeType(typeInfo, innerSeenTypeInfo)
	end
end

function _G.seeMultipleTypes(typeInfo, seenTypeInfos)
	for _, seenTypeInfo in ipairs(seenTypeInfos) do
		seeType(typeInfo, seenTypeInfo)
	end
end

do
	local BUILTIN_TYPE_NAMES = {
		"any",
		"bool",
		"int",
		"none",
		"float",
		"string",
		"table",
		"Type",
		"void",
		"placeholder",
	}
	local BUILTIN_TYPE_STRUCTS = {
		["any"]         = TypeInfoAny,
		["bool"]        = TypeInfoBool,
		["int"]         = TypeInfoInt,
		["none"]        = TypeInfoNone,
		["float"]       = TypeInfoFloat,
		["string"]      = TypeInfoString,
		["table"]       = TypeInfoTable,
		["Type"]        = TypeInfoType,        -- The result of e.g. type_of(int) or type_of(type_of(expression)).
		["void"]        = TypeInfoVoid,        -- Used when no useful type is expected or available.
		["placeholder"] = TypeInfoPlaceholder, -- Used in polymorphic functions.
	}
	local BUILTIN_TYPE_TAG_TO_NAME = {
		[!(TYPE_ANY)]         = "any",
		[!(TYPE_BOOL)]        = "bool",
		[!(TYPE_INT)]         = "int",
		[!(TYPE_NONE)]        = "none",
		[!(TYPE_FLOAT)]       = "float",
		[!(TYPE_STRING)]      = "string",
		[!(TYPE_TABLE)]       = "table",
		[!(TYPE_TYPE)]        = "Type",
		[!(TYPE_VOID)]        = "void",
		[!(TYPE_PLACEHOLDER)] = "placeholder",
	}

	function _G.addTypeInfosForBuiltinTypes(state)
		for _, typeName in ipairs(BUILTIN_TYPE_NAMES) do
			local typeInfo   = newTypeInfo(state, BUILTIN_TYPE_STRUCTS[typeName])
			typeInfo.isReady = true -- No need to call markTypeAsReady() at this point. No usercode should be running.

			state.builtinTypeInfos[typeName] = typeInfo
			table.insert(state.allTypeInfos,                    typeInfo)
			table.insert(state.allTypeInfosByTag[typeInfo.tag], typeInfo)
		end
	end

	-- bool, typeName = isTypeBuiltin( typeInfo )
	function _G.isTypeBuiltin(typeInfo)
		local typeName = BUILTIN_TYPE_TAG_TO_NAME[typeInfo.tag]
		if not typeName then  return false, ""  end

		return true, typeName
	end
end

local function doesLambdaHaveSignature(lambda, funcSig)
	local argsIn     = lambda.argumentsIn
	local argTypesIn = funcSig.argumentTypesIn
	if (argsIn and #argsIn.arguments or 0) ~= #argTypesIn then  return false  end

	local argsOut     = lambda.argumentsOut
	local argTypesOut = funcSig.argumentTypesOut
	if (argsOut and #argsOut.arguments or 0) ~= #argTypesOut then  return false  end

	if argsIn then
		for i, arg in ipairs(argsIn.arguments) do
			if arg.declaration.inferredType ~= argTypesIn[i] then  return false  end
		end
	end
	if argsOut then
		for i, arg in ipairs(argsOut.arguments) do
			if arg.declaration.inferredType ~= argTypesOut[i] then  return false  end
		end
	end

	-- if (lambda.polymorphs ~= nil) ~= funcSig.isPolymorphic then  return false  end  -- Not needed when using dumbHash.

	return true
end

function _G.getTypeInfoForLambda(state, lambda)
	local argsIn   = lambda.argumentsIn
	local argsOut  = lambda.argumentsOut
	local dumbHash = 0

	if lambda.polymorphs then
		dumbHash = -(1 + (argsIn and #argsIn.arguments or 0) + (argsOut and #argsOut.arguments*0x100 or 0))

	else
		if argsIn then
			for argIndex, arg in ipairs(argsIn.arguments) do
				local argType = arg.declaration.inferredType
				if not argType then  return nil  end
				dumbHash = dumbHash+argType.id*argIndex*argIndex
			end
		end
		if argsOut then
			for argIndex, arg in ipairs(argsOut.arguments) do
				local argType = arg.declaration.inferredType
				if not argType then  return nil  end
				dumbHash = dumbHash+argType.id*argIndex*argIndex*0x1000
			end
		end
	end

	local byTagAndValue      = state.allTypeInfosByTagAndValue[!(TYPE_FUNCTION)]
	local typeInfoCached     = byTagAndValue[dumbHash] -- Linked list where the first key is the hash and the rest are type infos.
	local typeInfoCachedLast = nil

	while typeInfoCached do
		if doesLambdaHaveSignature(lambda, typeInfoCached) then  return typeInfoCached  end
		typeInfoCachedLast = typeInfoCached
		typeInfoCached     = byTagAndValue[typeInfoCached]
	end

	local funcSig         = newTypeInfo(state, TypeInfoFunction)
	funcSig.isPolymorphic = lambda.polymorphs ~= nil

	local placeholderType       = lambda.polymorphs and state.builtinTypeInfos.placeholder           or nil
	local placeholderTypeVararg = placeholderType   and getTypeInfoForVararg(state, placeholderType) or nil

	local allAreReady = true

	if argsIn then
		for i, arg in ipairs(argsIn.arguments) do
			local typeInfo = (
				placeholderType
				and (arg.declaration.name.nodeType == !(AST_VARARG) and placeholderTypeVararg or placeholderType)
				or  arg.declaration.inferredType or errorInternal(state, arg)
			)
			seeType(funcSig, typeInfo)
			funcSig.argumentTypesIn[i] = typeInfo
			allAreReady                = allAreReady and typeInfo.isReady
		end
	end
	if argsOut then
		for i, arg in ipairs(argsOut.arguments) do
			local typeInfo = (
				placeholderType
				and (arg.declaration.name.nodeType == !(AST_VARARG) and placeholderTypeVararg or placeholderType)
				or  arg.declaration.inferredType or errorInternal(state, arg)
			)
			seeType(funcSig, typeInfo)
			funcSig.argumentTypesOut[i] = typeInfo
			allAreReady                 = allAreReady and typeInfo.isReady
		end
	end

	table.insert(state.allTypeInfos,                        funcSig)
	table.insert(state.allTypeInfosByTag[!(TYPE_FUNCTION)], funcSig)
	byTagAndValue[typeInfoCachedLast or dumbHash] = funcSig

	if allAreReady then
		markTypeAsReady(state, funcSig)
	end

	return funcSig
end

do
	local function getTypeInfoForListOrCompoundType(state, typeInfos, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfosByTag[tag]) do
			if areArraysEqual(typeInfos, typeInfoCached) then  return typeInfoCached  end
		end

		local typeInfo = newTypeInfo(state, schematicForTypeInfo)
		copyToArray(typeInfos, typeInfo)

		seeMultipleTypes(typeInfo, typeInfos)

		table.insert(state.allTypeInfos,           typeInfo)
		table.insert(state.allTypeInfosByTag[tag], typeInfo)

		local allAreReady = true

		for _, itemType in ipairs(typeInfos) do
			if not itemType.isReady then
				allAreReady = false
				break
			end
		end

		if allAreReady then
			markTypeAsReady(state, typeInfo)
		end

		return typeInfo
	end

	function _G.getTypeInfoForList(state, typeInfos)
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(TYPE_LIST), TypeInfoList)
	end

	-- Note: typeInfos is expected to be sorted by type ID already if doSort is false.
	function _G.getTypeInfoForCompoundType(state, typeInfos, doSort)
		!ASSERT `type(doSort) == "boolean"`
		if doSort then
			table.sort(typeInfos, compareIdsOfTypes)
		end
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(TYPE_COMPOUND), TypeInfoCompound)
	end
end

do
	local function getTypeInfoForArrayOrVararg(state, itemType, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfosByTag[tag]) do
			if itemType == typeInfoCached.itemType then  return typeInfoCached  end
		end

		local typeInfo    = newTypeInfo(state, schematicForTypeInfo)
		typeInfo.itemType = itemType or errorInternal()

		seeType(typeInfo, itemType)

		table.insert(state.allTypeInfos,           typeInfo)
		table.insert(state.allTypeInfosByTag[tag], typeInfo)

		if itemType.isReady then
			markTypeAsReady(state, typeInfo)
		end

		return typeInfo
	end

	function _G.getTypeInfoForArray(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(TYPE_ARRAY), TypeInfoArray)
	end

	function _G.getTypeInfoForVararg(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(TYPE_VARARG), TypeInfoVararg)
	end
end

function _G.getTypeInfoForNamespace(state, scope)
	!ASSERT `scope`

	local byTagAndValue  = state.allTypeInfosByTagAndValue[!(TYPE_NAMESPACE)]
	local typeInfoCached = byTagAndValue[scope]
	if typeInfoCached then  return typeInfoCached  end

	local namespaceInfo = newTypeInfo(state, TypeInfoNamespace)
	namespaceInfo.scope = scope

	table.insert(state.allTypeInfos,                         namespaceInfo)
	table.insert(state.allTypeInfosByTag[!(TYPE_NAMESPACE)], namespaceInfo)
	byTagAndValue[scope] = namespaceInfo

	markTypeAsReady(state, namespaceInfo)

	return namespaceInfo
end



-- Note: The expression must already be inferred!
function _G.getTypeRepresentedByExpression(expr)
	!ASSERT `expr.inferredType`
	local nodeType = expr.nodeType

	if nodeType == !(AST_TYPE) or nodeType == !(AST_STRUCT) or nodeType == !(AST_ENUM) or nodeType == !(AST_TYPE_OF) then
		return expr.representedType

	elseif nodeType == !(AST_CAST) then
		return
			expr.inferredType.tag == !(TYPE_TYPE) -- Is this check needed? @Speed
			and getTypeRepresentedByExpression(expr.expression)
			or  nil

	elseif nodeType == !(AST_IDENTIFIER) then
		return expr.declaration.valueTypeInfo -- May be nil.
	elseif nodeType == !(AST_BAKE) then
		return expr.name.declaration.valueTypeInfo -- May be nil.

	-- elseif expr.inferredType.tag == !(TYPE_TYPE) then
	-- 	errorInternal("Incomplete: Unhandled type node type '%s'.", AST_NAMES[expr.nodeType]) -- (Good? Not sure. 2021-07-31)
	else
		return nil
	end
end

-- Note: The expression must already be inferred!
function _G.requireTypeRepresentedByExpression(state, expr)
	local typeInfoRepresented = getTypeRepresentedByExpression(expr)
	if typeInfoRepresented then  return typeInfoRepresented  end

	local typeInfo = expr.inferredType

	if typeInfo.tag == !(TYPE_LIST) then
		typeError(state, expr, "Expected a type. This is a function call.")
	elseif typeInfo.tag ~= !(TYPE_TYPE) then
		typeError(state, expr, "Expected a type. (Got %s)", getFriendlyTypeInfoName(typeInfo))
	elseif not isExpressionConstant(state, expr, false) then
		-- @UX: Better message for foreign values.
		typeError(state, expr, "Expected a constant. (Got variable of type '%s')", getFriendlyTypeInfoName(typeInfo))
	else
		!ifDEBUG `print(getFriendlyTypeInfoName(typeInfo))`
		errorInternal(state, expr, "The expression should represent a type but we somehow don't have any TypeInfo.")
	end
end



function _G.isScope(node)  return SCOPE_SET[node.nodeType] or false  end

function _G.isScopeDeclarative(scope)  return SCOPE_SET_DECLARATIVE[scope.nodeType] or false  end
function _G.isScopeImperative (scope)  return SCOPE_SET_IMPERATIVE [scope.nodeType] or false  end



function _G.doesImperativeBlockHaveVariableDeclarations(block)
	return nil ~= (
		itemWith1(block.declarations, `kind`, !(DECL_KIND_LOCAL_VAR))
		-- or itemWith1(block.declarations, `kind`, !(DECL_KIND_READ_ONLY))
	)
end



function _G.getLambda(node)
	return astFindParent1(node, !(AST_LAMBDA))
end



-- declaration, fromUsing = findDeclaration( compilationState, startNode, name [, declarationToIgnore ] )
function _G.findDeclaration(state, startNode, name, declToIgnore)
	local ipairs                = ipairs
	local astFindParentScope    = astFindParentScope
	local canNodeSeeDeclaration = canNodeSeeDeclaration
	local isDeclarationConstant = isDeclarationConstant
	local isDeclarationExported = isDeclarationExported

	local scope = isScope(startNode) and startNode or astFindParentScope(startNode)

	while scope do
		-- This seem a little bit @Ugly maybe. How does this compare to polymorphic functions regarding declarations
		-- existing directly in the scope? (Baked values in functions probably set decl.checkedRedeclaration.)
		while scope.nodeType == !(AST_STRUCT) and scope.polymorphs do
			scope = astFindParentScope(scope)
			if not scope then  return nil, nil  end
		end

		do
			local decl = (
				not scope.declarationsByName[declToIgnore]
				and scope.declarationsByName[name]
				or  scope.declarationsByName2[name]
			)
			if decl and canNodeSeeDeclaration(state, startNode, decl) then
				-- assert(decl ~= declToIgnore)
				return decl, nil
			end
		end

		if scope.imports then
			for _, import in ipairs(scope.imports) do
				local fileScope = import.fileScope
				local decl = fileScope and (
					not fileScope.declarationsByName[declToIgnore]
					and fileScope.declarationsByName[name]
					or  fileScope.declarationsByName2[name]
				)
				if decl and isDeclarationExported(decl) then
					-- assert(decl ~= declToIgnore)
					return decl, nil
				end
			end
		end

		if scope.usings then
			for _, using in ipairs(scope.usings) do
				local usingScope = using.scope
				local decl = usingScope and (
					not usingScope.declarationsByName[declToIgnore]
					and usingScope.declarationsByName[name]
					or  usingScope.declarationsByName2[name]
				)
				local nodeType = decl and usingScope.nodeType
				if nodeType
					and (
						not (nodeType == !(AST_FILE_SCOPE) or nodeType == !(AST_GLOBAL_SCOPE) or nodeType == !(AST_NAMESPACE)) -- Look for only exports in these scopes.
						or isDeclarationExported(decl)
					)
					and (
						isDeclarationConstant(decl)
						or (
							using.variableDeclaration
							and canNodeSeeDeclaration(state, startNode, using.variableDeclaration)
						)
					)
				then
					-- assert(decl ~= declToIgnore)
					return decl, using
				end
			end
		end

		-- Don't cross any module boundary!
		if scope.nodeType == !(AST_FILE_SCOPE) and scope.isModule then
			break
		end

		scope = astFindParentScope(scope)
	end

	return nil, nil
end

function _G.findPublicDeclarationInScope(state, scope, name)
	!ASSERT `name`
	if scope.nodeType == !(AST_FILE_SCOPE) or scope.nodeType == !(AST_NAMESPACE) then
		local decl = scope.declarationsByName[name]
		return decl and isDeclarationExported(decl) and decl or nil
	else
		return scope.declarationsByName[name]
	end
end
function _G.findMemberDeclaration(state, scope, name)
	!ASSERT `name`
	return scope.declarationsByName[name]
end
function _G.findDynamicMemberDeclaration(state, scope, name)
	!ASSERT `name`
	local decl = scope.declarationsByName[name]
	return decl and decl.kind == !(DECL_KIND_LOCAL_VAR) and decl or nil
end

function _G.findDeclarationInEnumForValue(state, enum, constValueExpr)
	for _, decl in ipairs(enum.declarations) do
		assert(constValueExpr.nodeType == decl.value.nodeType)

		if decl.value.nodeType == !(AST_LITERAL) then
			if decl.value.value == constValueExpr.value then  return decl  end

		elseif decl.value.nodeType == !(AST_TYPE) then
			if decl.value.representedType == constValueExpr.representedType then  return decl  end

		else
			errorUnhandledNodeType(state, constValueExpr)
		end
	end

	return nil
end

do
	local indexOf            = indexOf
	local itemWith1Remember  = itemWith1Remember
	local astFindParentScope = astFindParentScope
	local isScopeDeclarative = isScopeDeclarative

	function _G.canNodeSeeDeclaration(state, node, decl)
		-- It doesn't matter if this is true and we're in a declarative scope because we check that in the loop below.
		local canSeeImperativeVariables = (decl.kind == !(DECL_KIND_LOCAL_VAR) --[[or decl.kind == !(DECL_KIND_READ_ONLY)]])

		local name                     = decl.name.name
		local nodeScope, nodeStatement = astFindParentScope(node)
		local nodeScope0               = nodeScope

		if nodeStatement.nodeType == !(AST_DECLARATION) then
			nodeStatement = nodeStatement.assignment or nodeStatement -- Not sure if needed. See :DeclarationAssignment
		elseif nodeStatement.nodeType == !(AST_ARGUMENTS) then
			nodeStatement = astFindParent1(node, !(AST_ARGUMENT)) or errorInternal()
		end

		while true do
			if not (nodeScope.declarationsByName[name] and indexOf(nodeScope.declarations, decl)) then -- @Speed: Don't call indexOf()! Also, indexOfRemember() doesn't seem to be faster here. 2020-07-15
			-- if not (nodeScope.declarationsByName[name] and indexOfRemember(nodeScope.declarations, nodeScope.declarations, decl)) then -- I don't think this works when !if adds declarations. 2020-06-20
				-- void  (Keep looking through parent scopes and update canSeeImperativeVariables as we go.)

			-- Non-static declarations are always visible.
			elseif not (decl.kind == !(DECL_KIND_LOCAL_VAR) --[[or decl.kind == !(DECL_KIND_READ_ONLY)]]) then
				return true

			-- Everything in declarative scopes is always visible EXCEPT (variable) struct members
			-- (and enum members but those don't matter as they're always constant).
			elseif isScopeDeclarative(nodeScope) then
				return not (
					nodeScope.nodeType == !(AST_STRUCT)
					and nodeScope ~= nodeScope0
				)

			elseif not canSeeImperativeVariables then
				return false

			-- Imperative scopes
			----------------------------------------------------------------

			elseif nodeScope.nodeType == !(AST_BLOCK) then
				local block = nodeScope

				-- Note: If the node is inside the initial assignment then we need to treat the declaration
				-- and the assignment as if they were the same statement. Otherwise the assignment will be
				-- able to see it's own declarations, which is illegal! :DeclarationAssignment
				local declScope, declStatement = astFindParentScope(decl.assignment or decl)
				assert(declScope == block)

				return (declStatement.position < nodeStatement.position)

			elseif nodeScope.nodeType == !(AST_LAMBDA) then
				-- Lambdas act as imperative scopes for arguments, but declarative scopes otherwise. (Could maybe use some @Cleanup.)
				local lambda = nodeScope
				if lambda ~= nodeScope0 then  return true  end

				-- We should only get here if both node and decl is inside arguments.
				local arg = decl.parent
				!ASSERT("arg.nodeType           == "..AST_ARGUMENT)
				!ASSERT("nodeStatement.nodeType == "..AST_ARGUMENT)

				!if DEBUG then
					if arg.source.path ~= node.source.path then
						typeError2(state, node, "Internal compiler error: node", arg, "arg")
					end
				!end

				return (arg.position < nodeStatement.position)

			elseif nodeScope.nodeType == !(AST_FOR) then
				-- This is really a combination of a declarative scope and an imperative scope. (Not sure if this is good. 2020-03-19)
				-- @Robustness: Give a makeover similar to AST_LAMBDA here below? 2020-04-27
				return true

			----------------------------------------------------------------

			else
				errorUnhandledNodeType(state, nodeScope)
			end

			if canSeeImperativeVariables and nodeScope.nodeType == !(AST_LAMBDA) and not (
				(nodeScope.captures and itemWith1Remember(nodeScope.captures, nodeScope.captures, `name`, name))
				or nodeScope.captureAll
			) then
				-- Lambdas act as the only boundary between imperative and declarative
				-- scopes right now. Maybe this will change in the future? 2019-12-07
				canSeeImperativeVariables = false
			end

			nodeScope, nodeStatement = astFindParentScope(nodeScope)
			if not nodeScope then  return false  end
		end
	end
end

-- printDeclarationChain( [ file=io.stdout, ] compilationState, declaration, typeName )
function _G.printDeclarationChain(file, state, decl, typeName)
	if type(file) ~= "userdata" then  return printDeclarationChain(io.stdout, file, state, decl)  end

	!local MAX_CHAIN_LENGTH = 10

	for _ = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(file, state, decl.name, "Info", "...here is '%s' declared.", typeName)

		local declCurrent = decl.name.declaration -- @Cleanup: Can we use decl.name.declaration instead here?
		if not declCurrent then  break  end

		decl            = nil
		local valueExpr = getDeclarationValue(declCurrent)

		if valueExpr then
			while valueExpr.replacing do  valueExpr = valueExpr.replacing  end

			if valueExpr.nodeType == !(AST_IDENTIFIER) then
				local ident = valueExpr
				typeName    = ident.name
				decl        = ident.declaration or findDeclaration(state, ident, typeName, declCurrent)
			end
		end

		if not decl then  break  end
	end
end



-- declaration = findInferredPreloadDeclaration( state, dependent, name, tag, waitIfNotInferred )
-- Returns nil if the declaration is not inferred, and if waitIfNotInferred is set, the dependent is now waiting.
function _G.findInferredPreloadDeclaration(state, dependent, name, tag, waitIfNotInferred)
	local module = itemWith2(state.globalScope.fileScopes, "isModule",true, "moduleName","preload")
		or errorInternal(2, state, dependent, "'preload' module not loaded.")

	local decl = findPublicDeclarationInScope(state, module, name)
		or errorInternal(2, state, dependent, "No declaration '%s' in 'preload' module.", name)

	if decl.inferredType then
		-- void
	elseif waitIfNotInferred then
		!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_INFERRED, `decl`, `nil`)
	else
		return nil
	end

	!ASSERT(`decl.valueTypeInfo`,            nil, `decl`)
	!ASSERT(`decl.valueTypeInfo.tag == tag`, nil, `decl`)

	return decl
end



function _G.typeError(state, node, s, ...)
	nodeError(state, node, "Typer", s, ...)
end
function _G.typeError2(state, node1,s1, node2,s2)
	!TRACE(2)
	printerr()
	!ifDEBUG `astPrint(node1)`
	typeMessage(io.stderr, state, node1, "Error", "%s", s1)
	!ifDEBUG `astPrint(node2)`
	typeMessage(io.stderr, state, node2, "Info",  "%s", s2)
	exitFailure()
end
function _G.typeError3(state, node1,s1, node2,s2, node3,s3)
	!TRACE(2)
	printerr()
	!ifDEBUG `astPrint(node1)`
	typeMessage(io.stderr, state, node1, "Error", "%s", s1)
	!ifDEBUG `astPrint(node2)`
	typeMessage(io.stderr, state, node2, "Info",  "%s", s2)
	!ifDEBUG `astPrint(node3)`
	typeMessage(io.stderr, state, node3, "Info",  "%s", s3)
	exitFailure()
end

-- typeMessage( [ outputFile=io.stdout, ] compilationState, node, label, formatString, ... )
function _G.typeMessage(file, state, node, label, s, ...)
	if type(file) ~= "userdata" then  return typeMessage(io.stdout, file, state, node, label, s, ...)  end
	return nodeMessage(file, state, node, label, "Typer", s, ...)
end



function _G.getFriendlyTypeInfoName(typeInfo)
	!local APPEND_ID = DEBUG and 1==1
	local  name      = ""

	if typeInfo.tag == !(TYPE_STRUCT) then
		local structInfo = typeInfo
		local struct     = structInfo.astNode
		name             = structInfo.name

		if struct.polymorphSourceStruct then
			local params = {}

			if struct.bakeDeclarations then
				for argIndex, declBaked in ipairs(struct.bakeDeclarations) do
					local valueExpr = declBaked.value

					if valueExpr.nodeType == !(AST_IDENTIFIER) and declBaked.inferredType.tag == !(TYPE_ENUM) then
						local enumInfo   = declBaked.inferredType
						params[argIndex] = (enumInfo.name ~= "" and enumInfo.name or !(TYPE_NAMES[TYPE_ENUM])) .. "." .. valueExpr.name

					elseif valueExpr.nodeType == !(AST_LITERAL) then
						local literal    = valueExpr
						params[argIndex] = literal.literalType == !(LITERAL_STRING) and F("%q", literal.value) or tostring(literal.value)

					elseif valueExpr.nodeType == !(AST_TYPE) then
						local typeNode   = valueExpr
						params[argIndex] = getFriendlyTypeInfoName(typeNode.representedType)

					else
						params[argIndex] = "~"
					end
				end
			end

			name = (
				struct.polymorphSourceStruct.representedType.name
				.. "(" .. table.concat(params, ",") .. ")"
			)
		end

	elseif typeInfo.tag == !(TYPE_ENUM) then
		local enumInfo = typeInfo
		name           = enumInfo.name

	elseif typeInfo.tag == !(TYPE_FUNCTION) then
		local funcSig      = typeInfo
		local typeTextsIn  = {}
		local typeTextsOut = {}

		for i, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			if i > 1 then  table.insert(typeTextsIn, ",")  end
			table.insert(typeTextsIn, getFriendlyTypeInfoName(argTypeInfo))
		end

		for i, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			typeTextsOut[i] = getFriendlyTypeInfoName(argTypeInfo)
		end

		name = typeTextsOut[1]
			and F("function%s(%s)->(%s)", (funcSig.isPolymorphic and ".poly" or ""), table.concat(typeTextsIn), table.concat(typeTextsOut, ","))
			or  F("function%s(%s)->void", (funcSig.isPolymorphic and ".poly" or ""), table.concat(typeTextsIn))

	elseif typeInfo.tag == !(TYPE_COMPOUND) then
		local compound  = typeInfo
		local typeTexts = {}

		for i, compoundItem in ipairs(compound) do
			typeTexts[i] = getFriendlyTypeInfoName(compoundItem)
		end

		name = table.concat(typeTexts, "|")

	elseif typeInfo.tag == !(TYPE_LIST) then
		local listSig   = typeInfo
		local typeTexts = {}

		for i, typeInfo in ipairs(listSig) do
			typeTexts[i] = getFriendlyTypeInfoName(typeInfo)
		end

		name = "list("..table.concat(typeTexts, ", ")..")"

	elseif typeInfo.tag == !(TYPE_ARRAY) then
		local arraySig = typeInfo
		name           = "array("..getFriendlyTypeInfoName(arraySig.itemType)..")"

	elseif typeInfo.tag == !(TYPE_VARARG) then
		local varargSig = typeInfo
		name            = "..."..getFriendlyTypeInfoName(varargSig.itemType)

	elseif typeInfo.tag == !(TYPE_NAMESPACE) then
		local namespaceInfo = typeInfo
		local scope         = namespaceInfo.scope
		local scopeParent   = scope.parent

		if scopeParent.nodeType == !(AST_DECLARATION) and isDeclarationConstant(scopeParent) and scope == scopeParent.value then
			name = 'namespace("'..scopeParent.name.name..'")'
		else
			name = 'namespace'
		end
	end

	if name == "" then
		name = TYPE_NAMES[typeInfo.tag] or errorInternal("%d", typeInfo.tag)
	end

	!(if APPEND_ID then)  name = name .. "@" .. typeInfo.id  !(end)

	return name
end



local nodeInferrers = {}

!(
local nodeNames = {}
local nodeNameLast
local nodeTypeLast

local function NODE_INFERRER(funcHeaderCode)
	local replacements

	funcHeaderCode, replacements = funcHeaderCode:gsub("function +nodeInferrers%.(Ast%w+)", function(nodeName)
		if nodeNames[nodeName] then
			error("Duplicate node inferrer: "..nodeName)
		end
		nodeNames[nodeName] = true

		local nodeType = astStructNameToType[nodeName] or error(nodeName)
		local lua

		if STATIC_PROFILER then
			local inferrerName = "nodeInferrer_"..nodeName
			lua = "local function "..inferrerName
		else
			lua = "nodeInferrers["..nodeType.."--[["..nodeName.."]]] = function"
		end

		nodeNameLast = nodeName
		nodeTypeLast = nodeType

		return lua
	end)

	assert(replacements == 1, funcHeaderCode)

	__LUA(funcHeaderCode)
end

local function NODE_INFERRER_END(endCode)
	__LUA(endCode)

	if STATIC_PROFILER then
		local inferrerName = "nodeInferrer_"..nodeNameLast
		__LUA("\nnodeInferrers[",toLua(nodeTypeLast),"] = ",inferrerName)
	end
end
)

-- identifierEarly, identifierLate, extraShadowMessageEarly, extraShadowMessageLate = getEarlyAndLateForRedeclarationError( state, identifier1, identifier2 )
local function getEarlyAndLateForRedeclarationError(state, identEarly, identLate)
	local extraMessageEarly = ""
	local extraMessageLate  = ""

	-- Globals before locals.  @Incomplete: May need update since globals refactor. 2020-03-26
	if isDeclarationGlobal(identEarly.declaration) ~= isDeclarationGlobal(identLate.declaration) then
		if isDeclarationGlobal(identLate.declaration) then
			identEarly, identLate = identLate, identEarly
		end

	-- Static before dynamic.
	elseif isDeclarationStatic(identEarly.declaration) ~= isDeclarationStatic(identLate.declaration) then
		if isDeclarationStatic(identLate.declaration) then
			identEarly, identLate = identLate, identEarly
		end
		if isScopeImperative(astFindParentScope(identLate.declaration)) then
			extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope, unlike variables.)"
		end

	-- Low depth before high depth.
	-- Early in file before late in file.
	else
		local depthEarly = astGetDepth(identEarly)
		local depthLate  = astGetDepth(identLate)

		if depthLate < depthEarly or (depthLate == depthEarly and identLate.position < identEarly.position) then
			-- @Incomplete: Explicitly handle the identifiers being declared in different files. (May be unnecessary.)
			identEarly, identLate = identLate, identEarly
		end

		if isDeclarationConstant(identEarly.declaration) then
			if isScopeImperative(astFindParentScope(identEarly.declaration)) then
				extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope.)"
			end
		elseif identEarly.declaration.kind == !(DECL_KIND_STATIC) then
			extraMessageEarly = " (Note that static variables are visible to the whole scope.)" -- @Design: Not sure if this rule is good.
		end
	end

	return identEarly, identLate, extraMessageEarly, extraMessageLate
end

-- okToContinue, encounteredIdentifierWithMissingDeclaration = ensureConstantIdentifierChainHasAllDeclarationsSet( state, declaration, dependent )
local function ensureConstantIdentifierChainHasAllDeclarationsSet(state, decl0, dependent)
	local decl = decl0

	while true do
		if not isDeclarationConstant(decl) then  return true, nil  end

		local ident = decl.value
		if not ident                           then  return true, nil  end -- Will trigger an error later. Constant declarations must have values.
		if ident.nodeType ~= !(AST_IDENTIFIER) then  return true, nil  end

		decl = ident.declaration
		if not decl then
			return true, ident -- Good? 2020-06-10
			-- !DEPEND_AND_RETURN(`dependent`, DEPEND_HAS_DECLARATION, `ident`, nil, `false, ident`)
		end

		if decl == decl0 then
			typeError(state, ident, "Constant name recursively refers to itself.") -- @UX: Better error explanation.
		end
	end
end

-- checkRedeclarationAndMaybeAddOverload( state, ident, decl, isMember, scope, declExisting=findDeclaration(...) )
local function checkRedeclarationAndMaybeAddOverload(state, ident, decl, isMember, scope, declExisting)
	decl.checkedRedeclaration = true

	declExisting = declExisting or findDeclaration(state, ident, ident.name, decl)
	if not declExisting then  return  end
	!ASSERT `declExisting ~= decl`

	local scopeExisting = astFindParentScope(declExisting)

	-- Member.
	if isMember and decl.kind == !(DECL_KIND_LOCAL_VAR) and scope ~= scopeExisting then
		-- void  (Variable members never shadow anything.)

	-- Function overload. (Note: Overloads have to be registered before the identifier DEPEND_AND_RETURN on anything.)
	elseif
		isDeclarationConstant(decl) and isDeclarationConstant(declExisting)
		and !!(CONST_SET{ AST_LAMBDA, AST_VARIANT_OF })[followIdentifiersToConstantValue(state, decl        .value).nodeType]
		and !!(CONST_SET{ AST_LAMBDA, AST_VARIANT_OF })[followIdentifiersToConstantValue(state, declExisting.value).nodeType]
	then
		declExisting = declExisting.overloadOf or declExisting

		if declExisting == decl then
			-- This simplifies finding an overload later.
			declExisting.overloadOf = declExisting
			declExisting.overloads  = declExisting.overloads or {}
			table.insert(declExisting.overloads, declExisting)

		elseif scope ~= scopeExisting then
			-- void  Update: We now allow constant function declarations to shadow functions in other scopes. Overload "clusters" will continue being separated by scope.
			--[[
			local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, declExisting.name, ident)
			typeError2(state,
				identLate,  F("Trying to add a new overload to '%s' which is in another scope. Overloads must currently be declared in the same scope.", ident.name),
				identEarly, F("...here is the previous function.")
			)
			--]]

		elseif declExisting.overloadsLocked then
			typeError2(state,
				declExisting.name, F("Trying to add a new overload to '%s' after it's type has been inferred. Overloads currently has to happen in the same 'parsing cycle'.", ident.name),
				ident,             F("...this is the new overload.")
			)

		else
			if decl.kind ~= declExisting.kind then
				typeError2(state,
					decl,         F("Overloaded names must have the same visibility. This one is '%s'.", DECL_KIND_TITLES[decl.kind]),
					declExisting, F("...and this one is '%s'.", DECL_KIND_TITLES[declExisting.kind])
				)
			elseif declExisting.name.inferredType then
			-- if declExisting.inferredType then
				typeError2(state,
					decl,         F("Internal error: Trying to add overload to already inferred function '%s'. Currently all overloads have to be added during the same cycle. (This message is probably not very helpful. Sorry!)", ident.name),
					declExisting, F("...here is the inferred function.")
				)
			end

			decl.overloadOf        = declExisting
			declExisting.overloads = declExisting.overloads or {}
			table.insert(declExisting.overloads, decl)

			-- This dependency means declExisting won't get inferred until earliest next
			-- cycle by which time all overloads should have been added (I think). This
			-- should work as the first occurence of a name will make the second occurence
			-- wait before the second has been able to do anything. (This is true even
			-- when we remove unordered from the queue.)
			!DEPEND(`declExisting.name`, DEPEND_NODE_INFERRED, `decl`)
			-- !DEPEND(`declExisting`, DEPEND_NODE_INFERRED, `decl`) -- Doesn't work as it's currently the name that sets overloadsLocked! 2020-06-25 @Cleanup
		end

	-- Non-shadow.
	elseif not decl.canShadow then
		local identEarly, identLate, extraMessageEarly, extraMessageLate = getEarlyAndLateForRedeclarationError(state, declExisting.name, ident)
		-- !ifDEBUG `identEarly, identLate = declExisting.name, ident`
		-- !ifDEBUG `astPrintTree(astFindCommonParent(identEarly, identLate))`
		typeError2(state,
			identLate,  F("'%s' has already been declared.%s", ident.name, extraMessageLate),
			identEarly, F("...it was declared here.%s", extraMessageEarly)
		)

	-- Shadow in same scope.
	elseif
		scope == scopeExisting
		or (
			-- We do not allow declarations on lambda bodies to shadow the lambda's arguments.
			scope.nodeType                         == !(AST_BLOCK)
			and astFindParentScope(scope).nodeType == !(AST_LAMBDA)
			and astFindParentScope(scope)          == scopeExisting
		)
	then
		typeError2(state,
			ident,             F("'%s' has already been declared in the same scope (which means name shadowing does not work).", ident.name),
			declExisting.name, F("...it was declared here.")
		)

	-- Shadowing something in an outer (or inner?) scope.
	-- @Robustness: Don't allow file-scope variables to be shadows (just like constants)?
	else
		-- void  (Valid shadow.)
	end
end

local function inferIdentifierOrVarargOrBlank(state, identOrVarargOrBlank)
	-- 1. Things to ignore.
	if identOrVarargOrBlank.kind == !(IDENT_KIND_IGNORE) then
		moveToNextRelevantPipe(state, identOrVarargOrBlank)
		return
	end

	local vararg         =                identOrVarargOrBlank.nodeType == !(AST_VARARG) and identOrVarargOrBlank or nil
	local blank          = not vararg and identOrVarargOrBlank.nodeType == !(AST_BLANK)  and identOrVarargOrBlank or nil
	local ident          = not (vararg or blank)                                         and identOrVarargOrBlank or nil
	local decl           = identOrVarargOrBlank.declaration
	local parent         = identOrVarargOrBlank.parent
	local parentNodeType = parent.nodeType

	-- 2. Loose identifier.
	if identOrVarargOrBlank.kind == !(IDENT_KIND_LOOSE) or identOrVarargOrBlank.kind == !(IDENT_KIND_ASSIGNMENT) then
		if not decl then
			local using
			decl, using = findDeclaration(state, identOrVarargOrBlank, identOrVarargOrBlank.name)

			if not decl then
				!DEPEND_AND_RETURN(`identOrVarargOrBlank`, DEPEND_DECLARATION, `identOrVarargOrBlank.name`)
			end

			identOrVarargOrBlank.declaration = decl
			identOrVarargOrBlank.fromUsing   = using
			fulfillDependencies(state, identOrVarargOrBlank.queued, !(DEPEND_HAS_DECLARATION))
		end

		if not (
			-- We don't care about polymorphism/overloads in these contexts:
			vararg -- How about blanks?
			or not decl.value
			or (parentNodeType == !(AST_LOCATION))
			or (parentNodeType == !(AST_CALL)        and ident == parent.callee)
			or (parentNodeType == !(AST_DEBUG)       and parent.action == "print")
			or (parentNodeType == !(AST_DECLARATION) and isDeclarationConstant(parent) and ident == parent.value) -- Note: Declarations do their own validation of the identifier in this case.
		) then
			if isDeclarationConstant(decl) then
				if not decl.inferredType then
					!DEPEND_AND_RETURN(`identOrVarargOrBlank`, DEPEND_NODE_INFERRED, `decl`) -- Needed for decl.overloadOf to be valid.
				elseif not decl.overloadsLocked then
					errorInternal(state, decl, "Overloads are not locked when they should.")
				end

				-- Overloaded names refer to multiple things, so that's an error!
				if decl.overloadOf then
					local declBase = ident.declaration
					declBase       = declBase.overloadOf or declBase

					-- This is just so we get a better overload list in the error message.
					if not declBase.inferredType then
						!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `declBase`)
					end

					!TRACE()
					printerr()
					typeMessage(io.stderr, state, ident, "Error", "'%s' has multiple overloads and we don't know which one this is referring to.", ident.name)
					for i, declOverload in ipairs(declBase.overloads) do
						typeMessage(io.stderr, state, declOverload.name, "Info", "...overload #%d.", i)
					end
					exitFailure()
				end
			end

			local valueExpr = decl.value

			-- Polymorphic functions also contain the polymorphed functions and are thus a collection of functions, so referring to them may be a bad idea!
			-- (How does this work when calling a function from a module or a static struct member function? @Incomplete @Robustness)
			if valueExpr.nodeType == !(AST_LAMBDA) and valueExpr.polymorphs then
				typeError(state, ident, "Cannot refer to polymorphic function '%s' outside calls.", ident.name)

			-- Polymorphic structs are similar to polymorphed functions as they are collections of structs, so referring to them may be a bad idea too!
			-- (Also, like with the functions, think about modules. @Incomplete @Robustness)
			elseif valueExpr.nodeType == !(AST_STRUCT) and valueExpr.polymorphs then
				typeError(state, ident, "Missing arguments after name for polymorphic struct '%s'.", ident.name) -- @Polish: Point after the identifier.
			end
		end

		local typeInfo = decl.inferredType
		if not typeInfo then
			!DEPEND_AND_RETURN(`identOrVarargOrBlank`, DEPEND_NODE_INFERRED, `decl`)
		end
		if vararg and (vararg.surroundedByParentheses or not areMultipleValuesEnabledAtPosition(state, vararg)) then
			vararg.surroundedByParentheses = true
			typeInfo                       = adjustTypeToOne(state, vararg, typeInfo, true)
		end

		identOrVarargOrBlank.inferredType = typeInfo

		if identOrVarargOrBlank.fromUsing then
			-- @Cleanup: Move this to simplifyExpressionIfConstant()?
			!ASSERT `ident`
			local access        = astNewNode(AstAccess, ident, parent)
			access.object       = astCopy(ident.fromUsing.expression, access, access)

			local literal       = astNewNode(AstLiteral, access, access)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = ident.name
			access.member       = literal

			addUnqueuedChildrenToQueueRecursively(state, access)
			replaceQueuedNodeAndUnqueueOldTree(state, ident, access)
			-- Stay in PIPE_INFER.

		else
			moveToNextRelevantPipe(state, identOrVarargOrBlank)

			if
				ident
				and isDeclarationConstant(decl) and followIdentifiersToConstantValue(state, ident).nodeType ~= !(AST_TABLE) -- Not sure how robust this condition is. @Robustness
			then
				simplifyExpressionIfConstant(state, ident)
			end
		end

		return

	elseif identOrVarargOrBlank.kind == !(IDENT_KIND_RELATIVE) then
		!ASSERT `ident`

		local typeInfo = getExpectedTypeInfo(state, ident, false, "identifier", ident)
		if not typeInfo then
			-- @UX: Improve the error message if two relative identifiers wait for each other.
			-- (We probably need getExpectedTypeInfo() to return the target node along with the type.)
			return
		end

		if typeInfo.tag ~= !(TYPE_ENUM) then
			typeError(state, ident, "Relative identifiers only support enum types. (This is %s)", getFriendlyTypeInfoName(typeInfo))
		end

		local enumInfo = typeInfo
		local decl     = findMemberDeclaration(state, enumInfo.astNode, ident.name)

		if not decl then
			typeError2(state,
				ident,            F("%s has no member '%s'.", getFriendlyTypeInfoName(enumInfo), ident.name),
				enumInfo.astNode, F("...here is the accessed enum.")
			)
		end

		ident.declaration  = decl
		ident.inferredType = enumInfo

		moveToNextRelevantPipe(state, ident)
		return
	end

	!ASSERT("decl",                                                                          nil, `identOrVarargOrBlank`)
	!ASSERT("parentNodeType == "..AST_DECLARATION.." or parentNodeType == "..AST_ASSIGNMENT, nil, `identOrVarargOrBlank`)

	-- 3. Assignment target in declaration (which is a copy of the identifier in the declaration).
	if identOrVarargOrBlank.kind == !(IDENT_KIND_DECLARATION_ASSIGNMENT) then
		!ASSERT("parentNodeType == "..AST_ASSIGNMENT)

		if not decl.inferredType then
			!DEPEND_AND_RETURN_INTERNAL(`identOrVarargOrBlank`, DEPEND_NODE_INFERRED, `decl`)
		end

		identOrVarargOrBlank.inferredType = decl.inferredType
		moveToNextRelevantPipe(state, identOrVarargOrBlank)
		return
	end

	-- 4. At this point we're defining a declared identifier.
	if identOrVarargOrBlank.kind ~= !(IDENT_KIND_DECLARATION) then
		errorInternal(state, identOrVarargOrBlank, "Unexepected identifier kind '%s'.", (IDENT_KIND_TITLES[identOrVarargOrBlank.kind] or "?"))
	end

	local scope        = astFindParentScope(decl) or errorInternal(state, identOrVarargOrBlank, "Could not find what scope '%s' is in.", identOrVarargOrBlank.name)
	local isEnumMember = scope.nodeType == !(AST_ENUM)
	local isMember     = isEnumMember or scope.nodeType == !(AST_STRUCT)

	-- Check for redeclaration/shadowing (before we DEPEND_AND_RETURN).
	if ident and not (decl.checkedRedeclaration or decl.isDocumentation) then
		local okToContinue, identWithoutDecl = ensureConstantIdentifierChainHasAllDeclarationsSet(state, decl, ident)
		if not okToContinue then  return  end

		if identWithoutDecl then
			-- where(state, ident) ; where(state, identWithoutDecl) ; print("================")

			-- !DEPEND_AND_RETURN(`ident`, DEPEND_HAS_DECLARATION, `identWithoutDecl`) -- Seemingly not needed.

			-- void  Let the/some other identifier in the chain call checkRedeclarationAndMaybeAddOverload() instead. (Is this always working?)

		else
			local declExisting = findDeclaration(state, ident, ident.name, decl)

			if declExisting then
				if declExisting.value then
					okToContinue, identWithoutDecl = ensureConstantIdentifierChainHasAllDeclarationsSet(state, declExisting, ident)
					if not okToContinue then  return  end

					if identWithoutDecl then
						!DEPEND_AND_RETURN(`ident`, DEPEND_HAS_DECLARATION, `identWithoutDecl`) -- Important for redeclaration stuff to work.
					end
				end

				checkRedeclarationAndMaybeAddOverload(state, ident, decl, isMember, scope, declExisting)
			end
		end
	end

	local typeExpr = decl.type
	if typeExpr and not typeExpr.inferredType then
		!DEPEND_AND_RETURN(`identOrVarargOrBlank`, DEPEND_NODE_INFERRED, `typeExpr`)
	end

	if isEnumMember then
		local enum = scope
		if not enum.representedType then
			-- AstEnum is the only scope that gets inferred before its declarations.
			!DEPEND_AND_RETURN(`identOrVarargOrBlank`, DEPEND_NODE_INFERRED, `enum`)
		elseif not enum.representedType.memberTypeInfo then
			!DEPEND_AND_RETURN(`identOrVarargOrBlank`, DEPEND_TYPE_MEMBERS_READY, `enum.representedType`)
		end
	end

	local valueExpr = getDeclarationValue(decl, true)
	if (not typeExpr or isDeclarationConstant(decl)) and not valueExpr.inferredType then
		--[[ DEBUG
		if valueExpr.nodeType == !(AST_LITERAL) then
			print("====================")
			astPrintTree(identOrVarargOrBlank.parent)
			where(state, identOrVarargOrBlank)
			astPrint(valueExpr)
			where(state, valueExpr)
		end
		--]]
		!DEPEND_AND_RETURN(`identOrVarargOrBlank`, DEPEND_NODE_INFERRED, `valueExpr`)
	end

	--
	-- No more dependencies for this identifier/vararg/blank after this point!
	--

	decl.overloadsLocked = true

	-- Check that call signatures aren't too similar. Optional arguments could make several overloads match calls, i.e.:
	--   local func :: () {}
	--   local func :: (n:int=0) {}
	--   func() -- First or second?
	-- (I don't think this chack is really needed here as we get an error when calling the overloaded name
	-- if there are argument matching issues. Let's just look for identical signatures. 2021-08-05)
	if decl.overloadOf == decl then
		for i = 1, #decl.overloads-1 do
			local decl1     = decl.overloads[i]
			local funcSig1  = decl1.value.inferredType
			local argTypes1 = funcSig1.argumentTypesIn

			for i = i+1, #decl.overloads do
				local decl2     = decl.overloads[i]
				local funcSig2  = decl2.value.inferredType
				local argTypes2 = funcSig2.argumentTypesIn
				local identical

				if funcSig1 == funcSig2 then
					identical = true

				elseif #argTypes1 ~= #argTypes2 then
					identical = false

				else
					identical = true

					for argIndex = 1, #argTypes1 do
						if argTypes1[argIndex] ~= argTypes2[argIndex] then
							identical = false
							break
						end
					end
				end

				if identical then
					local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
					typeError2(state,
						identLate,  F("Call signatures for function overloads for '%s' are identical. (%s)", ident.name, getFriendlyTypeInfoName(funcSig1)),
						identEarly, F("...here is the other function.")
					)
				end
			end

			--[[
			local decl1     = decl.overloads[i]
			local lambda1   = followIdentifiersToConstantValue(state, decl1.value)
			local args1     = lambda1.argumentsIn and lambda1.argumentsIn.arguments
			local funcSig1  = lambda1.inferredType
			local argTypes1 = funcSig1.argumentTypesIn

			for i = i+1, #decl.overloads do
				local decl2     = decl.overloads[i]
				local lambda2   = followIdentifiersToConstantValue(state, decl2.value)
				local args2     = lambda2.argumentsIn and lambda2.argumentsIn.arguments
				local funcSig2  = lambda2.inferredType
				local argTypes2 = funcSig2.argumentTypesIn

				if funcSig1 == funcSig2 then
					local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
					typeError2(state,
						identLate,  F("Call signatures for function overloads for '%s' are identical. (%s)", ident.name, getFriendlyTypeInfoName(funcSig1)),
						identEarly, F("...here is the other function.")
					)
				end

				-- @Incomplete @Robustness: Check that vararg works.
				for argIndex = 1, math.min(#argTypes1, #argTypes2)+1 do
					local argTypeInfo1 = argTypes1[argIndex]
					local argTypeInfo2 = argTypes2[argIndex]
					argTypeInfo1       = argTypeInfo1 and adjustTypeToOne(state, decl1.name, argTypeInfo1)
					argTypeInfo2       = argTypeInfo2 and adjustTypeToOne(state, decl2.name, argTypeInfo2)

					local isRequired1  = argTypeInfo1 ~= nil and args1[argIndex].isRequired
					local isRequired2  = argTypeInfo2 ~= nil and args2[argIndex].isRequired

					if not (isRequired1 or isRequired2) then
						local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
						typeError2(state,
							identEarly, F("Call signatures for function overloads (%s) are too similar.", ident.name),
							identLate,  F("...here is the other function.")
						)
					end

					if not (argTypeInfo1 and argTypeInfo1 == argTypeInfo2) then  break  end
				end
			end
			--]]
		end
	end

	-- Tell parents that this declaration exists so we can detect more cases of shadowing.
	-- @Speed: Can we get rid of the whole declarationsInTree thing if we make overloads explicit? Not sure. 2021-07-24
	if not (decl.isDocumentation or decl.canShadow or vararg or blank or (isMember and decl.kind == !(DECL_KIND_LOCAL_VAR))) then
		local parentScope = scope
		local name        = ident.name

		repeat
			local declarationsInTree = parentScope.declarationsInTree[name]

			if not declarationsInTree then
				declarationsInTree                   = {}
				parentScope.declarationsInTree[name] = declarationsInTree
			end

			table.insert(declarationsInTree, decl)

			if parentScope.nodeType == !(AST_FILE_SCOPE) and parentScope.isModule then  break  end

			parentScope = astFindParentScope(parentScope)
		until not parentScope
	end

	local typeInfo

	-- Specified type.
	if typeExpr then
		typeInfo = requireTypeRepresentedByExpression(state, typeExpr)

	-- Infer type from value.
	else
		!ASSERT(`valueExpr`, `"Missing both type and value from declaration."`)
		!ASSERT(`not vararg`)

		if decl.value then
			typeInfo = valueExpr.inferredType
		else
			valueExpr, typeInfo = getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, nil, nil, nil, false)
		end
		typeInfo = adjustTypeToOne(state, valueExpr, typeInfo, true)
	end

	assert(typeInfo)
	local typeInfoForDecl = nil

	-- Do extra stuff in constant declarations.
	if isDeclarationConstant(decl) then
		valueExpr       = valueExpr or getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, nil, nil, nil, false)
		typeInfoForDecl = getTypeRepresentedByExpression(valueExpr)

		if isEnumMember then
			-- Note: AstEnum already validated that valueExpr's type is compatible with the enum.
			local enum     = scope
			local enumInfo = enum.representedType
			typeInfo       = enumInfo -- Kind of a @Hack, but maybe it's fine for enum members!

			if enumInfo.memberTypeInfo.tag == !(TYPE_TYPE) and followIdentifiersToConstantValue(state, valueExpr).nodeType ~= !(AST_FOREIGN) then
				-- This means you can for example say: local myVar: MyEnum.MY_TYPE
				assert(typeInfoForDecl)
			end
		end

		local tag = typeInfo.tag

		if tag == !(TYPE_TYPE) then
			if not typeInfoForDecl then
				errorInternal(state, valueExpr, "Missing what type this constant expression represents.")
			end

		elseif tag == !(TYPE_ENUM) then -- @Robustness: Actually detect whether we have a type enum and include it here above. (Isn't that what we're doing? 2021-08-06)
			-- void  For now we may or may not have a type enum and typeInfoForDecl.

		elseif tag == !(TYPE_PLACEHOLDER) then
			-- void  Just ignore this for now. We get here when placeholders are combined with auto-baking (which produces constants).

		elseif typeInfoForDecl then
			errorInternal(
				state, valueExpr, "type=%s, typeRepresented=%s",
				getFriendlyTypeInfoName(typeInfo), getFriendlyTypeInfoName(typeInfoForDecl)
			)
		end
	end

	if vararg then
		if vararg.surroundedByParentheses then
			-- void
		elseif not areMultipleValuesEnabledAtPosition(state, vararg) then
			vararg.surroundedByParentheses = true
		else
			typeInfo = getTypeInfoForVararg(state, typeInfo)
		end
	end

	identOrVarargOrBlank.inferredType = typeInfo
	decl.valueTypeInfo                = typeInfoForDecl -- May be nil.  @Cleanup: Move this and relevant code to nodeInferrers.AstDeclaration().

	!if DEBUG then
		if debug_onlyInferTypes then
			io.write("DEFINE ", identOrVarargOrBlank.name ,":", getFriendlyTypeInfoName(typeInfo), " (", DECL_KIND_TITLES[decl.kind], ")")
			if typeInfoForDecl then  io.write(" (VALUE ", getFriendlyTypeInfoName(typeInfoForDecl), ")")  end
			io.write(" IN ")
			astPrint(astFindParentScope(decl))
		end
	!end

	moveToNextRelevantPipe(state, identOrVarargOrBlank)
end

!NODE_INFERRER `function nodeInferrers.AstIdentifier(state, ident)`
	return (inferIdentifierOrVarargOrBlank(state, ident))
!NODE_INFERRER_END `end`
!NODE_INFERRER `function nodeInferrers.AstVararg(state, vararg)`
	return (inferIdentifierOrVarargOrBlank(state, vararg))
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstBlank(state, blank)`
	if blank.parent.nodeType == !(AST_DECLARATION) then
		-- @Cleanup: Move this stuff into inferIdentifierOrVarargOrBlank().
		local decl = blank.parent

		if not (decl.kind == !(DECL_KIND_LOCAL_VAR) --[[or decl.kind == !(DECL_KIND_READ_ONLY)]]) then
			typeError(state, blank, "Blank names in declarations require the declaration to declare a local variable.")
		elseif not isScopeImperative(astFindParentScope(decl)) then
			typeError(state, blank, "Blank names are only allowed in imperative contexts.")
		end

		inferIdentifierOrVarargOrBlank(state, blank)
		if not blank.inferredType then  return  end

		if decl.parent.nodeType == !(AST_BLOCK) then
			if not decl.assignment then
				typeError(state, blank, "Blank names in declarations require an assigment.")
			end
			local valueExpr = getAssignmentValue(state, blank, decl.assignment.values, decl.assignmentIndex, nil, nil, nil, false)
			!ASSERT(`valueExpr.inferredType`, nil, `blank`)
			if isExpressionConstant(state, valueExpr, true) then
				typeError(state, valueExpr, "Values for blank names in declarations must not be constant.")
			end
		end

	elseif blank.parent.nodeType == !(AST_ASSIGNMENT) then
		local assignment = blank.parent
		if assignment.binaryOperation ~= "" then
			typeError(state, blank, "Blank names cannot be used in assignments with binary operations. (The operation here is '%s')", assignment.binaryOperation)
		end

		blank.inferredType = state.builtinTypeInfos.any
		moveToNextRelevantPipe(state, blank)

	else
		errorUnhandledNodeType(state, blank)
	end
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstType(state, typeNode)`
	-- Note: typeNode.declaration may already be filled for generated type nodes.

	local decl = nil
	local typeInfo, typeInfoRepresented

	!if DEBUG and 1==0 then
		if typeNode.kind == !(TYPE_KIND_UNSET) then
			astPrintTree(typeNode)
			errorInternal(state, typeNode)
		end
	!end

	if typeNode.typeReferenceNode then
		local typeRef = typeNode.typeReferenceNode
		if not typeRef.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `typeRef`)
		end

		typeInfoRepresented = requireTypeRepresentedByExpression(state, typeRef)
		typeInfo            = state.builtinTypeInfos.Type

	elseif typeNode.kind == !(TYPE_KIND_SIMPLE_BUILTIN) then
		typeInfoRepresented = state.builtinTypeInfos[typeNode.typeName]
		typeInfo            = state.builtinTypeInfos.Type

	elseif typeNode.kind == !(TYPE_KIND_FUNCTION) then
		local lambda = typeNode.functionHeader or errorInternal()

		if not lambda.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `lambda`)
		end
		assert(lambda.inferredType.tag == !(TYPE_FUNCTION))

		local funcSig       = getTypeInfoForLambda(state, lambda)
		typeInfoRepresented = funcSig
		typeInfo            = state.builtinTypeInfos.Type

	elseif typeNode.kind == !(TYPE_KIND_ARRAY) then
		local itemTypeNode = typeNode.arrayItemType or errorInternal(state, typeNode)

		if not itemTypeNode.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `itemTypeNode`)
		end

		local itemTypeInfo = requireTypeRepresentedByExpression(state, itemTypeNode)
		if itemTypeInfo.tag == !(TYPE_NONE) then
			typeError(state, itemTypeNode, "Arrays cannot contain nil.")
		elseif itemTypeInfo.tag == !(TYPE_COMPOUND) and indexWith1(itemTypeInfo, "tag", !(TYPE_NONE)) then
			typeError(state, itemTypeNode, "Arrays cannot contain nil. (Item type is %s)", getFriendlyTypeInfoName(itemTypeInfo))
		end

		local arraySig      = getTypeInfoForArray(state, itemTypeInfo)
		typeInfoRepresented = arraySig
		typeInfo            = state.builtinTypeInfos.Type

	elseif typeNode.kind == !(TYPE_KIND_COMPOUND) then
		for _, typeExpr in ipairs(typeNode.components) do
			if not typeExpr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `typeExpr`)
			end
		end

		-- Note: It's ok that these share the same table!
		local typeInfos  = {}        -- Keys are sequence numbers, values are TypeInfo.
		local typeIds    = typeInfos -- Keys are AstNode, values are type IDs.
		local duplicates = typeInfos -- Keys are TypeInfo, values are source expressions.

		local isFromCompound = {}

		for _, typeExpr in ipairs(typeNode.components) do
			!(
			local _ERROR_DUPLICATE_TYPE = `
				printerr()
				typeMessage(io.stderr, state, typeExpr, "Error", "Duplicate type specified in $siteName. (%s)", getFriendlyTypeInfoName($typeInfo))
				if isFromCompound[$typeInfo] then
					typeMessage(io.stderr, state, duplicates[$typeInfo], "Info", "...this sub-compound type contains the same type.")
				else
					typeMessage(io.stderr, state, duplicates[$typeInfo], "Info", "...this is the same type.")
				end
				exitFailure()
			`
			local function ERROR_DUPLICATE_TYPE(siteName, typeInfoVar)
				local lua = templateToLua(_ERROR_DUPLICATE_TYPE, {
					siteName = siteName,
					typeInfo = typeInfoVar,
				})
				__LUA(lua)
			end
			)

			local componentType = requireTypeRepresentedByExpression(state, typeExpr)

			if componentType.tag == !(TYPE_COMPOUND) then
				-- Unpack the sub-compound type so we don't end up with compound types of other compound types.
				local compound = componentType

				for _, compoundItem in ipairs(compound) do
					if duplicates[compoundItem] then
						-- if compoundItem.tag ~= !(TYPE_ENUM) and getTypeRepresentedByExpression(duplicates[compoundItem]).tag == !(TYPE_ENUM) then -- @Incomplete: duplicates[compoundItem] is (or may be?) a compound type - we have to go deeper! (Can we?)
						-- 	!ERROR_DUPLICATE_TYPE("compound type (through enum member type in sub-compound type)", `compoundItem`)
						-- else
							!ERROR_DUPLICATE_TYPE("compound type (through sub-compound type)", `compoundItem`)
						-- end
					-- elseif compoundItem.tag == !(TYPE_ENUM) and duplicates[compoundItem.memberTypeInfo] then
					-- 	!ERROR_DUPLICATE_TYPE("compound type (through enum member type in sub-compound type)", `compoundItem.memberTypeInfo`)
					end

					table.insert(typeInfos, compoundItem)
					typeIds[typeExpr]            = compoundItem.id
					duplicates[compoundItem]     = typeExpr -- @UX: Should we ignore duplicate nil types?
					isFromCompound[compoundItem] = true

					-- if compoundItem.tag == !(TYPE_ENUM) then
					-- 	duplicates[compoundItem.memberTypeInfo]     = typeExpr -- Not sure if this is actually a good rule. What about int|float compounds?
					-- 	isFromCompound[compoundItem.memberTypeInfo] = true
					-- end
				end

			else
				if duplicates[componentType] then
					-- if componentType.tag ~= !(TYPE_ENUM) and getTypeRepresentedByExpression(duplicates[componentType]).tag == !(TYPE_ENUM) then
					-- 	!ERROR_DUPLICATE_TYPE("compound type (through enum member type)", `componentType`)
					-- else
						!ERROR_DUPLICATE_TYPE("compound type", `componentType`)
					-- end
				-- elseif componentType.tag == !(TYPE_ENUM) and duplicates[componentType.memberTypeInfo] then
				-- 	!ERROR_DUPLICATE_TYPE("compound type (through enum member type)", `componentType.memberTypeInfo`)
				elseif componentType.tag == !(TYPE_ANY) then
					typeError(state, typeExpr, "Cannot include 'any' in compound types.")
				end

				table.insert(typeInfos, componentType)
				typeIds[typeExpr]         = componentType.id
				duplicates[componentType] = typeExpr -- @UX: Should we ignore duplicate nil types?

				-- if componentType.tag == !(TYPE_ENUM) then
				-- 	duplicates[componentType.memberTypeInfo] = typeExpr -- Not sure if this is actually a good rule. What about int|float compounds?
				-- end
			end
		end

		table.sort(typeNode.components, function(a, b)  return typeIds[a] < typeIds[b]  end) -- @Cleanup @Speed: This is probably unnecessary.

		typeInfoRepresented = getTypeInfoForCompoundType(state, typeInfos, true)
		typeInfo            = state.builtinTypeInfos.Type

	else
		decl = typeNode.declaration

		if not decl then
			assert(typeNode.typeName ~= "")

			decl = findDeclaration(state, typeNode, typeNode.typeName)
			if not decl then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_DECLARATION, `typeNode.typeName`)
			elseif not decl.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `decl`)
			end
		end

		typeInfoRepresented = decl.valueTypeInfo -- May be nil, in which case we'll get an error here below.
		typeInfo            = decl.inferredType or errorInternal()

		-- Type enum members can be used as types, as a special case.
		if isDeclarationConstant(decl) and typeInfo.tag == !(TYPE_ENUM) then
			local enum     = typeInfo.astNode     or errorInternal()
			local enumInfo = enum.representedType or errorInternal()

			if enumInfo.memberTypeInfo.tag == !(TYPE_TYPE) then
				typeInfo = enumInfo.memberTypeInfo
			end
		end

		if typeInfo.tag ~= !(TYPE_TYPE) then
			!TRACE()
			printerr()
			typeMessage(io.stderr, state, typeNode, "Error", "'%s' is not a type. (It is %s)", typeNode.typeName, getFriendlyTypeInfoName(typeInfo))
			printDeclarationChain(io.stderr, state, decl, typeNode.typeName)
			exitFailure()
		end
	end

	!ASSERT `typeInfoRepresented`
	!ASSERT `typeInfo`

	typeNode.representedType = typeInfoRepresented
	typeNode.inferredType    = typeInfo
	typeNode.declaration     = decl
	fulfillDependencies(state, typeNode.queued, !(DEPEND_HAS_DECLARATION))

	moveToNextRelevantPipe(state, typeNode)
!NODE_INFERRER_END `end`

local function getArgumentNodeForError(callOrReturnOrOther, valueIndex, valueExpr)
	return
		callOrReturnOrOther.nodeType == !(AST_CALL) and callOrReturnOrOther.isMethod and valueIndex == 1
		and valueExpr
		or  astGetExpressionVisuallyFurthestToTheLeft(valueExpr)
end

-- wantEnumAndGotLiteralOfCorrectType, isCompatible, compatibilityScore = checkForLiteralVsEnumSituation( valueExpression, typeInfoToMatch )
local function checkForLiteralVsEnumSituation(valueExpr, typeInfoToMatch)
	if typeInfoToMatch.tag ~= !(TYPE_ENUM)   then  return false, false, 0  end
	if valueExpr.nodeType  ~= !(AST_LITERAL) then  return false, false, 0  end

	-- No need to call isTypeCompatibleWith() because enum member types are always simple, and we don't want e.g. Type to cast to int.
	if not (
		valueExpr.inferredType == typeInfoToMatch.memberTypeInfo
		or (valueExpr.literalType == !(LITERAL_INTEGER) and typeInfoToMatch.memberTypeInfo.tag == !(TYPE_FLOAT)) -- Integer literals should always be able to pass as float literals.
	) then
		return false, false, 0
	end

	for _, decl in ipairs(typeInfoToMatch.astNode.declarations) do
		!ASSERT("decl.value.nodeType == "..AST_LITERAL, nil, `decl.value`)

		if decl.value.value == valueExpr.value then
			-- typeError2(state, valueExpr, "This!", decl.value, "It's this!") -- DEBUG
			return true, true, !(TYPE_COMPATABILITY_INDIRECT)
		end
	end

	return true, false, 0
end

-- doesMatch, compatibilityScore = checkIfValuesMatchArgumentTypes(
--     state, callOrReturnOrOther, values, valueTypes, typeInfos,
--     softCheck, calleeDeclarationForCurrentOverload=nil, argumentsNamed=nil, strict
-- )
-- The strict flag is for polymorphic and overloaded calls.
local function checkIfValuesMatchArgumentTypes(state, callOrReturnOrOther, values, valueTypes, typeInfos, softCheck, calleeDecl, argsNamed, strict)
	--[[
		Situations:

		two :: (x:int,   y:int) -> (x:int    y:int) -- accept in/out 2
		var :: (x:int, ...:int) -> (x:int, ...:int) -- accept in/out 1+vararg
		return  x, (two())  --- request 2
		func(   x, (two())  )-- request 2
		return  x, (var())  --- request 2
		func(   x, (var())  )-- request 2
		return  x, (...)    --- request 2  (Note: The vararg can result in nil.)
		func(   x, (...)    )-- request 2  (Note: The vararg can result in nil.)
		return  x, two()    --- request 1+list(2)
		func(   x, two()    )-- request 1+list(2)
		return  x, ...      --- request 1+vararg
		func(   x, ...      )-- request 1+vararg
		return  x, var()    --- request 1+list(1+vararg)
		func(   x, var()    )-- request 1+list(1+vararg)
	]]

	local isCallingName         = callOrReturnOrOther.nodeType == !(AST_CALL) and callOrReturnOrOther.callee.nodeType == !(AST_IDENTIFIER)
	local isCallingConstantName = false
	local constLambda           = nil

	if isCallingName then
		calleeDecl            = calleeDecl or callOrReturnOrOther.callee.declaration
		isCallingConstantName = isDeclarationConstant(calleeDecl)

		if isCallingConstantName then
			constLambda = followIdentifiersToConstantValue(state, calleeDecl.value)
			!ASSERT("constLambda.nodeType == "..AST_LAMBDA)
			!ASSERT("constLambda.inferredType")
		end
	end

	-- Get accepted count.
	local typeInfoCount   = #typeInfos
	local acceptingVararg = typeInfoCount > 0 and typeInfos[typeInfoCount].tag == !(TYPE_VARARG)
	local acceptedMin     = acceptingVararg and typeInfoCount-1 or typeInfoCount
	local acceptedMax     = acceptingVararg and math.huge       or typeInfoCount

	-- Consider optional arguments for calls.
	-- @Robustness: Disallow this in PIPE_INFER:  local take2::(req:int,opt=0){} ; local get2::()->int,int{} ; take2(get2())  -- :DisallowListAsLastValueToFunctionWithOptionalArguments
	if constLambda then
		if not areArraysEqual(typeInfos, constLambda.inferredType.argumentTypesIn) then
			-- We should only get here if checking overloads.
			if softCheck then  return false, 0  end
			errorInternal()
		end

		local argsIn = constLambda.argumentsIn and constLambda.argumentsIn.arguments
		for i = acceptedMin, 1, -1 do
			local arg = argsIn[i]
			if arg.isRequired then  break  end
			acceptedMin = acceptedMin-1
		end
	end

	-- Get requested count.
	local valueCount    = #values
	local valueExprLast = values[valueCount]
	local requestedMin  = valueCount
	local requestedMax  = valueCount
	local slotsToCheck  = valueCount -- Assuming the requested count is accepted.

	if not valueExprLast then
		-- void

	elseif valueExprLast.nodeType == !(AST_CALL) then
		local valueCall = valueExprLast

		if not valueCall.surroundedByParentheses then
			local calleeTypeInfo = valueCall.callee.inferredType

			if calleeTypeInfo.tag == !(TYPE_LIST) then
				calleeTypeInfo = calleeTypeInfo[1] or errorInternal() -- The error should have happened when inferring AstCall.
			end

			assert(calleeTypeInfo.tag == !(TYPE_FUNCTION))

			local argTypesOut = calleeTypeInfo.argumentTypesOut
			local argCount    = #argTypesOut

			if argCount == 0 then
				if softCheck then  return false, 0  end
				typeError(state, valueCall, "Function call returns nothing. (Expected at least one value.)")
			end

			local returnsVararg = argCount > 0 and argTypesOut[argCount].tag == !(TYPE_VARARG)
			local returnsMin    = returnsVararg and argCount-1 or argCount
			local returnsMax    = returnsVararg and math.huge  or argCount

			requestedMin = valueCount - 1 + returnsMin
			requestedMax = valueCount - 1 + returnsMax
			slotsToCheck = valueCount - 1 + argCount
		end

	elseif valueExprLast.nodeType == !(AST_VARARG) then
		local valueVararg = valueExprLast

		if not valueVararg.surroundedByParentheses then
			requestedMin = valueCount - 1
			requestedMax = math.huge
			slotsToCheck = valueCount
		end
	end

	-- Increase requestedMin according to named arguments. (Also do some validation of the named arguments.)
	if argsNamed and argsNamed[1] then
		!ASSERT("constLambda") -- We should only get here when calling a constant name to a function.

		-- @Robustness: constLambda.argumentsIn was nil at some point today. How and why? 2020-05-01
		local argsIn = constLambda.argumentsIn and constLambda.argumentsIn.arguments or errorInternal(state, argsNamed[1].value)

		if argsNamed[1].argumentIndex > 0 then
			for argIndex = valueCount+1, acceptedMin do -- Is acceptedMin good?
				local arg = argsIn[argIndex]
				if not arg.isRequired then  break  end

				local argNamed = itemWith1(argsNamed, "argumentIndex", argIndex)

				-- @Cleanup: Duplicate named argument check. (Maybe keep these and remove the one in the other function?)
				if not argNamed then
					!local NAMED_ARG_ERROR = trimTemplate`
						if softCheck then  return false, 0  end
						local call = callOrReturnOrOther
						typeError2(state,
							call, F("Missing value for required argument #%d (%s).", argIndex, arg.declaration.name.name),
							arg,  F("...here is the argument in the called function.")
						)
					`
					!!(NAMED_ARG_ERROR)
				end

				requestedMin = requestedMin+1
			end
		else
			for argIndex = 1, acceptedMin do -- Is acceptedMin good?
				local arg = argsIn[argIndex]
				if not arg.isRequired then  break  end

				local name     = arg.declaration.name.name
				local argNamed = nil

				for _, _argNamed in ipairs(argsNamed) do
					if _argNamed.key.name == name then
						argNamed = _argNamed
						break
					end
				end

				-- @Cleanup: Duplicate named argument check. (Maybe keep these and remove the one in the other function?)
				if not (argNamed or values[argIndex]) then
					!!(NAMED_ARG_ERROR)
				end

				if argIndex > valueCount then
					requestedMin = requestedMin+1
				end
			end
		end
	end

	-- ifDEBUG `io.write(F("requested %.0f-%.0f, accepted %.0f-%.0f  ", requestedMin, requestedMax, acceptedMin, acceptedMax)) ; astPrint(callOrReturnOrOther)`

	-- Too few values.
	-- @UX: Better error message if the last value is a call (without parentheses).
	if requestedMin < acceptedMin then
		if softCheck then  return false, 0  end

		local exprForError = valueExprLast and getArgumentNodeForError(callOrReturnOrOther, 1, values[1]) or callOrReturnOrOther
		local prefix       = requestedMax+acceptedMax == math.huge and "Incorrect number of" or "Missing"
		local thingsStr    = (callOrReturnOrOther.nodeType == !(AST_CALL) and "arguments") or (callOrReturnOrOther.nodeType == !(AST_RETURN) and "values to return") or "values"
		local gotStr       = (requestedMax ~= math.huge and F("%d", requestedMin)) or (requestedMin == 0 and "variable amount") or F("%d + variable amount", requestedMin)

		-- local errorFunc
		-- 	=   not valueExprLast and callOrReturnOrOther.nodeType == !(AST_RETURN)
		-- 	and typeErrorAfter -- @Polish: Point after 'return'.
		-- 	or  typeError

		typeError--[[errorFunc]](state, exprForError, "%s %s. (Wanted %d, got %s)", prefix, thingsStr, acceptedMin, gotStr)

	-- Too many values.
	-- @UX: Better error message if the last value is a call (without parentheses).
	elseif requestedMax > acceptedMax then
		!ASSERT `not acceptingVararg`

		if softCheck then  return false, 0  end

		local valueIndex          = math.min(acceptedMax+1, valueCount)
		local firstExtraValueExpr = values[valueIndex]
		local exprForError        = getArgumentNodeForError(callOrReturnOrOther, valueIndex, firstExtraValueExpr)
		local prefix              = requestedMax+acceptedMax == math.huge and "Incorrect number of" or "Too many"
		local thingsStr           = (callOrReturnOrOther.nodeType == !(AST_CALL) and "arguments") or (callOrReturnOrOther.nodeType == !(AST_RETURN) and "values to return") or "values"
		local gotStr              = (requestedMax ~= math.huge and F("%d", requestedMin)) or (requestedMin == 0 and "variable amount") or F("%d + variable amount", requestedMin)

		typeError(state, exprForError, "%s %s. (Wanted %d, got %s)", prefix, thingsStr, acceptedMax, gotStr) -- Note: acceptedMax is never infinite here.
	end

	local compatibilityScoreSum = 0

	!(
	local function SET_STRICT_TYPE_MATCH_FLAG(argIndexCode)
		__LUA(templateToLua(
			trimTemplate`
				if constLambda and constLambda.polymorphSourceLambda then
					local argsIn    = constLambda.polymorphSourceLambda.argumentsIn
					argsIn          = argsIn and argsIn.arguments
					local arg       = argsIn and (argsIn[$argIndex] or argsIn[#argsIn]) or errorInternal(state, valueExpr)
					strictTypeMatch = (arg.hasPlaceholders or arg.autobake ~= $AUTOBAKE_DISABLED) and $STRICT_TYPE_MATCH_YES or $STRICT_TYPE_MATCH_NO
				end
			`,
			{
				AUTOBAKE_DISABLED     = AUTOBAKE_DISABLED,
				STRICT_TYPE_MATCH_NO  = STRICT_TYPE_MATCH_NO,
				STRICT_TYPE_MATCH_YES = STRICT_TYPE_MATCH_YES,
				argIndex              = argIndexCode,
			}
		))
	end
	)

	for slot = 1, slotsToCheck do
		local valueIndex      = math.min(slot, valueCount)
		local valueExpr       = values[valueIndex]
		local valueTypeInfo   = valueTypes[valueIndex]

		local typeInfoIndex   = math.min(slot, typeInfoCount)
		local typeInfoToMatch = typeInfos[typeInfoIndex]

		local isCompatible, compatibilityScore

		-- Function call (0..inf values).
		if valueTypeInfo.tag == !(TYPE_LIST) then
			local callOutArgIndex = slot - valueIndex + 1
			valueTypeInfo         = valueTypeInfo[callOutArgIndex]

			if not valueTypeInfo then
				if softCheck then  return false, 0  end
				typeError(state, valueExpr, "Function call returns nothing. (Expected at least one value.)") -- Note: "Nothing" is not the same as vararg of zero length.
			end

			local adjustVarargToIncludeNil = not (valueTypeInfo.tag == !(TYPE_VARARG) and typeInfoToMatch.tag == !(TYPE_VARARG))
			local valueTypeInfoAdjusted    = adjustTypeToOne(state, valueExpr,           valueTypeInfo, adjustVarargToIncludeNil) -- We have a value with a type.
			local typeInfoToMatchAdjusted  = adjustTypeToOne(state, callOrReturnOrOther, typeInfoToMatch)                         -- We want a specific type.

			local strictTypeMatch = !(STRICT_TYPE_MATCH_NO)
			!SET_STRICT_TYPE_MATCH_FLAG(`typeInfoIndex`)

			isCompatible, compatibilityScore = isTypeCompatibleWith(state, valueTypeInfoAdjusted, typeInfoToMatchAdjusted, strictTypeMatch, valueExpr)

			if not isCompatible then
				if softCheck then  return false, 0  end
				-- @UX: Tell the name of the call/return argument. (For calls, probably only possible for constants, and maybe not all. Not sure! Returns just depend on the output arguments being named.)
				-- @UX: Tell the name of the value call's argument. (Probably only possible for constants, and maybe not all. Not sure!)
				typeError(
					state, valueExpr,
					"Type mismatch for %s #%d (return value #%d from call). (Wanted %s, got %s)",
					(callOrReturnOrOther.nodeType == !(AST_CALL) and "argument") or (callOrReturnOrOther.nodeType == !(AST_RETURN) and "return value") or "value",
					slot,
					callOutArgIndex,
					getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
					getFriendlyTypeInfoName(valueTypeInfoAdjusted)
				)
			end

		-- Vararg (0..inf values) OR other (1 value).
		else
			local adjustVarargToIncludeNil = not (valueTypeInfo.tag == !(TYPE_VARARG) and typeInfoToMatch.tag == !(TYPE_VARARG))
			local valueTypeInfoAdjusted    = adjustTypeToOne(state, valueExpr,           valueTypeInfo, adjustVarargToIncludeNil) -- We have a value with a type.
			local typeInfoToMatchAdjusted  = adjustTypeToOne(state, callOrReturnOrOther, typeInfoToMatch)                         -- We want a specific type.

			local strictTypeMatch = !(STRICT_TYPE_MATCH_NO)
			!SET_STRICT_TYPE_MATCH_FLAG(`typeInfoIndex`)

			isCompatible, compatibilityScore = isTypeCompatibleWith(state, valueTypeInfoAdjusted, typeInfoToMatchAdjusted, strictTypeMatch, valueExpr)

			local wantEnumAndGotLiteralOfCorrectType = false
			if not isCompatible and not strict then
				wantEnumAndGotLiteralOfCorrectType, isCompatible, compatibilityScore = checkForLiteralVsEnumSituation(valueExpr, typeInfoToMatchAdjusted)
			end

			if not isCompatible then
				if softCheck then  return false, 0  end
				!ifDEBUG `astPrintTree(callOrReturnOrOther)`
				if wantEnumAndGotLiteralOfCorrectType then
					typeError2(state,
						valueExpr,                       F("Enum '%s' has no value '%s'.", getFriendlyTypeInfoName(typeInfoToMatchAdjusted), valueToStringForMessage(valueExpr.value)),
						typeInfoToMatchAdjusted.astNode, F("...here is the enum.")
					)
				else
					typeError(
						state, getArgumentNodeForError(callOrReturnOrOther, valueIndex, valueExpr),
						"Type mismatch for %s #%d. (Wanted %s, got %s)",
						(callOrReturnOrOther.nodeType == !(AST_CALL) and "argument") or (callOrReturnOrOther.nodeType == !(AST_RETURN) and "return value") or "value",
						slot,
						getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
						getFriendlyTypeInfoName(valueTypeInfoAdjusted)
					)
				end
			end
		end

		compatibilityScoreSum = compatibilityScoreSum + compatibilityScore
	end

	if argsNamed then  for _, argNamed in ipairs(argsNamed) do
		local argIndex = argNamed.argumentIndex

		if argIndex == 0 then
			local name = argNamed.key.name

			for _argIndex, arg in ipairs(constLambda.argumentsIn and constLambda.argumentsIn.arguments or EMPTY_TABLE) do
				if arg.declaration.name.name == name then
					argIndex = _argIndex
					break
				end
			end

			if argIndex == 0 then
				-- We should only get here if checking overloads.
				if softCheck then  return false, 0  end
				errorInternal()
			end
		end

		local valueExpr       = argNamed.value
		local valueTypeInfo   = valueExpr.inferredType

		local typeInfoToMatch = typeInfos[argIndex]

		-- @Incomplete: Vararg is not yet supported for named arguments. 2020-04-09
		local valueTypeInfoAdjusted   = adjustTypeToOne(state, valueExpr,           valueTypeInfo,   true)
		local typeInfoToMatchAdjusted = adjustTypeToOne(state, callOrReturnOrOther, typeInfoToMatch, true)

		local strictTypeMatch = !(STRICT_TYPE_MATCH_NO)
		!SET_STRICT_TYPE_MATCH_FLAG(`argIndex`)

		local isCompatible, compatibilityScore = isTypeCompatibleWith(state, valueTypeInfoAdjusted, typeInfoToMatchAdjusted, strictTypeMatch, valueExpr)

		local wantEnumAndGotLiteralOfCorrectType = false
		if not isCompatible and not strict then
			wantEnumAndGotLiteralOfCorrectType, isCompatible, compatibilityScore = checkForLiteralVsEnumSituation(valueExpr, typeInfoToMatchAdjusted)
		end

		if not isCompatible then
			if softCheck then  return false, 0  end
			!ifDEBUG `astPrintTree(callOrReturnOrOther)`
			if wantEnumAndGotLiteralOfCorrectType then
				typeError2(state,
					valueExpr,                       F("Enum '%s' has no value '%s'.", getFriendlyTypeInfoName(typeInfoToMatchAdjusted), valueToStringForMessage(valueExpr.value)),
					typeInfoToMatchAdjusted.astNode, F("...here is the enum.")
				)
			else
				typeError(
					state, valueExpr,
					"Type mismatch for argument #%d (%s). (Wanted %s, got %s)",
					argIndex,
					argNamed.key.name,
					getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
					getFriendlyTypeInfoName(valueTypeInfoAdjusted)
				)
			end
		end

		compatibilityScoreSum = compatibilityScoreSum + compatibilityScore
	end end

	-- @Incomplete: Decrease compatibilityScoreSum as optional arguments are left out?

	return true, compatibilityScoreSum
end

local function ensureNamedArgumentsHaveAssignedIndicies(state, call, lambdaOrStruct, sequentialArguments)
	if not call.argumentsNamed[1]               then  return  end
	if call.argumentsNamed[1].argumentIndex > 0 then  return  end

	!ASSERT("lambdaOrStruct")
	local isLambda = (lambdaOrStruct.nodeType == !(AST_LAMBDA))

	-- Assign indicies.
	for _, argNamed in ipairs(call.argumentsNamed) do
		local name     = argNamed.key.name
		local argIndex = nil

		if isLambda then
			for _argIndex, arg in ipairs(lambdaOrStruct.argumentsIn and lambdaOrStruct.argumentsIn.arguments or EMPTY_TABLE) do
				if arg.declaration.name.name == name then
					argIndex = _argIndex
					break
				end
			end

		else
			!ASSERT `lambdaOrStruct.bakeDeclarations`

			for _argIndex, declBaked in ipairs(lambdaOrStruct.bakeDeclarations) do
				if declBaked.name.name == name then
					argIndex = _argIndex
					break
				end
			end
		end

		if not argIndex then
			typeError2(state,
				argNamed.key,   F("No argument '%s'.", name),
				lambdaOrStruct, F("...here is the %s.", (isLambda and "called function" or "struct"))
			)

		elseif sequentialArguments[argIndex] then
			local early, late = getEarlyAndLateExpression(argNamed.key, sequentialArguments[argIndex])
			typeError3(state,
				late,           F("Overlapping values for argument #%d (%s).", argIndex, name),
				early,          F("...here is the previous value."),
				lambdaOrStruct, F("...here is the %s.", (isLambda and "called function" or "struct"))
			)
		end

		argNamed.argumentIndex = argIndex
	end

	local argCount
		=   isLambda
		and (lambdaOrStruct.argumentsIn and #lambdaOrStruct.argumentsIn.arguments or 0)
		or  #lambdaOrStruct.bakeDeclarations

	-- Check for missing required arguments.  @Cleanup: Move this to checkIfValuesMatchArgumentTypes(). (Need to handle structs!)
	for argIndex = #sequentialArguments+1, argCount do
		local decl

		if isLambda then
			local arg = lambdaOrStruct.argumentsIn.arguments[argIndex]
			if not arg.isRequired then  break  end
			decl = arg.declaration
		else
			decl = lambdaOrStruct.bakeDeclarations[argIndex]
		end

		local argNamed = itemWith1(call.argumentsNamed, "argumentIndex", argIndex)
		if not argNamed then
			typeError2(state,
				call, F("Missing value for required argument #%d (%s).", argIndex, decl.name.name),
				decl, F("...here is the argument in the %s.", (isLambda and "called function" or "struct"))
			)
		end
	end
end

-- matches|nil = getMatchingFunctions( state, call, realArguments, realArgumentTypes, declarations )
local function getMatchingFunctions(state, call, realArguments, realArgumentTypes, declarations)
	local matches = nil

	for _, decl in ipairs(declarations) do
		local funcSig = decl.inferredType or errorInternal(state, decl, "Declaration should be inferred but isn't.")
		!ASSERT("funcSig.tag == "..TYPE_FUNCTION)

		local doesMatch, compatibilityScore = checkIfValuesMatchArgumentTypes(
			state, call, realArguments, realArgumentTypes, funcSig.argumentTypesIn,
			true, decl, call.argumentsNamed, true
		)
		if doesMatch then
			matches = matches or {}
			table.insert(matches, {declaration=decl, score=compatibilityScore})
		end
	end

	return matches
end

local function getBestMatchOrTriggerError(state, call, matches, matchTerm, errorTextOnDraw)
	table.sort(matches, function(a, b)
		return a.score > b.score
	end)

	local highscore = matches[1].score

	if not matches[2] or matches[2].score < highscore then
		return matches[1].declaration
	end

	!ifDEBUG `astPrintTree(state.globalScope)`
	!TRACE()
	printerr()
	!ifDEBUG    `typeMessage(io.stderr, state, call.callee, "Error", "%s (highscore=%s)", errorTextOnDraw, highscore)`
	!ifNotDEBUG `typeMessage(io.stderr, state, call.callee, "Error", "%s",                errorTextOnDraw           )`

	for i, matchData in ipairs(matches) do
		!ifNotDEBUG `if matchData.score < highscore then  break  end`

		!if DEBUG then
			typeMessage(
				io.stderr, state, matchData.declaration.name,
				"Info", "...%s #%d: %s (score=%s)",
				matchTerm, i, getFriendlyTypeInfoName(matchData.declaration.inferredType),
				(matchData.score == highscore and "high" or matchData.score)
			)
		!else
			typeMessage(
				io.stderr, state, matchData.declaration.name,
				"Info", "...%s #%d: %s",
				matchTerm, i, getFriendlyTypeInfoName(matchData.declaration.inferredType)
			)
		!end
	end

	exitFailure()
end

local function getPathToNode(state, topNode, node, nodeContainers, nodeKeys)
	!ASSERT `topNode`
	local locations = {}

	-- while true do
	while node ~= topNode do
		local loc = {
			containerNode = node.parent,
			container     = nodeContainers[node] or errorInternal(state, node),
			key           = nodeKeys[node]       or errorInternal(state, node),
		}
		table.insert(locations, loc)
		-- if node == topNode then  break  end
		node = node.parent or errorInternal(state, topNode)
	end

	return reverseArray(locations)
end

local function handlePolymorphicCall(state, call, calleeTypeInfo, realArguments, realArgumentTypes)
	local ident = call.callee
	if ident.nodeType ~= !(AST_IDENTIFIER) then
		errorInternal(state, ident, "Expected an identifier. Referring to unknown polymorphic function.")
	end

	local decl = ident.declaration
	if not isDeclarationConstant(decl) then
		errorInternal(state, ident, "Identifier is not a constant.")
	end

	local lambda = decl.value or errorInternal(state, decl)
	lambda       = followIdentifiersToConstantValue(state, lambda)
	assert(lambda.nodeType == !(AST_LAMBDA))

	for _, statement in ipairs(lambda.statementsStatic) do
		if statement.queued and statement.queued.pipe <= !(PIPE_READY) then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_PASSED_READY, `statement`)
		end
	end
	for _, statement in ipairs(lambda.statementsDynamic) do
		if statement.queued and statement.queued.pipe <= !(PIPE_READY) then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_PASSED_READY, `statement`)
		end
	end

	!ASSERT `lambda.polymorphs`
	for _, morphDecl in ipairs(lambda.polymorphs) do
		if morphDecl.queued.pipe <= !(PIPE_READY) then
			!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_PASSED_READY, `morphDecl`)
		end
	end

	--
	-- No more dependencies for the call after this point (except when we're done)!
	--

	checkIfValuesMatchArgumentTypes( -- Basically checks everything but placeholders.
		state, call, realArguments, realArgumentTypes, calleeTypeInfo.argumentTypesIn,
		false, nil, call.argumentsNamed, false
	)

	-- Prepare for auto-bake stuff.
	local autobaking               = false
	local autobakeIndex            = 0
	local nonAutobakeArguments     = realArguments
	local nonAutobakeArgumentTypes = realArgumentTypes
	local relevantPolymorphs       = lambda.polymorphs

	for argIndex, arg in ipairs(lambda.argumentsIn.arguments) do
		if arg.autobake == !(AUTOBAKE_REQUIRED) then
			autobaking    = true
			autobakeIndex = autobakeIndex+1

			if autobakeIndex == 1 then
				nonAutobakeArguments     = {unpack(nonAutobakeArguments)}
				nonAutobakeArgumentTypes = {unpack(nonAutobakeArgumentTypes)}
				relevantPolymorphs       = {unpack(relevantPolymorphs)}
			end

			if call.isMethod then
				errorInternal(state, arg, "@Incomplete: Handle method calls when auto-baking.")
			end

			local valueExpr     = realArguments    [argIndex] or errorInternal(state, call)
			local valueTypeInfo = realArgumentTypes[argIndex] or errorInternal(state, valueExpr)

			if not isExpressionConstant(state, valueExpr, false) then
				-- @UX: Better message for foreign values.
				typeError(state, valueExpr, "Argument must be constant for baking.")
			end

			for i, morphDecl in ipairsr(relevantPolymorphs) do
				local morphLambda    = morphDecl.value
				local autobakedValue = morphLambda.bakeValues[autobakeIndex] or errorInternal()

				-- @Robustness: I'm not sure areConstantTreesEqual() works properly for enums. It might.
				if not areConstantTreesEqual(state, valueExpr, autobakedValue) then
					table.remove(relevantPolymorphs, i)
				end
			end

		elseif arg.autobake == !(AUTOBAKE_ENABLED) then
			errorInternal(state, arg, "@Incomplete: Optional auto-baking.")
		end
	end

	if autobaking then
		for argIndex, arg in ipairsr(lambda.argumentsIn.arguments) do
			if arg.autobake == !(AUTOBAKE_REQUIRED) then
				table.remove(nonAutobakeArguments,     argIndex)
				table.remove(nonAutobakeArgumentTypes, argIndex)
			end
		end
	end

	-- Check for previous matching polymorph(s).
	local matchingMorphs = getMatchingFunctions(state, call, nonAutobakeArguments, nonAutobakeArgumentTypes, relevantPolymorphs)

	if matchingMorphs then
		local morphDecl = getBestMatchOrTriggerError(
			state, call, matchingMorphs, "polymorph",
			"Internal compiler error: There are several matching polymorphs."
		)

		if autobaking then
			for argIndex, arg in ipairsr(lambda.argumentsIn.arguments) do
				if arg.autobake == !(AUTOBAKE_REQUIRED) then
					local valueExpr = call.arguments[argIndex]
					unqueueChildrenRecursively(state, valueExpr)
					unqueue(valueExpr)
					table.remove(call.arguments, argIndex)
				end
			end

			for argIndexNew, valueExpr in ipairs(call.arguments) do
				valueExpr.queued.key = argIndexNew
			end
		end

		-- Update the callee to represent the correct polymorph.
		ident.declaration  = morphDecl
		ident.inferredType = nil

		queueForReinfer(state, ident) -- Re-infer callee.

		local dependency = getExistingDependency(state, call, !(DEPEND_NODE_INFERRED), ident) -- I think this may always be nil currently?! 2020-07-07
		if dependency then
			call.queued.waitingOn = dependency
			return
		else
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `ident`)
		end
	end

	-- Create declaration for the morphed lambda.
	local morphDecl            = astNewNode(AstDeclaration, lambda, lambda)
	morphDecl.kind             = !(DECL_KIND_LOCAL_CONST)
	morphDecl.name             = newIdentifier(morphDecl, morphDecl, !(IDENT_KIND_DECLARATION), F("%s_POLY%d", ident.name, #lambda.polymorphs+1), morphDecl)
	morphDecl.addedByPolymorph = true

	local morphLambda                 = astCopy(lambda, nil, morphDecl)
	morphLambda.polymorphSourceLambda = lambda
	morphDecl.value                   = morphLambda

	-- Don't keep copies of previous polymorphs we've made - that would quickly create a mess!
	-- (@Speed: Don't even copy them in the first place!)
	do
		morphLambda.polymorphs = nil

		for i, statement in ipairsr(morphLambda.statementsStatic) do
			if statement.nodeType == !(AST_DECLARATION) and statement.addedByPolymorph then
				table.remove(morphLambda.statementsStatic, i) -- Should be fast enough. There shouldn't be that many statements in lambdas.
			end
		end

		if morphLambda.bakeDeclarations then
			for _, declBaked in ipairs(morphLambda.bakeDeclarations) do
				declBaked.checkedRedeclaration = true -- @Hack to prevent redeclaration errors between polymorphed lambda and base lambda.
			end
		end
	end

	table.insert(lambda.polymorphs, morphDecl)

	local function cleanUpMorphedLambda(node, container, key)
		if node == morphLambda.body then  return !(VISIT_IGNORE_CHILDREN)  end

		-- @Robustness @Robustness @Robustness: So much @Hack!
		node.inferredType    = nil
		node.valueTypeInfo   = nil
		node.representedType = nil

		-- AstBake nodes are only used before baking.
		if node.nodeType == !(AST_BAKE) then
			local bake       = node
			container[key]   = bake.name
			bake.name.parent = bake.parent
			return !(VISIT_IGNORE_CHILDREN)
		end
	end
	astVisitAllNodes(morphLambda, cleanUpMorphedLambda)

	-- Fill in baked values in morphed lambda.
	!ASSERT `lambda.argumentsIn`
	local bakeIndex = 0

	for argIndex, arg in ipairs(lambda.argumentsIn.arguments) do
		local declTypeExpr = arg.declaration.type -- This is probably an AstType, if anything.

		if declTypeExpr then
			local nodeContainers = {}
			local nodeKeys       = {}

			local function fillInBakedValues(node, container, key)
				nodeContainers[node] = container or arg.declaration
				nodeKeys      [node] = key       or "type"

				if node.nodeType ~= !(AST_BAKE) then  return  end

				local bake = node
				bakeIndex  = bakeIndex+1

				if arg.autobake ~= !(AUTOBAKE_DISABLED) then
					typeError(state, bake, "Combinations of auto-baking and placeholder types are not supported yet.")
				end

				-- @Incomplete: Handle optional arguments.
				local valueExpr     = realArguments[argIndex]
				local bakeValueExpr = nil
				local bakeValueType = nil

				if valueExpr then
					bakeValueType  = realArgumentTypes[argIndex] or errorInternal(state, valueExpr)
				else
					local argNamed = itemWith1(call.argumentsNamed, "argumentIndex", argIndex) or errorInternal(state, call)
					valueExpr      = argNamed.value
					bakeValueType  = valueExpr.inferredType or errorInternal(state, valueExpr)
				end
				bakeValueType = adjustTypeToOne(state, valueExpr, bakeValueType)

				!(
				local function BAKE_ERROR(messageAndParamsCode)
					TRACE()
					__LUA(templateToLua(
						trimTemplate`
							printerr()
							typeMessage(io.stderr, state, valueExpr, "Error", $message)
							if bakeValueExpr then
								typeMessage(
									io.stderr, state, bakeValueExpr, "Info",
									"...here is the current value being looked at. (Type is '%s')",
									getFriendlyTypeInfoName(bakeValueExpr.inferredType))
							end
							exitFailure()
						`,
						{message=messageAndParamsCode}
					))
				end
				)

				for _, patternLoc in ipairs(getPathToNode(state, declTypeExpr, bake, nodeContainers, nodeKeys)) do
					if patternLoc.containerNode.nodeType == !(AST_TYPE) then
						local patternTypeNode = patternLoc.containerNode

						if patternTypeNode.kind == !(TYPE_KIND_ARRAY) then
							if bakeValueType.tag == !(TYPE_ARRAY) then
								local arraySig = bakeValueType
								bakeValueExpr  = nil
								bakeValueType  = arraySig.itemType or errorInternal(state, valueExpr)

							elseif bakeValueType.tag == !(TYPE_STRUCT) and bakeValueType.kind == !(STRUCT_KIND_ARRAY) then
								local structInfo = bakeValueType
								bakeValueExpr    = nil
								bakeValueType    = structInfo.valueType or errorInternal(state, valueExpr)

							else
								!BAKE_ERROR`"Polymorphic call: Unexpected type. (Wanted an array, got %s)", getFriendlyTypeInfoName(bakeValueType)`
							end

						else
							errorUnhandledNodeType(state, patternTypeNode)
						end

					elseif patternLoc.containerNode.nodeType == !(AST_CALL) then
						local patternCall = patternLoc.containerNode

						if bakeValueType.tag == !(TYPE_STRUCT) then
							-- void
						elseif bakeValueType.tag == !(TYPE_TYPE) then
							-- Note sure if this is bullet proof or sane in any way...
							assert(bakeValueExpr)
							bakeValueType = requireTypeRepresentedByExpression(state, bakeValueExpr)
						else
							!BAKE_ERROR`"Polymorphic call: Expected a type to be a (polymorphic) struct. (Got %s)", getFriendlyTypeInfoName(bakeValueType)`
						end

						local structInfo = bakeValueType
						local struct     = structInfo.astNode

						if structInfo.tag ~= !(TYPE_STRUCT) then
							!BAKE_ERROR`"Polymorphic call: Expected a type to be a (polymorphic) struct. (Got %s)", getFriendlyTypeInfoName(structInfo)`
						elseif not struct.polymorphSourceStruct then
							bakeValueExpr = struct
							!BAKE_ERROR`"Polymorphic call: Expected a type to be a polymorphic struct. (%s is not polymorphic)", getFriendlyTypeInfoName(structInfo)`
						end

						-- @Incomplete: Handle optional arguments.
						if #patternCall.arguments ~= #(struct.bakeDeclarations or EMPTY_TABLE) then
							bakeValueExpr = struct
							!BAKE_ERROR`
								"Polymorphic call: Expected an argument value type to be a polymorphic struct that takes %d argument%s. (%s takes %d)  (Note: Optional arguments are not handled properly yet.)",
								#patternCall.arguments,
								patternCall.arguments[2] and "s" or "",
								getFriendlyTypeInfoName(structInfo),
								#(struct.bakeDeclarations or EMPTY_TABLE)
							`
						end

						local declBakedOther = struct.bakeDeclarations and struct.bakeDeclarations[patternLoc.key] or errorInternal(state, valueExpr)

						bakeValueExpr = declBakedOther.value or errorInternal(state, declBakedOther)
						bakeValueType = bakeValueExpr.inferredType -- Note: declBakedOther.name may not be inferred yet.

						if not bakeValueType then
							!BAKE_ERROR`"Internal compiler error: Polymorphic call: Expected this to be inferred."` -- 'this' is referring to bakeValueExpr. (See BAKE_ERROR)
						end

					else
						errorUnhandledNodeType(state, patternLoc.containerNode)
					end
				end--for getPathToNode

				local declBaked = morphLambda.bakeDeclarations and morphLambda.bakeDeclarations[bakeIndex] or errorInternal(state, bake)
				if bakeValueExpr then
					declBaked.value = astCopy(bakeValueExpr, declBaked, declBaked)
				else
					declBaked.value = createTypeNodeFromInfo(state, bakeValueType, declBaked, declBaked)
				end

				return !(VISIT_IGNORE_CHILDREN) -- There should only be an identifier inside AstBake.
			end
			astVisitAllNodes(declTypeExpr, fillInBakedValues)
		end
	end
	!ASSERT `bakeIndex == #(lambda.bakeDeclarations or EMPTY_TABLE)`

	if autobaking then
		morphLambda.bakeValues = morphLambda.bakeValues or {}

		for argIndex, arg in ipairsr(morphLambda.argumentsIn.arguments) do
			if arg.autobake == !(AUTOBAKE_REQUIRED) then
				--
				-- Here we convert auto-baked arguments to hidden declarations
				-- in the lambda and update the calling site accordingly.
				--
				local declBaked  = arg.declaration
				declBaked.parent = morphLambda
				declBaked.checkedRedeclaration = true -- @Hack to prevent redeclaration errors between polymorphed lambda and base lambda.
				table.insert(morphLambda.statementsStatic, declBaked)
				table.insert(morphLambda.declarations,     declBaked)
				-- morphLambda.bakeDeclarations = morphLambda.bakeDeclarations or {} ; table.insert(morphLambda.bakeDeclarations, declBaked) -- Should we do this? It may be useless.
				addDeclarationToNames(morphLambda, declBaked)

				-- Reuse valueExpr instead of making a copy. Note that this is the
				-- only thing in the morphed lambda that will already be inferred.
				local valueExpr            = realArguments[argIndex]
				declBaked.value            = valueExpr
				valueExpr.parent           = declBaked
				valueExpr.queued.container = declBaked
				valueExpr.queued.key       = "value"
				table.insert(morphLambda.bakeValues, 1, valueExpr)

				table.remove(morphLambda.argumentsIn.arguments, argIndex)
				table.remove(call.arguments,                    argIndex)

			elseif arg.autobake == !(AUTOBAKE_ENABLED) then
				errorInternal(state, arg, "@Incomplete: Optional auto-baking.")
			end
		end

		if not morphLambda.argumentsIn.arguments[1] then
			removeItem(morphLambda.statementsStatic, morphLambda.argumentsIn)
			morphLambda.argumentsIn = nil
		end

		-- !ifDEBUG `astPrintTree(call)`
		-- !ifDEBUG `astPrintTree(morphLambda)`
	end

	-- Update the source lambda, add queueds etc.
	local i                    = #lambda.statementsStatic+1
	lambda.statementsStatic[i] = morphDecl

	addUnqueuedChildrenToQueueRecursively(state, morphDecl, !(PIPE_INFER))
	addToQueue(state, morphDecl, lambda.statementsStatic, i, !(PIPE_INFER))

	if morphLambda.bakeDeclarations then
		for _, declBaked in ipairs(morphLambda.bakeDeclarations) do
			local valueExpr         = declBaked.value
			declBaked.valueTypeInfo = getTypeRepresentedByExpression(valueExpr)
			moveToNextRelevantPipe(state, valueExpr)
		end
	end

	-- Update the callee to represent the correct polymorph.
	ident.declaration  = morphDecl
	ident.inferredType = nil

	queueForReinfer(state, ident) -- Re-infer callee.

	local dependency = getExistingDependency(state, call, !(DEPEND_NODE_INFERRED), ident) -- I think this may always be nil currently?! 2020-07-07
	if dependency then
		call.queued.waitingOn = dependency
		return
	else
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `ident`)
	end
end

local function handleOverloadedCall(state, call, realArguments, realArgumentTypes)
	local ident    = call.callee
	local declBase = ident.declaration.overloadOf

	!ASSERT `declBase.overloads`
	local matchingOverloads = getMatchingFunctions(state, call, realArguments, realArgumentTypes, declBase.overloads)

	if not matchingOverloads then
		local params
		local argTypeTexts = {}

		for i, argTypeInfo in ipairs(realArgumentTypes) do
			if i > 1 then  table.insert(argTypeTexts, ",")  end
			table.insert(argTypeTexts, getFriendlyTypeInfoName(argTypeInfo))
		end

		argTypeTexts[1] = argTypeTexts[1] or "void"

		!TRACE()
		printerr()
		typeMessage(io.stderr, state, ident, "Error", "Did not find any matching overload to call. (Arguments: %s)", table.concat(argTypeTexts))
		for i, declOverload in ipairs(declBase.overloads) do
			typeMessage(io.stderr, state, declOverload.name, "Info", "...overload #%d: %s", i, getFriendlyTypeInfoName(declOverload.inferredType))
		end
		exitFailure()
	end

	local decl = getBestMatchOrTriggerError(
		state, call, matchingOverloads, "overload",
		"There are several matching overloads."
	)
	local calleeTypeInfo = decl.inferredType

	-- Update the callee to represent the correct overload.
	-- @Robustness: Is this safe? I don't think anything except the calls itself depends directly on, and uses values from, any callee.
	ident.declaration  = decl
	ident.inferredType = calleeTypeInfo

	return calleeTypeInfo
end

local function handlePolymorphicStruct(state, call)
	local typeNode = call.callee
	assert(typeNode.nodeType == !(AST_TYPE))

	local structInfo = typeNode.representedType
	assert(structInfo.tag == !(TYPE_STRUCT))
	assert(structInfo.isPolymorphic)

	if call.isMethod then
		local exprForError = astGetOriginal(typeNode)
		if exprForError.nodeType == !(AST_ACCESS) then
			exprForError = exprForError.member
		end
		typeError(state, exprForError, "This is not a method. (It is struct '%s')", getFriendlyTypeInfoName(structInfo))
	end

	local struct = structInfo.astNode

	!ASSERT `struct.polymorphs`
	for _, morphDecl in ipairs(struct.polymorphs) do
		if not morphDecl.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `morphDecl`)
		end
	end

	--
	-- No more dependencies for the struct call after this point (except when we're done)!
	--

	ensureNamedArgumentsHaveAssignedIndicies(state, call, struct, call.arguments)

	-- Check arguments.  @UX: Better error message for foreign values.
	for argIndex, argExpr in ipairs(call.arguments) do
		if not isExpressionConstant(state, argExpr, false) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(argExpr), "Struct argument #%d is not constant.", argIndex)
		end
	end
	for _, argNamed in ipairs(call.argumentsNamed) do
		if not isExpressionConstant(state, argNamed.value, false) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(argNamed.value), "Struct argument #%d (%s) is not constant.", argNamed.argumentIndex, argNamed.key.name)
		end
	end

	!ASSERT `struct.bakeDeclarations`
	local requested   = #call.arguments + #call.argumentsNamed
	local acceptedMax = #struct.bakeDeclarations
	local acceptedMin = acceptedMax

	for argIndex = acceptedMax, 1, -1 do
		if not struct.bakeDeclarations[argIndex].value then  break  end
		acceptedMin = acceptedMin-1
	end

	if requested < acceptedMin then
		typeError(state, call, "Too few struct arguments. (Expected %d, got %d)", acceptedMin, requested)

	elseif requested > acceptedMax then
		local valueExpr = call.arguments[acceptedMax+1]
		typeError(
			state, (valueExpr and astGetExpressionVisuallyFurthestToTheLeft(valueExpr) or call),
			"Too many struct arguments. (Expected %d, got %d)",
			acceptedMax, requested
		)
	end

	-- Check for previous matching polymorph.
	for _, morphDecl in ipairs(struct.polymorphs) do
		local morphStruct = morphDecl.value
		local isMatch     = true

		for argIndex, declBaked in ipairs(morphStruct.bakeDeclarations) do
			local valueBaked = declBaked.value
			local valueExpr  = call.arguments[argIndex]

			if not valueExpr then
				local argNamed = itemWith1(call.argumentsNamed, "argumentIndex", argIndex)
				valueExpr      = argNamed and argNamed.value or struct.bakeDeclarations[argIndex].value
			end

			if not areConstantTreesEqual(state, valueExpr, valueBaked) then
				isMatch = false ; break
			end
		end

		if isMatch then
			-- Change the call into a type node.
			local morphTypeNode       = astNewNode(AstType, typeNode, call.parent)
			morphTypeNode.kind        = !(TYPE_KIND_USER)
			morphTypeNode.typeName    = morphDecl.name.name
			morphTypeNode.declaration = morphDecl

			replaceQueuedNodeAndUnqueueOldTree(state, call, morphTypeNode)

			-- Stay in PIPE_INFER. Also, the next line is needed.
			--
			-- @Robustness: Waiting for morphDecl instead of the name seem to result in an error here.
			-- Why is the reverse true for the DEPEND_AND_RETURN at the end of this function?
			-- Also, should we use getExistingDependency() like in handlePolymorphicCall()?
			--
			!DEPEND_AND_RETURN(`morphTypeNode`, DEPEND_NODE_INFERRED, `morphDecl.name`)
		end
	end

	-- Create declaration for the morphed struct.
	local morphDecl            = astNewNode(AstDeclaration, struct, struct)
	morphDecl.kind             = !(DECL_KIND_LOCAL_CONST)
	morphDecl.name             = newIdentifier(morphDecl, morphDecl, !(IDENT_KIND_DECLARATION), F("%s_POLY%d", typeNode.typeName, #struct.polymorphs+1), morphDecl)
	morphDecl.addedByPolymorph = true

	local morphStruct                 = astCopy(struct, nil, morphDecl)
	morphStruct.inferredType          = nil
	morphStruct.representedType       = nil
	morphStruct.polymorphSourceStruct = struct
	morphDecl.value                   = morphStruct

	-- Don't keep copies of previous polymorphs we've made - that would quickly create a mess!
	-- (@Speed: Don't even copy them in the first place!)
	do
		morphStruct.polymorphs = nil

		for i, statement in ipairsr(morphStruct.statementsStatic) do
			if statement.nodeType == !(AST_DECLARATION) and statement.addedByPolymorph then
				table.remove(morphStruct.statementsStatic, i) -- This line should only trigger at most twice per polymorph.
			end
		end
	end

	table.insert(struct.polymorphs, morphDecl)

	-- Bake values into morphed struct.
	for argIndex, declBaked in ipairs(morphStruct.bakeDeclarations) do
		local valueExpr = call.arguments[argIndex]

		if not valueExpr then
			local argNamed = itemWith1(call.argumentsNamed, "argumentIndex", argIndex)
			valueExpr      = argNamed and argNamed.value
		end

		if valueExpr then -- valueExpr is nil for optional arguments.
			declBaked.value = astCopy(valueExpr, nil, declBaked) -- Overwrite any old value expression.
		end

		declBaked.checkedRedeclaration = true -- @Hack to prevent redeclaration errors between polymorphed struct and base struct.
	end

	-- Update the source struct, add queueds etc.
	local i                    = #struct.statementsStatic+1
	struct.statementsStatic[i] = morphDecl
	addToQueueRecursively(state, morphDecl, struct.statementsStatic, i, !(PIPE_INFER))

	-- Change the call into a type node.
	local morphTypeNode       = astNewNode(AstType, typeNode, call.parent)
	morphTypeNode.kind        = !(TYPE_KIND_USER)
	morphTypeNode.typeName    = morphDecl.name.name
	morphTypeNode.declaration = morphDecl

	replaceQueuedNodeAndUnqueueOldTree(state, call, morphTypeNode)

	-- Stay in PIPE_INFER. Also, the next line is needed.
	!DEPEND_AND_RETURN(`morphTypeNode`, DEPEND_NODE_INFERRED, `morphDecl`)
end

local function doesExpressionRepresentPolymorphicStructType(expr)
	if expr.inferredType.tag ~= !(TYPE_TYPE) then  return false  end

	local typeRepresented = getTypeRepresentedByExpression(expr)
	return
		typeRepresented ~= nil
		and typeRepresented.tag == !(TYPE_STRUCT)
		and typeRepresented.isPolymorphic
end
local function doesExpressionRepresentStructType(expr)
	if expr.inferredType.tag ~= !(TYPE_TYPE) then  return false  end

	local typeRepresented = getTypeRepresentedByExpression(expr)
	return typeRepresented ~= nil and typeRepresented.tag == !(TYPE_STRUCT)
end

!NODE_INFERRER `function nodeInferrers.AstCall(state, call)`
	local callee     = call.callee
	local calleeType = callee.inferredType

	-- Wait for callee.
	if callee.queued.pipe <= !(PIPE_INFER) then -- :WaitForCalleeToPassInfer
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_PASSED_INFER, `callee`)
	end
	-- if not calleeType then -- Not enough?
	-- 	!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `callee`)
	-- end

	local isCallingConstantNameOrDeclaredType = (
		(
			callee.nodeType == !(AST_IDENTIFIER)
			or (callee.nodeType == !(AST_TYPE) and callee.declaration ~= nil)
		)
		and isDeclarationConstant(callee.declaration)
	)

	-- Wait for constant declaration.  (Waiting for the callee isn't enough
	-- for some reason. Maybe there's a problem with things waiting for
	-- declaration.name instead of declarations themselves. 2020-05-12)
	--
	-- (Needed anymore since :WaitForCalleeToPassInfer?)
	--
	if isCallingConstantNameOrDeclaredType and not callee.declaration.inferredType then
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `callee.declaration`)
	end

	-- Wait for overloads.
	if isCallingConstantNameOrDeclaredType and callee.declaration.overloadOf then
		local ident = callee
		!ASSERT("callee.nodeType == "..AST_IDENTIFIER) -- Only functions can be overloaded in which case 'callee' should not be a type here.
		local declBase = ident.declaration.overloadOf

		calleeType = declBase.inferredType
		if not calleeType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `declBase`) -- If the base is overloaded then all others should be too.
		end
	end

	-- Wait for arguments.
	for _, argExpr in ipairs(call.arguments) do
		if argExpr.queued.pipe <= !(PIPE_READY) then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_PASSED_READY, `argExpr`)
		end
		-- if not argExpr.inferredType then
		-- 	!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `argExpr`)
		-- end
	end
	for _, argNamed in ipairs(call.argumentsNamed) do
		-- Only wait for the values.
		if not argNamed.value.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `argNamed.value`)
		end
	end

	calleeType = adjustTypeToOne(state, callee, calleeType, true)

	!local NOT_CALLABLE = templateToLua(
		trimTemplate`
			if callee.nodeType == $nodeTypeIdent then
				local ident = callee
				typeError(state, ident, "'%s' is not a function. (It is %s)", ident.name, getFriendlyTypeInfoName(ident.inferredType))
			else
				typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeType))
			end
		`,
		{nodeTypeIdent=AST_IDENTIFIER}
	)

	if call.argumentsNamed[1] then
		if not isCallingConstantNameOrDeclaredType then
			typeError(state, call.argumentsNamed[1].key, "The called object must be a constant identifier for named arguments to work.")
		end
		if not (calleeType.tag == !(TYPE_FUNCTION) or calleeType.tag == !(TYPE_TYPE)) then
			errorInternal(state, call.argumentsNamed[1].key, "@Incomplete: Handle named arguments for non-function calls.")
		end
	end

	-- Infer call depending on callee type.
	if calleeType.tag == !(TYPE_FUNCTION) then
		-- void

	elseif doesExpressionRepresentPolymorphicStructType(callee) then -- @Cleanup: We can/should probably just check callee.declaration.valueTypeInfo here.
		if isScope(call.parent) then
			errorParsing(
				state, astGetExpressionVisuallyFurthestToTheLeft(call),
				"Invalid statement. This not a function call - it is struct type '%s'.",
				getFriendlyTypeInfoName(getTypeRepresentedByExpression(callee))
			)
		end

		handlePolymorphicStruct(state, call)
		return

	elseif doesExpressionRepresentStructType(callee) then -- @Cleanup: We can/should probably just check callee.declaration.valueTypeInfo here.
		local structInfo = getTypeRepresentedByExpression(callee)

		-- We have to wait for the members for inherited declarations to be available.
		if not structInfo.hasMembers then
			!DEPEND_AND_RETURN(`call`, DEPEND_TYPE_MEMBERS_READY, `structInfo`)
		end

		local decl = findMemberDeclaration(state, structInfo.astNode, "!call")
		if not decl then
			typeError(state, call, "%s has no !call declaration and thus cannot be called.", getFriendlyTypeInfoName(structInfo))
		end

		local ident = astCopyIdentifier(decl.name, callee, call, !(IDENT_KIND_LOOSE))
		replaceQueuedNodeAndUnqueueOldTree(state, callee, ident)

		return inferNode(state, call)

	else
		!!(NOT_CALLABLE)
	end

	-- Callee should be a function at this point.
	local funcSig = calleeType
	!ASSERT("funcSig.tag == "..TYPE_FUNCTION)

	if call.isMethod and callee.nodeType ~= !(AST_ACCESS) then
		typeError(state, callee, "This is not an object that allows method calls.")
	end

	local realArguments     = (call.isMethod and {callee, unpack(call.arguments)} or call.arguments)
	-- local realArgumentTypes = {}

	local realArgumentTypes = !!(STATIC{}) -- Not sure if actually faster than making a new table every time.
	for i = #realArgumentTypes, 1, -1 do
		realArgumentTypes[i] = nil
	end

	if call.isMethod then
		local typeInfo       = callee.object.inferredType
		realArgumentTypes[1] = adjustTypeToOne(state, callee.object, typeInfo, true) -- Is adjustTypeToOne necessary? @Cleanup
	end
	for _, argExpr in ipairs(call.arguments) do
		local typeInfo = argExpr.inferredType
		if !!(CONST_SET{ AST_VARARG, AST_CALL })[argExpr.nodeType] and argExpr.surroundedByParentheses then
			typeInfo = adjustTypeToOne(state, argExpr, typeInfo, true)
		end
		table.insert(realArgumentTypes, typeInfo)
	end

	-- Overloaded call.
	!if DEBUG then
		if callee.nodeType == !(AST_IDENTIFIER) and not callee.declaration.overloadsLocked then
			errorInternal(state, callee)
		end
	!end
	if isCallingConstantNameOrDeclaredType and callee.declaration.overloadOf then
		funcSig = handleOverloadedCall(state, call, realArguments, realArgumentTypes) or errorInternal(state, call)
	end

	local constLambda = nil

	if isCallingConstantNameOrDeclaredType then
		constLambda = followIdentifiersToConstantValue(state, callee.declaration.value)

		if constLambda.nodeType ~= !(AST_LAMBDA) then
			!ifDEBUG`
				astPrint(callee)
				astPrint(callee.declaration)
				astPrint(constLambda)
				where(state, constLambda)
			`
			errorInternal(state, call)
		end
	end

	ensureNamedArgumentsHaveAssignedIndicies(state, call, constLambda, realArguments)

	-- Polymorphic call.
	if funcSig.isPolymorphic then
		handlePolymorphicCall(state, call, funcSig, realArguments, realArgumentTypes)
		return -- Wait for the polymorphed function to infer.
	end

	-- Plain call.
	checkIfValuesMatchArgumentTypes(
		state, call, realArguments, realArgumentTypes, funcSig.argumentTypesIn,
		false, nil, call.argumentsNamed, false
	)

	-- Make sure foreign function calls don't have gaps among the arguments as
	-- that may have unexpected consequences (since we don't "put" the default
	-- value in empty slots for foreign functions).
	if call.argumentsNamed[1] and constLambda.bodyIsForeign then
		local argsIn        = constLambda.argumentsIn.arguments
		local argInCount    = #argsIn
		local isVararg      = funcSig.argumentTypesIn[argInCount].tag == !(TYPE_VARARG)
		local maxNamedCount = isVararg and argInCount-1 or argInCount
		local requiredCount = maxNamedCount

		for argIndex = requiredCount, 1, -1 do
			local arg = argsIn[argIndex]
			if arg.isRequired then  break  end
			requiredCount = requiredCount-1
		end

		local firstGapAtIndex = nil

		for argIndex = requiredCount+1, maxNamedCount do
			local valueExpr = realArguments[argIndex]
			local nodeForError

			if not valueExpr then
				local argNamed = itemWith1(call.argumentsNamed, "argumentIndex", argIndex)
				valueExpr      = argNamed and argNamed.value
				nodeForError   = argNamed and argNamed.key
			end

			if not valueExpr then
				firstGapAtIndex = firstGapAtIndex or argIndex

			elseif firstGapAtIndex then
				local arg = argsIn[firstGapAtIndex]
				typeError(
					state, nodeForError,
					"Foreign function calls must not have gaps before the last specified optional argument. Missing value for argument #%d (%s).",
					firstGapAtIndex, arg.declaration.name.name
				)
			end
		end
	end

	local listSig  = getTypeInfoForList(state, funcSig.argumentTypesOut)
	local typeInfo = listSig

	if listSig[1] and (call.surroundedByParentheses or not areMultipleValuesEnabledAtPosition(state, call)) then
		call.surroundedByParentheses = true
		typeInfo                     = adjustTypeToOne(state, call, listSig, true)
	end

	-- Handle inlining.
	if constLambda then
		if call.inline == !(INLINE_MAY) then
			if constLambda.inline ~= !(INLINE_MAY) then
				call.inline = constLambda.inline
			end
		elseif call.inline == !(INLINE_YES) then
			if constLambda.bodyIsForeign then
				-- We allow no_inline because it's effectively a no-op for foreign function calls. Maybe we should emit a warning.
				typeError(state, callee, "Cannot inline calls to foreign functions.")
			end
		end
		-- call.inline may be INLINE_MAY at this point.
	else
		if call.inline == !(INLINE_YES) then
			-- We allow no_inline because it's effectively a no-op for variable function calls. Maybe we should emit a warning.
			typeError(state, callee, "Can only inline calls to function constants.")
		end
		call.inline = !(INLINE_NO) -- Make sure call.inline isn't INLINE_MAY.
	end

	-- Handle !must.
	if
		constLambda
		and constLambda.argumentsOut
		and constLambda.argumentsOut.arguments[1].isRequired
		and not !!(CONST_SET{ AST_VARIANT_OF, AST_TYPE_OF, AST_TYPE_INFO, AST_DEBUG })[call.parent.nodeType]
	then
		local lastRequiredIndex = lastIndexWith1(constLambda.argumentsOut.arguments, "isRequired", true)
		local assignment        = call.parent

		if assignment.nodeType ~= !(AST_ASSIGNMENT) then
			local name = constLambda.argumentsOut.arguments[lastRequiredIndex].declaration.name.name
			typeError(
				state, call,
				"Function requires return value #%d%s to be explicitly received in an assigment.",
				lastRequiredIndex, (name ~= "" and F(" (%s)", name) or "")
			)
		end

		local valueIndex  = indexOf(assignment.values, call) or errorInternal(state, call) -- The call shouldn't be one of the targets. That would've been a parsing error!
		local targetIndex = valueIndex+lastRequiredIndex-1

		if not assignment.targets[targetIndex] or (call.surroundedByParentheses and lastRequiredIndex > 1) then
			local name = constLambda.argumentsOut.arguments[lastRequiredIndex].declaration.name.name
			typeError(
				state, call,
				"Missing assignment target for return value #%d%s which is required to be explicitly received.",
				lastRequiredIndex, (name ~= "" and F(" (%s)", name) or "")
			)
		end
	end

	if constLambda then
		call.wantLocation = constLambda.wantCallerLocation
	end

	call.inferredType = typeInfo
	moveToNextRelevantPipe(state, call)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstReturn(state, returnNode)`
	for _, valueExpr in ipairs(returnNode.values) do
		if not valueExpr.inferredType then
			!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `valueExpr`)
		end
	end

	local scope = astFindParentScope(returnNode) or errorInternal()

	while scope.nodeType ~= !(AST_LAMBDA) do
		if not isScopeImperative(scope) then -- This may eventually be AstFileScope, at most.
			-- I think this is an internal compiler error, actually. Parsing must have goofed up or something.
			typeError(state, scope, "Return statement is not in a function.")
		end

		scope = astFindParentScope(scope) or errorInternal()
	end

	local lambda = scope

	if not lambda.inferredType then
		!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `lambda`)
	end

	local typeInfos = {}
	for i, valueExpr in ipairs(returnNode.values) do
		typeInfos[i] = valueExpr.inferredType
	end

	checkIfValuesMatchArgumentTypes(
		state, returnNode, returnNode.values, typeInfos, lambda.inferredType.argumentTypesOut,
		false, nil, nil, false
	)
	moveToNextRelevantPipe(state, returnNode)
!NODE_INFERRER_END `end`

-- valueExpression|replacementIdentifier = maybeReplaceValueExpressionWithEnumValueIdentifier( state, valueExpression, targetTypeInfo )
local function maybeReplaceValueExpressionWithEnumValueIdentifier(state, valueExpr, typeInfo)
	if typeInfo.tag ~= !(TYPE_ENUM) then  return valueExpr  end

	if not (valueExpr.nodeType == !(AST_LITERAL) or valueExpr.nodeType == !(AST_TYPE)) then
		return valueExpr
	end

	local enumInfo = typeInfo
	local decl     = findDeclarationInEnumForValue(state, enumInfo.astNode, valueExpr) or errorInternal(state, valueExpr)
	local ident    = astCopyIdentifier(decl.name, valueExpr, decl, !(IDENT_KIND_LOOSE))

	replaceQueuedNodeAndUnqueueOldTree(state, valueExpr, ident)
	moveToNextRelevantPipe(state, ident, !(PIPE_INFER)) -- Will ident be in a good pipe? It'll probably end up in PIPE_READY which seems right. 2021-08-03
	return ident
end

!NODE_INFERRER `function nodeInferrers.AstDeclaration(state, decl)`
	local valueExpr            = getDeclarationValue(decl, true)
	local isConst              = isDeclarationConstant(decl)
	local identOrVarargOrBlank = decl.name

	if valueExpr then
		if valueExpr.nodeType == !(AST_TABLE) then
			local tableNode = valueExpr
			if tableNode.queued.pipe <= !(PIPE_INFER) then
				!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_PASSED_INFER, `tableNode`)
			end

		elseif not valueExpr.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `valueExpr`)
		end

		if isConst and valueExpr.nodeType == !(AST_STRUCT) or valueExpr.nodeType == !(AST_ENUM) then
			valueExpr.representedType.name = identOrVarargOrBlank.name
		end
	end

	local typeInfo = identOrVarargOrBlank.inferredType
	if not typeInfo then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `identOrVarargOrBlank`)
	end

	if decl.notes then
		for _, note in ipairs(decl.notes) do
			if not note.inferredType then
				!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `note`)
			end
		end
	end

	local scope    = astFindParentScope(decl)
	local typeExpr = decl.type

	local isForeignVariableMember = (not isConst and decl.parent == scope and scope.nodeType == !(AST_STRUCT) and scope.isForeign)

	if typeExpr then
		if not typeExpr.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `typeExpr`)
		end

		local typeInfoRepresented = requireTypeRepresentedByExpression(state, typeExpr)

		if decl.parent.nodeType == !(AST_ARGUMENT) then
			-- void  Ignore function arguments.
		elseif typeInfoRepresented.tag ~= !(TYPE_COMPOUND) then
			-- void  Only compound types have a higher requirement on the value at the moment.
		elseif isConst then
			typeError(
				state, identOrVarargOrBlank,
				"Constants cannot be compound types. (Type is %s)",
				getFriendlyTypeInfoName(typeInfoRepresented)
			)
		elseif isForeignVariableMember then
			-- void  These never need a value.
		elseif not valueExpr then
			typeError(
				state, identOrVarargOrBlank,
				"An initial value is required for compound types. (Type is %s)",
				getFriendlyTypeInfoName(typeInfoRepresented)
			)
		end
	end

	if valueExpr and isConst and valueExpr.nodeType == !(AST_IDENTIFIER) and not valueExpr.fromVariant then
		local declBase = valueExpr.declaration.overloadOf

		if declBase and not declBase.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `declBase`)
		end
	end

	--
	-- No more dependencies for this declaration after this point!
	--

	decl.inferredType = typeInfo -- @Speed: We probably want to set this as soon as possible as many things may wait for the declaration to get inferred.

	if valueExpr then
		if valueExpr.nodeType == !(AST_IDENTIFIER) and not valueExpr.declaration.overloadsLocked then
			errorInternal(state, valueExpr)
		end

		local valueType = valueExpr.inferredType
		if valueType.tag == !(TYPE_NAMESPACE) and not isConst then
			typeError(state, valueExpr, "References to namespaces must be constant.")
		end

		-- Validate that the assigned value is the same type as the declared name.
		--
		-- (Not needed for vararg as those only exist as arguments and don't have default values.
		-- Also, this doesn't run for enum members as those declarations never have any specified types.)
		--
		if typeExpr and identOrVarargOrBlank.nodeType ~= !(AST_VARARG) then
			if decl.assignment then
				getAssignmentValue(state, identOrVarargOrBlank, decl.assignment.values, decl.assignmentIndex, typeInfo, nil, nil, false)

			elseif not isTypeCompatibleWith(state, valueType, typeInfo, !(STRICT_TYPE_MATCH_NO), valueExpr) then -- Note: No need to call adjustTypeToOne() for valueExpr.
				local wantEnumAndGotLiteralOfCorrectType, isCompatible = checkForLiteralVsEnumSituation(valueExpr, typeInfo)

				if isCompatible then
					-- void
				elseif wantEnumAndGotLiteralOfCorrectType then
					typeError2(state,
						valueExpr,        F("Enum '%s' has no value '%s'.", getFriendlyTypeInfoName(typeInfo), valueToStringForMessage(valueExpr.value)),
						typeInfo.astNode, F("...here is the enum.")
					)
				else
					-- @UX: Use the same error message as getAssignmentValue().
					typeError(
						state, valueExpr, "Value type mismatch for assignment target #%d. (Wanted %s, got %s)",
						decl.assignmentIndex,
						getFriendlyTypeInfoName(typeInfo),
						getFriendlyTypeInfoName(valueType)
					)
				end
			end
		end

		if shouldDeclarationValueDefinitivelyBeConstant(decl) or isScopeDeclarative(scope) then
			local valueIsConst, dynExpr = isExpressionConstant(state, valueExpr, false)
			if valueIsConst then
				-- void

			elseif dynExpr.nodeType == !(AST_LAMBDA) then
				local lambda = dynExpr
				!ASSERT `lambda.captures or lambda.captureAll`
				typeError(
					state, lambda,
					"Value for declared %s '%s' is not a constant expression. (Functions with captures are not constant.)",
					(isConst and "constant" or "variable"),
					identOrVarargOrBlank.name
				)

			elseif dynExpr.nodeType == !(AST_FOREIGN) then
				local foreign = dynExpr

				if foreign == valueExpr then
					-- void
					-- We usually treat foreign values as runtime values. The only exception is when
					-- it's placed directly on a declaration. (Can this be solved in a better way?)
					-- :SpecialForeignValueRules
				else
					typeError(state, foreign, "Cannot evaluate foreign values during compile time.")
				end

			else
				typeError(
					state, dynExpr,
					"%s for declared %s '%s' is not a constant expression.%s",
					(dynExpr == valueExpr and "Value"    or "Sub-expression inside the value"),
					(isConst              and "constant" or "variable"),
					identOrVarargOrBlank.name,
					(not isConst and isScopeDeclarative(scope) and " (All values in declarative scopes must be constant.)" or "")
				)
			end
		end

		if isConst and valueExpr.nodeType == !(AST_IDENTIFIER) and not valueExpr.fromVariant then
			local ident    = valueExpr
			local declBase = ident.declaration.overloadOf

			if declBase then
				if decl.overloadOf then
					typeError2(state,
						decl,     F("Cannot overload aliases of already overloaded names."),
						declBase, F("...here is one of the overloads for '%s'.", ident.name)
					)
				end
				decl.overloadOf = declBase -- Note: We don't add decl as an overload itself.
			end
		end

		--
		-- Not sure if this enum value check/replacement should be exactly here.
		--
		-- Note that we only get here in static context, but we probably don't need to
		-- do anything for values in imperative-context variable declarations anyway.
		--
		if scope.nodeType ~= !(AST_ENUM) then
			--[[valueExpr = ]]maybeReplaceValueExpressionWithEnumValueIdentifier(state, valueExpr, typeInfo)
		end

	elseif not (
		doesTypeHaveAnyDefaultValue(typeInfo)
		-- Ignore missing values for arguments (which are then required arguments).
		or decl.parent.nodeType == !(AST_ARGUMENT)
		-- Variables in foreign structs do not need initial values since those structs never get constructed locally anyway.
		or isForeignVariableMember
	) then
		!ASSERT `not isConst` -- This should have been detected in inferIdentifierOrVarargOrBlank() (I think).
		typeError(state, identOrVarargOrBlank, "Variables in type group '%s' must have a specified initial value.", TYPE_NAMES[typeInfo.tag])
	end

	if decl.notes then
		for _, note in ipairs(decl.notes) do
			local typeRepresented = requireTypeRepresentedByExpression(state, note)
			if typeRepresented.tag ~= !(TYPE_STRUCT) then
				typeError(state, note, "Expected a struct type. (This is %s)", getFriendlyTypeInfoName(typeRepresented))
			end
		end
	end

	moveToNextRelevantPipe(state, decl)

	!if DEBUG and 1==0 then
		if decl.s == 450 then
			astPrintTree(decl)
			where(state, decl, "Declaration inferred.")
		end
	!end

	if scope.nodeType == !(AST_FILE_SCOPE) and state.sendMessages then
		local message = newMessage(!(MESSAGE_CODE_TYPECHECKED))
		table.insert(state.messages, message)

		local typeInfoForPublic
			=   isTypePublic(typeInfo)
			and typeInfo
			or  state.builtinTypeInfos.void

		local codeDecl          = CodeDeclaration()
		codeDecl.serial         = decl.s
		codeDecl.typeInfo       = getPublicType(state, typeInfoForPublic)
		codeDecl.filepath       = decl.source.path
		codeDecl.lineNumber     = decl.line
		codeDecl.filePosition   = decl.position
		codeDecl.name           = identOrVarargOrBlank.name
		codeDecl.expressions[1] = nil -- @Incomplete: Generate child CodeNodes.
		codeDecl.rootExpression = nil -- @Incomplete: Generate child CodeNodes.
		codeDecl.isConstant     = isConst

		if decl.notes then
			for i, note in ipairs(decl.notes) do
				local typeRepresented = getTypeRepresentedByExpression(note)
				codeDecl.notes[i]     = typeRepresented.id
			end
		end

		message.declaration = codeDecl
	end
!NODE_INFERRER_END `end`

!!local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = {
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "none",
	[LITERAL_FLOAT]   = "float",
	[LITERAL_STRING]  = "string",
}
_G.!(local )!!BUILTIN_TYPE_TAG_TO_LITERAL_TYPE = {
	[TYPE_BOOL]   = LITERAL_BOOLEAN,
	[TYPE_INT]    = LITERAL_INTEGER,
	[TYPE_NONE]   = LITERAL_NIL,
	[TYPE_FLOAT]  = LITERAL_FLOAT,
	[TYPE_STRING] = LITERAL_STRING,
}

!NODE_INFERRER `function nodeInferrers.AstLiteral(state, literal)`
	local typeName       = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType] or errorUnhandledNodeType(state, literal)
	literal.inferredType = state.builtinTypeInfos[typeName]
	moveToNextRelevantPipe(state, literal)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstUnary(state, unary)`
	local typeInfo = unary.expression.inferredType
	if not typeInfo then
		!DEPEND_AND_RETURN(`unary`, DEPEND_NODE_INFERRED, `unary.expression`)
	end

	if typeInfo.tag == !(TYPE_LIST) then
		typeInfo = adjustTypeToOne(state, unary.expression, typeInfo, true)
	end

	if not typeInfo.isReady then
		!DEPEND_AND_RETURN(`unary`, DEPEND_TYPE_READY, `typeInfo`) -- Needed when e.g. getting the length of array-like structs in some cases.  @Speed: Only wait when actually needed!
	end

	if unary.operation == "+" or unary.operation == "-" then
		-- @Incomplete: Allow int|float compound type here (or disallow declarations of that specific compound type).
		if not isTypeNumeric(typeInfo) then
			typeError(
				state, unary.expression,
				"Unary numeric operation (%s): Expected a float or int. (Got %s)",
				unary.operation,
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "not" then
		if typeInfo.tag ~= !(TYPE_BOOL) then
			wrapInImplicitCast(state, unary.expression, state.builtinTypeInfos.bool, true)
			return
		end

	elseif unary.operation == "#" then
		if not (
			(typeInfo.tag == !(TYPE_STRUCT) and typeInfo.valueType and not typeInfo.keyType) -- Should we allow keyType to be int? (Leaning towards no, I think. 2021-01-09)
			or !!(CONST_SET{ TYPE_ARRAY, TYPE_TABLE, TYPE_STRING, TYPE_VARARG })[typeInfo.tag]
		) then
			typeError(
				state, unary.expression,
				"Unary length operation (#): Expected an array, a table or a string. (Got %s)",
				getFriendlyTypeInfoName(typeInfo)
			)
		end

		typeInfo = state.builtinTypeInfos.int

	else
		errorUnhandledNodeType(state, unary)
	end

	unary.inferredType = typeInfo

	moveToNextRelevantPipe(state, unary)
	simplifyExpressionIfConstant(state, unary)
!NODE_INFERRER_END `end`

local function isCompoundCompare(state, binary, typeInfoL, typeInfoR)
	-- Detect situations like these: local v:int|string = 0 ; if v == ""

	local compound    = typeInfoL
	local otherType   = typeInfoR

	local lIsCompound = (compound.tag  == !(TYPE_COMPOUND))
	local rIsCompound = (otherType.tag == !(TYPE_COMPOUND))

	if lIsCompound and rIsCompound then
		-- The compound types must be the same for a theoretical test here to pass
		-- since both compounds must contain all of the other one's types, but we
		-- should already have checked for that and thus shouldn't be here. So, we
		-- simply say they are incompatible right away.
		return false
	elseif lIsCompound then
		-- void
	elseif rIsCompound then
		compound, otherType = otherType, compound
	else
		return false
	end

	return indexOf(compound, otherType) ~= nil -- We don't use isTypeCompatibleWith() here - the compound must contain exactly otherType!
end

local function isValidEqualityCheck(state, binary, typeInfoL, typeInfoR)
	if typeInfoL == typeInfoR or typeInfoL.tag == !(TYPE_ANY) or typeInfoR.tag == !(TYPE_ANY) then  return true  end

	-- We allow comparing namespaces even though technically each namespace has it's own unique type.
	-- Functions can also be compared freely despite having different signatures.
	if typeInfoL.tag == typeInfoR.tag and (typeInfoL.tag == !(TYPE_NAMESPACE) or typeInfoL.tag == !(TYPE_FUNCTION)) then  return true  end

	if isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR)  then  return true  end
	if isCompoundCompare(state, binary, typeInfoL, typeInfoR) then  return true  end

	return false
end

-- resultingTypeInfo = checkBinaryOperation( state, expressionForError, mainExpression, leftExpression, rightExpression, binaryOperation, typeInfoL, typeInfoR, inAssignment )
-- Resurns nil if a cast was added and we're now waiting for it to infer.
function _G.checkBinaryOperation(state, exprForError, exprMain,exprL,exprR, binOp, typeInfoL,typeInfoR, inAssignment)
	!local TYPE_MISMATCH = `typeError(
		state, exprForError,
		"Binary operation (%s): Type mismatch for operands. (Left is %s, right is %s)",
		binOp,
		getFriendlyTypeInfoName(typeInfoL),
		getFriendlyTypeInfoName(typeInfoR)
	)`

	-- String repetition.
	if binOp == "*" and (
		(typeInfoL.tag == !(TYPE_STRING) and typeInfoR.tag == !(TYPE_INT)) or
		(typeInfoL.tag == !(TYPE_INT)    and typeInfoR.tag == !(TYPE_STRING))
	) then
		local intExpr = (typeInfoL.tag == !(TYPE_INT) and exprL or exprR)
		if intExpr.nodeType == !(AST_LITERAL) and intExpr.value < 0 then
			typeError(state, intExpr, "String repetition: Integer is negative. (%d)", intExpr.value)
		end
		return state.builtinTypeInfos.string

	-- Numeric operation.
	elseif !!(CONST_SET{"+","-","*","^","%","/","//"})[binOp] then
		if not (isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR)) then
			typeError(
				state, exprMain,
				"Binary numeric operation (%s): Expected operands to be numeric. (Got %s and %s)",
				binOp,
				getFriendlyTypeInfoName(typeInfoL),
				getFriendlyTypeInfoName(typeInfoR)
			)
		end

		if binOp == "/" then
			return state.builtinTypeInfos.float
		elseif binOp == "//" then
			return state.builtinTypeInfos.int
		elseif typeInfoL.tag == !(TYPE_FLOAT) or typeInfoR.tag == !(TYPE_FLOAT) then
			return state.builtinTypeInfos.float
		else
			return state.builtinTypeInfos.int
		end

	-- Comparison.
	elseif !!(CONST_SET{"<",">","<=",">="})[binOp] then
		if not (typeInfoL == typeInfoR or (isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR))) then
			!!(TYPE_MISMATCH)
		elseif not !!(CONST_SET{ TYPE_INT, TYPE_FLOAT, TYPE_STRING })[typeInfoL.tag] then
			typeError(
				state, exprMain,
				"Binary comparison (%s): Expected a float, int or string. (Got %s)",
				binOp,
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		return state.builtinTypeInfos.bool

	-- Equality.
	elseif !!(CONST_SET{"==","~="})[binOp] then
		if not isValidEqualityCheck(state, exprForError, typeInfoL, typeInfoR) then
			!!(TYPE_MISMATCH)
		end
		return state.builtinTypeInfos.bool

	-- Boolean operation.
	elseif !!(CONST_SET{"and","or"})[binOp] then
		local bothAreBool = true
		local typeInfo    = state.builtinTypeInfos.bool

		if typeInfoL.tag ~= !(TYPE_BOOL) then
			!ASSERT `not inAssignment`
			bothAreBool = false
			wrapInImplicitCast(state, exprL, typeInfo, true)
		end
		if typeInfoR.tag ~= !(TYPE_BOOL) then
			bothAreBool = false
			wrapInImplicitCast(state, exprR, typeInfo, true)
		end

		if not bothAreBool then  return nil  end
		return typeInfo

	-- String concatenation.
	elseif binOp == ".." then
		if typeInfoL.tag ~= !(TYPE_STRING) then
			typeError(state, exprL, "String concatenation expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoL))
		elseif typeInfoR.tag ~= !(TYPE_STRING) then
			typeError(state, exprR, "String concatenation expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoR))
		end
		return state.builtinTypeInfos.string

	else
		errorUnhandledNodeType(state, exprForError)
	end
end

!NODE_INFERRER `function nodeInferrers.AstBinary(state, binary)`
	local typeInfoL = binary.left.inferredType
	local typeInfoR = binary.right.inferredType

	if not typeInfoL then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.left`)
	end
	if not typeInfoR then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.right`)
	end

	typeInfoL = adjustTypeToOne(state, binary.left,  typeInfoL, true)
	typeInfoR = adjustTypeToOne(state, binary.right, typeInfoR, true)

	local typeInfo = checkBinaryOperation(state, binary, binary.left,binary.left,binary.right, binary.operation, typeInfoL,typeInfoR, false)
	if not typeInfo then  return  end

	binary.inferredType = typeInfo

	moveToNextRelevantPipe(state, binary)
	simplifyExpressionIfConstant(state, binary)
!NODE_INFERRER_END `end`

function _G.getConstantNameOrTriggerError(state, node)
	if not (node.nodeType == !(AST_LITERAL) and node.literalType == !(LITERAL_STRING)) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(node), "Expected a name constant as the member.")
	end

	local literal = node
	local name    = literal.value

	if not name:find"^[%a_\128-\255][%w_\128-\255]*$" then
		typeError(state, literal, "Bad format or invalid characters in name '%s'.", name)
	end

	return name
end

-- memberName, memberValueType, constDecl = validateStructKey( state, dependent, keyExpr, structInfo, isLvalue )
-- Returns nil on failure and the dependent is now waiting.
function _G.validateStructKey(state, dependent, keyExpr, structInfo, isLvalue)
	local keyExprType = keyExpr.inferredType
	local memberName  = ""
	local memberValueType, constDecl

	if keyExprType.tag == !(TYPE_STRING) and keyExpr.nodeType == !(AST_LITERAL) then
		local memberLiteral = keyExpr
		memberName          = memberLiteral.value

		local decl = findMemberDeclaration(state, structInfo.astNode, memberName)

		if decl then
			if isLvalue and isDeclarationConstant(decl) then
				typeError2(state,
					memberLiteral, F("Cannot assign value to constant struct member %s.%s.", getFriendlyTypeInfoName(structInfo), memberName),
					decl,          F("...here is the declaration.")
				)
			end

			memberValueType = decl.inferredType
			if not memberValueType then
				!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_INFERRED, `decl`, nil, `nil`)
			end

			if isDeclarationConstant(decl) then  constDecl = decl  end

			return memberName, memberValueType, constDecl
		end
	end

	!local STRUCT_ERROR_NO_SUCH_MEMBER = `
	typeError2(state,
		keyExpr,            F("%s has no member '%s'.", getFriendlyTypeInfoName(structInfo), memberName),
		structInfo.astNode, F("...here is the accessed struct.")
	)
	`

	if structInfo.kind == !(STRUCT_KIND_TABLE) then
		if not structInfo.hasMembers then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_TYPE_MEMBERS_READY, `structInfo`, nil, `nil`)
		elseif not isTypeCompatibleWith(state, keyExprType, structInfo.keyType, !(STRICT_TYPE_MATCH_NO), keyExpr) then
			if memberName ~= "" then
				!!(STRUCT_ERROR_NO_SUCH_MEMBER)
			else
				typeError(state, keyExpr, "Expected struct member name or %s. (Got %s)", getFriendlyTypeInfoName(structInfo.keyType), getFriendlyTypeInfoName(keyExprType))
			end
		end
		memberName      = "" -- We know it's not a member at this point.
		memberValueType = structInfo.valueType

	elseif structInfo.kind == !(STRUCT_KIND_ARRAY) then
		if keyExprType.tag ~= !(TYPE_INT) then
			typeError(state, keyExpr, "Expected struct member name or array index. (Got %s)", getFriendlyTypeInfoName(keyExprType))
		end
		memberName      = "" -- We know it's not a member at this point.
		memberValueType = structInfo.valueType

	elseif memberName ~= "" then
		if not structInfo.hasMembers then
			-- This dependency should get fulfilled when hasMembers is set if
			-- there's no appropriate declaration, so we can handle the
			-- situation of table-like structs with string keys (or show a
			-- better error message than when pipes get stuck).
			!DEPEND_AND_RETURN(`dependent`, DEPEND_MEMBER_DECLARATION, `memberName`, `structInfo.astNode`, `nil`)
		end
		!!(STRUCT_ERROR_NO_SUCH_MEMBER)

	elseif not structInfo.hasMembers then
		!DEPEND_AND_RETURN(`dependent`, DEPEND_TYPE_MEMBERS_READY, `structInfo`, nil, `nil`) -- Make sure structInfo.kind is fully known.

	else
		!ASSERT("structInfo.kind == "..STRUCT_KIND_NORMAL)

		if keyExprType.tag ~= !(TYPE_STRING) then
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(keyExpr),
				"Member names for struct instances must be strings. (This is %s)",
				getFriendlyTypeInfoName(keyExprType)
			)
		elseif keyExpr.nodeType ~= !(AST_LITERAL) then
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(keyExpr),
				"Member names for struct instances must be constant expressions. (Type is string)"
			)
		else
			!!(STRUCT_ERROR_NO_SUCH_MEMBER)
		end
	end

	return memberName, memberValueType, constDecl
end

local function checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode(state, topNodeToCheck, staticObjectNode)
	local function checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode_onVisit(node)
		if
			node.nodeType == !(AST_ACCESS)
			or (
				node.nodeType == !(AST_IDENTIFIER)
				and node.parent.nodeType == !(AST_ACCESS)
				and node == node.parent.object
			)
			or (
				node.nodeType == !(AST_LITERAL)
				and node.parent.nodeType == !(AST_ACCESS)
				and node == node.parent.member
			)
		then
			-- void

		else
			typeError2(state,
				staticObjectNode, F("Trying to access a static object using code that looks like it's supposed to do something at runtime. Ambiguous intension."),
				node,             F("...this looks like a runtime expression.")
			)
		end
	end
	astVisitAllNodes(topNodeToCheck, checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode_onVisit)
end

!NODE_INFERRER `function nodeInferrers.AstAccess(state, access)`
	local typeObject = access.object.inferredType
	local typeMember = access.member.inferredType

	if not typeObject then
		!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `access.object`)
	end
	if not typeMember then
		!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `access.member`)
	end

	if typeObject.tag == !(TYPE_LIST) then
		typeObject = adjustTypeToOne(state, access.object, typeObject, true)
	end
	typeMember = adjustTypeToOne(state, access.member, typeMember, true)

	local isDirectObject  = access.object.inferredType == typeObject
	local isDirectMember  = access.member.inferredType == typeMember

	local isLvalue        = access.parent.nodeType == !(AST_ASSIGNMENT) and access.queued.container == access.parent.targets
	local typeRepresented = getTypeRepresentedByExpression(access.object)

	if typeObject.tag == !(TYPE_TABLE) then
		if typeMember.tag == !(TYPE_NONE) then
			typeError(state, access.member, "Table keys cannot be nil.")

		elseif typeMember.tag == !(TYPE_COMPOUND) and indexOf(typeMember, state.builtinTypeInfos.none) then
			typeError(state, access.member, "Table keys cannot be nil. (Type is %s)", getFriendlyTypeInfoName(typeMember))

		--[[ This warning message may be too noisy in some programs.
		elseif typeMember.tag == !(TYPE_ANY) then
			-- @Incomplete: Add a setting to suppress warnings.
			state.warnings = state.warnings + 1
			typeMessage(
				io.stderr, state, astGetExpressionVisuallyFurthestToTheLeft(access.member),
				"Warning", "Table key is 'any' and thus possibly nil."
			)
		--]]
		end

		access.inferredType = state.builtinTypeInfos.any
		moveToNextRelevantPipe(state, access)

	elseif typeObject.tag == !(TYPE_ARRAY) then
		local arraySig = typeObject

		if typeMember.tag == !(TYPE_INT) then
			-- @Incomplete: Check for isLvalue and constantness.

			if access.member.nodeType == !(AST_LITERAL) and access.member.value < 1 then
				local indexLiteral = access.member
				typeError(state, indexLiteral, "Array index is %d.", indexLiteral.value)
			end

			access.inferredType = arraySig.itemType

			if not (isExpressionConstant(state, access.object, false) and isExpressionConstant(state, access.member, false)) then
				moveToNextRelevantPipe(state, access)
				return
			end

			-- Check that the item in the constant array exists.
			local indexLiteral = access.member
			assert(indexLiteral.nodeType == !(AST_LITERAL))
			local i = indexLiteral.value

			local tableNode = followIdentifiersToConstantValue(state, access.object)
			assert(tableNode.nodeType == !(AST_TABLE))

			local itemExpr = nil

			for _, tableField in ipairs(tableNode.fields) do
				assert(tableField.key.nodeType == !(AST_LITERAL))
				if tableField.key.value == i then
					itemExpr = tableField.value
				end
			end

			if not itemExpr then
				typeError(state, indexLiteral, "No item at index %d in constant array. (Length is %d)", i, #tableNode.fields)
			end

			moveToNextRelevantPipe(state, access)

		-- elseif not isLvalue and typeMember.tag == !(TYPE_STRING) then
		-- 	local abstractMemberLiteral = access.member
		-- 	local abstractMemberName    = getConstantNameOrTriggerError(state, abstractMemberLiteral)
		-- 	if abstractMemberName == ? then ... end

		else
			typeError(state, access.member, "Expected an array index of type int. (Got %s)", getFriendlyTypeInfoName(typeMember))
		end

	elseif typeObject.tag == !(TYPE_STRUCT) or (typeRepresented and typeRepresented.tag == !(TYPE_STRUCT)) then
		local structInfo                             = typeRepresented or typeObject
		local memberName, memberValueType, constDecl = validateStructKey(state, access, access.member, structInfo, isLvalue)

		if not memberName      then  return  end
		if not memberValueType then  errorInternal(state, access.member)  end

		if not constDecl then
			if typeRepresented then
				-- We don't allow StructType.dynamicMember except in certain contexts.
				-- @Incomplete: Make it possible to get default values, though!
				local foundNode = astFindParent(access, !!(CONST_SET{
					AST_TYPE_OF, AST_TYPE_INFO, AST_LOCATION,
					unpack(scopeNodeTypes)
				}))

				if not !!(CONST_SET{ AST_TYPE_OF, AST_TYPE_INFO, AST_LOCATION, })[foundNode.nodeType] then
					typeError(state, access.member, "Dynamic member '%s' is not accessible in static context.", memberName)
				end
			end

			access.inferredType = memberValueType
			moveToNextRelevantPipe(state, access)

			-- @Hack for accessing !location() members statically. @Speed
			-- @Incomplete: We need this for type_info() as well!
			-- Note: Values here must be the same as the location's constant!
			if access.member.nodeType == !(AST_LITERAL) and isExpressionConstant(state, access.object, false) then
				local locTypeDecl = findInferredPreloadDeclaration(state, l, "SourceCodeLocation", !(TYPE_STRUCT), false) -- @Speed: Cache!

				if locTypeDecl and typeObject == locTypeDecl.valueTypeInfo then
					local loc            = followIdentifiersToConstantValue(state, access.object)
					local literal        = astNewNode(AstLiteral, access, access.parent)
					literal.inferredType = memberValueType

					if access.member.value == "filePath" then
						literal.literalType  = !(LITERAL_STRING)
						literal.value        = loc.target.source.path

					elseif access.member.value == "lineNumber" then
						literal.literalType  = !(LITERAL_INTEGER)
						literal.value        = loc.target.line

					elseif access.member.value == "position" then
						literal.literalType  = !(LITERAL_INTEGER)
						literal.value        = loc.target.position

					else
						errorInternal(state, access.member, "Unhandled member '%s' for !location().", access.member.value)
					end

					replaceQueuedNodeAndUnqueueOldTree(state, access, literal)
					moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
				end
			end

			return
		end

		if not (
			isExpressionConstant(state, access.object, false)
			or (access.parent.nodeType == !(AST_CALL) and access.parent.isMethod) -- It's ok to do e.g. getObject().staticMethod!()
		) then
			checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode(state, access.object, access.member)
		end

		local valueExpr = followIdentifiersToConstantValue(state, constDecl.value)
		local nodeType  = valueExpr.nodeType
		local replacement

		if memberValueType.tag == !(TYPE_ENUM) then -- For enum values we check the type, but for all other nodes we check the nodeType. Is this exception fine? @Robustness
			replacement = astCopyIdentifier(constDecl.name, access.member, nil, !(IDENT_KIND_LOOSE))

		elseif !!(CONST_SET{ AST_LITERAL, AST_FOREIGN })[nodeType] then
			replacement = astCopy(valueExpr, access.member)

		elseif nodeType == !(AST_TYPE) then
			replacement = astCopy(valueExpr, access.member)
			addUnqueuedChildrenToQueueRecursively(state, replacement, !(PIPE_DONE))

		elseif nodeType == !(AST_IDENTIFIER) and valueExpr.inferredType.tag == !(TYPE_ENUM) then
			replacement = astCopy(valueExpr, access.member)

		elseif !!(CONST_SET{ AST_ENUM, AST_STRUCT })[nodeType] then
			replacement = createTypeNodeFromInfo(state, valueExpr.representedType, access.member, access.parent) -- Parent is temp and will change in a moment.

		elseif nodeType == !(AST_LAMBDA) then
			if access.parent.nodeType == !(AST_CALL) and access == access.parent.callee and access.parent.isMethod then
				--
				-- Change obj.staticMethod!(...) into staticMethod(obj, ...)
				--
				-- AstCall (method)
				--   CALLEE AstAccess
				--     AstIdentifier (object)
				--     AstLiteral (string)
				--   ARG1...
				--
				-- AstCall (normal)
				--   CALLEE AstIdentifier (static function)
				--   ARG1 AstIdentifier (object)
				--   ARG2...
				--
				local call = access.parent

				-- Move object from access to call arguments.
				local obj = access.object
				table.insert(call.arguments, 1, obj)
				obj.parent = call

				-- Update all argument queueds.
				for i, argExpr in ipairs(call.arguments) do
					argExpr.queued.container = call.arguments
					argExpr.queued.key       = i
				end

				-- Update callee using access. (Note: access==callee)
				local ident = newIdentifier(call, access.member, !(IDENT_KIND_LOOSE), constDecl.name.name, constDecl, constDecl.inferredType)
				replaceQueuedNode(state, access, ident)
				moveToNextRelevantPipe(state, ident)

				-- Update call.
				call.isMethod = false

				-- Unqueue now unused nodes.
				unqueue(access.member)

				return
			end

			replacement = newIdentifier(access.parent, access.member, !(IDENT_KIND_LOOSE), constDecl.name.name, constDecl, constDecl.inferredType)

		else
			!ifDEBUG `where(state, access)`
			errorUnhandledNodeType(state, valueExpr)
		end

		assert(replacement) -- Constants must be simplified!

		replaceQueuedNodeAndUnqueueOldTree(state, access, replacement)
		moveToNextRelevantPipe(state, replacement, !(PIPE_INFER))

	elseif typeObject.tag == !(TYPE_ENUM) or (typeRepresented and typeRepresented.tag == !(TYPE_ENUM)) then
		local memberLiteral = access.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)

		local enumInfo      = typeRepresented or typeObject
		local decl          = findMemberDeclaration(state, enumInfo.astNode, memberName)

		if not decl then
			typeError(state, memberLiteral, "'%s' is not a member of %s.", memberName, getFriendlyTypeInfoName(enumInfo))
		elseif isLvalue then
			typeError(state, memberLiteral, "Cannot assign values to enum members. (Enum is %s)", getFriendlyTypeInfoName(enumInfo))
		end

		!ASSERT `isDeclarationConstant(decl)`

		local ident = astCopyIdentifier(decl.name, access, access.parent, !(IDENT_KIND_LOOSE))
		replaceQueuedNodeAndUnqueueOldTree(state, access, ident)

		-- Stay in the current pipe so we get simplified. (Needed? Or maybe we can @Speed things up here?)
		inferNode(state, ident)

	elseif typeObject.tag == !(TYPE_NAMESPACE) then
		assert(isDirectObject)

		local memberLiteral = access.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)

		local namespaceInfo = typeObject
		if not (namespaceInfo.scope.nodeType == !(AST_NAMESPACE) or namespaceInfo.scope.nodeType == !(AST_FILE_SCOPE)) then
			errorInternal(state, namespaceInfo.scope)
		end

		local decl = findPublicDeclarationInScope(state, namespaceInfo.scope, memberName)

		if not decl then
			!DEPEND_AND_RETURN(`access`, DEPEND_DECLARATION, `memberName`, `namespaceInfo.scope`)
		elseif not decl.inferredType then
			!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `decl`)
		end

		local ident = astCopyIdentifier(decl.name, access, access.parent, !(IDENT_KIND_LOOSE))
		replaceQueuedNodeAndUnqueueOldTree(state, access, ident)

		-- Stay in the current pipe so we get simplified. (Needed? Or maybe we can @Speed things up here?)
		inferNode(state, ident)

	elseif typeObject.tag == !(TYPE_STRING) then
		local strExpr   = access.object
		local indexExpr = access.member

		if typeMember.tag ~= !(TYPE_INT) then
			typeError(state, indexExpr, "Expected a string byte position of type int. (Got %s)", getFriendlyTypeInfoName(typeMember))
		elseif indexExpr.nodeType == !(AST_LITERAL) and indexExpr.value <= 0 then
			typeError(state, indexExpr, "String byte position is not positive. (It is %d)", indexExpr.value)
		end

		access.inferredType = typeMember

		if not (isExpressionConstant(state, strExpr, false) and isExpressionConstant(state, indexExpr, false)) then
			moveToNextRelevantPipe(state, access)
			return
		end

		assert(strExpr.nodeType   == !(AST_LITERAL))
		assert(indexExpr.nodeType == !(AST_LITERAL))

		local s = strExpr.value
		local i = indexExpr.value

		if i > #s then
			typeError(state, indexExpr, "String byte position is greater than the length of the string. (Index is %d, length is %d)", i, #s)
		end

		local literal = newLiteral(access.parent, access, !(LITERAL_INTEGER), s:byte(i), typeMember)
		replaceQueuedNodeAndUnqueueOldTree(state, access, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	elseif typeObject.tag == !(TYPE_VARARG) then
		local indexExpr = access.member

		if typeMember.tag ~= !(TYPE_INT) then
			typeError(state, indexExpr, "Expected an index of type int. (Got %s)", getFriendlyTypeInfoName(typeMember))
		elseif indexExpr.nodeType == !(AST_LITERAL) and indexExpr.value <= 0 then
			typeError(state, indexExpr, "Index is not positive. (It is %d)", indexExpr.value)
		end

		local varargSig     = typeObject
		access.inferredType = varargSig.itemType -- Treat varargs like arrays (i.e. we don't use adjustTypeToOne() when accessing them).
		moveToNextRelevantPipe(state, access)

	else
		typeError(state, access, "Values of type '%s' do not have members.", getFriendlyTypeInfoName(typeObject))
	end
!NODE_INFERRER_END `end`

local function validateIndiciesInArrayLikeConstructor(state, tableNode, itemType)
	for _, tableField in ipairs(tableNode.fields) do
		local indexExpr = tableField.key

		if indexExpr.inferredType.tag == !(TYPE_INT) and indexExpr.nodeType ~= !(AST_LITERAL) then
			-- @Incomplete: Allow indices to be variable? :VariableArrayIndices
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(indexExpr),
				"Array indices must be constant in constructors."
			)
		end
	end

	local trailingExpr = tableNode.trailingExpression
	if trailingExpr then
		adjustTypeToOne(state, trailingExpr, trailingExpr.inferredType) -- Ensure this is not a call that returns nothing.
	end

	-- Validate indices and sequence.
	local indexLiterals       = {}
	local highestLiteralIndex = 0

	for _, tableField in ipairs(tableNode.fields) do
		local literal = tableField.key

		if literal.inferredType.tag == !(TYPE_INT) then
			local arrayIndex = literal.value

			if indexLiterals[arrayIndex] then
				typeError2(state,
					literal,                   F("Duplicate array index %d.", arrayIndex),
					indexLiterals[arrayIndex], F("...first occurance is here.")
				)
			elseif arrayIndex <= 0 then
				typeError(state, literal, "Array index is not positive. (It is %d)", arrayIndex)
			end

			indexLiterals[arrayIndex] = literal
			highestLiteralIndex       = math.max(highestLiteralIndex, arrayIndex)
		end
	end

	if trailingExpr and highestLiteralIndex > tableNode.highestGeneratedIndex then
		-- We get here if explicit indices are combined with a trailing expression.
		for i = tableNode.highestGeneratedIndex+1, highestLiteralIndex do
			local overlap = indexLiterals[i]
			if overlap then
				typeError2(state,
					trailingExpr, F("Potentially overlapping value(s) at or after array index %d because of this expression.", tableNode.highestGeneratedIndex+1),
					overlap,      F("...first overlap would be here.")
				)
			end
		end
		errorInternal() -- highestLiteralIndex would be incorrect if we're here.
	end

	for arrayIndex = 1, highestLiteralIndex do
		if not indexLiterals[arrayIndex] then
			typeError(state, tableNode, "Array is not a sequence. Missing item at index %d.", arrayIndex)
		end
	end

	-- Validate trailing expression.
	if not trailingExpr then
		-- void

	elseif trailingExpr.nodeType == !(AST_VARARG) then
		if not isTypeCompatibleWith(state, trailingExpr.inferredType.itemType, itemType, !(STRICT_TYPE_MATCH_NO), trailingExpr) then
			typeError(
				state, trailingExpr,
				"Array item type mismatch for vararg. (Wanted %s, got %s)",
				getFriendlyTypeInfoName(itemType),
				getFriendlyTypeInfoName(trailingExpr.inferredType.itemType)
			)
		end

	elseif trailingExpr.nodeType == !(AST_CALL) then
		local call        = trailingExpr
		local argTypesOut = call.callee.inferredType.argumentTypesOut

		for i, argTypeInfo in ipairs(argTypesOut) do
			argTypeInfo = adjustTypeToOne(state, call, argTypeInfo)

			if not isTypeCompatibleWith(state, argTypeInfo, itemType, !(STRICT_TYPE_MATCH_NO), trailingExpr) then
				typeError(
					state, call,
					"Array item type mismatch for return value #%d from call. (Wanted %s, got %s)",
					i,
					getFriendlyTypeInfoName(itemType),
					getFriendlyTypeInfoName(argTypeInfo)
				)
			end
		end

	else
		errorUnhandledNodeType(state, trailingExpr)
	end
end

local function inferTableArray(state, tableNode, arraySig)
	for _, tableField in ipairs(tableNode.fields) do
		local indexExpr = tableField.key

		if not indexExpr.inferredType then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `indexExpr`)
		elseif indexExpr.inferredType.tag ~= !(TYPE_INT) then
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(indexExpr),
				"Array indices must be integers. (This is %s)",
				getFriendlyTypeInfoName(indexExpr.inferredType)
			)
		end

		local itemExpr     = tableField.value
		local itemTypeInfo = itemExpr.inferredType

		if itemTypeInfo then
			if not isTypeCompatibleWith(state, adjustTypeToOne(state, itemExpr, itemTypeInfo, true), arraySig.itemType, !(STRICT_TYPE_MATCH_NO), itemExpr) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
					"Array item type mismatch. (Wanted %s, got %s)",
					getFriendlyTypeInfoName(arraySig.itemType),
					getFriendlyTypeInfoName(adjustTypeToOne(state, itemExpr, itemTypeInfo, true))
				)
			end
		elseif itemExpr.nodeType == !(AST_TABLE) then
			if isTypeTableLike(arraySig.itemType) then
				-- void  (Wait with validation.)
			else
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
					"Expected array item to be %s.",
					getFriendlyTypeInfoName(arraySig.itemType)
				)
			end
		else
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `itemExpr`)
		end
	end

	validateIndiciesInArrayLikeConstructor(state, tableNode, arraySig.itemType)

	-- tableNode.inferredType = arraySig -- Moved to earlier in nodeInferrers.AstTable().
end

local function inferTableStruct(state, tableNode, structInfo)
	if structInfo.astNode.isForeign then
		!TRACE()
		printerr()
		nodeMessage(io.stderr, state, tableNode, "Error", "Typer", "Cannot instantiate foreign struct '%s'.", getFriendlyTypeInfoName(structInfo))
		-- if structInfo.astNode.foreignThroughNode then
		-- 	nodeMessage(io.stderr, state, structInfo.astNode.foreignThroughNode, "Info", "Typer", "...the struct got its foreign state through this.")
		-- end
		exitFailure()
	end

	for _, tableField in ipairs(tableNode.fields) do
		local fieldKey     = tableField.key
		local fieldKeyType = fieldKey.inferredType

		if not fieldKeyType then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `fieldKey`)
		end

		local memberName, memberValueType = validateStructKey(state, tableNode, fieldKey, structInfo, true)
		if not memberName      then  return  end
		if not memberValueType then  errorInternal(state, fieldKey)  end

		!local TARGET_NAME   = `memberName ~= "" and F("value for struct field '%s'", memberName) or "value"`
		local fieldValue     = tableField.value
		local fieldValueType = fieldValue.inferredType

		if fieldValueType then
			if not isTypeCompatibleWith(state, adjustTypeToOne(state, fieldValue, fieldValueType, true), memberValueType, !(STRICT_TYPE_MATCH_NO), fieldValue) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(fieldValue),
					"Type mismatch for %s. (Wanted %s, got %s)",
					!!(TARGET_NAME),
					getFriendlyTypeInfoName(memberValueType),
					getFriendlyTypeInfoName(fieldValueType)
				)
			end
		elseif fieldValue.nodeType == !(AST_TABLE) then
			if isTypeTableLike(memberValueType) then
				-- void  (Wait with validation.)
			else
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(fieldValue),
					"Expected %s to be %s.",
					!!(TARGET_NAME),
					getFriendlyTypeInfoName(memberValueType)
				)
			end
		else
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `fieldValue`)
		end
	end

	if structInfo.kind == !(STRUCT_KIND_ARRAY) then
		validateIndiciesInArrayLikeConstructor(state, tableNode, structInfo.valueType)
	end

	-- Check trailing expression.
	if not tableNode.trailingExpression or structInfo.kind == !(STRUCT_KIND_ARRAY) then
		-- void
	elseif structInfo.kind == !(STRUCT_KIND_TABLE) then
		errorInternal(state,
			astGetExpressionVisuallyFurthestToTheLeft(tableNode.trailingExpression),
			"@Incomplete: Handle trailing expressions for table-like structs."
		)
	else
		typeError(state,
			astGetExpressionVisuallyFurthestToTheLeft(tableNode.trailingExpression),
			"Trailing expressions are only allowed for array-like structs. (The struct is '%s')",
			getFriendlyTypeInfoName(structInfo)
		)
	end

	-- Check for duplicate keys.
	-- @Incomplete: Check non-string keys (except integer keys if we're array-like).
	local keyLiterals = {}

	for _, tableField in ipairs(tableNode.fields) do
		if tableField.key.nodeType == !(AST_LITERAL) and tableField.key.literalType == !(LITERAL_STRING) then
			local memberLiteral = tableField.key
			local memberName    = memberLiteral.value

			if keyLiterals[memberName] then
				typeError2(state,
					memberLiteral,           F("Duplicate field '%s'.", memberName),
					keyLiterals[memberName], F("...first occurance is here.")
				)
			end

			keyLiterals[memberName] = memberLiteral
		end
	end

	-- tableNode.inferredType = structInfo -- Moved to earlier in nodeInferrers.AstTable().
end

!NODE_INFERRER `function nodeInferrers.AstTable(state, tableNode)`
	-- Note: tableNode.inferredType may get set before all child nodes are inferred.
	local typeExpected = tableNode.inferredType or getExpectedTypeInfo(state, tableNode, false, "constructor", tableNode)
	if not typeExpected then  return  end

	if typeExpected.tag == !(TYPE_ANY) and tableNode.parent.nodeType == !(AST_TABLE) then
		typeExpected = state.builtinTypeInfos.table
	end

	tableNode.inferredType = typeExpected

	local trailingExpr   = tableNode.trailingExpression
	local lastTableField = not trailingExpr and getLast(tableNode.fields) or nil

	if lastTableField and lastTableField.keyIsGenerated then
		local valueExpr = lastTableField.value

		-- Note: We don't need to check for vararg as the parser should have
		-- handled that (by setting trailingExpression right away).
		if valueExpr.nodeType == !(AST_CALL) and not valueExpr.surroundedByParentheses then
			if not valueExpr.inferredType then
				!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `valueExpr`)
			end

			trailingExpr                        = valueExpr

			valueExpr.parent                    = tableNode
			valueExpr.queued.container          = tableNode
			valueExpr.queued.key                = "trailingExpression"

			tableNode.trailingExpression        = valueExpr
			tableNode.fields[#tableNode.fields] = nil
			tableNode.highestGeneratedIndex     = tableNode.highestGeneratedIndex-1

			unqueue(lastTableField.key) -- Note: The key should be an int literal as it's generated.
		end
	end

	if trailingExpr and not trailingExpr.inferredType then
		!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `trailingExpr`)
	end

	if typeExpected.tag == !(TYPE_TABLE) then
		-- @Incomplete: Check for duplicate fields (among constant keys).
		-- @Incomplete: Check for nil keys.

		-- tableNode.inferredType = typeExpected -- Moved to earlier in nodeInferrers.AstTable().

		-- Note: We don't need to validate any types or anything (including tableNode.trailingExpression) as generic tables accept anything.

	elseif typeExpected.tag == !(TYPE_ARRAY) then
		inferTableArray(state, tableNode, typeExpected)
		if tableNode.queued.waitingOn then  return  end

	elseif typeExpected.tag == !(TYPE_STRUCT) then
		inferTableStruct(state, tableNode, typeExpected)
		if tableNode.queued.waitingOn then  return  end

	else
		typeError(
			state, tableNode,
			"This constructor is trying to get inferred as %s (type group '%s') which is illegal. (The inferred type must be array, struct or table.)",
			getFriendlyTypeInfoName(typeExpected),
			TYPE_NAMES[typeExpected.tag]
		)
	end

	-- !ASSERT `tableNode.inferredType`

	-- Make sure all children (including table-likes) are fully(!) inferred before we advance to the next pipe.
	for _, tableField in ipairs(tableNode.fields) do
		if tableField.value.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_PASSED_INFER, `tableField.value`)
		end
		if tableField.key.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_PASSED_INFER, `tableField.key`)
		end
	end
	if trailingExpr and trailingExpr.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_PASSED_INFER, `trailingExpr`)
	end

	moveToNextRelevantPipe(state, tableNode)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstArgument(state, arg)`
	if not arg.declaration.inferredType then
		!DEPEND_AND_RETURN(`arg`, DEPEND_NODE_INFERRED, `arg.declaration`)
	end
	moveToNextRelevantPipe(state, arg)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstArguments(state, args)`
	for _, arg in ipairs(args.arguments) do
		if arg.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`args`, DEPEND_NODE_INFERRED, `arg`)
		end
	end
	moveToNextRelevantPipe(state, args)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstLambda(state, lambda)`
	if lambda.polymorphs then
		lambda.inferredType = getTypeInfoForLambda(state, lambda) or errorInternal(state, lambda)
		moveToNextRelevantPipe(state, lambda)
		return
	end

	local argsIn  = lambda.argumentsIn
	local argsOut = lambda.argumentsOut

	if argsIn and argsIn.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `argsIn`)
	end
	if argsOut and argsOut.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `argsOut`)
	end
	if lambda.bodyTextLambda and lambda.bodyTextLambda.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.bodyTextLambda`)
	end

	if lambda.bodyIsForeign and lambda.foreignSource == "method" then
		-- Validate method.
		local argIn1   = argsIn and argsIn.arguments[1]
		local argType1 = argIn1 and argIn1.declaration.inferredType

		if not argIn1 then
			typeError(state, lambda, "Expected a struct as first argument for foreign method.")

		elseif argType1.tag ~= !(TYPE_STRUCT) then
			typeError(
				state, argIn1,
				"Expected the first arguments to be a struct. Foreign methods are only supported on structs. (Type is %s)",
				getFriendlyTypeInfoName(argType1)
			)

		elseif not argType1.astNode.isForeign and not argType1.hasMembers then
			!DEPEND_AND_RETURN(`lambda`, DEPEND_TYPE_MEMBERS_READY, `argType1`) -- We need this for isForeign to be valid.

		elseif not argType1.astNode.isForeign then
			typeError2(state,
				argIn1.declaration.type, F("%s is not a foreign struct. Foreign methods only work on foreign structs.", getFriendlyTypeInfoName(argType1)),
				argType1.astNode,        F("...here is the struct")
			)

		elseif not argIn1.isRequired then
			typeError(state, argIn1, "The first argument must not be optional for foreign methods.")
		end
	end

	-- Note: We don't require the body to inferred - just the "header".

	local bodyTextFunc = nil

	if lambda.bodyTextLambda then
		bodyTextFunc = prepareToRun(state, lambda, lambda.bodyTextLambda)
		if not bodyTextFunc then  return  end
	end

	--
	-- No more dependencies for this lambda after this point!
	--

	if bodyTextFunc then
		local bodyText
		do
			local body_text = bodyTextFunc -- For better error messages.
			bodyText        = body_text()
		end

		if type(bodyText) ~= "string" then
			typeError(state, lambda.bodyTextLambda, "Function did not return a string. (It returned %s)", type(bodyText))
		end

		local fileScope = astFindParent1(lambda, !(AST_FILE_SCOPE))

		-- @UX: Output all bodyTexts into a file that's easier to debug.
		local pathDummy
		if lambda.bodyTextLambda.source.path == fileScope.path then
			pathDummy = F("<body_text @ %s:%d>", fileScope.path, lambda.bodyTextLambda.line)
		else
			pathDummy = F("<body_text @ %s>", fileScope.path) -- @UX: Get the line number from the closest parent lambda with the same path as fileScope.
		end

		local tokens     = state.tokens
		local sourceInfo = {path=pathDummy, string=bodyText}

		insertNewToken(tokens, !(TOKEN_DUMMY), nil, sourceInfo, false)

		local locCountStartToken = tokens.n + 1

		-- @Incomplete: Include these times in the compilation stats.
		local timeLexingStart, timeLexingEnd = tokenizeString(state, sourceInfo, 1, true)

		countLinesOfCode(state, locCountStartToken, tokens.n)
		insertNewToken(tokens, !(TOKEN_PUNCTUATION), "}", sourceInfo, true) -- So we can parse the block.
		-- insertNewToken(tokens, !(TOKEN_DUMMY), nil, sourceInfo, true) -- Not needed.

		tokens[tokens.n].position1 = #bodyText
		tokens[tokens.n].position2 = #bodyText

		parseBlockStatements(state, lambda.body) -- May trigger a parsing error.

		if peekNextTok(state, 1) then
			errorParsingLast(state, "Expected the end of the body text.") -- This is pointing at an unbalanced '}'.
		end

		markTokensAsUnused(state)

		--
		-- WARNING: The body will be able to see everything a normal body would even though
		-- it was generated from a string which could have come from literally anywhere!
		--

		addUnqueuedChildrenToQueueRecursively(state, lambda.body)
		queueForReinfer(state, lambda.body) -- This was empty and probably got inferred right away.
	end

	if argsIn and not lambda.bodyIsForeign then
		for _, arg in ipairs(argsIn.arguments) do
			if arg.declaration.value and not isExpressionConstant(state, arg.declaration.value, true) then
				typeError(state,
					astGetExpressionVisuallyFurthestToTheLeft(arg.declaration.value),
					"Non-constant default values for arguments are not supported yet."
				)
			end
		end
	end

	local funcSig       = getTypeInfoForLambda(state, lambda) or errorInternal(state, lambda)
	lambda.inferredType = funcSig

	if lambda.bodyIsForeign then
		if not lambda.foreignSourceName then
			errorInternal(state, lambda, "@Incomplete: Infer lambda.foreignSourceName")
		end

		validateForeignSource(state, lambda.foreignSource, lambda.foreignSourceName.value, lambda.foreignSourceName)
		lambda.foreignSourceId = lambda.foreignSource.." "..lambda.foreignSourceName.value
	end

	moveToNextRelevantPipe(state, lambda)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstTypeOf(state, typeOf)`
	-- @Robustness: Check that the expression doesn't have code that looks like it's going to be executed, because it's not!

	local exprTypeInfo = typeOf.expression.inferredType

	if not exprTypeInfo then
		!DEPEND_AND_RETURN(`typeOf`, DEPEND_NODE_INFERRED, `typeOf.expression`)
	elseif exprTypeInfo.tag == !(TYPE_NAMESPACE) then
		typeError(state, typeOf.expression, "Namespaces don't have a type.")
	end
	if typeOf.expression.nodeType == !(AST_CALL) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeOf.expression), "Cannot get the type of function calls.")
	end

	typeOf.inferredType    = state.builtinTypeInfos.Type
	typeOf.representedType = exprTypeInfo

	if typeOf.representedType.tag == !(TYPE_VARARG) then
		local varargSig        = typeOf.representedType
		typeOf.representedType = varargSig.itemType
	end

	moveToNextRelevantPipe(state, typeOf)
	simplifyTypeExpression(state, typeOf, typeOf.representedType)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstVariantOf(state, variant)`
	if not variant.call.inferredType then
		!DEPEND_AND_RETURN(`variant`, DEPEND_NODE_INFERRED, `variant.call`)
	end

	local call = variant.call
	if call.nodeType == !(AST_TYPE) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(call), "Expected a function call. (This is a type.)")
	elseif call.nodeType ~= !(AST_CALL) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(call), "Expected a function call.")
	end

	local ident = call.callee
	if ident.nodeType ~= !(AST_IDENTIFIER) then
		typeError(state, call, "Expected the reference to the called function to be a constant name.")
	end

	local decl = ident.declaration
	if not isDeclarationConstant(decl) then
		typeError2(state,
			ident, F("'%s' is not constant.", ident.name),
			decl,  F("...here is the declaration.")
		)
	end

	local lambda = decl.value or errorInternal(state, decl)
	lambda       = followIdentifiersToConstantValue(state, lambda)

	!ASSERT("lambda.nodeType == "..AST_LAMBDA)

	if not (
		decl.overloadOf
		or (
			lambda.parent.parent.nodeType == !(AST_LAMBDA)
			and lambda.parent.parent.polymorphs
			and indexOf(lambda.parent.parent.polymorphs, lambda.parent)
		)
	) then
		typeError2(state,
			ident, F("'%s' is neither overloaded nor a polymorphic function.", ident.name),
			decl,  F("...here is the declaration.")
		)
	end

	local identCopy       = astCopy(ident, variant, variant.parent)
	identCopy.fromVariant = true

	replaceQueuedNodeAndUnqueueOldTree(state, variant, identCopy)
	moveToNextRelevantPipe(state, identCopy)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstTypeInfo(state, typeInfoNode)`
	-- @Robustness: Check that the expression doesn't have code that looks like it's going to be executed, because it's not!

	if not typeInfoNode.expression.inferredType then
		!DEPEND_AND_RETURN(`typeInfoNode`, DEPEND_NODE_INFERRED, `typeInfoNode.expression`)
	end

	local typeRepresented = requireTypeRepresentedByExpression(state, typeInfoNode.expression)
	local tag             = typeRepresented.tag
	local typeInfoStructName

	if tag == !(TYPE_ARRAY) then
		typeInfoStructName = "TypeInfoArray"
	elseif tag == !(TYPE_COMPOUND) then
		typeInfoStructName = "TypeInfoCompound"
	elseif tag == !(TYPE_ENUM) then
		typeInfoStructName = "TypeInfoEnum"
	elseif tag == !(TYPE_FUNCTION) then
		typeInfoStructName = "TypeInfoFunction"
	elseif tag == !(TYPE_STRUCT) then
		typeInfoStructName = "TypeInfoStruct"
	elseif tag == !(TYPE_VARARG) then
		typeInfoStructName = "TypeInfoVararg"

	elseif !!(CONST_SET{ -- :SimplePublicTypeInfo
		TYPE_ANY,
		TYPE_BOOL,
		TYPE_FLOAT,
		TYPE_INT,
		TYPE_NONE,
		TYPE_PLACEHOLDER,
		TYPE_STRING,
		TYPE_TABLE,
		TYPE_TYPE,
		TYPE_VOID,
	})[tag] then
		typeInfoStructName = "TypeInfo"

	else
		errorUnhandledType(state, typeInfoNode, typeRepresented)
	end

	!ASSERT `typeInfoStructName`

	local decl = findInferredPreloadDeclaration(state, typeInfoNode, typeInfoStructName, !(TYPE_STRUCT), true) -- @Speed: Cache 'decl'.
	if not decl then  return  end

	typeInfoNode.valueTypeInfo = typeRepresented
	typeInfoNode.inferredType  = decl.valueTypeInfo
	moveToNextRelevantPipe(state, typeInfoNode)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstLocation(state, loc)`
	local target = loc.expression
	if target and not target.inferredType then
		!DEPEND_AND_RETURN(`loc`, DEPEND_NODE_INFERRED, `target`)
	end

	local decl = findInferredPreloadDeclaration(state, loc, "SourceCodeLocation", !(TYPE_STRUCT), true) -- @Speed: Cache 'decl'.
	if not decl then  return  end

	if not target then
		target = loc -- Note: If loc is !caller_location then this isn't the actual target.

	else
		local original = astGetOriginal(target)

		if original.nodeType == !(AST_IDENTIFIER) then
			target = original.declaration or errorInternal(state, original, "Missing declaration for identifier.")

		elseif original.nodeType == !(AST_ACCESS) then
			if target.nodeType == !(AST_IDENTIFIER) then
				target = target.declaration -- This is probably a variable or enum constant.
			else
				errorInternal(state, loc, "@Incomplete: Locations of certain kinds of lookup targets.")
			end

		else
			typeError(state, target, "Cannot get the location of this expression.")
		end
	end

	loc.inferredType = decl.valueTypeInfo
	loc.target       = target
	moveToNextRelevantPipe(state, loc)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstCast(state, cast)`
	-- Note: For convenience, cast.targetType may be nil here for generated casts. cast.inferredType must be set in those cases.

	local expr = cast.expression

	if cast.targetType and not cast.targetType.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.targetType`)
	end
	if not expr.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `expr`)
	end

	local castType    = cast.inferredType or requireTypeRepresentedByExpression(state, cast.targetType)
	local exprType    = adjustTypeToOne(state, expr, expr.inferredType, true)
	local castTypeTag = castType.tag
	local exprTypeTag = exprType.tag

	!local INVALID_CAST = `
		typeError(
			state, astGetExpressionVisuallyFurthestToTheLeft(expr),
			"Cannot cast from %s to %s.",
			getFriendlyTypeInfoName(exprType),
			getFriendlyTypeInfoName(castType)
		)
	`

	cast.inferredType = castType

	-- Useless cast.
	if castType == exprType then
		if cast.targetType and !!(CONST_SET{ AST_STRUCT, AST_ENUM })[cast.targetType.nodeType] then
			-- @Robustness: We cannot unqueue struct and enum nodes as that
			-- would mess up the types themselves! Can we maybe move these
			-- nodes somewhere safe?
			moveToNextRelevantPipe(state, cast)
		else
			-- @Cleanup: Maybe cutOutPartOfNodeTree()/replaceQueuedNode() should update the pipe (or maybe
			-- we just keep the wrong queued in cutOutPartOfNodeTree()). :PipeTransferWhenReplacing
			cast.queued.pipe = expr.queued.pipe
			cutOutPartOfNodeTree(state, cast, expr)
		end
		return

	elseif
		-- Compatible types.
		(exprTypeTag == !(TYPE_ANY) or isTypeCompatibleWith(state, exprType, castType, !(STRICT_TYPE_MATCH_NO), expr))
		-- float <-> int
		or (isTypeNumeric(castType) and isTypeNumeric(exprType))
		-- Struct to substruct.
		or (exprTypeTag == !(TYPE_STRUCT) and castTypeTag == !(TYPE_STRUCT) and doesStructInherit(castType, exprType))
		-- Values to bool.
		or (castTypeTag == !(TYPE_BOOL) and !!(CONST_SET{
			TYPE_INT,
			TYPE_FLOAT,
			TYPE_STRING,
			TYPE_ARRAY
		})[exprTypeTag])
		-- Array-like struct to bool (passes as an array).
		or (castTypeTag == !(TYPE_BOOL) and exprTypeTag == !(TYPE_STRUCT) and exprType.kind == !(STRUCT_KIND_ARRAY))
		-- Enum member to real member type.
		or (exprTypeTag == !(TYPE_ENUM) and castType == exprType.memberTypeInfo)
		-- Type to int.
		or (exprTypeTag == !(TYPE_TYPE) and castTypeTag == !(TYPE_INT))
	then
		-- void  Valid cast.

	-- Compound to single.
	elseif castTypeTag ~= !(TYPE_COMPOUND) and exprTypeTag == !(TYPE_COMPOUND) then
		-- We get here for situations like these: local xMaybe:int|nil = 0 ; local x = cast(int) xMaybe
		-- The user better know what they're doing!
		local compound = exprType
		if not indexOf(compound, castType) then
			!!(INVALID_CAST)
		end

	-- Enum to numeric (not real member type).
	elseif exprTypeTag == !(TYPE_ENUM) and isTypeNumeric(castType) and isTypeNumeric(exprType.memberTypeInfo) then
		-- We need two casts to happen in sequence here so we wrap the expression in another cast.
		wrapInImplicitCast(state, cast.expression, exprType.memberTypeInfo, false)
		simplifyExpressionIfConstant(state, cast.expression)

	-- Enum member type to enum.
	elseif castTypeTag == !(TYPE_ENUM) and exprType == castType.memberTypeInfo then
		if isExpressionConstant(state, expr, false) then
			assert(expr.nodeType == !(AST_LITERAL) or expr.nodeType == !(AST_TYPE))

			local enumInfo = castType
			local decl     = findDeclarationInEnumForValue(state, enumInfo.astNode, expr)

			if not decl then
				typeError2(state,
					expr,             F("Enum '%s' has no value '%s'.", getFriendlyTypeInfoName(enumInfo), valueToStringForMessage(expr.value)),
					enumInfo.astNode, F("...here is the enum.")
				)
			end
		end

	else
		!!(INVALID_CAST)
	end

	moveToNextRelevantPipe(state, cast)
	simplifyExpressionIfConstant(state, cast)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstAssignment(state, assignment)`
	for _, targetExpr in ipairs(assignment.targets) do
		if not targetExpr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `targetExpr`)
		end
	end
	for _, expr in ipairs(assignment.values) do
		if not expr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `expr`)
		end
	end

	-- Validate targets.
	for _, targetExpr in ipairs(assignment.targets) do
		if not !!(CONST_SET{ AST_IDENTIFIER, AST_ACCESS, AST_BLANK })[targetExpr.nodeType] then
			!ifDEBUG`astPrint(targetExpr)`
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(targetExpr), "Invalid assignment target. Expected a variable name or object field.")
		end
	end

	-- Validate values.
	-- Note: Enum member values are already validated by the enum itself.
	local declScope        = assignment.forDeclaration and astFindParentScope(assignment) or nil
	local isEnumMemberDecl = declScope ~= nil and declScope.nodeType == !(AST_ENUM)

	if not isEnumMemberDecl then
		for i, targetExpr in ipairs(assignment.targets) do
			getAssignmentValue(state, targetExpr, assignment.values, i, targetExpr.inferredType, assignment.binaryOperation, nil, false)
		end
	end

	-- @Incomplete: Check that !must args from functions have an assignment target.

	moveToNextRelevantPipe(state, assignment)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstBreak(state, breakNode)`
	moveToNextRelevantPipe(state, breakNode)
!NODE_INFERRER_END `end`
!NODE_INFERRER `function nodeInferrers.AstContinue(state, continue)`
	moveToNextRelevantPipe(state, continue)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstDefer(state, defer)`
	if defer.body.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`defer`, DEPEND_NODE_INFERRED, `defer.body`)
	end

	astVisitAllNodesInUnit(defer.body, false, function(node)
		if node.nodeType == !(AST_RETURN) then
			typeError2(state,
				node,  F("Cannot return from within a defer."),
				defer, F("...here is the defer.")
			)
		elseif node.nodeType == !(AST_BREAK) or node.nodeType == !(AST_CONTINUE) then
			local loop = node.loop or astFindParent(node, !!(CONST_SET{ AST_FOR, AST_WHILE }))

			if astHasParent(defer, loop) then
				typeError2(state,
					node,  F("Cannot %s from within a defer to the outside.", (node.nodeType == !(AST_BREAK) and "break" or "continue")),
					defer, F("...here is the defer.")
				)
			end
		end
	end)

	moveToNextRelevantPipe(state, defer)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstImport(state, import)`
	if import.fileScope then
		import.inferredType = getTypeInfoForNamespace(state, import.fileScope)
		moveToNextRelevantPipe(state, import)
		return
	end

	local importName = import.importName
	local path

	!(
	local function SET_PATH(pathCode, pathFallbackCode, fileDescription)
		__LUA(templateToLua(
			`
				path = $pathCode

				if not isReadableFile(path) then
					local pathFallback = $pathFallbackCode

					if not isReadableFile(pathFallback) then
						typeError(state, import, "Could not read $fileDescription '%s' or '%s'.", path, pathFallback)
					end

					path = pathFallback
				end
			`,
			{pathCode=pathCode, pathFallbackCode=pathFallbackCode, fileDescription=fileDescription}
		))
	end
	)

	if not import.isLoad then
		!SET_PATH(
			`F("%s/modules/%s.gloa",    COMPILER_DIRECTORY, importName)`,
			`F("%s/modules/%s/%s.gloa", COMPILER_DIRECTORY, importName, (importName:gsub("^.*/", "")))`,
			"module file"
		)
	elseif isPathAbsolute(importName) then
		path = importName
	else
		!SET_PATH(
			`F("%s/%s.gloa",    state.projectDirectory, importName)`,
			`F("%s/%s/%s.gloa", state.projectDirectory, importName, (importName:gsub("^.*/", "")))`,
			"file"
		)
	end

	local globalScope = state.globalScope

	if state.fileBuffers[path] then
		import.fileScope = itemWith1(globalScope.fileScopes, "path", path) or errorInternal(path)

	else
		!ifDEBUG `profilerPause()`

		local isPreload  = not import.isLoad and importName == "preload"
		local tokens     = state.tokens
		local sourceInfo = {path=path, string=""}

		if isPreload then
			insertNewToken(tokens, !(TOKEN_DUMMY),     nil,       sourceInfo, false)
		else
			insertNewToken(tokens, !(TOKEN_DIRECTIVE), "import",  sourceInfo, false)
			insertNewToken(tokens, !(TOKEN_STRING),    "preload", sourceInfo, false)
		end

		local locCountStartToken = tokens.n + 1

		local timeLexingStart, timeLexingEnd = readAndTokenizeFile(state, path, (not isPreload))
		local timeLexing                     = timeLexingEnd - timeLexingStart
		!ASSERT(`state.fileBuffers[path]`, `path`)
		-- !ifDEBUG `printf("%.7f  %s", timeLexing, path)`

		if not isPreload then
			countLinesOfCode(state, locCountStartToken, tokens.n)
		end

		sourceInfo.string = state.fileBuffers[path]
		insertNewToken(tokens, !(TOKEN_DUMMY), nil, sourceInfo, true)

		local timeStart   = timerGetCurrentInSeconds()
		local fileScope   = parseFileScope(state, globalScope, path, (not import.isLoad), importName)
		local timeParsing = timerGetCurrentInSeconds() - timeStart

		state.timeLexing         = state.timeLexing         + timeLexing
		state.timeLexingInPipes  = state.timeLexingInPipes  + timeLexing
		state.timeParsing        = state.timeParsing        + timeParsing
		state.timeParsingInPipes = state.timeParsingInPipes + timeParsing

		if peekNextTok(state, 1) then
			errorParsingNext(state, "Expected the end of the file.")
		end

		markTokensAsUnused(state)

		!ifDEBUG `profilerUnpause()`

		table.insert(globalScope.statementsStatic, fileScope)
		table.insert(globalScope.fileScopes,       fileScope)

		if import.isLoad then
			astMoveRelevantThingsFromFileScopeToGlobalScope(state, fileScope)
		end

		local i = indexOf(globalScope.fileScopes, fileScope) or errorInternal()
		addToQueueRecursively(state, fileScope, globalScope.fileScopes, i)

		import.fileScope = fileScope
	end

	import.inferredType = getTypeInfoForNamespace(state, import.fileScope)
	moveToNextRelevantPipe(state, import)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstUsing(state, using)`
	local expr     = using.expression
	local typeInfo = expr.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`using`, DEPEND_NODE_INFERRED, `expr`)
	end

	local usingScope

	if expr.nodeType == !(AST_IDENTIFIER) then
		local ident = expr
		local decl  = ident.declaration

		if typeInfo.tag == !(TYPE_STRUCT) then
			local structInfo    = typeInfo
			usingScope          = structInfo.astNode
			if not isDeclarationConstant(decl) then  using.variableDeclaration = decl  end
		elseif typeInfo.tag == !(TYPE_ENUM) then
			local enumInfo      = typeInfo
			usingScope          = enumInfo.astNode -- Using an enum value is the same as using the enum type. :UsingEnumValueOrType
		elseif typeInfo.tag == !(TYPE_NAMESPACE) then
			local namespaceInfo = typeInfo
			usingScope          = namespaceInfo.scope
		else
			typeError(state, ident, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_NAMES[typeInfo.tag])
		end

	elseif expr.nodeType == !(AST_TYPE) then
		local typeNode = expr
		typeInfo       = typeNode.representedType

		if typeInfo.tag == !(TYPE_STRUCT) then
			local structInfo = typeInfo
			usingScope       = structInfo.astNode
		elseif typeInfo.tag == !(TYPE_ENUM) then
			local enumInfo   = typeInfo
			usingScope       = enumInfo.astNode -- :UsingEnumValueOrType
		else
			typeError(state, typeNode, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_NAMES[typeInfo.tag])
		end

	elseif expr.nodeType == !(AST_ACCESS) then
		local access = expr
		if typeInfo.tag == !(TYPE_ENUM) then
			local enumInfo = typeInfo
			usingScope     = enumInfo.astNode -- :UsingEnumValueOrType
		else
			-- @Incomplete: Support using struct instance members which themselves are structs: using myObj.otherObj
			typeError(state, access, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_NAMES[typeInfo.tag])
		end

	else
		!ifDEBUG`astPrint(expr)`
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Invalid or unsupported 'using' expression.")
	end

	local scopeOfUsing = astFindParentScope(using)

	local usingExisting = (
		scopeOfUsing.usings and itemWith1(scopeOfUsing.usings, "scope", usingScope)
		-- Treat usings among function arguments as if they were in the body.
		or scopeOfUsing.nodeType == !(AST_BLOCK) and scopeOfUsing.parent.nodeType == !(AST_LAMBDA) and scopeOfUsing.parent.usings and itemWith1(scopeOfUsing.parent.usings, "scope", usingScope)
	)

	if usingExisting then
		-- Note: We don't look at .variableDeclaration. Maybe we should?
		local usingEarly = usingExisting
		local usingLate  = using

		if usingLate.position < usingEarly.position then
			usingEarly, usingLate = usingLate, usingEarly
		end

		typeError2(state,
			usingLate,  F("Duplicate using in the same scope."),
			usingEarly, F("...first using is here.")
		)
	end

	using.scope = usingScope

	moveToNextRelevantPipe(state, using)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstForeign(state, foreign)`
	-- @Cleanup: Make AstLambda use AstForeign?
	if foreign.foreignSource == "method" then
		errorParsing(state, foreign.foreignSourceName, "Only function bodies can be marked as foreign methods.")
	end

	-- @Robustness: Further limit places the expected type can be inferred from for foreign values.
	local typeInfoExpected = getExpectedTypeInfo(state, foreign, true, "foreign value", foreign)
	if not typeInfoExpected then  return  end

	foreign.inferredType = typeInfoExpected

	if not foreign.foreignSourceName then
		errorInternal(state, foreign, "@Incomplete: Infer foreign.foreignSourceName")
	end

	validateForeignSource(state, foreign.foreignSource, foreign.foreignSourceName.value, foreign.foreignSourceName)
	foreign.foreignSourceId = foreign.foreignSource.." "..foreign.foreignSourceName.value

	moveToNextRelevantPipe(state, foreign)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstBake(state, bake)`
	local scope, statement = astFindParentScope(bake)
	if not (scope and (
		(scope.nodeType == !(AST_LAMBDA) and statement == scope.argumentsIn)
		-- or (scope.nodeType == !(AST_STRUCT) and scope.bakeDeclarations and indexOf(scope.bakeDeclarations, statement))
	)) then
		astPrintTree(bake)
		astPrintTree(scope)
		errorParsing(state, bake, "Unexpected '$'.")
	end

	if not bake.name.inferredType then
		!DEPEND_AND_RETURN(`bake`, DEPEND_NODE_INFERRED, `bake.name`)
	end

	bake.inferredType = bake.name.inferredType
	moveToNextRelevantPipe(state, bake)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstDebug(state, debugNode)`
	local expr     = debugNode.expression
	local typeInfo = expr.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`debugNode`, DEPEND_NODE_INFERRED, `expr`)
	end

	if debugNode.action == "assert" then
		if typeInfo.tag ~= !(TYPE_BOOL) then
			wrapInImplicitCast(state, expr, state.builtinTypeInfos.bool, true)
			return
		end

		if not isExpressionConstant(state, expr, true) then
			local _, dynExpr = isExpressionConstant(state, expr, true)
			typeError(state, dynExpr, "Expression is not constant.")

		elseif not isExpressionConstant(state, expr, false) then
			local _, foreign = isExpressionConstant(state, expr, false)
			typeError(state, foreign, "Cannot statically assert foreign values as they are not known at compile-time.")

		elseif not (expr.nodeType == !(AST_LITERAL) and expr.literalType == !(LITERAL_BOOLEAN)) then
			errorInternal(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Constant expression did not result in a boolean literal.")

		elseif expr.value then
			-- void  Assertion passed!

		elseif not expr.replacing then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Assertion failed!")

		elseif expr.replacing.nodeType == !(AST_BINARY) then
			local binary = expr.replacing
			local l      = binary.left
			local r      = binary.right

			local textL = (
				!local e = `l`
				!!(e).nodeType == !(AST_LITERAL)    and (!!(e).literalType == !(LITERAL_STRING) and F("'%s'", !!(e).value) or tostring(!!(e).value)) or
				!!(e).nodeType == !(AST_TYPE)       and getFriendlyTypeInfoName(!!(e).representedType) or
				!!(e).nodeType == !(AST_IDENTIFIER) and !!(e).declaration.overloadOf and !!(e).name.."#overload"..(indexOf(!!(e).declaration.overloadOf.overloads, !!(e).declaration) or "?") or
				!!(e).nodeType == !(AST_IDENTIFIER) and !!(e).declaration.addedByPolymorph and !!(e).declaration.value.nodeType == !(AST_LAMBDA) and !!(e).name.."#poly"..(indexOf(!!(e).declaration.value.polymorphSourceLambda.polymorphs, !!(e).declaration) or "?").."#"..getFriendlyTypeInfoName(!!(e).inferredType) or
				nil
			)
			local textR = (
				!local e = `r`
				!!(e).nodeType == !(AST_LITERAL)    and (!!(e).literalType == !(LITERAL_STRING) and F("'%s'", !!(e).value) or tostring(!!(e).value)) or
				!!(e).nodeType == !(AST_TYPE)       and getFriendlyTypeInfoName(!!(e).representedType) or
				!!(e).nodeType == !(AST_IDENTIFIER) and !!(e).declaration.overloadOf and !!(e).name.."#overload"..(indexOf(!!(e).declaration.overloadOf.overloads, !!(e).declaration) or "?") or
				!!(e).nodeType == !(AST_IDENTIFIER) and !!(e).declaration.addedByPolymorph and !!(e).declaration.value.nodeType == !(AST_LAMBDA) and !!(e).name.."#poly"..(indexOf(!!(e).declaration.value.polymorphSourceLambda.polymorphs, !!(e).declaration) or "?").."#"..getFriendlyTypeInfoName(!!(e).inferredType) or
				nil
			)

			if textL and textR then
				if textL == textR then
					typeError(state, binary, "Binary assertion failed! (Both sides are %s)", textL)
				else
					typeError(state, binary, "Binary assertion failed! (Left is %s, right is %s)", textL, textR)
				end

			elseif textL then
				typeError(state, binary, "Binary assertion failed! (Left is %s)", textL)
			elseif textR then
				typeError(state, binary, "Binary assertion failed! (Right is %s)", textR)

			else
				!ifDEBUG `astPrintTree(binary)`
				typeError(state, binary, "Binary assertion failed!")
			end

		elseif expr.replacing.nodeType == !(AST_CAST) and expr.replacing.expression.inferredType.tag ~= !(TYPE_BOOL) then
			local cast      = expr.replacing
			local typeInfo  = cast.expression.inferredType
			local tag       = typeInfo.tag
			typeError(
				state, cast, "Assertion failed! '%s' value is %s.",
				getFriendlyTypeInfoName(typeInfo),
				(
					(tag == !(TYPE_INT) or tag == !(TYPE_FLOAT)) and "zero"
					or "empty"
				)
			)

		else
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Assertion failed!")
		end

	elseif debugNode.action == "print" then
		astPrintTree(expr)
		typeMessage(state, expr, "!print", "The expression above is here.")

	else
		errorInternal(state, debugNode)
	end

	moveToNextRelevantPipe(state, debugNode)
!NODE_INFERRER_END `end`

local function inferIfOrWhile(state, ifOrWhile)
	local cond     = ifOrWhile.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`ifOrWhile`, DEPEND_NODE_INFERRED, `cond`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(TYPE_BOOL) then
		wrapInImplicitCast(state, cond, state.builtinTypeInfos.bool, true)
		return
	end

	-- @Optimize: Remove/replace the branch if the condition is statically known.

	moveToNextRelevantPipe(state, ifOrWhile)
end

!NODE_INFERRER `function nodeInferrers.AstIf(state, ifBranch)`
	inferIfOrWhile(state, ifBranch)
!NODE_INFERRER_END `end`
!NODE_INFERRER `function nodeInferrers.AstWhile(state, whileLoop)`
	inferIfOrWhile(state, whileLoop)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstStaticIf(state, staticIf)`
	local cond     = staticIf.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`staticIf`, DEPEND_NODE_INFERRED, `cond`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(TYPE_BOOL) then
		wrapInImplicitCast(state, cond, state.builtinTypeInfos.bool, true)
		return
	end

	if not isExpressionConstant(state, cond, false) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(cond), "Static if: The condition must be a constant expression.")
	elseif not (cond.nodeType == !(AST_LITERAL) and cond.literalType == !(LITERAL_BOOLEAN)) then
		errorInternal(state, astGetExpressionVisuallyFurthestToTheLeft(cond), "Constant condition expression did not result in a boolean literal.")
	end

	local scope = staticIf.parent
	assert(isScope(scope))

	local statementsStatic  = scope.statementsStatic
	local targetContainer   = staticIf.queued.container
	local insertionIndex    = staticIf.queued.key
	local containerIsStatic = targetContainer == statementsStatic

	local statementsNew = {}
	local newlyDeclared = {} -- Keys are declarations and name strings.

	local branchToUse = (cond.value and staticIf.branchTrue or staticIf.branchFalse)

	if branchToUse then
		-- Static ifs in static context should only have static statements,
		-- but in dynamic context there may be both static and dynamic.
		if containerIsStatic and branchToUse.statementsDynamic[1] then
			errorInternal(state, branchToUse.statementsDynamic[1], "Dynamic statement(s) in static context.")
		end

		addUnqueuedChildrenToQueueRecursively(state, branchToUse) -- Note: We update the queueds in a moment.

		local statementsNewContainer = (containerIsStatic and branchToUse.statementsStatic or branchToUse.statementsDynamic)

		for iNew, statement in ipairs(statementsNewContainer) do
			if statement.nodeType == !(AST_DECLARATION) and statement.canShadow then
				typeError(state, statement, "Cannot have shadowing declarations directly inside !if blocks.") -- @Incomplete: Make this work?
			end
			statement.parent    = scope
			statementsNew[iNew] = statement
		end

		if not containerIsStatic then
			for _, statement in ipairs(branchToUse.statementsStatic) do
				if statement.nodeType == !(AST_DECLARATION) and statement.canShadow then
					typeError(state, statement, "Cannot have shadowing declarations directly inside !if blocks.") -- @Incomplete: Make this work?
				end
				local iNew             = #statementsStatic+1
				statement.parent       = scope
				statement.container    = statementsStatic
				statement.key          = iNew
				statementsStatic[iNew] = statement
			end
		end

		for _, decl in ipairs(branchToUse.declarations) do
			table.insert(scope.declarations, decl)
			newlyDeclared[decl]           = true
			newlyDeclared[decl.name.name] = true
			addDeclarationToNames(scope, decl)
		end
		if branchToUse.imports then
			scope.imports = scope.imports or {}
			for _, import in ipairs(branchToUse.imports) do
				if import.exported then  errorInternal(state, import, "@Incomplete: Export from static if.")  end
				table.insert(scope.imports, import)
			end
		end
		if branchToUse.usings then
			scope.usings = scope.usings or {}
			for _, using in ipairs(branchToUse.usings) do
				table.insert(scope.usings, using)
			end
		end
	end

	for i = insertionIndex+1, #targetContainer do
		table.insert(statementsNew, targetContainer[i])
	end

	local iNew = 0
	for i = insertionIndex, math.max(#targetContainer, insertionIndex + #statementsNew - 1) do
		iNew               = iNew+1
		targetContainer[i] = statementsNew[iNew] -- May be nil at the end if the static if was empty and at the end of the scope.
	end

	for iNew = insertionIndex, #targetContainer do
		local statement            = targetContainer[iNew]
		statement.queued.container = targetContainer
		statement.queued.key       = iNew
	end

	staticIf.queued.pipe = !(PIPE_DONE) -- Not sure if needed. @Cleanup
	unqueue(staticIf) -- @Robustness: Check if the correct thing happens for things waiting on staticIf (i.e. the scope).

	-- Re-check redeclarations for already-inferred things later in the scope and in the tree.
	if branchToUse and branchToUse.declarations[1] then
		for _, decl in ipairs(scope.declarations) do
			if newlyDeclared[decl] then
				for _, declOther in ipairs(scope.declarationsInTree[decl.name.name] or EMPTY_TABLE) do
					local scopeOther = astFindParentScope(declOther)
					local isMember   = scopeOther.nodeType == !(AST_ENUM) or scopeOther.nodeType == !(AST_STRUCT)
					checkRedeclarationAndMaybeAddOverload(state, declOther.name, declOther, isMember, scopeOther, nil)
				end

			-- The following is not needed anymore after adding the above, right? 2020-06-20
			-- Note: .token is @Depricated. 2021-07-25
			-- elseif newlyDeclared[decl.name.name] and decl.token > staticIf.token and decl.queued.pipe > !(PIPE_INFER) then
			-- 	-- @Robustness: Do we need to call ensureConstantIdentifierChainHasAllDeclarationsSet() here?
			-- 	checkRedeclarationAndMaybeAddOverload(state, decl.name, decl, false, scope, nil)
			end
		end
	end
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstConditional(state, conditional)`
	local cond     = conditional.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `cond`)
	end
	if conditional.branchTrue and not conditional.branchTrue.inferredType then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `conditional.branchTrue`)
	end
	if not conditional.branchFalse.inferredType then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `conditional.branchFalse`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(TYPE_BOOL) then
		-- Note: This wrap will not affect conditional.conditionAndBranchTrue which is the actual expression we use in the output.
		wrapInImplicitCast(state, cond, state.builtinTypeInfos.bool, true)
		return
	end

	local branchTrue    = conditional.branchTrue or conditional.conditionAndBranchTrue
	local branchFalse   = conditional.branchFalse

	local typeTrue  = adjustTypeToOne(state, branchTrue,  branchTrue.inferredType,  true)
	local typeFalse = adjustTypeToOne(state, branchFalse, branchFalse.inferredType, true)

	if typeTrue == typeFalse then
		conditional.inferredType = typeTrue
	elseif isTypeNumeric(typeTrue) and isTypeNumeric(typeFalse) then
		conditional.inferredType = state.builtinTypeInfos.float
	else
		typeError(
			state, conditional,
			"Type mismatch in conditional. (Left branch is %s, right branch is %s)",
			getFriendlyTypeInfoName(typeTrue),
			getFriendlyTypeInfoName(typeFalse)
		)
	end

	-- Simplify branch if possible.
	if cond.nodeType == !(AST_LITERAL) then
		!ASSERT("cond.literalType == "..LITERAL_BOOLEAN) -- The value should have casted if it wasn't a boolean to begin with.

		local replacement       = cond.value and branchTrue or branchFalse
		conditional.queued.pipe = replacement.queued.pipe -- :PipeTransferWhenReplacing
		cutOutPartOfNodeTree(state, conditional, replacement)

		if replacement.inferredType ~= conditional.inferredType then
			wrapInImplicitCast(state, replacement, conditional.inferredType, true) -- We should only get here in the float vs. int situation.
		end

	else
		moveToNextRelevantPipe(state, conditional)
	end
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstSwitch(state, switch)`
	local typeInfo = switch.value.inferredType
	if not typeInfo then
		!DEPEND_AND_RETURN(`switch`, DEPEND_NODE_INFERRED, `switch.value`)
	end
	typeInfo = adjustTypeToOne(state, switch.value, typeInfo, true)

	for i, case in ipairs(switch.cases) do
		if case.body and case.body.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`switch`, DEPEND_NODE_INFERRED, `case.body`)
		elseif case.value and not case.value.inferredType then
			!DEPEND_AND_RETURN(`switch`, DEPEND_NODE_INFERRED, `case.value`)
		end
	end

	for i, case in ipairs(switch.cases) do
		if not case.value then
			-- void
		elseif not isExpressionConstant(state, case.value, true) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(case.value), "Case expression must be constant.")
		elseif not isTypeCompatibleWith(state, case.value.inferredType, typeInfo, !(STRICT_TYPE_MATCH_NO), case.value) then
			typeError(
				state, case.value,
				"Case type mismatch. (Wanted %s, got %s)",
				getFriendlyTypeInfoName(typeInfo), getFriendlyTypeInfoName(case.value.inferredType)
			)
		end
	end

	if switch.complete then
		local enumInfo = typeInfo

		if enumInfo.tag ~= !(TYPE_ENUM) then
			typeError(
				state, switch.value,
				"!complete requires the value to be an enum. (Got %s)",
				getFriendlyTypeInfoName(enumInfo)
			)
		end

		local coveredEnums = {}

		for _, case in ipairs(switch.cases) do
			if case.value then
				!ASSERT("case.value.nodeType == "..AST_IDENTIFIER)
				coveredEnums[case.value.name] = true
			end
		end

		local missingEnums = {}

		for _, member in ipairs(enumInfo.members) do
			if not coveredEnums[member.name] then
				table.insert(missingEnums, member.name)
			end
		end

		if missingEnums[1] then
			typeError(state, switch, "Missing cases: %s", table.concat(missingEnums, ", "))
		end
	end

	moveToNextRelevantPipe(state, switch)
	-- @Incomplete: Simplify AstSwitch.
!NODE_INFERRER_END `end`

local function addDeclarationInForLoop(state, forLoop, name, sourceNode, isImplicit, typeInfo)
	local decl        = astNewNode(AstDeclaration, sourceNode, forLoop)
	decl.inferredType = typeInfo
	decl.name         = newIdentifier(decl, sourceNode, !(IDENT_KIND_DECLARATION), name, decl, typeInfo)

	table.insert(forLoop.statementsDynamic, decl)
	table.insert(forLoop.declarations,      decl)
	addDeclarationToNames(forLoop, decl)

	--
	-- @UX: For now we allow implicit loop variables to shadow anything outside the loop
	-- which allows for this confusing situation:
	--
	--   local x = 0
	--   local arrOrArr: [][]int
	--   for arrOrArr  for it  x += it  -- The left 'it' belongs to the outer loop and the right 'it' to the inner.
	--
	-- Can we improve this behavior?
	--
	if not isImplicit then
		local declExisting = findDeclaration(state, forLoop, name)
		if declExisting then
			typeError2(state,
				decl.name,         F("'%s' has already been declared.", name),
				declExisting.name, F("...it was declared here.")
			)
		end
	end

	addToQueueRecursively(state, decl, forLoop, #forLoop, !(PIPE_DONE))
	moveToNextRelevantPipe(state, decl, !(PIPE_INFER))
end

!NODE_INFERRER `function nodeInferrers.AstFor(state, forLoop)`
	if not forLoop.body.queued then
		local names  = forLoop.names
		local values = forLoop.expressions

		-- @Incomplete: Add all declarations now and infer their types later to fix confusing "undeclared identifier" errors.
		-- (This is fixed since we wait with inferring the body, right? 2020-07-18)

		for _, expr in ipairs(values) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		----------------------------------------------------------------
		-- for [ i = ] start, end [, step ]
		if forLoop.forType == !(FOR_NUMERIC) then
			!ASSERT `#names <= 1`
			!ASSERT `values[2] and not values[4]`

			local anyFloat = false

			for _, valueExpr in ipairs(values) do
				local typeInfo = adjustTypeToOne(state, valueExpr, valueExpr.inferredType, true)

				if typeInfo.tag == !(TYPE_FLOAT) then
					anyFloat = true
					break
				end
			end

			for _, valueExpr in ipairs(values) do
				local typeInfo = adjustTypeToOne(state, valueExpr, valueExpr.inferredType, true)

				if not (typeInfo.tag == !(TYPE_INT) or typeInfo.tag == !(TYPE_FLOAT)) then
					typeError(
						state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
						"For loop: Expected %s. (Got %s)",
						(anyFloat and "a float" or "an int"),
						getFriendlyTypeInfoName(typeInfo)
					)
				end
			end

			if values[3] and values[3].nodeType == !(AST_LITERAL) and values[3].value == 0 then
				typeError(state, values[3], "For loop: The step value is 0.")
			end

			if
				values[1].nodeType == !(AST_LITERAL) and
				values[2].nodeType == !(AST_LITERAL) and
				(not values[3] or values[3].nodeType == !(AST_LITERAL))
			then
				local i1   = values[1].value
				local i2   = values[2].value
				local step = values[3] and values[3].value or 1

				if step > 0 and i2 < i1 then
					typeError(state, values[2], "For loop: The final value is lower than the starting value in ascending loop.")
				elseif step < 0 and i2 > i1 then
					typeError(state, values[2], "For loop: The final value is higher than the starting value in descending loop.")
				end
			end

			local name       = (names[1] and names[1].name) or "it"
			local sourceNode = names[1] or forLoop
			local typeInfo   = state.builtinTypeInfos[anyFloat and "float" or "int"]
			addDeclarationInForLoop(state, forLoop, name, sourceNode, names[1]==nil, typeInfo)

		----------------------------------------------------------------
		-- for [ v1, ... : ] obj
		elseif forLoop.forType == !(FOR_SHORT) then
			!ASSERT `#values == 1`

			-- Note: Built-in short-form for loops have the value first and then the index/key.
			local objExpr = values[1]
			local objType = objExpr.inferredType

			-- We adjust lists to one, but leave vararg as-is.
			if objType.tag == !(TYPE_LIST) then
				objType = adjustTypeToOne(state, objExpr, objExpr.inferredType, true)
			end

			if objType.tag == !(TYPE_ARRAY) then
				local arraySig = objType
				if names[3] then
					typeError(state, names[3], "For loop: Too many names for short-form array loop. (Expected at most a value name and an index name.)")
				end
				local name1       = (names[1] and names[1].name) or "it"
				local name2       = (names[2] and names[2].name) or "itIndex"
				local sourceNode1 = names[1] or forLoop
				local sourceNode2 = names[2] or forLoop
				addDeclarationInForLoop(state, forLoop, name2, sourceNode2, names[2]==nil, state.builtinTypeInfos.int)
				addDeclarationInForLoop(state, forLoop, name1, sourceNode1, names[1]==nil, arraySig.itemType)

			elseif objType.tag == !(TYPE_VARARG) then
				local varargSig = objType
				if names[3] then
					typeError(state, names[3], "For loop: Too many names for short-form vararg loop. (Expected at most a value name and an index name.)")
				end
				local name1       = (names[1] and names[1].name) or "it"
				local name2       = (names[2] and names[2].name) or "itIndex"
				local sourceNode1 = names[1] or forLoop
				local sourceNode2 = names[2] or forLoop
				addDeclarationInForLoop(state, forLoop, name2, sourceNode2, names[2]==nil, state.builtinTypeInfos.int)
				addDeclarationInForLoop(state, forLoop, name1, sourceNode1, names[1]==nil, varargSig.itemType)

			elseif objType.tag == !(TYPE_TABLE) then
				if names[3] then
					typeError(state, names[3], "For loop: Too many names for short-form table loop. (Expected at most a value name and a key name.)")
				end
				local name1       = (names[1] and names[1].name) or "it"
				local name2       = (names[2] and names[2].name) or "itIndex"
				local sourceNode1 = names[1] or forLoop
				local sourceNode2 = names[2] or forLoop
				local typeInfo    = state.builtinTypeInfos.any
				addDeclarationInForLoop(state, forLoop, name2, sourceNode2, names[2]==nil, typeInfo)
				addDeclarationInForLoop(state, forLoop, name1, sourceNode1, names[1]==nil, typeInfo)

			elseif objType.tag == !(TYPE_STRUCT) then
				local structInfo = objType

				-- We have to wait for the members for inherited declarations (including '!iterator') to be available.
				-- @Incomplete: Maybe don't wait if '!iterator' is not inherited.
				if not structInfo.hasMembers then
					!DEPEND_AND_RETURN(`forLoop`, DEPEND_TYPE_MEMBERS_READY, `structInfo`)
				end

				local decl = findMemberDeclaration(state, structInfo.astNode, "!iterator")

				if decl then
					if decl.overloadOf then
						typeError(state, decl, "This declaration is overloaded which is currently not supported for default iterators.")
					end

					local iterLambda   = followIdentifiersToConstantValue(state, decl.value)
					local iterTypeInfo = iterLambda.inferredType

					if iterTypeInfo.tag ~= !(TYPE_FUNCTION) then
						typeError(state, decl.value, "The !iterator value must be a function. (This is %s)", getFriendlyTypeInfoName(iterTypeInfo))
					end

					local intType = state.builtinTypeInfos.int

					if #iterTypeInfo.argumentTypesIn ~= 2 then
						typeError(
							state, iterLambda.argumentsIn.arguments[1],
							"Default iterators for structs must take exactly two values - the struct instance and a control value. (This returns %d)",
							#iterTypeInfo.argumentTypesOut
						)
					elseif not isTypeCompatibleWith(state, structInfo, iterTypeInfo.argumentTypesIn[1], !(STRICT_TYPE_MATCH_NO), objExpr) then
						typeError(
							state, iterLambda.argumentsIn.arguments[1],
							"The default iterator must take %s as the first argument. (This is %s)",
							getFriendlyTypeInfoName(structInfo),
							getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[1])
						)
					elseif iterTypeInfo.argumentTypesIn[2] ~= intType then
						typeError(
							state, iterLambda.argumentsIn.arguments[2],
							"The default iterator must take an int as the second argument. (This is %s)",
							getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[2])
						)
					end

					if #iterTypeInfo.argumentTypesOut ~= 2 then
						typeError(
							state, iterLambda.argumentsOut.arguments[1],
							"Default iterators for structs must return exactly two values - a control value and the current value. (This returns %d)",
							#iterTypeInfo.argumentTypesOut
						)
					elseif iterTypeInfo.argumentTypesOut[1] ~= intType then
						typeError(
							state, iterLambda.argumentsOut.arguments[1],
							"The default iterator must return int as the first argument. (This is %s)",
							getFriendlyTypeInfoName(iterTypeInfo.argumentTypesOut[1])
						)
					end
					-- Note: We don't care what type the second returned value is.

					if names[3] then
						typeError(state, names[3], "For loop: Too many names for short-form struct loop. (Expected at most a value name and a control value name.)")
					end
					names[1] = names[1] or newIdentifier(forLoop, forLoop, !(IDENT_KIND_LOOSE), "itIndex")
					names[2] = names[2] or newIdentifier(forLoop, forLoop, !(IDENT_KIND_LOOSE), "it")

					-- Convert FOR_SHORT into FOR_ITERATOR.
					values[1] = astCopyIdentifier(decl.name, nil, forLoop, !(IDENT_KIND_LOOSE))
					values[2] = objExpr
					values[3] = newLiteral(forLoop, forLoop, !(LITERAL_INTEGER), 0, intType)
					objExpr.queued.key = 2
					addToQueue(state, values[1], values,1, !(PIPE_INFER))
					addToQueue(state, values[3], values,3, !(PIPE_INFER))

					forLoop.forType = !(FOR_ITERATOR)
					-- Continue to after the reverse check below.

				elseif structInfo.kind == !(STRUCT_KIND_ARRAY) then
					if names[3] then
						typeError(state, names[3], "For loop: Too many names for short-form array loop. (Expected at most a value name and an index name.)")
					end
					local name1       = (names[1] and names[1].name) or "it"
					local name2       = (names[2] and names[2].name) or "itIndex"
					local sourceNode1 = names[1] or forLoop
					local sourceNode2 = names[2] or forLoop
					addDeclarationInForLoop(state, forLoop, name2, sourceNode2, names[2]==nil, state.builtinTypeInfos.int)
					addDeclarationInForLoop(state, forLoop, name1, sourceNode1, names[1]==nil, structInfo.valueType)

				else
					typeError(state, objExpr, "For loop: %s has no default iterator and is not array-like.", getFriendlyTypeInfoName(structInfo))
				end
			else
				typeError(
					state, objExpr,
					"For loop: Cannot iterate over values in type group '%s'. (Type is %s)",
					TYPE_NAMES[objType.tag],
					getFriendlyTypeInfoName(objType)
				)
			end

			if forLoop.reverse and not (
				objType.tag == !(TYPE_ARRAY)
				or objType.tag == !(TYPE_VARARG)
				or (objType.tag == !(TYPE_STRUCT) and objType.kind == !(STRUCT_KIND_ARRAY) and forLoop.forType == !(FOR_SHORT))
			) then
				typeError(
					state, objExpr,
					"For loop: Only arrays can be iterated in reverse. (This is %s)",
					getFriendlyTypeInfoName(objType)
				)
			end

			if forLoop.forType == !(FOR_ITERATOR) then  return  end

		----------------------------------------------------------------
		-- for v1, ... in iter [, state [, init ] ]
		elseif forLoop.forType == !(FOR_ITERATOR) then
			!ASSERT `#names >= 1`
			!ASSERT `values[1]`

			local iterExpr, iterType = getAssignmentValue(state, forLoop, values, 1, nil, nil, "loop value", false)
			if iterType.tag ~= !(TYPE_FUNCTION) then
				typeError(state, iterExpr, "For loop: Expected a function. (Got %s)", getFriendlyTypeInfoName(iterType))
			end

			local iterArgInCount = #iterType.argumentTypesIn + (iterType.argumentTypesIn[1] and getLast(iterType.argumentTypesIn).tag == !(TYPE_VARARG) and -1 or 0)
			if iterArgInCount > 2 then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(iterExpr),
					"For loop: Iterators must take at most two arguments - an invariant state object and a control value. (The signature of this function is %s)",
					getFriendlyTypeInfoName(iterType)
				)
			end

			local iterArgsOut = iterType.argumentTypesOut

			if not iterArgsOut[1] then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(iterExpr),
					"For loop: Iterator does not return anything."
				)

			elseif iterArgsOut[1].tag == !(TYPE_NONE) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(iterExpr),
					"For loop: The type of the first returned value from iterators cannot be none."
				)

			elseif iterArgsOut[#iterArgsOut].tag ~= !(TYPE_VARARG) and #names > #iterArgsOut then
				-- @Incomplete: Consider !must.
				typeError(
					state, names[#iterArgsOut+1],
					"For loop: Too many names specified for iterator. (Expected %d at most, got %d)",
					#iterArgsOut,
					#names
				)
			end

			local iterArgsIn = iterType.argumentTypesIn

			do
				local stateExpr, stateTypeInfo = getAssignmentValue(state, forLoop, values, 2, nil, nil, "loop value", true)
				local initExpr,  initTypeInfo  = getAssignmentValue(state, forLoop, values, 3, nil, nil, "loop value", true)

				if stateExpr and not isTypeCompatibleWith(state, adjustTypeToOne(state, stateExpr, stateTypeInfo, true), iterArgsIn[1], !(STRICT_TYPE_MATCH_NO), stateExpr) then
					typeError(
						state, stateExpr,
						"For loop: Type mismatch for iterator state (value #2). (Wanted %s, got %s)",
						getFriendlyTypeInfoName(iterArgsIn[1]),
						getFriendlyTypeInfoName(adjustTypeToOne(state, stateExpr, stateTypeInfo, true))
					)
				end
				if initExpr and not isTypeCompatibleWith(state, adjustTypeToOne(state, initExpr, initTypeInfo, true), iterArgsIn[2], !(STRICT_TYPE_MATCH_NO), initExpr) then
					typeError(
						state, initExpr,
						"For loop: Type mismatch for initial control value (value #3). (Wanted %s, got %s)",
						getFriendlyTypeInfoName(iterArgsIn[2]),
						getFriendlyTypeInfoName(adjustTypeToOne(state, initExpr, initTypeInfo, true))
					)
				end
			end

			-- Check that the iterator will be called correctly by the loop.
			do
				-- Situations:
				--   for ... in func()
				--   for ... in expr, func()
				--   for ... in expr, expr, func()
				--   for ... in expr, expr, expr

				local valueTypesForIter = {}
				for i = 1, #values do
					table.insert(valueTypesForIter, values[i].inferredType)
				end

				--
				-- @UX: Better error messages in checkIf*() as they are currently optimized for calls and return nodes.
				-- @UX: Can we have better error arrows too? But where should they point...?
				--
				-- @Cleanup: Don't add the iterator type as an invisible first argument to the iterator itself for this check. checkIf*() probably needs a medium-sized update.
				--           Maybe we should construct a temporary AstCall here?
				--
				checkIfValuesMatchArgumentTypes(
					state, forLoop, values, valueTypesForIter, {valueTypesForIter[1], unpack(iterArgsIn)},
					false, nil, nil, false
				)
			end

			local extraExpr = getAssignmentValue(state, forLoop, values, 4, nil, nil, "loop value", true)
			if extraExpr then
				typeError(state, extraExpr, "For loop: Too many loop values. (Expected 3 at most: interator function, interator state and control value)")
			end

			for i, ident in ipairs(names) do
				local typeInfo = iterArgsOut[i] or iterArgsOut[#iterArgsOut] -- May be vararg.
				typeInfo       = adjustTypeToOne(state, iterExpr, typeInfo, false)

				-- Strip none from compound types for the first value as an iterator returning nil will stop the loop.
				if i == 1 and typeInfo.tag == !(TYPE_COMPOUND) then
					local compound    = typeInfo
					local iInCompound = indexOf(compound, state.builtinTypeInfos.none)

					if not iInCompound then
						-- void
					elseif not compound[3] then
						typeInfo = compound[3-iInCompound] -- We want the type in the compound that's not none.
					else
						local typeInfos = {unpack(compound)}
						table.remove(typeInfos, iInCompound)
						typeInfo = getTypeInfoForCompoundType(state, typeInfos, false)
					end
				end

				addDeclarationInForLoop(state, forLoop, ident.name, ident, false, typeInfo)
			end

		----------------------------------------------------------------
		else
			errorInternal(state, forLoop, "%d", forLoop.forType)
		end

		-- Now that loop declarations have been added we can infer the body.
		local i = indexOf(forLoop.statementsStatic, forLoop.body) or errorInternal(state, forLoop.body)
		addToQueueRecursively(state, forLoop.body, forLoop.statementsStatic, i, !(PIPE_INFER))
	end

	for _, statement in ipairs(forLoop.statementsStatic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	for _, statement in ipairs(forLoop.statementsDynamic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, forLoop)
!NODE_INFERRER_END `end`

local function checkForRecursiveStruct(state, declThatWeAreChecking, memberPath,memberName,memberType, structInfo, parentStructInfo)
	local structInfoInner

	if memberType.tag == !(TYPE_STRUCT) then
		structInfoInner = memberType

		local decl
			=  findMemberDeclaration(state, parentStructInfo.astNode, memberName)
			or errorInternal(state, declThatWeAreChecking, "%s", table.concat(memberPath, "."))

		if isDeclarationConstant(decl) then  return  end

		local valueExpr = decl.value
		if valueExpr and !!(CONST_SET{ AST_FOREIGN, AST_NULL })[valueExpr.nodeType] then
			return
		end

		if structInfoInner == structInfo then
			local niceTypeName = getFriendlyTypeInfoName(structInfo)

			typeError2(state,
				declThatWeAreChecking.name, F(
					"%s.%s is of type %s. This creates an infinite recursive loop. (Note: Compound types containing the struct are ok (unless the default value is the struct type), e.g. %s|nil)",
					niceTypeName, table.concat(memberPath, "."), niceTypeName, niceTypeName
				),
				decl, "...here is the other member declaration."
			)
		end

	else
		local decl
			=  findMemberDeclaration(state, parentStructInfo.astNode, memberName)
			or errorInternal(state, declThatWeAreChecking, "%s", table.concat(memberPath, "."))

		if isDeclarationConstant(decl) then  return  end

		local valueExpr = decl.value
		if not valueExpr or !!(CONST_SET{ AST_FOREIGN, AST_NULL })[valueExpr.nodeType] then
			return
		end

		structInfoInner = valueExpr.inferredType
		if structInfoInner.tag ~= !(TYPE_STRUCT) then  return  end

		if structInfoInner == structInfo then
			local nodeForError = declThatWeAreChecking.value
			nodeForError       = nodeForError and astGetExpressionVisuallyFurthestToTheLeft(nodeForError) or declThatWeAreChecking

			local niceTypeName = getFriendlyTypeInfoName(structInfo)

			typeError2(state,
				nodeForError, F(
					"The default value for %s.%s is of type %s. This creates an infinite recursive loop.",
					niceTypeName, table.concat(memberPath, "."), niceTypeName
				),
				astGetExpressionVisuallyFurthestToTheLeft(valueExpr), F("...here is the default value.")
			)
		end
	end

	if not structInfoInner.hasMembers then  return  end

	local memberPathIndex = #memberPath+1

	for _, member in ipairs(structInfoInner.members) do
		memberPath[memberPathIndex] = member.name
		checkForRecursiveStruct(state, declThatWeAreChecking, memberPath,member.name,member.typeInfo, structInfo, structInfoInner)
	end

	memberPath[memberPathIndex] = nil
end

function _G.getEarlyAndLateExpression(expr1, expr2)
	if expr1.position < expr2.position then  return expr1, expr2  end
	return expr2, expr1
end

!NODE_INFERRER `function nodeInferrers.AstStruct(state, struct)`
	if struct.polymorphs then
		local structInfo         = newTypeInfo(state, TypeInfoStruct)
		structInfo.astNode       = struct
		-- structInfo.kind       = ?
		structInfo.isPolymorphic = true

		table.insert(state.allTypeInfos,                      structInfo)
		table.insert(state.allTypeInfosByTag[!(TYPE_STRUCT)], structInfo)

		struct.representedType = structInfo
		struct.inferredType    = state.builtinTypeInfos.Type

		structInfo.hasMembers = true -- Probably doesn't matter.
		fulfillDependencies(state, struct.queued, !(DEPEND_TYPE_MEMBERS_READY))

		markTypeAsReady(state, structInfo)

		moveToNextRelevantPipe(state, struct)
		return
	end

	-- Start by creating a TypeInfoStruct that others can grab a reference to right away (before any members are ready).
	local structInfo = struct.representedType

	if not structInfo then
		structInfo         = newTypeInfo(state, TypeInfoStruct)
		structInfo.astNode = struct

		if struct.valueType then
			structInfo.kind = struct.keyType and !(STRUCT_KIND_TABLE) or !(STRUCT_KIND_ARRAY)
		elseif struct.keyType then
			typeError(state, struct.keyType, "Missing a corresponding !value type for structured table.")
		end

		-- Note: We don't populate structInfo.members just yet. (Is this gonna a problem?)

		table.insert(state.allTypeInfos,                      structInfo)
		table.insert(state.allTypeInfosByTag[!(TYPE_STRUCT)], structInfo)

		struct.representedType = structInfo
		struct.inferredType    = state.builtinTypeInfos.Type
	end

	-- Wait for explicit contents to infer.
	for _, statement in ipairs(struct.statementsStatic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `statement`) -- Shouldn't this be DEPEND_NODE_PASSED_INFER?
		end
	end
	if struct.keyType and not struct.keyType.inferredType then
		!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `struct.keyType`)
	end
	if struct.valueType and not struct.valueType.inferredType then
		!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `struct.valueType`)
	end

	-- Wait for and validate inherits.
	if struct.inherits then
		for i, typeExpr in ipairs(struct.inherits) do
			typeExpr           = astGetReplacement(typeExpr)
			struct.inherits[i] = typeExpr

			local structInfoToInherit = requireTypeRepresentedByExpression(state, typeExpr)
			if structInfoToInherit.tag ~= !(TYPE_STRUCT) then
				typeError(state, typeExpr, "Expected the type of a struct to inherit members from.")
			end
			if not structInfoToInherit.hasMembers then
				!DEPEND_AND_RETURN(`struct`, DEPEND_TYPE_MEMBERS_READY, `structInfoToInherit`)
			end
			if doesStructInherit(structInfoToInherit, structInfo) then
				typeError(state, typeExpr, "Struct is trying to inherit members from itself.")
			end
		end
	end

	--
	-- No more dependencies for this struct after this point!
	--

	local typeSourceNodeK = struct.keyType
	local typeSourceNodeV = struct.valueType

	if typeSourceNodeK then  structInfo.keyType   = requireTypeRepresentedByExpression(state, typeSourceNodeK)  end
	if typeSourceNodeV then  structInfo.valueType = requireTypeRepresentedByExpression(state, typeSourceNodeV)  end

	-- Inherit members from other structs.
	if struct.inherits then
		local declarationsIncludingNew = {} -- Declarations will be sorted as expected.
		local inheritIndices           = {}

		for i, typeExpr in ipairs(struct.inherits) do
			inheritIndices[typeExpr] = i
		end

		for _, statement in ipairs(struct.statementsStatic) do
			if statement.nodeType == !(AST_DECLARATION) then
				local decl = statement
				table.insert(declarationsIncludingNew, decl)

			elseif inheritIndices[statement] then
				local typeExpr            = statement
				local structInfoToInherit = requireTypeRepresentedByExpression(state, typeExpr)

				for j = 1, inheritIndices[statement]-1 do
					local typeExprPrevious   = struct.inherits[j]
					local structInfoPrevious = requireTypeRepresentedByExpression(state, typeExprPrevious)
					if
						structInfoToInherit == structInfoPrevious
						-- @Speed?
						or doesStructInherit(structInfoToInherit, structInfoPrevious)
						or doesStructInherit(structInfoPrevious, structInfoToInherit)
					then
						typeError2(state,
							typeExpr,         F("Two inherited structs are the same or share a base struct."),
							typeExprPrevious, F("...here is the other inheritance.")
						)
					end
				end

				local structToInherit = structInfoToInherit.astNode

				for j, declToInherit in ipairs(structToInherit.declarations) do
					local decl = findMemberDeclaration(state, struct, declToInherit.name.name)
					if not decl or decl.parent ~= struct then
						table.insert(struct.declarations,      declToInherit)
						table.insert(declarationsIncludingNew, declToInherit)
						addDeclarationToNames(struct, declToInherit)
					elseif isDeclarationConstant(decl) and isDeclarationConstant(declToInherit) then
						-- void  Shadowing/overriding static declarations is permitted. (@Design: Should we limit this to only functions, methods, or even foreign methods?)
					else
						typeError3(state,
							typeExpr,      F("Trying to inherit a member called '%s' but the struct already has a member with that name.", decl.name.name),
							decl,          F("...one declaration."), -- This may be an inherited member too.
							declToInherit, F("...the other declaration.")
						)
					end
				end

				if structToInherit.isForeign and not struct.isForeign then
					typeError(
						state, typeExpr,
						"Trying to inherit foreign struct '%s' into non-foreign struct. Both structs must be foreign for inheritance to work.",
						getFriendlyTypeInfoName(structInfoToInherit)
					)
					-- struct.isForeign          = true
					-- struct.foreignThroughNode = typeExpr
				end

				if structInfoToInherit.keyType then
					if structInfo.keyType then
						local early, late = getEarlyAndLateExpression(typeExpr, typeSourceNodeK)
						typeError2(state, late, "Key type is already defined.", early, "...key type was defined here.")
					end
					typeSourceNodeK    = typeExpr
					structInfo.keyType = structInfoToInherit.keyType
				end
				if structInfoToInherit.valueType then
					if structInfo.valueType then
						local early, late = getEarlyAndLateExpression(typeExpr, typeSourceNodeV)
						typeError2(state, late, "Value type is already defined.", early, "...value type was defined here.")
					end
					typeSourceNodeV      = typeExpr
					structInfo.valueType = structInfoToInherit.valueType
				end
				-- @Incomplete: Handle structInfo.kind==STRUCT_KIND_ARRAY and structInfoToInherit.kind==STRUCT_KIND_TABLE, and vice versa.
				if structInfoToInherit.kind ~= !(STRUCT_KIND_NORMAL) then
					assert(structInfo.kind == !(STRUCT_KIND_NORMAL))
					structInfo.kind = structInfoToInherit.kind
				end
			end
		end

		struct.declarations = declarationsIncludingNew
	end

	-- Check invalid recursiveness.
	for _, decl in ipairs(struct.statementsStatic) do
		if decl.nodeType == !(AST_DECLARATION) then
			local memberName = decl.name.name
			local memberType = decl.inferredType or errorInternal(state, decl)
			-- ifDEBUG `print(memberName, getFriendlyTypeInfoName(memberType))`
			checkForRecursiveStruct(state, decl, {memberName},memberName,memberType, structInfo, structInfo)
		end
	end

	-- Add members to structInfo.
	local allAreReady = true

	for _, decl in ipairs(struct.declarations) do
		if not isDeclarationConstant(decl) then
			local memberName = decl.name.name
			local memberType = decl.inferredType or errorInternal(state, decl)

			local member    = TypeInfoStructMember()
			member.name     = memberName
			member.typeInfo = memberType
			table.insert(structInfo.members, member)
			seeType(structInfo, memberType)

			allAreReady = allAreReady and memberType.isReady

			-- Make sure we never attempt to construct foreign values for members natively.
			-- (There's also a check for this in ProgramWriter.)

			if struct.isForeign then
				-- void

			elseif decl.value and !!(CONST_SET{ AST_FOREIGN, AST_NULL })[decl.value.nodeType] then
				-- void  Already foreign values and nil are always fine.

			elseif member.typeInfo.tag == !(TYPE_STRUCT) then
				if member.typeInfo.astNode.isForeign then
					typeError(state, (decl.value or decl), "Struct member value is foreign but the struct itself isn't. Mark the struct as !foreign or use NULL as initial value for this member to be valid.")
					-- struct.isForeign          = true
					-- struct.foreignThroughNode = decl
				end

			elseif member.typeInfo.tag == !(TYPE_COMPOUND) then
				!ASSERT("decl.value.inferredType.tag ~= "..TYPE_COMPOUND)

				if decl.value.inferredType.tag == !(TYPE_STRUCT) and decl.value.inferredType.astNode.isForeign then
					typeError(state, decl.value, "Struct member value is foreign but the struct itself isn't. Mark the struct as !foreign or use NULL as initial value for this member to be valid.")
					-- struct.isForeign          = true
					-- struct.foreignThroughNode = decl
				end
			end
		end
	end

	if structInfo.keyType then
		if (structInfo.members[1] or struct.declarations[1]) and isAnyTypeCompatibleWith(state, structInfo.keyType, state.builtinTypeInfos.string, !(STRICT_TYPE_MATCH_NO), typeSourceNodeK) then
			-- Note: We trigger this error for static members too, not just dynamic, as some lookups would otherwise be ambiguous.
			typeError(
				state, typeSourceNodeK,
				"Table-like structs with keys of string compatible types (%s here) cannot also have members as that would create ambiguity in some cases.%s",
				getFriendlyTypeInfoName(structInfo.keyType),
				(struct.polymorphSourceStruct and " (Note that arguments to polymorphic structs become static members.)" or "")
			)
		elseif structInfo.keyType.tag == !(TYPE_NONE) then
			typeError(state, typeSourceNodeK, "!key type cannot be 'none'.")
		elseif structInfo.keyType.tag == !(TYPE_COMPOUND) and indexWith1(structInfo.keyType, "tag", !(TYPE_NONE)) then
			typeError(state, typeSourceNodeK, "!key type cannot contain 'none'. (Type is %s)", getFriendlyTypeInfoName(structInfo.keyType))
		end
		seeType(structInfo, structInfo.keyType)
		allAreReady = allAreReady and structInfo.keyType.isReady
	end

	if structInfo.valueType then
		if structInfo.valueType.tag == !(TYPE_NONE) then
			typeError(state, typeSourceNodeV, "!value type cannot be 'none'.")
		elseif structInfo.valueType.tag == !(TYPE_COMPOUND) and indexWith1(structInfo.valueType, "tag", !(TYPE_NONE)) then
			typeError(state, typeSourceNodeV, "!value type cannot contain 'none'. (Type is %s)", getFriendlyTypeInfoName(structInfo.valueType))
		end
		seeType(structInfo, structInfo.valueType)
		allAreReady = allAreReady and structInfo.valueType.isReady
	end

	structInfo.hasMembers = true
	fulfillDependencies(state, struct.queued, !(DEPEND_TYPE_MEMBERS_READY))

	if allAreReady then
		markTypeAsReady(state, structInfo)
	end

	moveToNextRelevantPipe(state, struct)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstEnum(state, enum)`
	-- Start by creating a TypeInfoEnum that others can grab a reference to right away (before any members are ready).
	local enumInfo = enum.representedType

	if not enumInfo then
		enumInfo         = newTypeInfo(state, TypeInfoEnum)
		enumInfo.astNode = enum

		-- Note: We don't populate enumInfo.members just yet. (Is this gonna a problem?)

		table.insert(state.allTypeInfos,                    enumInfo)
		table.insert(state.allTypeInfosByTag[!(TYPE_ENUM)], enumInfo)

		enum.representedType = enumInfo
		enum.inferredType    = state.builtinTypeInfos.Type
	end

	-- Wait for contents to infer.
	for _, statement in ipairs(enum.statementsStatic) do
		if statement.nodeType == !(AST_DECLARATION) then
			local decl = statement
			!ASSERT `decl.value`
			if not decl.value.inferredType then
				!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `decl.value`)
			end

		elseif statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	--
	-- No more dependencies for this enum after this point!
	--

	!ASSERT `enum.declarations[1]` -- This should have been caught during parsing.
	local enumMemberInfo

	if enum.memberType then
		!ASSERT `enum.memberType.typeName`
		enumMemberInfo = state.builtinTypeInfos[enum.memberType.typeName]
	else
		-- Just use the type of the first member as the wanted type for the enum.
		enumMemberInfo = enum.declarations[1].value.inferredType
		if not !!(CONST_SET{ TYPE_INT, TYPE_STRING, TYPE_TYPE, TYPE_BOOL, TYPE_FLOAT })[enumMemberInfo.tag] then
			typeError(state, enum, "Supported enum member types are: int, string, Type, bool, float")
		end
	end

	enumInfo.memberTypeInfo = enumMemberInfo or errorInternal()
	seeType(enumInfo, enumMemberInfo)

	for i, decl in ipairs(enum.declarations) do
		local valueExpr = decl.value

		if not isExpressionConstant(state, valueExpr, true) then
			typeError(state, valueExpr, "Enum value is not constant.")
		elseif not isTypeCompatibleWith(state, valueExpr.inferredType, enumMemberInfo, !(STRICT_TYPE_MATCH_NO), valueExpr) then
			typeError(state, valueExpr,
				"Value type mismatch for '%s'. (Wanted %s, got %s)",
				decl.name.name,
				getFriendlyTypeInfoName(enumMemberInfo),
				getFriendlyTypeInfoName(valueExpr.inferredType)
			)
		end

		local member        = TypeInfoEnumMember()
		member.name         = decl.name.name
		enumInfo.members[i] = member
	end

	enumInfo.hasMembers = true
	fulfillDependencies(state, enum.queued, !(DEPEND_TYPE_MEMBERS_READY))

	markTypeAsReady(state, enumInfo) -- This is always ok because the member type is always a built-in.

	moveToNextRelevantPipe(state, enum)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstFileScope(state, fileScope)`
	local valueExpr = fileScope.valueToExport

	if not valueExpr then
		-- void
	elseif valueExpr.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`fileScope`, DEPEND_NODE_PASSED_INFER, `valueExpr`)
	elseif valueExpr.inferredType.tag == !(TYPE_NAMESPACE) then
		typeError(state, valueExpr, "Cannot export namespaces.")
	elseif valueExpr.inferredType.tag == !(TYPE_FUNCTION) and valueExpr.inferredType.isPolymorphic then
		typeError(state, valueExpr, "Cannot export references to raw polymorphic functions.")
	end

	for _, statement in ipairs(fileScope.statementsStatic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`fileScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, fileScope)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstGlobalScope(state, globalScope)`
	for _, statement in ipairs(globalScope.statementsStatic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`globalScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, globalScope)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstBlock(state, block)`
	for _, statement in ipairs(block.statementsStatic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`block`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	for _, statement in ipairs(block.statementsDynamic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`block`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, block)
!NODE_INFERRER_END `end`

-- @Robustness @Cleanup: Join visitNodesForRunning() and crawl().
local function visitNodesForRunning(state, dependent, unit, visited, deepTopScopeDeclarations)
	local function visitNodesForRunning_onVisit(node)
		visited[node] = true

		if not node.queued then
			return !(VISIT_IGNORE_CHILDREN)

		elseif node.queued.pipe <= !(PIPE_EMIT) then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_PASSED_EMIT, `node`, nil, toLua(VISIT_BREAK))

		elseif node.nodeType == !(AST_IDENTIFIER) then
			local ident = node

			local decl  = ident.declaration-- or errorInternal(state, ident)
			if not decl then  return  end -- @Robustness @Cleanup: This currently only happens for names in calls with named arguments. 2020-04-09 :InferNamedArgIdents

			if visited[decl] then  return  end

			visitNodesForRunning(state, dependent, decl, visited, deepTopScopeDeclarations)
			if dependent.queued.waitingOn then  return !(VISIT_BREAK)  end

			if decl.value then  return  end

			local valueExpr = getDeclarationValue(decl)
			if valueExpr then
				visitNodesForRunning(state, dependent, valueExpr, visited, deepTopScopeDeclarations)
				if dependent.queued.waitingOn then  return !(VISIT_BREAK)  end
			end

		elseif node.nodeType == !(AST_DECLARATION) then
			local decl = node
			if decl.kind == !(DECL_KIND_STATIC) or decl.parent.nodeType == !(AST_NAMESPACE) then
				table.insert(deepTopScopeDeclarations, decl)
			end

		elseif node.nodeType == !(AST_LOCATION) then
			return !(VISIT_IGNORE_CHILDREN)

		elseif !!(CONST_SET{ AST_LITERAL, AST_FOREIGN, AST_TYPE_INFO })[node.nodeType] then
			return !(VISIT_IGNORE_CHILDREN)
		end
	end
	astVisitAllNodes(unit, visitNodesForRunning_onVisit)
end

function _G.crawl(state, unit, crawled, forMeta, cb)
	local function crawl_onVisit(node)
		!(
		local function MARK_CRAWLED(objCode, crawlObjKind)
			__LUA(templateToLua(
				trimTemplate`
					crawled[$obj] = true
					if cb then  cb($obj, $crawlObjKind)  end
				`,
				{obj=objCode, crawlObjKind=toLua(crawlObjKind)}
			))
		end
		local function MARK_CRAWLED_IF_NEW(objCode, crawlObjKind)
			__LUA(templateToLua(
				trimTemplate`
					if not crawled[$obj] then
						crawled[$obj] = true
						if cb then  cb($obj, $crawlObjKind)  end
					end
				`,
				{obj=objCode, crawlObjKind=toLua(crawlObjKind)}
			))
		end
		)

		local nodeType = node.nodeType

		-- Also see visitNodesForRunning():

		if not node.queued then
			!MARK_CRAWLED(`node`, CRAWL_NODE)
			return !(VISIT_IGNORE_CHILDREN)

		elseif nodeType == !(AST_IDENTIFIER) then
			local ident = node
			!MARK_CRAWLED(`ident`, CRAWL_NODE)

			local decl = ident.declaration-- or errorInternal(state, ident)
			if not decl then  return  end -- @Robustness @Cleanup: This currently only happens for names in calls with named arguments. 2020-04-09 :InferNamedArgIdents

			if crawled[decl] then  return  end

			crawl(state, decl, crawled, forMeta, cb)

			if decl.value then  return  end

			local valueExpr = getDeclarationValue(decl)
			if valueExpr then
				crawl(state, valueExpr, crawled, forMeta, cb)
			end

		elseif nodeType == !(AST_DECLARATION) then
			local decl = node

			if not decl.valueConstant then
				!MARK_CRAWLED(`decl`, CRAWL_NODE)
				return
			end

			-- This check seem a bit out of place maybe. @Cleanup
			if decl.inferredType.tag == !(TYPE_NAMESPACE) then
				!MARK_CRAWLED(`decl`, CRAWL_NODE)
				return
			end

			if decl ~= unit then -- decl is unit if we followed an identifier.
				-- Don't mark as crawled!
				return !(VISIT_IGNORE_CHILDREN)
			end

			!MARK_CRAWLED       (`decl`,               CRAWL_NODE    )
			!MARK_CRAWLED_IF_NEW(`decl.valueConstant`, CRAWL_CONSTANT)

		elseif nodeType == !(AST_LOCATION) then
			local loc = node
			!MARK_CRAWLED(`loc`, CRAWL_NODE)

			if not loc.ofCaller then
				!MARK_CRAWLED_IF_NEW(`loc.valueConstant`, CRAWL_CONSTANT)
			end

			return !(VISIT_IGNORE_CHILDREN)

		elseif nodeType == !(AST_LITERAL) or nodeType == !(AST_FOREIGN) or nodeType == !(AST_TYPE_INFO) then
			!MARK_CRAWLED       (`node`,               CRAWL_NODE    )
			!MARK_CRAWLED_IF_NEW(`node.valueConstant`, CRAWL_CONSTANT)
			return !(VISIT_IGNORE_CHILDREN)

		--

		elseif nodeType == !(AST_LAMBDA) then
			local lambda = node
			!MARK_CRAWLED(`lambda`, CRAWL_NODE)

			if lambda.metaOnly and not forMeta then
				return !(VISIT_IGNORE_CHILDREN)
			end

			if lambda.valueConstant then -- @Robustness: When is this not set? Be more clear!
				!MARK_CRAWLED_IF_NEW(`lambda.valueConstant`, CRAWL_CONSTANT)
			end

		elseif nodeType == !(AST_CALL) then
			local call = node
			!MARK_CRAWLED(`call`, CRAWL_NODE)

			if call.wantLocation then
				!MARK_CRAWLED_IF_NEW(`call.locationConstant`, CRAWL_CONSTANT)
			end

		elseif nodeType == !(AST_BLOCK) then
			local block = node
			!MARK_CRAWLED(`block`, CRAWL_NODE)

			for _, statement in ipairs(block.statementsDynamic) do
				crawl(state, statement, crawled, forMeta, cb)
			end

			return !(VISIT_IGNORE_CHILDREN)

		else
			!MARK_CRAWLED(`node`, CRAWL_NODE)
		end
	end
	astVisitAllNodes(unit, crawl_onVisit)
end

local function createRunReplacementFromTypeAndLuaValue(state, runNode, parent, typeInfo, v)
	local tag = typeInfo.tag

	if tag == !(TYPE_INT) or (tag == !(TYPE_ANY) and type(v) == "number" and v == math.floor(v)) then
		local n = v
		assert(type(n) == "number" and n == math.floor(n))
		local literal        = astNewNode(AstLiteral, runNode, parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = n
		literal.inferredType = state.builtinTypeInfos.int
		return literal

	elseif tag == !(TYPE_FLOAT) or (tag == !(TYPE_ANY) and type(v) == "number") then
		local n = v
		assert(type(n) == "number")
		local literal        = astNewNode(AstLiteral, runNode, parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = n
		literal.inferredType = state.builtinTypeInfos.float
		return literal

	elseif tag == !(TYPE_STRING) or (tag == !(TYPE_ANY) and type(v) == "string") then
		local s = v
		assert(type(s) == "string")
		local literal        = astNewNode(AstLiteral, runNode, parent)
		literal.literalType  = !(LITERAL_STRING)
		literal.value        = s
		literal.inferredType = state.builtinTypeInfos.string
		return literal

	elseif tag == !(TYPE_BOOL) or (tag == !(TYPE_ANY) and type(v) == "boolean") then
		local flag = v
		assert(type(flag) == "boolean")
		local literal        = astNewNode(AstLiteral, runNode, parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = flag
		literal.inferredType = state.builtinTypeInfos.bool
		return literal

	elseif tag == !(TYPE_NONE) or (tag == !(TYPE_ANY) and v == nil) then
		assert(v == nil)
		local literal        = astNewNode(AstLiteral, runNode, parent)
		literal.literalType  = !(LITERAL_NIL)
		literal.value        = nil
		literal.inferredType = state.builtinTypeInfos.none
		return literal

	elseif tag == !(TYPE_TABLE) or (tag == !(TYPE_ANY) and type(v) == "table") then
		local t = v
		assert(type(t) == "table")
		local tableNode = astNewNode(AstTable, runNode, parent)
		local anyType   = state.builtinTypeInfos.any

		for k, v in pairsSorted(t, naturalCompare) do
			local tableField    = KeyValuePair()
			tableField.key      = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, anyType, k)
			tableField.value    = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, anyType, v)
			table.insert(tableNode.fields, tableField)
		end

		tableNode.inferredType = state.builtinTypeInfos.table
		return tableNode

	elseif tag == !(TYPE_ARRAY) then
		local t = v
		assert(type(t) == "table")
		local arraySig  = typeInfo
		local tableNode = astNewNode(AstTable, runNode, parent)
		local intType   = state.builtinTypeInfos.int

		-- @Robustness: Check that all keys in 't' are valid.
		for i, v in ipairs(t) do
			local tableField = KeyValuePair()

			local indexLiteral        = astNewNode(AstLiteral, runNode, tableNode)
			indexLiteral.literalType  = !(LITERAL_INTEGER)
			indexLiteral.value        = i
			indexLiteral.inferredType = intType
			tableField.key            = indexLiteral

			tableField.value = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, arraySig.itemType, v)

			tableNode.fields[i] = tableField
		end

		tableNode.inferredType = arraySig
		return tableNode

	elseif tag == !(TYPE_STRUCT) then
		local t = v
		assert(type(t) == "table")
		local structInfo = typeInfo
		local tableNode  = astNewNode(AstTable, runNode, parent)
		local stringType = state.builtinTypeInfos.string
		assert(structInfo.hasMembers)

		-- @Incomplete @Incomplete @Incomplete!!!!!!!!!
		if structInfo.keyType or structInfo.valueType then
			errorInternal(state, runNode, "@Incomplete: Handle !run expression results containing instances of structs with !key and !value types.")
		end

		-- @Robustness: Check that all keys in 't' are valid.
		for _, member in ipairs(structInfo.members) do
			local tableField = KeyValuePair()

			local memberLiteral        = astNewNode(AstLiteral, runNode, tableNode)
			memberLiteral.literalType  = !(LITERAL_STRING)
			memberLiteral.value        = member.name
			memberLiteral.inferredType = stringType
			tableField.key             = memberLiteral

			tableField.value = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, member.typeInfo, t[member.name])

			table.insert(tableNode.fields, tableField)
		end

		tableNode.inferredType = structInfo
		return tableNode

	elseif tag == !(TYPE_ENUM) then
		local enumInfo     = typeInfo
		local ident        = astNewNode(AstIdentifier, runNode, parent)
		ident.kind         = !(IDENT_KIND_LOOSE)
		ident.inferredType = enumInfo

		if !!(CONST_SET{ TYPE_INT, TYPE_STRING, TYPE_BOOL, TYPE_FLOAT })[enumInfo.memberTypeInfo.tag] then
			for _, decl in ipairs(enumInfo.astNode.declarations) do
				local literal = decl.value
				assert(literal.nodeType == !(AST_LITERAL))
				if literal.value == v then
					ident.name        = decl.name.name
					ident.declaration = decl
					break
				end
			end

		elseif enumInfo.memberTypeInfo.tag == !(TYPE_TYPE) then
			for _, decl in ipairs(enumInfo.astNode.declarations) do
				if requireTypeRepresentedByExpression(state, decl.value).id == v then
					ident.name        = decl.name.name
					ident.declaration = decl
					break
				end
			end

		else
			errorUnhandledType(state, runNode, enumInfo.memberTypeInfo)
		end

		if not ident.declaration then
			typeError(state, runNode, "Got an invalid enum value. (Enum '%s', value: %s)", getFriendlyTypeInfoName(enumInfo), tostring(v))
		end

		return ident

	elseif tag == !(TYPE_FUNCTION) then
		local func = v
		assert(type(func) == "function")

		local theConst = nil

		for _, const in ipairs(state.constants) do
			if const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION) and state.runnerEnvironment[const.name] == func then
				theConst = const
				break
			end
		end

		if not theConst then
			errorInternal(state, runNode, "The resulting function is no an existing constant for some reason.")
		end

		local lambda = theConst.value

		if lambda.parent.nodeType == !(AST_DECLARATION) then
			local decl  = lambda.parent
			local ident = astCopyIdentifier(decl.name, runNode, parent, !(IDENT_KIND_LOOSE))
			return ident
		else
			local copy    = astCopy(lambda, nil, parent)
			copy.position = runNode.position
			copy.line     = runNode.line
			return copy
		end

	elseif tag == !(TYPE_TYPE) then
		local typeId = v
		assert(type(typeId) == "number" and typeId == math.floor(typeId))

		local typeRepresented = state.allTypeInfos[typeId]
		if not typeRepresented then
			typeError(state, runNode, "Got the ID of a type that doesn't exist. (Type ID %d)", typeId)
		end

		local typeNode = createTypeNodeFromInfo(state, typeRepresented, runNode, parent)
		return typeNode

	elseif tag == !(TYPE_COMPOUND) then
		typeError(state, runNode, "!run expression is, or contains something, of a compound type which is illegal. (Type is %s)", getFriendlyTypeInfoName(typeInfo))
	elseif tag == !(TYPE_NAMESPACE) then
		typeError(state, runNode, "!run expression is a namespace which is illegal here.")
	else
		errorUnhandledType(state, runNode, typeInfo)
	end
end

-- luaFunction = prepareToRun( state, dependent, lambdaToRun )
-- Returns nil if waiting.
function _G.prepareToRun(state, dependent, lambda)
	if lambda.queued.pipe <= !(PIPE_EMIT) then
		!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_PASSED_EMIT, `lambda`, nil, `nil`)
	end
	--[[ This is currently not needed as only functions may be waiting. 2020-02-26
	for _, const in ipairs(state.constants) do
		if not const.isReady and not (const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION)) then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_CONSTANT_READY, `const`, nil, `nil`)
		end
	end
	--]]

	local deepTopScopeDeclarations = {}

	visitNodesForRunning(state, dependent, lambda, {}, deepTopScopeDeclarations)
	if dependent.queued.waitingOn then  return nil  end

	local relevantObjects = {}
	crawl(state, lambda, relevantObjects, true, nil)

	for _, const in ipairs(state.constants) do
		if relevantObjects[const] and not const.isReady and (const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION)) then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_CONSTANT_READY, `const`, nil, `nil`)
		end
	end

	!ifDEBUG `profilerPause()`
	runnerSetup(state)

	local newConstants            = {}
	local newTopScopeDeclarations = {}

	for _, const in ipairs(state.constants) do
		if relevantObjects[const] and not state.runnerWrittenObjects[const] then
			assert(const.isReady)
			state.runnerWrittenObjects[const] = true
			table.insert(newConstants, const)
			const.nameLocked = true -- @UX: Update constant names as they are allocated (and not when declarations pass PIPE_EMIT).
		end
	end

	for _, decl in ipairs(state.globalScope.declarations) do
		if relevantObjects[decl] and not state.runnerWrittenObjects[decl] then
			state.runnerWrittenObjects[decl] = true
			table.insert(newTopScopeDeclarations, decl)
		end
	end
	for _, fileScope in ipairs(state.globalScope.fileScopes) do
		for __, decl in ipairs(fileScope.declarations) do
			if relevantObjects[decl] and not state.runnerWrittenObjects[decl] then
				state.runnerWrittenObjects[decl] = true
				table.insert(newTopScopeDeclarations, decl)
			end
		end
	end
	for __, decl in ipairs(deepTopScopeDeclarations) do
		if relevantObjects[decl] and not state.runnerWrittenObjects[decl] then
			state.runnerWrittenObjects[decl] = true
			table.insert(newTopScopeDeclarations, decl)
		end
	end

	local writer = state.runnerWriter

	writeLuaPreloads(state, writer, state.luaPreloads,            state.runnerWrittenPreloads            + 1, writer.luaMainChunkBody)
	writeLuaPreloads(state, writer, state.luaPreloadsCompiletime, state.runnerWrittenPreloadsCompiletime + 1, writer.luaMainChunkBody)
	state.runnerWrittenPreloads            = #state.luaPreloads
	state.runnerWrittenPreloadsCompiletime = #state.luaPreloadsCompiletime

	writeForeignImports                       (state, writer, newConstants, true,        writer.luaMainChunkBody, nil)
	writeConstantObjectsAndForwardDeclarations(state, writer, newConstants, EMPTY_TABLE, writer.luaMainChunkBody, nil)
	writeTopScopeDeclarations                 (state, writer, newTopScopeDeclarations,   writer.luaMainChunkBody, nil)

	-- !ifDEBUG `print(luaParser.toLua(writer.luaMainChunkBody, true))`
	runnerRunCurrentOutputAsChunkIfNotEmpty(state)
	!ifDEBUG `profilerUnpause()`

	local constName = lambda.valueConstant.name
	local func      = state.runnerEnvironment[constName]

	if type(func) ~= "function" then
		errorInternal(state, dependent, "Missing the compiled object to run for some reason. (Constant '%s')", constName)
	end

	return func
end

!NODE_INFERRER `function nodeInferrers.AstRun(state, runNode)`
	local func = prepareToRun(state, runNode, runNode.lambda)
	if not func then  return  end

	local v
	do
		local run = func -- For better error messages.
		v         = run()
	end

	if not isAnExpressionExpected(state, runNode) then
		runNode.inferredType = state.builtinTypeInfos.void
		moveToNextRelevantPipe(state, runNode)
		return
	end

	-- Replace the directive with a constant value.

	local returnNode = getLast(runNode.lambda.body.statementsDynamic)
	assert(returnNode.nodeType == !(AST_RETURN))

	local typeInfo = returnNode.values[1].inferredType
	typeInfo       = adjustTypeToOne(state, runNode, typeInfo, true)

	local replacement = createRunReplacementFromTypeAndLuaValue(state, runNode, runNode.parent, typeInfo, v)
	addUnqueuedChildrenToQueueRecursively(state, replacement, !(PIPE_INFER))

	replaceQueuedNodeAndUnqueueOldTree(state, runNode, replacement)
	if typeInfo.tag == !(TYPE_ANY) and replacement.inferredType.tag ~= !(TYPE_ANY) then
		replacement = wrapInImplicitCast(state, replacement, typeInfo, true)
	end

	moveChildrenToNextRelevantPipe(state, replacement)
	moveToNextRelevantPipe(state, replacement)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstNull(state, null)`
	local typeInfoExpected = getExpectedTypeInfo(state, null, false, "NULL value", null)
	if not typeInfoExpected then  return  end

	null.inferredType = typeInfoExpected
	moveToNextRelevantPipe(state, null)
!NODE_INFERRER_END `end`

!NODE_INFERRER `function nodeInferrers.AstNamespace(state, namespace)`
	namespace.inferredType = getTypeInfoForNamespace(state, (namespace.namespaceReferenceNode or namespace))
	moveToNextRelevantPipe(state, namespace)
!NODE_INFERRER_END `end`

!if DEBUG and not STATIC_PROFILER then
	!for nodeType, nodeName in ipairs(AST_NAMES) do
		!local inferrerName    = "nodeInferrer_"..nodeName
		local !!(inferrerName) = nodeInferrers[!(nodeType)]

		nodeInferrers[!(nodeType)] = function(state, node)
			return (!!(inferrerName)(state, node)) -- Better traceback in DEBUG mode.
		end
	!end
!end

function _G.inferNode(state, node)
	!if DEBUG then
		!if EXTRA_STATS then
			state.inferAttempts[node.nodeType] = state.inferAttempts[node.nodeType] + 1
		!end
		local nodeInferrer = nodeInferrers[node.nodeType] or errorInternal(state, node)
		nodeInferrer(state, node)
	!else
		return nodeInferrers[node.nodeType](state, node)
	!end
end

function _G.queueForReinfer(state, node)
	!ASSERT `node.queued`
	local queued               = node.queued
	queued.pipe                = !(PIPE_INFER)
	local queueActive          = state.queueActive
	queueActive.n              = queueActive.n + 1
	queueActive[queueActive.n] = queued
end



local ALWAYS_CONST = !(Set{
	AST_BAKE,
	AST_IMPORT,     -- Imports refer to namespaces which are always constant.
	AST_LITERAL, AST_NULL,
	AST_NAMESPACE,
	AST_VARIANT_OF, -- The resulting reference will always be constant.
	AST_STRUCT,  AST_ENUM,    -- Structs and enums are types (which are constant).
	AST_TYPE,    AST_TYPE_OF, -- All types are constant, just like literals.
	AST_LOCATION,
})
local NEVER_CONST = !(Set{
	AST_CALL,
	AST_TYPE_INFO, -- @Incomplete: Make type_info() a constant expression.
	AST_VARARG,
})

-- Note: It's assumed that the expression tree has all types figured out.
-- isConstant, firstDynamicExpression = isExpressionConstant( state, expr, foreignIsConst )
function _G.isExpressionConstant(state, expr, foreignIsConst)
	if not expr.inferredType then
		errorInternal(state, expr, "Missing inferred type.")
	end

	local nodeType = expr.nodeType

	if ALWAYS_CONST[nodeType] then
		return true, nil
	elseif NEVER_CONST[nodeType] then
		return false, expr

	elseif nodeType == !(AST_IDENTIFIER) then
		local ident = expr
		local decl  = ident.declaration or errorInternal(state, ident)
		if not isDeclarationConstant(decl) then  return false, ident  end

		return isExpressionConstant(state, decl.value, foreignIsConst)

	elseif nodeType == !(AST_CAST) or nodeType == !(AST_UNARY) then
		local castOrUnary = expr
		return isExpressionConstant(state, castOrUnary.expression, foreignIsConst)

	elseif nodeType == !(AST_BINARY) then
		local binary = expr

		local isConst, dynExpr = isExpressionConstant(state, binary.left, foreignIsConst)
		if not isConst then  return false, dynExpr  end

		return isExpressionConstant(state, binary.right, foreignIsConst)

	elseif nodeType == !(AST_LAMBDA) then -- Note: We should not get here for AstType nodes.
		local lambda = expr
		if lambda.captures or lambda.captureAll then  return false, lambda  end
		return true, nil

	elseif nodeType == !(AST_CONDITIONAL) then
		local conditional = expr

		local isConst, dynExpr = isExpressionConstant(state, conditional.condition, foreignIsConst)
		if not isConst then  return false, dynExpr  end

		if conditional.branchTrue then
			local isConst, dynExpr = isExpressionConstant(state, conditional.branchTrue, foreignIsConst)
			if not isConst then  return false, dynExpr  end
		end

		return isExpressionConstant(state, conditional.branchFalse, foreignIsConst)

	elseif nodeType == !(AST_ACCESS) then
		local access = expr

		local isConst, dynExpr = isExpressionConstant(state, access.object, foreignIsConst)
		if not isConst then  return false, dynExpr  end

		return isExpressionConstant(state, access.member, foreignIsConst)

	elseif nodeType == !(AST_TABLE) then
		local tableNode = expr
		if tableNode.trailingExpression then  return false, tableNode.trailingExpression  end

		for _, tableField in ipairs(tableNode.fields) do
			local isConst, dynExpr = isExpressionConstant(state, tableField.key,   foreignIsConst)
			if not isConst then  return false, dynExpr  end

			local isConst, dynExpr = isExpressionConstant(state, tableField.value, foreignIsConst)
			if not isConst then  return false, dynExpr  end
		end

		return true, nil

	elseif nodeType == !(AST_FOREIGN) then
		-- Technically foreign values are seen as constant at runtime, but since we don't
		-- know what they are at compile-time we (usually) treat them as runtime values.
		local foreign = expr
		if foreignIsConst then  return true, nil  end
		return false, foreign

	else
		errorUnhandledNodeType(state, expr)
	end
end

-- function _G.isExpressionExactlyOneValue(expr)
-- 	return not (expr.nodeType == !(AST_VARARG) or expr.nodeType == !(AST_CALL)) or expr.surroundedByParentheses
-- end



-- expression, typeInfo = getAssignmentValue( state, assignmentTarget, values, valueIndex, expectedTypeInfo=any, extraBinaryOperation="", targetTerm="assignment target", noError=false )
-- Note: Vararg node/type may be returned.
function _G.getAssignmentValue(state, targetExpr, values, i, typeInfoExpected, binOp, targetTerm, noError)
	!(
	local _TARGET_NAME = trimTemplate`
		targetExpr.nodeType == $nodeTypeIdent  and " ('"..targetExpr.name.."')" or
		targetExpr.nodeType == $nodeTypeAccess and targetExpr.member.nodeType == $nodeTypeLiteral and targetExpr.member.literalType == $literalTypeString and " ('"..targetExpr.member.value.."')" or
		""
	`
	local TARGET_NAME = templateToLua(_TARGET_NAME, {
		nodeTypeIdent     = AST_IDENTIFIER,
		nodeTypeAccess    = AST_ACCESS,
		nodeTypeLiteral   = AST_LITERAL,
		literalTypeString = LITERAL_STRING,
	})

	local _CALL_RETURNS_NOTHING = trimTemplate`
		typeError(state, call, "Called function returns nothing for %s #%d%s (return value #%d).", targetTerm, i, $targetName, argIndex)
	`
	local CALL_RETURNS_NOTHING = templateToLua(_CALL_RETURNS_NOTHING, {
		targetName = TARGET_NAME,
	})

	local _CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN = `
		if binOp == "" then
			local isCompatible = isTypeCompatibleWith(state, $valueTypeInfoAdjusted, typeInfoExpected, $STRICT_TYPE_MATCH_NO, $valueExpr)
			if isCompatible then  return $valueExpr, $valueTypeInfo  end

			wantEnumAndGotLiteralOfCorrectType, isCompatible = checkForLiteralVsEnumSituation($valueExpr, typeInfoExpected)
			if isCompatible then  return $valueExpr, typeInfoExpected  end

		else
			$valueTypeInfoAdjusted = checkBinaryOperation(
				state,
				targetExpr,
				$valueExpr, targetExpr, $valueExpr,
				binOp,
				typeInfoExpected, $valueTypeInfoAdjusted,
				true
			) or errorInternal()

			local isCompatible = isTypeCompatibleWith(state, $valueTypeInfoAdjusted, typeInfoExpected, $STRICT_TYPE_MATCH_NO, $valueExpr)
			if not isCompatible then
				wantEnumAndGotLiteralOfCorrectType, isCompatible = checkForLiteralVsEnumSituation($valueExpr, typeInfoExpected)
			end

			if isCompatible then
				-- void
			elseif wantEnumAndGotLiteralOfCorrectType then
				typeError2(state,
					$valueExpr,               F("Enum '%s' has no value '%s'.", getFriendlyTypeInfoName(typeInfoExpected), valueToStringForMessage($valueExpr.value)),
					typeInfoExpected.astNode, F("...here is the enum.")
				)
			else
				typeError(
					state, targetExpr,
					"Type mismatch between %s #%d%s (%s) and result of binary operation (%s) (%s).",
					targetTerm, i, $targetName, getFriendlyTypeInfoName(typeInfoExpected),
					binOp, getFriendlyTypeInfoName($valueTypeInfoAdjusted)
				)
			end

			return $valueExpr, $valueTypeInfo
		end
	`
	local function CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(valueExprVar, typeInfoVar, typeInfoAdjustedVar)
		local lua = templateToLua(_CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN, {
			STRICT_TYPE_MATCH_NO  = STRICT_TYPE_MATCH_NO,
			valueExpr             = valueExprVar,
			valueTypeInfo         = typeInfoVar,
			valueTypeInfoAdjusted = typeInfoAdjustedVar,
			targetName            = TARGET_NAME,
		})
		__LUA(lua)
	end
	)

	binOp      = binOp      or ""
	targetTerm = targetTerm or "assignment target"

	local valueExpr = values[i]

	if valueExpr then
		local valueTypeInfo = valueExpr.inferredType

		if valueTypeInfo.tag == !(TYPE_LIST) then
			valueTypeInfo = valueTypeInfo[1]

			if not valueTypeInfo then
				if noError then  return valueExpr, valueTypeInfo  end

				local call     = valueExpr
				local argIndex = 1
				!!(CALL_RETURNS_NOTHING)
			end
		end

		if not typeInfoExpected then  return valueExpr, valueTypeInfo  end

		local valueTypeInfoAdjusted              = adjustTypeToOne(state, valueExpr, valueTypeInfo, true)
		local wantEnumAndGotLiteralOfCorrectType = false
		!CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(`valueExpr`, `valueTypeInfo`, `valueTypeInfoAdjusted`)

		if wantEnumAndGotLiteralOfCorrectType then
			typeError2(state,
				valueExpr,                F("Enum '%s' has no value '%s'.", getFriendlyTypeInfoName(typeInfoExpected), valueToStringForMessage(valueExpr.value)),
				typeInfoExpected.astNode, F("...here is the enum.")
			)
		else
			local messageFormat = (
				valueTypeInfoAdjusted.tag == !(TYPE_FUNCTION) and typeInfoExpected.tag == !(TYPE_FUNCTION)
				and "Function signature is different from %s #%d%s. (Wanted %s, got %s)"
				or  "Value type mismatch for %s #%d%s. (Wanted %s, got %s)"
			)
			typeError(
				state, valueExpr, messageFormat,
				targetTerm, i, !!(TARGET_NAME),
				getFriendlyTypeInfoName(typeInfoExpected),
				getFriendlyTypeInfoName(valueTypeInfoAdjusted)
			)
		end
	end

	valueExpr = values[#values]

	if not valueExpr then
		if noError then  return nil, nil  end
		typeError(state, targetExpr, "Missing a value for %s #%d%s.", targetTerm, i, !!(TARGET_NAME))

	elseif valueExpr.nodeType == !(AST_CALL) and not valueExpr.surroundedByParentheses then
		local call      = valueExpr
		local lastIndex = #values
		local argIndex  = i-lastIndex+1

		local typeInfoForCall = call.inferredType
		local listSig

		if typeInfoForCall.tag == !(TYPE_LIST) then
			listSig = typeInfoForCall
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfoForCall)) -- This would actually be an internal error, right? 2020-07-19
		end

		local typeInfoForOutArg = listSig[argIndex]

		if typeInfoForOutArg then
			-- void
		elseif listSig[1] and listSig[#listSig].tag == !(TYPE_VARARG) then
			typeInfoForOutArg = listSig[#listSig]
		else
			if noError then  return nil, nil  end
			!!(CALL_RETURNS_NOTHING)
		end

		if not typeInfoExpected then  return call, typeInfoForOutArg  end

		local typeInfoForOutArgAdjusted          = adjustTypeToOne(state, call, typeInfoForOutArg, true)
		local wantEnumAndGotLiteralOfCorrectType = false -- Not actually used in this branch.
		!CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(`call`, `typeInfoForOutArg`, `typeInfoForOutArgAdjusted`)

		local calleeName = (call.callee.nodeType == !(AST_IDENTIFIER) and " of '"..call.callee.name.."'" or "")

		typeError(
			state, call,
			"The type of return value #%d%s (%s) does not match the type of %s #%d%s (%s).",
			argIndex, calleeName, getFriendlyTypeInfoName(typeInfoForOutArgAdjusted),
			targetTerm, i, !!(TARGET_NAME), getFriendlyTypeInfoName(typeInfoExpected)
		)

	elseif valueExpr.nodeType == !(AST_VARARG) and not valueExpr.surroundedByParentheses then
		local vararg = valueExpr
		return vararg, vararg.inferredType

	else
		if noError then  return nil, nil  end
		typeError(state, targetExpr, "Missing a value for %s #%d%s.", targetTerm, i, !!(TARGET_NAME))
	end
end



-- inferredTypeNode = createTypeNodeFromInfo( state, typeRepresented, sourceNode, parent )
function _G.createTypeNodeFromInfo(state, typeRepresented, sourceNode, parent)
	local typeNode           = astNewNode(AstType, sourceNode, parent)
	typeNode.inferredType    = state.builtinTypeInfos.Type
	typeNode.representedType = typeRepresented

	local isBuiltin, typeName = isTypeBuiltin(typeRepresented)

	if isBuiltin then
		typeNode.kind     = !(TYPE_KIND_SIMPLE_BUILTIN)
		typeNode.typeName = typeName
		return typeNode
	end

	local tag = typeRepresented.tag

	if tag == !(TYPE_STRUCT) or tag == !(TYPE_ENUM) then
		local structOrEnumInfo     = typeRepresented -- If struct, may be polymorphic.
		typeNode.kind              = !(TYPE_KIND_USER)
		typeNode.typeName          = structOrEnumInfo.name

	elseif tag == !(TYPE_COMPOUND) then
		typeNode.kind              = !(TYPE_KIND_COMPOUND)

	elseif tag == !(TYPE_ARRAY) then
		local arraySig             = typeRepresented
		typeNode.kind              = !(TYPE_KIND_ARRAY)
		typeNode.arrayItemType     = createTypeNodeFromInfo(state, arraySig.itemType, sourceNode, typeNode)

	elseif tag == !(TYPE_FUNCTION) then
		local funcSig              = typeRepresented
		typeNode.kind              = !(TYPE_KIND_FUNCTION)
		-- typeNode.functionHeader = ? -- This is not needed.

	else
		!ifDEBUG `print(getFriendlyTypeInfoName(typeRepresented))`
		errorInternal(state, typeNode, "Incomplete: Handle type group '%s'.", (TYPE_NAMES[tag] or "?"))
	end

	return typeNode
end

local function isTypeOrDoesTypeContainPlaceholder(typeInfo)
	if typeInfo.tag == !(TYPE_PLACEHOLDER) then
		return true

	elseif typeInfo.tag == !(TYPE_COMPOUND) then
		local compound = typeInfo
		return itemWith1(compound, "tag", !(TYPE_PLACEHOLDER)) ~= nil

	elseif typeInfo.tag == !(TYPE_FUNCTION) then
		local funcSig = typeInfo
		for _, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			if isTypeOrDoesTypeContainPlaceholder(argTypeInfo) then  return true  end
		end
		for _, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			if isTypeOrDoesTypeContainPlaceholder(argTypeInfo) then  return true  end
		end
		return false

	else
		return false
	end
end

function _G.simplifyTypeExpression(state, expr, typeRepresented)
	!ASSERT("expr.nodeType ~= "..AST_TYPE)
	!ASSERT("typeRepresented")

	if isTypeOrDoesTypeContainPlaceholder(typeRepresented) then  return  end

	local typeNode = createTypeNodeFromInfo(state, typeRepresented, expr, expr.parent)

	if expr.nodeType == !(AST_IDENTIFIER) then
		local ident          = expr
		typeNode.declaration = ident.declaration
	end

	addUnqueuedChildrenToQueueRecursively(state, typeNode, !(PIPE_INFER))
	moveChildrenToNextRelevantPipe(state, typeNode)

	replaceQueuedNodeAndUnqueueOldTree(state, expr, typeNode)
end

local function simplifyCast(state, cast)
	if cast.expression.nodeType == !(AST_ACCESS) then  return  end -- Cannot simplify views.

	local exprTypeInfo = cast.expression.inferredType
	local castTypeInfo = cast.inferredType

	local parent = cast.parent
	if
		parent.nodeType == !(AST_CONDITIONAL)
		and parent.conditionAndBranchTrue
		and parent.conditionAndBranchTrue ~= parent.condition
		and cast == parent.condition
	then
		-- Simplifying this cast would mess up the output. Example situation:
		-- local x = if myString "a" else "b"
		return
	end

	if exprTypeInfo == castTypeInfo then
		errorInternal(state, cast) -- This should have been simplified away already.

	-- int -> float
	elseif exprTypeInfo.tag == !(TYPE_INT) and castTypeInfo.tag == !(TYPE_FLOAT) then
		!ASSERT("cast.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(cast.expression.value) == 'number'")

		local literal        = astNewNode(AstLiteral, cast, cast.parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = cast.expression.value
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- float -> int
	elseif exprTypeInfo.tag == !(TYPE_FLOAT) and castTypeInfo.tag == !(TYPE_INT) then
		!ASSERT("cast.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(cast.expression.value) == 'number'")

		local literal        = astNewNode(AstLiteral, cast, cast.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = math.modf(cast.expression.value)
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		validateIntegerRange(state, literal.value, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- (numeric) -> bool
	elseif isTypeNumeric(exprTypeInfo) and castTypeInfo.tag == !(TYPE_BOOL) then
		!ASSERT("cast.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(cast.expression.value) == 'number'")

		local literal        = astNewNode(AstLiteral, cast, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = cast.expression.value ~= 0
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- string -> bool
	elseif exprTypeInfo.tag == !(TYPE_STRING) and castTypeInfo.tag == !(TYPE_BOOL) then
		!ASSERT("cast.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(cast.expression.value) == 'string'")

		local literal        = astNewNode(AstLiteral, cast, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = cast.expression.value ~= ""
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- array -> bool
	elseif exprTypeInfo.tag == !(TYPE_ARRAY) and castTypeInfo.tag == !(TYPE_BOOL) then
		local tableNode = followIdentifiersToConstantValue(state, cast.expression)
		assert(tableNode.nodeType == !(AST_TABLE))

		local literal        = astNewNode(AstLiteral, cast, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = tableNode.fields[1] ~= nil -- (Assume the array constructor is valid.)
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- enum -> enumMemberType (int, float, string, bool or Type)
	elseif exprTypeInfo.tag == !(TYPE_ENUM) and isTypeCompatibleWith(state, exprTypeInfo.memberTypeInfo, castTypeInfo, !(STRICT_TYPE_MATCH_NO), cast.expression) then
		local castIsDirect = (castTypeInfo == exprTypeInfo.memberTypeInfo)

		local enumInfo = exprTypeInfo
		local ident    = cast.expression

		assert(ident.nodeType == !(AST_IDENTIFIER)) -- All enums should have been simplified to identifiers.

		!ASSERT `isDeclarationConstant(ident.declaration)`
		local valueExpr = followIdentifiersToConstantValue(state, ident)

		if BUILTIN_TYPE_TAG_TO_LITERAL_TYPE[castTypeInfo.tag] then
			local literal = valueExpr
			if literal.nodeType ~= !(AST_LITERAL) then
				errorInternal(state, literal)
			end

			local literalCopy = astCopy(literal, cast)

			if castIsDirect then
				assert(literalCopy.inferredType == castTypeInfo)

			elseif exprTypeInfo.memberTypeInfo.tag == !(TYPE_INT) and castTypeInfo.tag == !(TYPE_FLOAT) then
				literalCopy.literalType  = !(LITERAL_FLOAT)
				literalCopy.inferredType = castTypeInfo

			else
				errorInternal(
					state, cast,
					"Incomplete: Implicitly cast enum from %s to %s.",
					getFriendlyTypeInfoName(exprTypeInfo.memberTypeInfo),
					getFriendlyTypeInfoName(castTypeInfo)
				)
			end

			replaceQueuedNodeAndUnqueueOldTree(state, cast, literalCopy)
			moveToNextRelevantPipe(state, literalCopy, !(PIPE_INFER))

		elseif castTypeInfo.tag == !(TYPE_TYPE) then
			assert(castIsDirect)

			local typeNode = valueExpr
			assert(typeNode.nodeType == !(AST_TYPE))

			local typeNodeCopy = astCopy(typeNode, cast)

			addUnqueuedChildrenToQueueRecursively(state, typeNodeCopy, !(PIPE_DONE)) -- Only does something if the type has parameters.
			replaceQueuedNodeAndUnqueueOldTree(state, cast, typeNodeCopy)
			moveToNextRelevantPipe(state, typeNodeCopy, !(PIPE_INFER))

		else
			errorInternal(state, cast, "Incomplete: Handle casting enum to %s.", getFriendlyTypeInfoName(castTypeInfo))
		end

	-- enumMemberType -> enum
	elseif castTypeInfo.tag == !(TYPE_ENUM) and exprTypeInfo == castTypeInfo.memberTypeInfo then
		local enumInfo = castTypeInfo
		local decl     = findDeclarationInEnumForValue(state, enumInfo.astNode, cast.expression) or errorInternal(state, cast.expression)
		local ident    = astCopyIdentifier(decl.name, cast, cast.parent, !(IDENT_KIND_LOOSE))

		replaceQueuedNodeAndUnqueueOldTree(state, cast, ident)
		moveToNextRelevantPipe(state, ident, !(PIPE_INFER))

	-- Type -> int
	elseif exprTypeInfo.tag == !(TYPE_TYPE) and castTypeInfo.tag == !(TYPE_INT) then
		local typeRepresented = getTypeRepresentedByExpression(cast.expression) or errorInternal(state, cast)
		local literal         = newLiteral(cast.parent, cast, !(LITERAL_INTEGER), typeRepresented.id, castTypeInfo)

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- (whatever) -> compound
	elseif castTypeInfo.tag == !(TYPE_COMPOUND) then
		typeError(state, cast, "Cannot cast constants to compound types. (Target type is %s)", getFriendlyTypeInfoName(castTypeInfo))

	-- (whatever) -> any
	-- any -> (whatever)
	elseif exprTypeInfo.tag == !(TYPE_ANY) or castTypeInfo.tag == !(TYPE_ANY) then -- Handle this last!
		-- void

	else
		errorInternal(
			state, cast,
			"Incomplete: Handle casting constant from %s to %s.",
			getFriendlyTypeInfoName(exprTypeInfo),
			getFriendlyTypeInfoName(castTypeInfo)
		)
	end
end

local function simplifyUnary(state, unary)
	-- @Incomplete: Simplify these kinds of expressions (including implicit casts): not (str ~= "") => str == ""

	if unary.expression.nodeType == !(AST_ACCESS) then  return  end -- Cannot simplify views.

	local typeInfo = unary.inferredType

	if nil then

	!for _, opArithmetic in ipairs{"+","-"} do
	elseif unary.operation == !(opArithmetic) then
		!ASSERT("unary.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(unary.expression.value) == 'number'")

		local literal = astNewNode(AstLiteral, unary, unary.parent)

		literal.literalType
			=  typeInfo.tag == !(TYPE_INT)   and !(LITERAL_INTEGER)
			or typeInfo.tag == !(TYPE_FLOAT) and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = !!(opArithmetic ~= "+" and opArithmetic or "") unary.expression.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	elseif unary.operation == "not" then
		!ASSERT("unary.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(unary.expression.value) == 'boolean'")

		local literal        = astNewNode(AstLiteral, unary, unary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = not unary.expression.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	elseif unary.operation == "#" then
		local valueExpr = followIdentifiersToConstantValue(state, unary.expression)
		local length    = 0

		if valueExpr.nodeType == !(AST_TABLE) then
			local tableNode = valueExpr

			if tableNode.inferredType.tag == !(TYPE_ARRAY) then
				for _, tableField in ipairs(tableNode.fields) do
					length = math.max(length, tableField.key.value)
				end

			elseif tableNode.inferredType.tag == !(TYPE_TABLE) then
				errorUnhandledNodeType(state, unary)

			else
				errorInternal(state, tableNode)
			end

		elseif valueExpr.nodeType == !(AST_LITERAL) then
			local literal = valueExpr
			!ASSERT("literal.literalType == "..LITERAL_STRING)

			length = #literal.value

		else
			errorUnhandledNodeType(state, valueExpr)
		end

		local literal        = astNewNode(AstLiteral, unary, unary.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = length
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	else
		errorUnhandledNodeType(state, unary)
	end
end

local function simplifyBinary(state, binary)
	local l  = binary.left
	local r  = binary.right
	local op = binary.operation

	if l.nodeType == !(AST_ACCESS) or r.nodeType == !(AST_ACCESS) then  return  end -- Cannot simplify views.

	!local ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS = templateToLua(
		`
			if l.nodeType    ~= $nodeTypeLiteral then  errorInternal()  end
			if r.nodeType    ~= $nodeTypeLiteral then  errorInternal()  end
			if type(l.value) ~= "number"         then  errorInternal()  end
			if type(r.value) ~= "number"         then  errorInternal()  end
		`, {
			nodeTypeLiteral = toLua(AST_LITERAL),
		}
	)

	-- @Incomplete: Simplify these kinds of expressions: (1+x)+2 => (1+2)+x => 3+x
	-- @Incomplete: Simplify these kinds of expressions: 1 + -x => 1 - x
	local typeInfo = binary.inferredType
	local replacement

	if op == "*" and typeInfo.tag == !(TYPE_STRING) then
		local s     = l.value
		local count = r.value

		if l.inferredType.tag == !(TYPE_INT) then
			s, count = count, s
		end

		replacement = newLiteral(binary.parent, binary, !(LITERAL_STRING), s:rep(count), typeInfo)

	!for _, opArithmeticKeepType in ipairs{"+","-","*","^","%"} do
	elseif op == !(opArithmeticKeepType) then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		local literalType
			=  typeInfo.tag == !(TYPE_INT)   and !(LITERAL_INTEGER)
			or typeInfo.tag == !(TYPE_FLOAT) and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		local n = l.value !!(opArithmeticKeepType) r.value -- This should produce the correct result for any combination of int and float.

		replacement = newLiteral(binary.parent, binary, literalType, n, typeInfo)
	!end

	elseif op == "/" then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		replacement = newLiteral(binary.parent, binary, !(LITERAL_FLOAT), l.value/r.value, typeInfo)

	elseif op == "//" then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		replacement = newLiteral(binary.parent, binary, !(LITERAL_INTEGER), math.floor(l.value/r.value), typeInfo)

	!for _, opComparison in ipairs{"<",">","<=",">="} do
	elseif op == !(opComparison) then
		!ASSERT("l.nodeType == "..AST_LITERAL)
		!ASSERT("r.nodeType == "..AST_LITERAL)

		!if DEBUG then
			local lType = type(l.value)
			!ASSERT("lType == type(r.value)")
			!ASSERT("lType == 'number' or lType == 'string'")
		!end

		replacement = newLiteral(binary.parent, binary, !(LITERAL_BOOLEAN), (l.value !!(opComparison) r.value), typeInfo)
	!end

	!for _, opEquality in ipairs{"==","~="} do
	elseif op == !(opEquality) then
		local valueL, valueR

		if l.inferredType.tag == !(TYPE_TYPE) then
			!ASSERT("r.inferredType.tag == "..TYPE_TYPE)
			valueL = getTypeRepresentedByExpression(l) or errorInternal(state, l)
			valueR = getTypeRepresentedByExpression(r) or errorInternal(state, r)

		elseif l.inferredType.tag == !(TYPE_NAMESPACE) then
			!ASSERT("l.inferredType.tag == "..TYPE_NAMESPACE)
			valueL = l.inferredType.scope or errorInternal(state, l, "L")
			valueR = r.inferredType.scope or errorInternal(state, r, "R")

		elseif l.nodeType == !(AST_LITERAL) then
			!ASSERT("r.nodeType == "..AST_LITERAL)
			!ASSERT("type(l.value) == type(r.value)")
			valueL = l.value
			valueR = r.value

		elseif
			l.inferredType.tag == !(TYPE_STRUCT)
			and findInferredPreloadDeclaration(state, l, "SourceCodeLocation", !(TYPE_STRUCT), false) -- @Speed: Cache!
			and l.inferredType == findInferredPreloadDeclaration(state, l, "SourceCodeLocation", !(TYPE_STRUCT), false).valueTypeInfo
		then
			!ASSERT("r.inferredType == l.inferredType")
			valueL = followIdentifiersToConstantValue(state, l).target
			valueR = followIdentifiersToConstantValue(state, r).target

		else
			-- @Robustness: This is probably not fool proof as fallback here.
			valueL = followIdentifiersToConstantValue(state, l)
			valueR = followIdentifiersToConstantValue(state, r)
			!ASSERT("valueL.nodeType == valueR.nodeType")
		end

		replacement = newLiteral(binary.parent, binary, !(LITERAL_BOOLEAN), (valueL !!(opEquality) valueR), typeInfo)
	!end

	!for _, opLogical in ipairs{"and","or"} do
	elseif op == !(opLogical) then
		!ASSERT("l.nodeType == "..AST_LITERAL)
		!ASSERT("r.nodeType == "..AST_LITERAL)
		!ASSERT("type(l.value) == 'boolean'")
		!ASSERT("type(r.value) == 'boolean'")

		replacement = newLiteral(binary.parent, binary, !(LITERAL_BOOLEAN), (l.value !!(opLogical) r.value), typeInfo)
	!end

	elseif op == ".." then
		!ASSERT("l.nodeType == "..AST_LITERAL)
		!ASSERT("r.nodeType == "..AST_LITERAL)
		!ASSERT("type(l.value) == 'string'")
		!ASSERT("type(r.value) == 'string'")

		-- @Speed: Concatenate more than two values at a time. (Maybe the parsing stage need an update.)
		replacement = newLiteral(binary.parent, binary, !(LITERAL_STRING), l.value..r.value, typeInfo)

	else
		errorUnhandledNodeType(state, binary)
	end

	!ASSERT `replacement`
	replaceQueuedNodeAndUnqueueOldTree(state, binary, replacement)

	if replacement.nodeType == !(AST_LITERAL) and replacement.literalType == !(LITERAL_INTEGER) then
		validateIntegerRange(state, replacement.value, replacement)
	end

	moveToNextRelevantPipe(state, replacement, !(PIPE_INFER))
end

function _G.simplifyExpressionIfConstant(state, expr)
	if not isExpressionConstant(state, expr, false) then
		if
			-- :SpecialForeignValueRules
			expr.nodeType == !(AST_IDENTIFIER)
			and isDeclarationConstant(expr.declaration)
			and expr.declaration.value.nodeType == !(AST_FOREIGN)
		then
			local ident       = expr
			local foreign     = ident.declaration.value
			local foreignCopy = astCopy(foreign, ident, ident.parent)

			replaceQueuedNodeAndUnqueueOldTree(state, ident, foreignCopy)
			moveToNextRelevantPipe(state, foreignCopy, !(PIPE_INFER))
		end

	elseif expr.nodeType == !(AST_IDENTIFIER) then
		local ident = expr
		local decl  = ident.declaration or errorInternal(state, ident)
		if not isDeclarationConstant(decl) then  return  end

		local typeInfo = ident.inferredType

		if typeInfo.tag == !(TYPE_ENUM) then
			if ident.name ~= decl.name.name then
				-- @Cleanup: Is this necessary? Can't we just do ident.name=decl.name.name?
				local copy = astCopyIdentifier(decl.name, ident, ident.parent, !(IDENT_KIND_LOOSE))
				replaceQueuedNodeAndUnqueueOldTree(state, ident, copy)
				moveToNextRelevantPipe(state, copy, !(PIPE_INFER))
			end
			return
		end

		local typeInfoRepresented = decl.valueTypeInfo

		if typeInfoRepresented then
			simplifyTypeExpression(state, ident, typeInfoRepresented)
			return
		end

		!ASSERT("typeInfo.tag ~= "..TYPE_TYPE)
		if not isTypeSimple(typeInfo) then  return  end

		if decl.value.nodeType == !(AST_ACCESS) then  return  end -- This will create a constant lookup (AKA view).

		-- At this point we should have a literal to copy. Hopefully the expression we copy
		-- has been simplified into a literal if it wasn't a literal to begin with.
		local literal = decl.value
		if literal.nodeType ~= !(AST_LITERAL) then
			-- astPrintTree(state.globalScope)
			errorInternal(state, literal)
		end

		local copy = astCopy(literal, ident, ident.parent)
		replaceQueuedNodeAndUnqueueOldTree(state, ident, copy)
		moveToNextRelevantPipe(state, copy, !(PIPE_INFER))

	elseif expr.nodeType == !(AST_CAST) then
		simplifyCast(state, expr)
	elseif expr.nodeType == !(AST_UNARY) then
		simplifyUnary(state, expr)
	elseif expr.nodeType == !(AST_BINARY) then
		simplifyBinary(state, expr)

	else
		-- void
	end
end



-- Values of simple types are non-objects (e.g. ints) in the outputted Lua code.
-- Note: Glóa types are represented as ints in Lua and thus are 'simple'.
function _G.isTypeSimple(typeInfo)
	local tag = typeInfo.tag
	return !!(CONST_SET{
		TYPE_BOOL,
		TYPE_INT,
		TYPE_NONE,
		TYPE_FLOAT,
		TYPE_STRING,
		TYPE_TYPE,
		TYPE_ENUM -- All enum member types are simple.
	})[tag] or false
end

function _G.isTypeNumeric(typeInfo)
	return !!(CONST_SET{ TYPE_INT, TYPE_FLOAT })[typeInfo.tag] or false
end

function _G.isTypeTableLike(typeInfo)
	return !!(CONST_SET{ TYPE_TABLE, TYPE_STRUCT, TYPE_ARRAY })[typeInfo.tag] or false
end

function _G.isTypePublic(typeInfo)
	local tag = typeInfo.tag
	if !!(CONST_SET{ TYPE_LIST, TYPE_NAMESPACE, TYPE_PLACEHOLDER, TYPE_VARARG })[tag] then  return false  end
	if !!(CONST_SET{ TYPE_FUNCTION, TYPE_STRUCT })[tag] and typeInfo.isPolymorphic    then  return false  end
	return true
end

--
-- isCompatible, compatibilityScore = isTypeCompatibleWith   ( state, typeToCheck, otherType, strictTypeMatch, nodeForError )
-- isCompatible                     = isAnyTypeCompatibleWith( state, typeToCheck, otherType, strictTypeMatch, nodeForError ) -- If typeToCheck is an enum, check each compound item.
-- strictTypeMatch                  = STRICT_TYPE_MATCH_NO | STRICT_TYPE_MATCH_YES
--
-- strictTypeMatch ought to be yes for arguments of morphed polymorphic functions that were baked or came from a placeholder argument.
-- (Not sure if the baked state matter - maybe just the placeholder state.)
--
function _G.isTypeCompatibleWith(state, typeToCheck, otherType, strictTypeMatch, nodeForError)
	!ASSERT `type(typeToCheck)     == "table"`
	!ASSERT `type(otherType)       == "table"`
	!ASSERT `type(strictTypeMatch) == "number"`
	!ASSERT `type(nodeForError)    == "table"`

	if typeToCheck == otherType then  return true, !(TYPE_COMPATABILITY_SAME)  end

	local typeToCheckTag = typeToCheck.tag
	local otherTypeTag   = otherType.tag

	-- Namespaces are never compatible with anything but themselves as they're not allowed in most places.
	if typeToCheckTag == !(TYPE_NAMESPACE) or otherTypeTag == !(TYPE_NAMESPACE) then  return false, 0  end

	-- Placeholders cannot actually be checked - we just say they are compatible with
	-- everything (except namespaces) until the situation is handled elsewhere.
	if typeToCheckTag == !(TYPE_PLACEHOLDER) or otherTypeTag == !(TYPE_PLACEHOLDER) then  return true, !(TYPE_COMPATABILITY_LOWEST)  end

	-- Everything is compatible with the 'any' type. The user better know what they're doing!
	if otherTypeTag == !(TYPE_ANY) then  return true, !(TYPE_COMPATABILITY_ANY)  end

	if strictTypeMatch == !(STRICT_TYPE_MATCH_NO) then
		-- Ints are always compatible with floats (but the opposite is false).
		-- This should be safe as all numbers are 64-bit floats in Lua 5.1 (I think).
		if typeToCheckTag == !(TYPE_INT) and otherTypeTag == !(TYPE_FLOAT) then  return true, !(TYPE_COMPATABILITY_COMPATIBLE)  end

		-- Substructs are compatible with base structs.
		if typeToCheckTag == !(TYPE_STRUCT) and otherTypeTag == !(TYPE_STRUCT) then
			if doesStructInherit(typeToCheck, otherType) then  return true, !(TYPE_COMPATABILITY_COMPATIBLE)  end
			return false, 0
		end

		-- Structs and arrays are outputted as tables in Lua, so they are always compatible with tables in Glóa.
		if otherTypeTag == !(TYPE_TABLE) and !!(CONST_SET{ TYPE_STRUCT, TYPE_ARRAY })[typeToCheckTag] then
			return true, !(TYPE_COMPATABILITY_SAME_IN_LUA)
		end

		-- Enums are compatible with their member types.
		if typeToCheckTag == !(TYPE_ENUM) then
			local isCompatible, compatibilityScore = isTypeCompatibleWith(state, typeToCheck.memberTypeInfo, otherType, !(STRICT_TYPE_MATCH_NO), nodeForError)
			return isCompatible, compatibilityScore*!(TYPE_COMPATABILITY_INDIRECT/TYPE_COMPATABILITY_SAME)
		end

		if typeToCheckTag == !(TYPE_COMPOUND) then
			-- All compound items has to match the target. (If only one item matches, an explicit cast is needed.)
			local compoundToCheck = typeToCheck
			for _, compoundItemToCheck in ipairs(compoundToCheck) do
				if not isTypeCompatibleWith(state, compoundItemToCheck, otherType, !(STRICT_TYPE_MATCH_NO), nodeForError) then  return false, 0  end
			end
			return true, !(TYPE_COMPATABILITY_COMPOUND)
		end

		if otherTypeTag == !(TYPE_COMPOUND) then
			-- typeToCheck has to match at least one compound item.
			local otherCompound = otherType
			for _, otherCompoundItem in ipairs(otherCompound) do
				if isTypeCompatibleWith(state, typeToCheck, otherCompoundItem, !(STRICT_TYPE_MATCH_NO), nodeForError) then  return true, !(TYPE_COMPATABILITY_COMPOUND)  end
			end
			return false, 0
		end
	end

	-- Array compatability completely depends on the item type.
	if otherTypeTag == !(TYPE_ARRAY) then
		if typeToCheckTag == !(TYPE_ARRAY) then
			!if DEBUG then
				if not typeToCheck.itemType then  errorInternal(state, nodeForError, getFriendlyTypeInfoName(typeToCheck))  end
				if not otherType.itemType   then  errorInternal(state, nodeForError, getFriendlyTypeInfoName(otherType))    end
			!end
			local isCompatible, compatibilityScore = isTypeCompatibleWith(state, typeToCheck.itemType, otherType.itemType, strictTypeMatch, nodeForError)
			return isCompatible, compatibilityScore

		elseif typeToCheckTag == !(TYPE_STRUCT) and typeToCheck.kind == !(STRUCT_KIND_ARRAY) then -- We allow array-like structs even if strictTypeMatch is yes.
			!if DEBUG then
				if not typeToCheck.valueType then  errorInternal(state, nodeForError, getFriendlyTypeInfoName(typeToCheck))  end
				if not otherType.itemType    then  errorInternal(state, nodeForError, getFriendlyTypeInfoName(otherType))    end
			!end
			local isCompatible, compatibilityScore = isTypeCompatibleWith(state, typeToCheck.valueType, otherType.itemType, strictTypeMatch, nodeForError)
			return isCompatible, compatibilityScore
		end

		return false, 0
	end

	return false, 0
end

function _G.isAnyTypeCompatibleWith(state, typeToCheck, otherType, strictTypeMatch, nodeForError)
	if typeToCheck.tag == !(TYPE_COMPOUND) then
		for _, compoundItem in ipairs(typeToCheck) do
			if isTypeCompatibleWith(state, compoundItem, otherType, strictTypeMatch, nodeForError) then  return true  end
		end
		return false
	else
		return (isTypeCompatibleWith(state, typeToCheck, otherType, strictTypeMatch, nodeForError))
	end
end

function _G.doesStructInherit(structInfoToCheck, otherStructInfo)
	!ASSERT `otherStructInfo`

	if not structInfoToCheck.astNode.inherits then  return false  end

	for _, typeExpr in ipairs(structInfoToCheck.astNode.inherits) do
		local structInfoInherited = getTypeRepresentedByExpression(typeExpr)

		if structInfoInherited == otherStructInfo or doesStructInherit(structInfoInherited, otherStructInfo) then
			return true
		end
	end

	return false
end

function _G.compareIdsOfTypes(a, b)
	return a.id < b.id
end

-- singleTypeInfo = adjustTypeToOne( state, expressionForError, typeInfo [, adjustVarargToIncludeNil=false ] )
-- Types that aren't single: TypeInfoVararg and TypeInfoList.
do
	local function adjustVarargItemTypeToOneAndToIncludeNil(state, itemType)
		local tag = itemType.tag
		if tag == !(TYPE_ANY) or tag == !(TYPE_NONE) then  return itemType  end

		local nilType = state.builtinTypeInfos.none

		if tag ~= !(TYPE_COMPOUND) then
			local twoTypes = !!(STATIC{})
			if itemType.id < nilType.id then
				twoTypes[1] = itemType
				twoTypes[2] = nilType
			else
				twoTypes[1] = nilType
				twoTypes[2] = itemType
			end
			return getTypeInfoForCompoundType(state, twoTypes, false)
		end

		local compound = itemType
		if indexOf(compound, nilType) then  return compound  end

		return getTypeInfoForCompoundType(state, {nilType, unpack(compound)}, true)
	end

	function _G.adjustTypeToOne(state, exprForError, typeInfo, adjustVarargToIncludeNil)
		if typeInfo.tag == !(TYPE_LIST) then
			typeInfo = typeInfo[1] or typeError(state, exprForError, "Function call returns nothing. (Expected at least one value.)") -- Note: "Nothing" is not the same as vararg of zero length.
		end

		if typeInfo.tag == !(TYPE_VARARG) then
			typeInfo = typeInfo.itemType
			if adjustVarargToIncludeNil then
				typeInfo = adjustVarargItemTypeToOneAndToIncludeNil(state, typeInfo)
			end
		end

		return typeInfo
	end
end



local function getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError)
	!(
	local NO_EXPECTATION = 'typeError(state, nodeForError, "Could not determine the type of this %s.", expectantTerm)'
	if DEBUG and 1==1 then
		NO_EXPECTATION = "astPrintTree(state.globalScope) ; "..NO_EXPECTATION
	end
	)

	if node.nodeType == !(AST_TABLE) then
		-- Detect constructors that look like arrays.
		local tableNode   = node
		local tableField1 = tableNode.fields[1]
		if not tableField1 then  !!(NO_EXPECTATION)  end

		local fieldKey = tableField1.key

		if fieldKey.nodeType == !(AST_LITERAL) and fieldKey.literalType == !(LITERAL_INTEGER) then
			local fieldValue = tableField1.value
			if fieldValue.nodeType == !(AST_TABLE) then  !!(NO_EXPECTATION)  end

			if not fieldValue.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `fieldValue`, nil, `nil`)
			end

			local typeInfo = adjustTypeToOne(state, fieldValue, fieldValue.inferredType)
			return getTypeInfoForArray(state, typeInfo)

		elseif not fieldKey.inferredType then
			if fieldKey.nodeType ~= !(AST_TABLE) then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `fieldKey`, nil, `nil`)
			end
		end
	end

	!!(NO_EXPECTATION)
end

-- Returns nil if we're now waiting for something. Errors on failure.
function _G.getExpectedTypeInfo(state, node, strict, expectantTerm, nodeForError)
	local parentNodeType = node.parent.nodeType

	if parentNodeType == !(AST_ASSIGNMENT) then
		local assignment = node.parent
		local i          = indexOf(assignment.values, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		local decl = (assignment.forDeclaration and assignment.declarations[i] or nil)

		if decl then
			if decl.inferredType then
				return decl.inferredType
			elseif not decl.type then
				return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			elseif not decl.type.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
			else
				return requireTypeRepresentedByExpression(state, decl.type)
			end

		else
			if not assignment.targets[i].inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `assignment.targets[i]`, nil, `nil`)
			end
			return assignment.targets[i].inferredType
		end

	--[[ Is this older than the above? What's going on? @Cleanup!
	elseif parentNodeType == !(AST_ASSIGNMENT) then
		local assignment = node.parent
		local i          = indexOf(assignment.values, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		local decl = (assignment.forDeclaration and assignment.declarations[i] or nil)

		if decl then
			if decl.inferredType then
				return decl.inferredType

			elseif decl.parent.nodeType == !(AST_ENUM) then
				local enum     = decl.parent
				local enumInfo = enum.representedType
				if enumInfo then
					return enumInfo
				elseif enum.memberType or decl ~= enum.declarations[1] then
					-- @Incomplete: This doesn't work right now as enums wait for their members. Enums need to be more like structs!
					!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `enum`, nil, `nil`)
				else
					return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
				end

			elseif decl.type then
				if not decl.type.inferredType then
					!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
				else
					return requireTypeRepresentedByExpression(state, decl.type)
				end

			else
				return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			end

		else
			-- @Incomplete: Get type from assignment target.
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end
	]]

	elseif parentNodeType == !(AST_DECLARATION) then
		local decl = node.parent
		if node ~= decl.value then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		if decl.inferredType then
			return decl.inferredType

		elseif decl.parent.nodeType == !(AST_ENUM) then
			local enum     = decl.parent
			local enumInfo = enum.representedType
			if enumInfo then
				return enumInfo
			elseif enum.memberType or decl ~= enum.declarations[1] then
				-- @Incomplete: This doesn't work right now as enums wait for their members. Enums need to be more like structs!
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `enum`, nil, `nil`)
			else
				return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			end

		elseif decl.type then
			if not decl.type.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
			else
				return requireTypeRepresentedByExpression(state, decl.type)
			end

		elseif node.nodeType == !(AST_TABLE) then
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))

		else
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end

	elseif parentNodeType == !(AST_CAST) then
		local cast = node.parent
		if node ~= cast.expression then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		if not cast.targetType.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `cast.targetType`, nil, `nil`)
		end

		return requireTypeRepresentedByExpression(state, cast.targetType)

	elseif parentNodeType == !(AST_BINARY) then
		local binary = node.parent
		local other  = node == binary.left and binary.right or binary.left

		if not other.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `other`, nil, `nil`)
		end

		return other.inferredType

	elseif parentNodeType == !(AST_TABLE) then
		local tableNode = node.parent
		if not tableNode.inferredType then
			-- Note: Tables will always get inferred before child tables.
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `tableNode`, nil, `nil`)
		end

		local tableField = nil
		local isKey      = false

		for _, _tableField in ipairs(tableNode.fields) do
			if node == _tableField.key then
				isKey      = true
				tableField = _tableField
				break
			elseif node == _tableField.value then
				tableField = _tableField
				break
			end
		end

		!ASSERT `tableField`

		if tableNode.inferredType.tag == !(TYPE_TABLE) then
			return state.builtinTypeInfos.any

		elseif tableNode.inferredType.tag == !(TYPE_ARRAY) then
			if isKey then  return state.builtinTypeInfos.int  end

			local arraySig = tableNode.inferredType
			return arraySig.itemType

		elseif tableNode.inferredType.tag == !(TYPE_STRUCT) then
			if isKey then  return state.builtinTypeInfos.string  end

			local structInfo = tableNode.inferredType
			if not structInfo.hasMembers then
				!DEPEND_AND_RETURN(`node`, DEPEND_TYPE_MEMBERS_READY, `structInfo`, nil, `nil`)
			end

			local memberLiteral = tableField.key
			if not memberLiteral.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `memberLiteral`, nil, `nil`)
			end

			local memberName = memberLiteral.value
			local member     = itemWith1(structInfo.members, "name", memberName)

			if not member then
				typeError2(state,
					memberLiteral,      F("%s has no member '%s'.", getFriendlyTypeInfoName(structInfo), memberName),
					structInfo.astNode, F("...here is the struct.")
				)
			end

			return member.typeInfo

		else
			errorInternal(state, tableNode, getFriendlyTypeInfoName(tableNode.inferredType))
		end

	elseif parentNodeType == !(AST_RETURN) then
		local returnNode = node.parent

		if returnNode.runDirective then
			return getExpectedTypeInfo(state, returnNode.runDirective, strict, expectantTerm, nodeForError)
		end

		local i = indexOf(returnNode.values, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		local lambda  = getLambda(returnNode)
		local funcSig = lambda.inferredType

		if not funcSig then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `lambda`, nil, `nil`)
		end

		local argTypesOut = funcSig.argumentTypesOut
		local argTypeInfo = argTypesOut[i]

		if
			(not argTypeInfo and argTypesOut[1] and argTypesOut[#argTypesOut].tag == !(TYPE_VARARG))
			or (argTypeInfo and argTypeInfo.tag == !(TYPE_VARARG))
		then
			local varargSig = argTypeInfo or argTypesOut[#argTypesOut]
			argTypeInfo     = varargSig.itemType
		end

		-- Note: We don't need to get too fancy with validation here as the return is validated later.
		if not argTypeInfo then
			typeError(state, returnNode, "Too many values specified for return.")
		end

		return argTypeInfo

	elseif parentNodeType == !(AST_CONDITIONAL) then
		local conditional = node.parent
		local branchTrue  = conditional.branchTrue -- Note: We don't fall back to conditionAndBranchTrue here. (See :DoNotExpectBoolCondition)
		local branchFalse = conditional.branchFalse
		local typeInfo

		if node == branchTrue then
			typeInfo = branchFalse.inferredType
			if not typeInfo then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `branchFalse`, nil, `nil`)
			end

		elseif node == branchFalse then
			branchTrue = branchTrue or conditional.conditionAndBranchTrue

			typeInfo = branchTrue.inferredType
			if not typeInfo then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `branchTrue`, nil, `nil`)
			end

		else
			assert(node == conditional.condition)
			-- Note: We don't return bool here, even though it's expected,
			-- because it would make NULL seem valid (and contructors, though
			-- those have additional checking). :DoNotExpectBoolCondition
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end

		return typeInfo

	elseif parentNodeType == !(AST_SWITCH) then
		local switch = node.parent
		if node == switch.value then
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end

		typeInfo = switch.value.inferredType
		if not typeInfo then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `switch.value`, nil, `nil`)
		end

		return typeInfo

	elseif parentNodeType == !(AST_ACCESS) then
		local access = node.parent
		if node == access.object then
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end

		local objType = access.object.inferredType
		if not objType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `access.object`, nil, `nil`)
		end

		if objType.tag == !(TYPE_TABLE) then
			return state.builtinTypeInfos.any

		elseif objType.tag == !(TYPE_ENUM) then
			return objType

		elseif objType.tag == !(TYPE_STRUCT) then
			local structInfo = objType
			if not structInfo.hasMembers then
				!DEPEND_AND_RETURN(`node`, DEPEND_TYPE_MEMBERS_READY, `structInfo`, nil, `nil`)
			end

			if structInfo.kind == !(STRUCT_KIND_ARRAY) then
				if not structInfo.members[1] then
					return state.builtinTypeInfos.int
				else
					-- void  We actually expect int|string, but we don't want to generate a compound type here - we always want a specific type to be expected!
				end

			elseif structInfo.kind == !(STRUCT_KIND_TABLE) then
				if not structInfo.members[1] then
					return structInfo.keyType
				elseif structInfo.keyType.tag == !(TYPE_STRING) then
					return state.builtinTypeInfos.string -- We shouldn't get here as you cannot combine having members and having !key be string.
				else
					-- void  We actually expect structInfo.keyType|string, but we don't want to generate a compound type here - we always want a specific type to be expected!
				end

			elseif structInfo.kind == !(STRUCT_KIND_NORMAL) then
				return state.builtinTypeInfos.string
			end

			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))

		else
			-- !ifDEBUG `print(getFriendlyTypeInfoName(objType))`
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end

	elseif strict then
		return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))

	elseif parentNodeType == !(AST_CALL) then
		local call = node.parent
		local i    = indexOf(call.arguments, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		local calleeTypeInfo = call.callee.inferredType
		if not calleeTypeInfo then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `call.callee`, nil, `nil`)
		end

		if not call.inferredType and call.callee.nodeType == !(AST_IDENTIFIER) and call.callee.declaration.overloadOf then
			-- Circular dependency:
			-- Overloaded and polymorphic calls must have all args inferred before being valid,
			-- and table constructors etc. must know the exact function being called.
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			--[[
			typeError(
				state, node, !(
					"Circular dependency: Call to overloaded function '%s' is waiting for this argument, but the argument is also waiting for the call to finish."
					.." Use a cast to specify what type this value is to solve the situation."
				),
				call.callee.name
			)
			--]]
		end

		if calleeTypeInfo.tag == !(TYPE_FUNCTION) then
			-- void
		elseif calleeTypeInfo.tag == !(TYPE_TYPE) then
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		else
			!ifDEBUG `astPrint(call.callee)`
			errorInternal(state, node, getFriendlyTypeInfoName(calleeTypeInfo))
		end

		local argTypesIn  = calleeTypeInfo.argumentTypesIn
		local argTypeInfo = argTypesIn[i]

		if
			(argTypeInfo and argTypeInfo.tag == !(TYPE_VARARG))
			or (not argTypeInfo and argTypesIn[1] and argTypesIn[#argTypesIn].tag == !(TYPE_VARARG))
		then
			local varargSig = argTypeInfo or argTypesIn[#argTypesIn]
			argTypeInfo     = varargSig.itemType
		end

		-- Note: We don't need to get too fancy with validation here as the call is validated later.
		if not argTypeInfo then
			!ifDEBUG `astPrintTree(call)`
			typeError(state, call, "Too many arguments specified for call.")
		end

		if argTypeInfo.tag == !(TYPE_PLACEHOLDER) then
			-- (See above circular dependency note.)
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			--[[
			typeError(
				state, node, !(
					"Circular dependency: Call to polymorphic function%s is waiting for this argument, but the argument is also waiting for the call to finish."
					.." Use a cast to specify what type this value is to solve the situation."
				),
				(call.callee.nodeType == !(AST_IDENTIFIER) and F(" '%s'", call.callee.name) or "")
			)
			--]]
		end

		return argTypeInfo

	else
		return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
	end
	errorInternal()
end



-- Note: The expression must be constant!
function _G.followIdentifiersToConstantValue(state, constExpr0)
	local constExpr = constExpr0

	while constExpr.nodeType == !(AST_IDENTIFIER) do
		local decl = constExpr.declaration
		if not decl then
			typeError2(state,
				constExpr,  F("Internal error: Missing declaration reference for '%s'.", constExpr.name),
				-- constExpr,  F("Internal error: Missing declaration reference for '%s'. (There may possibly be an undeclared identifier involved or a circular dependency.)", constExpr.name),
				constExpr0, F("...here is the initial identifier.")
			)
		end

		constExpr = decl.value or errorInternal(state, decl, "Missing value for declaration which is expected to be constant.")

		if constExpr == constExpr0 then
			-- !ifDEBUG `astPrintTree(decl)`
			-- !ifDEBUG `where(state, decl)`
			typeError2(state,
				constExpr, F("Recursive constant identifier."),
				decl,      F("...here is the declaration.")
			)
		end
	end

	return constExpr
end



function _G.wrapInImplicitCast(state, nodeToWrap, resultingTypeInfo, addToInferPipe)
	local cast        = astNewNode(AstCast, nodeToWrap, nodeToWrap.parent)
	cast.isImplicit   = true
	cast.inferredType = resultingTypeInfo
	pokeAndQueueUnqueuedNodeIntoTree(state, nodeToWrap, cast, cast,"expression", (addToInferPipe and !(PIPE_INFER) or !(PIPE_READY)))
	return cast
end



local EXPRESSION_EXPECTED = !(Set{
	AST_ACCESS,
	AST_ASSIGNMENT,
	AST_BAKE,
	AST_BINARY,
	AST_CALL,
	AST_CAST,
	AST_CONDITIONAL,
	AST_DEBUG,
	AST_VARIANT_OF,
	AST_RETURN,
	AST_RUN, -- Good?
	AST_TABLE,
	AST_TYPE,
	AST_TYPE_OF,
	AST_UNARY,
	AST_USING,
})
local EXPRESSION_NOT_EXPECTED = !(Set{
	AST_ARGUMENT,
	AST_ARGUMENTS,
	AST_BLOCK,
	AST_DEFER,
	AST_ENUM,
	AST_FILE_SCOPE,
	AST_GLOBAL_SCOPE,
	AST_LAMBDA,
	AST_NAMESPACE,
	AST_STRUCT,
})

-- Used by AstRun.
function _G.isAnExpressionExpected(state, node)
	local parent         = node.parent
	local parentNodeType = parent.nodeType

	if EXPRESSION_EXPECTED[parentNodeType] then
		return true
	elseif EXPRESSION_NOT_EXPECTED[parentNodeType] then
		return false
	elseif parentNodeType == !(AST_DECLARATION) then
		return node == parent.name or node == parent.type or node == parent.value or (parent.notes and indexOf(parent.notes, node)) ~= nil
	elseif parentNodeType == !(AST_FOR) then
		return node ~= parent.body
	elseif !!(CONST_SET{ AST_IF, AST_STATIC_IF, AST_WHILE })[parentNodeType] then
		return node == parent.condition
	else
		errorUnhandledNodeType(state, node.parent)
	end
end



-- Note: The expressions must already be inferred!
function _G.areConstantTreesEqual(state, expr1, expr2)
	expr1 = followIdentifiersToConstantValue(state, expr1)
	expr2 = followIdentifiersToConstantValue(state, expr2)

	if expr1 == expr2 then
		return true
	elseif expr1.nodeType ~= expr2.nodeType then
		return false
	elseif expr1.nodeType == !(AST_LITERAL) then
		return expr1.literalType == expr2.literalType and expr1.value == expr2.value
	elseif expr1.nodeType == !(AST_TYPE) then
		return expr1.representedType.id == expr2.representedType.id
	else
		errorUnhandledNodeType(state, expr1)
	end
end



-- valueExpression = getDeclarationValue( declaration [, fallBackToLastAssignmentValue=false ] )
function _G.getDeclarationValue(decl, fallBackToLastAssignmentValue)
	return decl.value or decl.assignment and (
		decl.assignment.values[decl.assignmentIndex]
		or (fallBackToLastAssignmentValue and getLast(decl.assignment.values) or nil)
	)
end

function _G.isDeclarationGlobal(decl)
	return decl.kind == !(DECL_KIND_EXPORT_CONST) and decl.parent.nodeType == !(AST_FILE_SCOPE) and not decl.parent.isModule
end

function _G.isDeclarationConstant(decl)
	return decl.kind == !(DECL_KIND_LOCAL_CONST) or decl.kind == !(DECL_KIND_EXPORT_CONST)
end
function _G.isDeclarationImperative(decl)
	return not isDeclarationConstant(decl)
end
function _G.isDeclarationStatic(decl)
	return decl.kind == !(DECL_KIND_LOCAL_CONST) or decl.kind == !(DECL_KIND_EXPORT_CONST) or decl.kind == !(DECL_KIND_STATIC)
end
function _G.isDeclarationWritable(decl)
	return decl.kind == !(DECL_KIND_LOCAL_VAR) or decl.kind == !(DECL_KIND_EXPORT_VAR) or decl.kind == !(DECL_KIND_STATIC)
end
function _G.isDeclarationExported(decl)
	return decl.kind == !(DECL_KIND_EXPORT_VAR) or decl.kind == !(DECL_KIND_EXPORT_CONST)
end

-- Note: This function does not check what scope the declaration is in!
-- The scope may require the value to be constant even if this function returns false.
function _G.shouldDeclarationValueDefinitivelyBeConstant(decl)
	return not isDeclarationWritable(decl)
end



--[[
function _G.getOverloadBase(decl)
	return decl.overloadOf -- We currently don't keep any chains. 2020-06-12

	-- decl = decl.overloadOf
	-- if not decl then  return nil  end

	-- while decl.overloadOf and decl.overloadOf ~= decl do
	-- 	decl = decl.overloadOf
	-- end

	-- return decl
end
--]]



-- Determine whether calls or varargs should adjust to one.
function _G.areMultipleValuesEnabledAtPosition(state, node)
	local parentNodeType = node.parent.nodeType

	if parentNodeType == !(AST_DECLARATION) then
		local decl = node.parent
		return node == decl.name

	elseif parentNodeType == !(AST_ASSIGNMENT) then
		local assignment = node.parent
		return node.queued.container == assignment.values and not assignment.values[node.queued.key+1]

	elseif parentNodeType == !(AST_CALL) then
		local call = node.parent
		return node.queued.container == call.arguments and not call.arguments[node.queued.key+1]

	elseif parentNodeType == !(AST_RETURN) then
		local returnNode = node.parent
		return node.queued.container == returnNode.values and not returnNode.values[node.queued.key+1]

	elseif parentNodeType == !(AST_TABLE) then
		local tableNode = node.parent
		if tableNode.trailingExpression then  return node == tableNode.trailingExpression  end

		-- Predict what tableNode.trailingExpression may be when the table infers (if anything).
		local lastTableField = getLast(tableNode.fields)
		return lastTableField ~= nil and lastTableField.keyIsGenerated and node == lastTableField.value

	elseif parentNodeType == !(AST_FOR) then
		local forLoop = node.parent
		return node.queued.container == forLoop.expressions

	elseif parentNodeType == !(AST_ACCESS) then
		local access = node.parent
		return node == access.object

	elseif parentNodeType == !(AST_UNARY) then
		local unary = node.parent
		return node.nodeType == !(AST_VARARG) and unary.operation == "#"

	elseif !!(CONST_SET{ AST_TYPE, AST_VARIANT_OF, AST_TYPE_OF, AST_TYPE_INFO, AST_DEBUG })[parentNodeType] then
		return true -- These are static expressions. They don't care about resulting values of any subexpressions - only about the subexpressions themselves.

	elseif isScope(node.parent) then
		return true -- We don't really care about statement-level nodes.

	else
		return false
	end
end



-- validateIntegerRange( state, number [, nodeForError ] )
function _G.validateIntegerRange(state, n, nodeForError)
	if n == math.floor(n) and n ~= n+1 and n ~= n-1 then -- Not perfect, but good enough for now. 2020-06-05
		-- void
	elseif nodeForError then
		typeError(state, nodeForError, "Integer is out of range. (%s)", n)
	else
		errorLine(nil, "Integer is out of range. (%s)", n)
	end
end


