--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	areTreesEqual
	checkBinaryOperation
	createTypeNodeFromInfo
	findDeclaration, findPublicDeclarationInScope, findMemberDeclaration, findDynamicMemberDeclaration, isDeclarationVisibleToNode, printDeclarationChain
	followIdentifiersToConstantValue
	getAssignmentValue
	getClosestScope, getClosestScopeForDeclaration, isScope, isScopeDeclarative, isScopeImperative
	getDeclarationValue, isDeclarationGlobal
	getLambda
	inferNode, queueForReinfer
	isExpressionConstant
	isPartOfAnyDeclaration
	isTypeSimple, isTypeNumeric, isTypeTableLike, isTypeCompatibleWith, doesStructInherit, adjustTypeToOne
	newTypeInfo, isTypeBuiltin, getTypeInfo*
	simplifyExpressionIfConstant, simplifyTypeExpression
	typeError, typeErrorAfter, typeError2, typeMessage
	wrapInImplicitCast

--============================================================]]



!(
_G.typeTags        = {}
local typeTagNames = {}

local function structTypeInfo(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			local tag         = itemWith1(fields._overrides, 1, "tag")[2] or error()
			typeTags[name]    = tag
			typeTagNames[tag] = name:gsub("^TypeInfo", ""):lower()
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_TypeInfo"{
	{`tag`, 0}, -- This is like a "type of type info". The word "type" is used in so many places so we call it "tag" here to make it less confusing...
	{`id`,  0},
}

local !structTypeInfo"TypeInfoAny:_TypeInfo"   {_overrides={{`tag`,1}}}
local !structTypeInfo"TypeInfoBool:_TypeInfo"  {_overrides={{`tag`,2}}}
local !structTypeInfo"TypeInfoInt:_TypeInfo"   {_overrides={{`tag`,3}}}
local !structTypeInfo"TypeInfoNone:_TypeInfo"  {_overrides={{`tag`,4}}}
local !structTypeInfo"TypeInfoFloat:_TypeInfo" {_overrides={{`tag`,5}}}
local !structTypeInfo"TypeInfoString:_TypeInfo"{_overrides={{`tag`,6}}}
local !structTypeInfo"TypeInfoTable:_TypeInfo" {_overrides={{`tag`,7}}}
local !structTypeInfo"TypeInfoType:_TypeInfo"  {_overrides={{`tag`,8}}}

local !structTypeInfo"TypeInfoVoid:_TypeInfo"       {_overrides={{`tag`,0}}}
local !structTypeInfo"TypeInfoPlaceholder:_TypeInfo"{_overrides={{`tag`,9}}}

_G.!(local )!!SIMPLE_TYPE_TAG = {
	-- These small type infos don't have any extra information.
	[typeTags.TypeInfoAny]    = true,
	[typeTags.TypeInfoBool]   = true,
	[typeTags.TypeInfoInt]    = true,
	[typeTags.TypeInfoNone]   = true,
	[typeTags.TypeInfoFloat]  = true,
	[typeTags.TypeInfoString] = true,
	[typeTags.TypeInfoTable]  = true,
	[typeTags.TypeInfoType]   = true,
}

local !structTypeInfo"TypeInfoArray:_TypeInfo"{
	_overrides={{`tag`,10}},
	{`itemType`, nil}, -- TypeInfo
}

local !structTypeInfo"TypeInfoVararg:_TypeInfo"{
	_overrides={{`tag`,11}},
	{`itemType`, nil}, -- TypeInfo
}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{ -- AKA function signature.
	_overrides={{`tag`,12}},
	{`argumentTypesIn`,      {}}, -- []TypeInfo  @Cleanup: Use TypeInfoList here?
	{`argumentTypesOut`,     {}}, -- []TypeInfo  @Cleanup: Use TypeInfoList here?
	{`requiredArgumentsIn`,  {}}, -- []bool
	{`requiredArgumentsOut`, {}}, -- []bool
	{`isPolymorphic`,        false},
}

local !struct"TypeInfoStructMember"{
	{`name`,     ""},
	{`typeInfo`, nil},
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	_overrides={{`tag`,13}},

	{`astNode`,       nil}, -- AstStruct
	{`name`,          ""},  -- Filled in during definition.

	{`kind`,          STRUCT_KIND_NORMAL}, -- STRUCT_KIND_NORMAL|STRUCT_KIND_TABLE|STRUCT_KIND_ARRAY
	{`keyType`,       nil}, -- TypeInfo  Used if kind==STRUCT_KIND_TABLE.
	{`valueType`,     nil}, -- TypeInfo  Used if kind==STRUCT_KIND_TABLE or kind==STRUCT_KIND_ARRAY.

	{`members`,       {}},  -- []TypeInfoStructMember
	{`hasMembers`,    false},

	{`isPolymorphic`, false},
}

local !struct"TypeInfoEnumMember"{
	{`name`, ""},
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	_overrides={{`tag`,14}},
	{`astNode`,        nil}, -- AstEnum
	{`name`,           ""},
	{`memberTypeInfo`, nil}, -- Must be one of these primitive types: int, string, type, bool or float.
	{`members`,        {}},  -- []TypeInfoEnumMember
}

local !structTypeInfo"TypeInfoNamespace:_TypeInfo"{
	_overrides={{`tag`,15}},
	{`scope`, nil}, -- AstScope
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	_overrides={{`tag`,16}},
	-- [1]=typeInfo1, ...
}

local !structTypeInfo"TypeInfoList:_TypeInfo"{ -- Special type used for returns from calls (both when sending and receiving).
	_overrides={{`tag`,17}},
	-- [1]=typeInfo1, ...
}

_G.TYPE_TAG_NAMES         = !(typeTagNames)
_G.XXX_TYPE_TAG_FUNCTION  = !(typeTags.TypeInfoFunction)
_G.XXX_TYPE_TAG_STRUCT    = !(typeTags.TypeInfoStruct)
_G.XXX_TYPE_TAG_ENUM      = !(typeTags.TypeInfoEnum)
_G.XXX_TYPE_TAG_NAMESPACE = !(typeTags.TypeInfoNamespace)



-- typeInfo = newTypeInfo( compilationState, TypeInfoCreator )
function _G.newTypeInfo(state, TypeInfoCreator)
	!ifDEBUG `if not TypeInfoCreator then  errorInternal(2, "No TypeInfoCreator specified.")  end`

	state.lastTypeId = state.lastTypeId+1

	local typeInfo = TypeInfoCreator()
	typeInfo.id    = state.lastTypeId

	--[[
	if typeInfo.id == 22 then
		errorInternal("DEBUG")
	end
	--]]

	return typeInfo
end

do
	local builtinTypeInfos = {}

	local BUILTIN_TYPE_STRUCTS = {
		["any"]         = TypeInfoAny,
		["bool"]        = TypeInfoBool,
		["int"]         = TypeInfoInt,
		["none"]        = TypeInfoNone,
		["float"]       = TypeInfoFloat,
		["string"]      = TypeInfoString,
		["table"]       = TypeInfoTable,
		["type"]        = TypeInfoType,        -- The result of e.g. type_of(int) or type_of(type_of(expression)).
		["void"]        = TypeInfoVoid,        -- Used when no useful type is expected or available.
		["placeholder"] = TypeInfoPlaceholder, -- Used in polymorphic functions.
	}

	function _G.getTypeInfoForBuiltinType(state, typeName)
		local typeInfo = builtinTypeInfos[typeName]

		if not typeInfo then
			local TypeInfoCreator      = BUILTIN_TYPE_STRUCTS[typeName] or errorInternal(tostring(typeName))
			typeInfo                   = newTypeInfo(state, TypeInfoCreator)
			builtinTypeInfos[typeName] = typeInfo

			table.insert(state.allTypeInfos, typeInfo)
		end

		return typeInfo
	end

	-- bool, typeName = isTypeBuiltin( typeInfo )
	function _G.isTypeBuiltin(typeInfo)
		!ASSERT `typeInfo`
		if typeInfo == builtinTypeInfos["any"]         then  return true, "any"          end
		if typeInfo == builtinTypeInfos["bool"]        then  return true, "bool"         end
		if typeInfo == builtinTypeInfos["int"]         then  return true, "int"          end
		if typeInfo == builtinTypeInfos["none"]        then  return true, "none"         end
		if typeInfo == builtinTypeInfos["float"]       then  return true, "float"        end
		if typeInfo == builtinTypeInfos["string"]      then  return true, "string"       end
		if typeInfo == builtinTypeInfos["table"]       then  return true, "table"        end
		if typeInfo == builtinTypeInfos["type"]        then  return true, "type"         end
		if typeInfo == builtinTypeInfos["placeholder"] then  return true, "placeholder"  end
		return false, ""
	end
end

local function doesLambdaHaveSignature(lambda, funcSig)
	local argsIn     = lambda.argumentsIn
	local argTypesIn = funcSig.argumentTypesIn
	if (argsIn and #argsIn.arguments or 0) ~= #argTypesIn then  return false  end

	local argsOut     = lambda.argumentsOut
	local argTypesOut = funcSig.argumentTypesOut
	if (argsOut and #argsOut.arguments or 0) ~= #argTypesOut then  return false  end

	if argsIn then
		local requiredArgsIn = funcSig.requiredArgumentsIn
		for i, arg in ipairs(argsIn.arguments) do
			if arg.declaration.name.inferredType ~= argTypesIn[i]      then  return false  end
			if arg.isRequired                    ~= requiredArgsIn[i]  then  return false  end
		end
	end
	if argsOut then
		for i, arg in ipairs(argsOut.arguments) do
			if arg.declaration.name.inferredType ~= argTypesOut[i] then  return false  end
		end
	end

	if lambda.isPolymorphic ~= funcSig.isPolymorphic then  return false  end

	return true
end

function _G.getTypeInfoForLambda(state, lambda)
	local argsIn  = lambda.argumentsIn
	local argsOut = lambda.argumentsOut

	if not lambda.isPolymorphic then
		if argsIn then
			for _, arg in ipairs(argsIn.arguments) do
				if not arg.declaration.name.inferredType then  return nil  end
			end
		end
		if argsOut then
			for _, arg in ipairs(argsOut.arguments) do
				if not arg.declaration.name.inferredType then  return nil  end
			end
		end
	end

	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoFunction) and doesLambdaHaveSignature(lambda, typeInfoCached) then
			return typeInfoCached
		end
	end

	local funcSig         = newTypeInfo(state, TypeInfoFunction)
	funcSig.isPolymorphic = lambda.isPolymorphic

	local placeholderType       = lambda.isPolymorphic and getTypeInfoForBuiltinType(state, "placeholder"  ) or nil
	local placeholderTypeVararg = lambda.isPolymorphic and getTypeInfoForVararg     (state, placeholderType) or nil

	if argsIn then
		for i, arg in ipairs(argsIn.arguments) do
			funcSig.argumentTypesIn[i]
				=   placeholderType
				and (arg.declaration.name.nodeType == !(nodeTypes.AstVararg) and placeholderTypeVararg or placeholderType)
				or  arg.declaration.name.inferredType
			funcSig.requiredArgumentsIn[i]  = arg.isRequired
		end
	end
	if argsOut then
		for i, arg in ipairs(argsOut.arguments) do
			funcSig.argumentTypesOut[i]
				=   placeholderType
				and (arg.declaration.name.nodeType == !(nodeTypes.AstVararg) and placeholderTypeVararg or placeholderType)
				or  arg.declaration.name.inferredType
			funcSig.requiredArgumentsOut[i] = arg.isRequired
		end
	end

	table.insert(state.allTypeInfos, funcSig)
	return funcSig
end

do
	local function getTypeInfoForListOrCompoundType(state, typeInfos, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfos) do
			if typeInfoCached.tag == tag and areArraysEqual(typeInfos, typeInfoCached) then
				return typeInfoCached
			end
		end

		local typeInfo = newTypeInfo(state, schematicForTypeInfo)
		copyToArray(typeInfos, typeInfo)
		table.insert(state.allTypeInfos, typeInfo)

		return typeInfo
	end

	function _G.getTypeInfoForList(state, typeInfos)
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(typeTags.TypeInfoList), TypeInfoList)
	end

	-- Note: typeInfos is expected to be sorted by type ID.
	function _G.getTypeInfoForCompoundType(state, typeInfos)
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(typeTags.TypeInfoCompound), TypeInfoCompound)
	end
end

do
	local function getTypeInfoForArrayOrVararg(state, itemType, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfos) do
			if typeInfoCached.tag == tag and itemType == typeInfoCached.itemType then
				return typeInfoCached
			end
		end

		local typeInfo    = newTypeInfo(state, schematicForTypeInfo)
		typeInfo.itemType = itemType
		table.insert(state.allTypeInfos, typeInfo)

		return typeInfo
	end

	function _G.getTypeInfoForArray(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(typeTags.TypeInfoArray), TypeInfoArray)
	end

	function _G.getTypeInfoForVararg(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(typeTags.TypeInfoVararg), TypeInfoVararg)
	end
end

function _G.getTypeInfoForNamespace(state, scope)
	!ASSERT `scope`

	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoNamespace) and scope == typeInfoCached.scope then
			return typeInfoCached
		end
	end

	local namespaceInfo = newTypeInfo(state, TypeInfoNamespace)
	namespaceInfo.scope = scope
	table.insert(state.allTypeInfos, namespaceInfo)

	return namespaceInfo
end



-- Note: The expression must already be inferred!
function _G.getTypeRepresentedByExpression(expr)
	!ASSERT `expr.inferredType`

	if expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		return typeNode.representedType
	elseif expr.nodeType == !(nodeTypes.AstStruct) then
		local struct = expr
		return struct.representedType
	elseif expr.nodeType == !(nodeTypes.AstEnum) then
		local enum = expr
		return enum.representedType
	elseif expr.nodeType == !(nodeTypes.AstTypeOf) then
		local typeOf = expr
		return typeOf.representedType
	elseif expr.nodeType == !(nodeTypes.AstAccess) then -- Not sure if this is needed. @Cleanup
		local access = expr
		return access.representedType -- May be nil.

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		return
			cast.inferredType.tag == !(typeTags.TypeInfoType) -- Is this check needed?
			and getTypeRepresentedByExpression(cast.expression)
			or  nil

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		return ident.declaration.valueTypeInfo -- May be nil.
	elseif expr.nodeType == !(nodeTypes.AstBake) then
		local bake = expr
		return bake.name.declaration.valueTypeInfo -- May be nil.

	elseif expr.inferredType.tag == !(typeTags.TypeInfoType) then
		errorInternal("Incomplete: Unhandled node type: %s", getFriendlyTypeInfoName(expr.inferredType))
	else
		return nil
	end
end

-- Note: The expression must already be inferred!
function _G.requireTypeRepresentedByExpression(state, expr)
	local typeInfoRepresented = getTypeRepresentedByExpression(expr)
	if typeInfoRepresented then  return typeInfoRepresented  end

	local typeInfo = expr.inferredType

	if typeInfo.tag == !(typeTags.TypeInfoList) then
		typeError(state, expr, "Expected a type. This is a function call.")
	elseif typeInfo.tag ~= !(typeTags.TypeInfoType) then
		typeError(state, expr, "Expected a type. (Got %s)", getFriendlyTypeInfoName(typeInfo))
	elseif not isExpressionConstant(state, expr, false) then
		-- @UX: Better message for foreign values.
		typeError(state, expr, "Expected a constant. (Got variable of type '%s')", getFriendlyTypeInfoName(typeInfo))
	else
		!ifDEBUG `print(getFriendlyTypeInfoName(typeInfo))`
		errorInternal(state, expr, "The expression should represent a type but we somehow don't have any TypeInfo.")
	end
end



-- scope, childClosestToScope = getClosestScope( node )
_G.getClosestScope = astFindParentScope
--[[
function _G.getClosestScope(node)
	-- @Incomplete: Treat global declarations differently and depricate
	-- getClosestScopeForDeclaration() (or simply change the parent of
	-- globals to the actual globalScope, though that has problems too).
	return astFindParent(node,
		!outputCommaSeparatedValues(unpack(scopeNodeTypes))
	)
end
]]

-- Since the physical parent of global declarations actually is a file scope
-- we have to treat these declarations differently sometimes. This function
-- returns the correct scope for global declarations.
function _G.getClosestScopeForDeclaration(state, decl)
	-- do return getClosestScope(decl) end
	return isDeclarationGlobal(decl) and state.globalScope or getClosestScope(decl)
end

function _G.isScope           (node)   return SCOPE_SET            [node .nodeType] or false  end
function _G.isScopeDeclarative(scope)  return SCOPE_SET_DECLARATIVE[scope.nodeType] or false  end
function _G.isScopeImperative (scope)  return SCOPE_SET_IMPERATIVE [scope.nodeType] or false  end



function _G.getLambda(node)
	return astFindParent1(node, !(nodeTypes.AstLambda))
end



-- declaration, fromUsing = findDeclaration( compilationState, startNode, name [, declarationToIgnore ] )
function _G.findDeclaration(state, startNode, name, declToIgnore)
	local scope = isScope(startNode) and startNode or getClosestScope(startNode)

	while scope do
		for _, decl in ipairs(scope.declarations) do
			if decl ~= declToIgnore and decl.name.name == name and isDeclarationVisibleToNode(decl, startNode) then
				return decl, nil
			end
		end

		-- @Speed: Don't re-check already checked declarations. (Any potential speed-up may be neglectable though. Need to test with a bigger program.)

		for _, import in ipairs(scope.imports) do
			if import.fileScope then
				for _, decl in ipairs(import.fileScope.declarations) do
					if decl ~= declToIgnore and decl.isExported and decl.name.name == name then
						return decl, nil
					end
				end
			end
		end

		for _, using in ipairs(scope.usings) do
			if using.scope then
				local nodeType    = using.scope.nodeType
				local onlyExports = !!(anyV(`nodeType`, nodeTypes.AstNamespace,nodeTypes.AstFileScope,nodeTypes.AstGlobalScope))

				for _, decl in ipairs(using.scope.declarations) do
					if
						decl ~= declToIgnore
						and decl.name.name == name
						and not (onlyExports and not decl.isExported)
						and (
							decl.isConstant or (
								using.variableDeclaration
								and isDeclarationVisibleToNode(using.variableDeclaration, startNode)
							)
						)
					then
						return decl, using
					end
				end
			end
		end

		for _, decl in ipairs(scope.declarationsInTree[name] or EMPTY_TABLE) do
			if decl ~= declToIgnore and isDeclarationVisibleToNode(decl, startNode) then
				return decl, nil
			end
		end

		-- Don't cross any module boundary!
		if scope.nodeType == !(nodeTypes.AstFileScope) and scope.isModule then
			break
		end

		scope = getClosestScope(scope)
	end

	return nil, nil
end

function _G.findPublicDeclarationInScope(state, scope, name)
	!ASSERT `name`
	if (scope.nodeType == !(nodeTypes.AstFileScope) and scope.isModule) or scope.nodeType == !(nodeTypes.AstNamespace) then
		for _, decl in ipairs(scope.declarations) do
			if decl.isExported and decl.name.name == name then  return decl  end
		end
	else
		for _, decl in ipairs(scope.declarations) do
			if decl.name.name == name then  return decl  end
		end
	end

	return nil
end
function _G.findMemberDeclaration(state, scope, name)
	!ASSERT `name`
	for _, decl in ipairs(scope.declarations) do
		if decl.name.name == name then  return decl  end
	end
	return nil
end
function _G.findDynamicMemberDeclaration(state, scope, name)
	!ASSERT `name`
	for _, decl in ipairs(scope.declarations) do
		if not decl.isConstant and decl.name.name == name then  return decl  end
	end
	return nil
end

function _G.isDeclarationVisibleToNode(decl, node)
	if isDeclarationGlobal(decl) then  return true  end

	local nodeScope, nodeScopeChild = getClosestScope(node)
	local canSeeImperativeVariables = not decl.isConstant -- It doesn't matter if this is true and we're in a declarative scope because we check that in the loop below.

	while true do
		if not indexOf(nodeScope.declarations, decl) then
			-- void  (Keep looking through parent scopes and update canSeeImperativeVariables as we go.)

		elseif decl.isConstant or isScopeDeclarative(nodeScope) then
			return true

		elseif not canSeeImperativeVariables then
			return false

		elseif !!(anyV(`nodeScope.nodeType`, nodeTypes.AstFor,nodeTypes.AstLambda)) then -- These are really a combination of declarative and imperative scopes.
			return true

		elseif nodeScope.nodeType == !(nodeTypes.AstBlock) then
			local block = nodeScope

			-- Note: If the node is inside the initial assignment then we need to treat the declaration
			-- and the assignment as if they were the same statement. Otherwise the assignment will be
			-- able to see it's own declarations, which is illegal!
			local declScope, declScopeChild = getClosestScope(decl.assignment or decl)

			if declScope == block then
				local imperativeIndexForDecl = indexOf(block.statements, declScopeChild) or errorInternal()
				local imperativeIndexForNode = indexOf(block.statements, nodeScopeChild) or errorInternal()

				return (imperativeIndexForDecl < imperativeIndexForNode)

			else
				-- The declaration is probably from a using. The only things you can use right
				-- now are structs and enums, both being declarative scopes. 2020-01-03
				!ASSERT `isScopeDeclarative(declScope)`
				return true
			end

		else
			errorUnhandledNodeType(state, nodeScope)
		end

		if canSeeImperativeVariables and nodeScope.nodeType == !(nodeTypes.AstLambda) then
			-- Lambdas act as the only boundary between imperative and declarative
			-- scopes right now. Maybe this will change in the future? 2019-12-07
			canSeeImperativeVariables = false
		end

		nodeScope, nodeScopeChild = getClosestScope(nodeScope)
		if not nodeScope then  return false  end -- This shouldn't happen I don't think, unless decl and node is not part of the same tree.
	end
end

-- printDeclarationChain( [ file=io.stdout, ] compilationState, declaration, typeName )
function _G.printDeclarationChain(file, state, decl, typeName)
	if type(file) ~= "userdata" then  return printDeclarationChain(io.stdout, file, state, decl)  end

	!local MAX_CHAIN_LENGTH = 10

	for _ = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(file, state, decl.name, "Info", "...here is '%s' declared.", typeName)

		local declCurrent = decl.name.declaration -- @Cleanup: Can we use decl.name.declaration instead here?
		if not declCurrent then  break  end

		decl            = nil
		local valueExpr = getDeclarationValue(declCurrent)

		if valueExpr then
			while valueExpr.replacing do  valueExpr = valueExpr.replacing  end

			if valueExpr.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = valueExpr
				typeName    = ident.name
				decl        = ident.declaration or findDeclaration(state, ident, typeName, declCurrent)
			end
		end

		if not decl then  break  end
	end
end



function _G.typeError(state, node, s, ...)
	nodeError(state, node, "Typer", s, ...)
end
function _G.typeErrorAfter(state, node, s, ...)
	nodeErrorAfter(state, node, "Typer", s, ...)
end

function _G.typeError2(state, node1, s1, node2, s2)
	!TRACE(2)
	printerr()
	!ifDEBUG `astPrint(node1)`
	typeMessage(io.stderr, state, node1, "Error", "%s", s1)
	!ifDEBUG `astPrint(node2)`
	typeMessage(io.stderr, state, node2, "Info",  "%s", s2)
	exitFailure()
end

-- typeMessage( [ outputFile=io.stdout, ] compilationState, node, label, formatString, ... )
function _G.typeMessage(file, state, node, label, s, ...)
	if type(file) ~= "userdata" then  return typeMessage(io.stdout, file, state, node, label, s, ...)  end
	return nodeMessage(file, state, node, label, "Typer", s, ...)
end



function _G.getFriendlyTypeInfoName(typeInfo)
	local name = ""

	if typeInfo.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		name             = structInfo.name

		if structInfo.astNode.polymorphSourceStruct then
			local params = {}

			for argIndex, declBaked in ipairs(structInfo.astNode.bakeDeclarations) do
				local valueExpr = declBaked.value

				if valueExpr.nodeType == !(nodeTypes.AstLiteral) then
					local literal    = valueExpr
					params[argIndex] = literal.literalType == !(LITERAL_STRING) and F("%q", literal.value) or tostring(literal.value)

				elseif valueExpr.nodeType == !(nodeTypes.AstType) then
					local typeNode   = valueExpr
					params[argIndex] = getFriendlyTypeInfoName(typeNode.representedType)

				else
					params[argIndex] = "~"
				end
			end

			name
				= structInfo.astNode.polymorphSourceStruct.representedType.name
				.."("..table.concat(params, ",")..")"
		end

	elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo = typeInfo
		name           = enumInfo.name

	elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
		local funcSig      = typeInfo
		local typeTextsIn  = {}
		local typeTextsOut = {}

		for i, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			if i > 1 then
				table.insert(typeTextsIn, ",")
			end
			table.insert(typeTextsIn, getFriendlyTypeInfoName(argTypeInfo))
			if not (funcSig.requiredArgumentsIn[i] or argTypeInfo.tag == !(typeTags.TypeInfoVararg)) then
				table.insert(typeTextsIn, "?")
			end
		end

		for i, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			typeTextsOut[i] = getFriendlyTypeInfoName(argTypeInfo)
		end

		name = typeTextsOut[1]
			and F("function(%s)->(%s)", table.concat(typeTextsIn), table.concat(typeTextsOut, ","))
			or  F("function(%s)->void", table.concat(typeTextsIn))

	elseif typeInfo.tag == !(typeTags.TypeInfoCompound) then
		local compound  = typeInfo
		local typeTexts = {}

		for i, compoundItem in ipairs(compound) do
			typeTexts[i] = getFriendlyTypeInfoName(compoundItem)
		end

		name = table.concat(typeTexts, "|")

	elseif typeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig   = typeInfo
		local typeTexts = {}

		for i, typeInfo in ipairs(listSig) do
			typeTexts[i] = getFriendlyTypeInfoName(typeInfo)
		end

		name = "list("..table.concat(typeTexts, ", ")..")"

	elseif typeInfo.tag == !(typeTags.TypeInfoArray) then
		local arraySig = typeInfo
		name           = "array("..getFriendlyTypeInfoName(arraySig.itemType)..")"

	elseif typeInfo.tag == !(typeTags.TypeInfoVararg) then
		local varargSig = typeInfo
		name            = "..."..getFriendlyTypeInfoName(varargSig.itemType)

	elseif typeInfo.tag == !(typeTags.TypeInfoNamespace) then
		local namespaceInfo = typeInfo
		local scope         = namespaceInfo.scope
		local scopeParent   = scope.parent

		if scopeParent.nodeType == !(nodeTypes.AstDeclaration) and scopeParent.isConstant and scope == scopeParent.value then
			name = 'namespace("'..scopeParent.name.name..'")'
		else
			name = 'namespace'
		end
	end

	if name == "" then
		name = TYPE_TAG_NAMES[typeInfo.tag] or errorInternal("%d", typeInfo.tag)
	end

	-- !(if DEBUG then)  name = name.."@"..typeInfo.id  !(end)

	return name
end



local nodeInferrers = {}

!(
local nodeNames = {}

local function NODE_INFERRER(funcHeaderCode)
	local replacements

	funcHeaderCode, replacements = funcHeaderCode:gsub("function +nodeInferrers%.(Ast%w+)", function(nodeName)
		if nodeNames[nodeName] then
			error("Duplicate node inferrer: "..nodeName)
		end
		nodeNames[nodeName] = true

		local nodeType = nodeTypes[nodeName] or error(nodeName)
		return "nodeInferrers[--[["..nodeName.."]]"..nodeType.."] = function"
	end)

	assert(replacements == 1, funcHeaderCode)

	__LUA(funcHeaderCode)
end
)

function _G.isPartOfAnyDeclaration(identOrVararg)
	local parent = identOrVararg.parent

	if parent.nodeType == !(nodeTypes.AstDeclaration) then
		local decl = parent
		return identOrVararg == decl.name

	elseif parent.nodeType == !(nodeTypes.AstAssignment) then
		local assignment = parent
		return assignment.forDeclaration and indexOf(assignment.targets, identOrVararg) ~= nil

	else
		return false
	end
end

-- identifierEarly, identifierLate, extraShadowMessageEarly, extraShadowMessageLate = getEarlyAndLateForRedeclarationError( state, identifier1, identifier2 )
local function getEarlyAndLateForRedeclarationError(state, identEarly, identLate)
	local extraMessageEarly = ""
	local extraMessageLate  = ""

	-- Globals before locals.
	if isDeclarationGlobal(identEarly.declaration) ~= isDeclarationGlobal(identLate.declaration) then
		if isDeclarationGlobal(identLate.declaration) then
			identEarly, identLate = identLate, identEarly
		end

	-- Constants before variables.
	elseif identEarly.declaration.isConstant ~= identLate.declaration.isConstant then
		if identLate.declaration.isConstant then
			identEarly, identLate = identLate, identEarly
		end

		if isScopeImperative(getClosestScopeForDeclaration(state, identLate.declaration)) then
			extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope, unlike variables.)"
		end

	-- Low depth before high depth.
	-- Early in file before late in file.
	else
		local depthEarly = astGetDepth(identEarly)
		local depthLate  = astGetDepth(identLate)

		if depthLate < depthEarly or (depthLate == depthEarly and identLate.token < identEarly.token) then
			-- @Incomplete: Explicitly handle the identifiers being declared in different files. (May be unnecessary.)
			identEarly, identLate = identLate, identEarly
		end

		if identEarly.declaration.isConstant and isScopeImperative(getClosestScopeForDeclaration(state, identEarly.declaration)) then
			extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope.)"
		end
	end

	return identEarly, identLate, extraMessageEarly, extraMessageLate
end

local function checkRedeclaration(state, ident, decl, isMember, scope)
	decl.checkedRedeclaration = true

	local declExisting = findDeclaration(state, ident, ident.name, decl)
	if not declExisting then  return  end
	!ASSERT `declExisting ~= decl`

	local scopeExisting = getClosestScopeForDeclaration(state, declExisting)

	-- Member.
	if isMember and not decl.isConstant and scope ~= scopeExisting then
		-- void  (Variable members never shadow anything.)

	-- Function overload. (Note: Overloads have to be registered before the identifier DEPEND_AND_RETURN on anything.)
	elseif
		decl            .isConstant
		and declExisting.isConstant
		and decl        .value.nodeType == !(nodeTypes.AstLambda)
		and declExisting.value.nodeType == !(nodeTypes.AstLambda)
	then
		while declExisting.overloadOf and declExisting.overloadOf ~= declExisting do  declExisting = declExisting.overloadOf  end

		if declExisting == decl then
			-- This simplifies finding an overload later.
			declExisting.overloadOf = declExisting
			table.insert(declExisting.overloads, declExisting)

		elseif scope ~= scopeExisting then
			local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, declExisting.name, ident)
			typeError2(state,
				identLate,  F("Trying to add a new overload to '%s' which is in another scope. Overloads must currently be declared in the same scope.", ident.name),
				identEarly, F("...here is the previous function.")
			)

		elseif declExisting.overloadsLocked then
			typeError2(state,
				declExisting.name, F("Trying to add a new overload to '%s' after it's type has been inferred. Overloads currently has to happen in the same 'parsing cycle'.", ident.name),
				ident,             F("...this is the new overload.")
			)

		else
			decl.overloadOf = declExisting
			table.insert(declExisting.overloads, decl)

			local lambda         = decl.value
			local lambdaExisting = declExisting.value

			assert(not lambdaExisting.inferredType)

			-- This dependency means lambdaExisting won't get inferred until earliest next cycle
			-- by which time all overloads should have been added (I think). This should work as
			-- the first occurence of a name will make the second occurence wait before the
			-- second has been able to do anything. (This is true even when we remove unordered
			-- from the queue.)
			addDependency(state, lambdaExisting, !(DEPEND_NODE_INFERRED), lambda)
		end

	-- Non-shadow.
	elseif not decl.canShadow then
		local identEarly, identLate, extraMessageEarly, extraMessageLate = getEarlyAndLateForRedeclarationError(state, declExisting.name, ident)
		-- !ifDEBUG `identEarly, identLate = declExisting.name, ident`
		-- !ifDEBUG `astPrintTree(astFindCommonParent(identEarly, identLate))`
		typeError2(state,
			identLate,  F("'%s' has already been declared.%s", ident.name, extraMessageLate),
			identEarly, F("...it was declared here.%s", extraMessageEarly)
		)

	-- Shadow in same scope.
	elseif
		scope == scopeExisting
		or (
			-- We do not allow declarations on lambda bodies to shadow the lambda's arguments.
			scope.nodeType                      == !(nodeTypes.AstBlock)
			and getClosestScope(scope).nodeType == !(nodeTypes.AstLambda)
			and getClosestScope(scope)          == scopeExisting
		)
	then
		typeError2(state,
			ident,             F("'%s' has already been declared in the same scope (which means name shadowing does not work).", ident.name),
			declExisting.name, F("...it was declared here.")
		)

	-- Shadowing something in an outer (or inner?) scope.
	-- @Robustness: Don't allow file-scope variables to be shadows (just like constants)?
	else
		-- void  (Valid shadow.)
	end
end

local function isPolymorphicLambda(node)
	return node.nodeType == !(nodeTypes.AstLambda) and node.isPolymorphic
end
local function isPolymorphicStruct(node)
	return node.nodeType == !(nodeTypes.AstStruct) and node.isPolymorphic
end

local function inferIdentifierOrVararg(state, identOrVararg)
	local vararg = identOrVararg.nodeType == !(nodeTypes.AstVararg) and identOrVararg or nil
	local ident  = not vararg                                       and identOrVararg or nil
	local parent = identOrVararg.parent
	local decl   = identOrVararg.declaration

	-- 1. Loose identifier.
	if not isPartOfAnyDeclaration(identOrVararg) then
		if not decl then
			local using
			decl, using = findDeclaration(state, identOrVararg, identOrVararg.name)

			if not decl then
				!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_DECLARATION, `identOrVararg.name`)
			end

			identOrVararg.declaration = decl
			identOrVararg.fromUsing   = using
		end

		if
			not ident
			or (parent.nodeType == !(nodeTypes.AstCall)  and ident == parent.callee)
			or (parent.nodeType == !(nodeTypes.AstDebug) and parent.action == "print")
		then
			-- void

		-- Overloaded names refer to multiple things, so that's an error!
		-- @Incomplete: Add a way to refer to a specific overload.
		elseif decl.overloadOf then
			local declBase = ident.declaration
			while declBase.overloadOf and declBase.overloadOf ~= declBase do  declBase = declBase.overloadOf  end

			if not declBase.name.inferredType then
				-- This is just so we get a better overload list in the error message.
				!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `declBase.name`)
			end

			!TRACE()
			printerr()
			typeMessage(io.stderr, state, ident, "Error", "'%s' has multiple overloads and we don't know which one this is referring to.", ident.name)
			for i, declOverload in ipairs(declBase.overloads) do
				typeMessage(io.stderr, state, declOverload.name, "Info", "...overload #%d.", i)
			end
			exitFailure()

		-- Polymorphic functions also contain the polymorphed functions and are thus a collection of functions, so referring to them may be a bad idea!
		-- (How does this work when calling a function from a module or a static struct member function? @Incomplete @Robustness)
		elseif isPolymorphicLambda(getDeclarationValue(decl) or decl) then
			typeError(state, ident, "Cannot refer to polymorphic function '%s' outside calls.", ident.name)

		-- Polymorphic structs are similar to polymorphed functions as they are collections of structs, so referring to them may be a bad idea too!
		-- (Also, like with the functions, think about modules. @Incomplete @Robustness)
		elseif isPolymorphicStruct(getDeclarationValue(decl) or decl) then
			typeErrorAfter(state, ident, "Missing arguments for polymorphic struct '%s'.", ident.name)
		end

		local typeInfo = decl.name.inferredType
		if not typeInfo then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `decl`)
		end

		identOrVararg.inferredType = typeInfo

		if identOrVararg.fromUsing then
			-- @Cleanup: Move this to simplifyExpressionIfConstant()?
			!ASSERT `ident`
			local access        = astNewNode(AstAccess, ident.token, parent)
			access.object       = astCopy(ident.fromUsing.expression, access.token, access)

			local literal       = astNewNode(AstLiteral, access.token, access)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = ident.name
			access.member       = literal

			addUnqueuedChildrenToQueueRecursively(state, access)
			replaceQueuedNodeAndUnqueueOldTree(state, ident, access)
			-- Stay in the current pipe.

		else
			moveToNextRelevantPipe(state, identOrVararg)
			if ident then
				simplifyExpressionIfConstant(state, ident)
			end
		end

		return
	end

	!ASSERT("decl")
	!ASSERT("parent.nodeType == "..nodeTypes.AstDeclaration.." or parent.nodeType == "..nodeTypes.AstAssignment)

	-- 2. Assignment target in declaration (which is a copy of the identifier in the declaration).
	if parent.nodeType == !(nodeTypes.AstAssignment) then
		local identInDecl = decl.name
		if not identInDecl.inferredType then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `identInDecl`)
		end
		identOrVararg.inferredType = identInDecl.inferredType

		moveToNextRelevantPipe(state, identOrVararg)
		return
	end

	-- 3. At this point we're defining a declared identifier.

	local scope = getClosestScopeForDeclaration(state, decl)

	if not scope then
		astPrint(identOrVararg)
		typeError(state, identOrVararg, "Internal compiler error: Could not find what scope '%s' is in.", identOrVararg.name)
	end

	local isEnumMember = scope.nodeType == !(nodeTypes.AstEnum)
	local isMember     = isEnumMember or scope.nodeType == !(nodeTypes.AstStruct)

	local isLambdaArgOut = (
		not isMember
		and scope.nodeType == !(nodeTypes.AstLambda)
		and scope.argumentsOut ~= nil
		and decl.parent.parent == scope.argumentsOut
	)

	local isForeignLambdaArgIn = (
		not isLambdaArgOut and not isMember
		and scope.nodeType == !(nodeTypes.AstLambda)
		and scope.bodyIsForeign
		and scope.argumentsIn ~= nil
		and decl.parent.parent == scope.argumentsIn
	)

	-- Check for redeclaration/shadowing (before we DEPEND_AND_RETURN).
	if not (decl.checkedRedeclaration or vararg or isLambdaArgOut or isForeignLambdaArgIn) then
		checkRedeclaration(state, ident, decl, isMember, scope)
	end

	local typeExpr = decl.type
	if typeExpr and not typeExpr.inferredType then
		!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `typeExpr`)
	end

	if isEnumMember then
		local enum = scope
		if not enum.representedType then
			-- AstEnum is the only scope that gets inferred before its declarations.
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `enum`)
		end
	end

	local valueExpr = getDeclarationValue(decl, true)
	if (not typeExpr or decl.isConstant) and not valueExpr.inferredType then
		!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `valueExpr`)
	end

	--
	-- No more dependencies for this identifier after this point!
	--

	decl.overloadsLocked = true

	-- Check that call signatures aren't too similar. Optional arguments could make several overloads match calls, i.e.:
	--   local func :: () {}
	--   local func :: (n:int=0) {}
	--   func() -- First or second?
	if decl.overloadOf == decl then
		for i = 1, #decl.overloads-1 do
			local decl1         = decl.overloads[i]
			local funcSig1      = decl1.value.inferredType
			local argTypes1     = funcSig1.argumentTypesIn
			local argRequireds1 = funcSig1.requiredArgumentsIn

			for i = i+1, #decl.overloads do
				local decl2         = decl.overloads[i]
				local funcSig2      = decl2.value.inferredType
				local argTypes2     = funcSig2.argumentTypesIn
				local argRequireds2 = funcSig2.requiredArgumentsIn

				if funcSig1 == funcSig2 then
					local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
					typeError2(state,
						identLate,  F("Call signatures for function overloads for '%s' are identical. (%s)", ident.name, getFriendlyTypeInfoName(funcSig1)),
						identEarly, F("...here is the other function.")
					)
				end

				-- local requiredCount1 = 0
				-- local requiredCount2 = 0

				-- @Incomplete @Robustness: Check that vararg works.
				for argIndex = 1, math.min(#argTypes1, #argTypes2)+1 do
					local argTypeInfo1 = argTypes1[argIndex]
					local argTypeInfo2 = argTypes2[argIndex]
					argTypeInfo1       = argTypeInfo1 and adjustTypeToOne(state, decl1.name, argTypeInfo1)
					argTypeInfo2       = argTypeInfo2 and adjustTypeToOne(state, decl2.name, argTypeInfo2)

					local isRequired1  = argTypeInfo1 ~= nil and argRequireds1[argIndex]
					local isRequired2  = argTypeInfo2 ~= nil and argRequireds2[argIndex]

					-- if isRequired1 then  requiredCount1 = requiredCount1+1  end
					-- if isRequired2 then  requiredCount2 = requiredCount2+1  end

					if not (isRequired1 or isRequired2) then
						local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
						typeError2(state,
							identEarly, F("Call signatures for function overloads (%s) are too similar.", ident.name),
							identLate,  F("...here is the other function.")
						)
					end

					if not (argTypeInfo1 and argTypeInfo1 == argTypeInfo2) then  break  end
				end

				--[[ This is a bit too restrictive!
				if requiredCount1 == requiredCount2 then
					for argIndex = 1, requiredCount1 do
						local argTypeInfo1 = adjustTypeToOne(state, decl1.name, argTypes1[argIndex])
						local argTypeInfo2 = adjustTypeToOne(state, decl2.name, argTypes2[argIndex])
						if
							isTypeCompatibleWith(argTypeInfo1, argTypeInfo2) or
							isTypeCompatibleWith(argTypeInfo2, argTypeInfo1)
						then
							local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
							typeError2(state,
								identEarly, F("Call signatures for function overloads (%s) are too similar. (Argument #%d, %s vs. %s)",
									ident.name,
									argIndex,
									getFriendlyTypeInfoName(argTypeInfo1),
									getFriendlyTypeInfoName(argTypeInfo2)
								)
								identLate, F("...here is the other function.")
							)
						end
					end
				end
				--]]
			end
		end
	end

	-- Tell parents that this declaration exists so we can detect more cases of shadowing.
	if not (isLambdaArgOut or decl.canShadow or vararg) then -- Should vararg do this? I think it's not needed.
		local parentScope = scope

		repeat
			local declarationsInTree = parentScope.declarationsInTree[ident.name]

			if not declarationsInTree then
				declarationsInTree = {}
				parentScope.declarationsInTree[ident.name] = declarationsInTree
			end

			table.insert(declarationsInTree, decl)

			if parentScope.nodeType == !(nodeTypes.AstFileScope) and parentScope.isModule then  break  end

			parentScope = getClosestScope(parentScope)
		until not parentScope
	end

	local typeInfo

	-- Specified type.
	if typeExpr then
		typeInfo = requireTypeRepresentedByExpression(state, typeExpr)

	-- Infer type from value.
	else
		!ASSERT(`valueExpr`, toLua("Missing both type and value from declaration."))
		!ASSERT(`not vararg`)

		if decl.value then
			typeInfo = valueExpr.inferredType
		else
			valueExpr, typeInfo = getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, nil, nil, nil)
		end
		typeInfo = adjustTypeToOne(state, valueExpr, typeInfo, true)
	end

	assert(typeInfo)
	local typeInfoForDecl = nil

	-- Check if the value is constant.
	if decl.isConstant then
		valueExpr       = valueExpr or getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, nil, nil, nil)
		typeInfoForDecl = getTypeRepresentedByExpression(valueExpr)

		if isEnumMember then
			-- Note: AstEnum already validated that valueExpr's type is compatible with the enum.
			local enum     = scope
			local enumInfo = enum.representedType
			typeInfo       = enumInfo -- Kind of a @Hack, but maybe it's fine for enum members!

			if enumInfo.memberTypeInfo.tag == !(typeTags.TypeInfoType) then
				-- This means you can for example say: local myVar:MyEnum.MY_TYPE
				assert(typeInfoForDecl)
			end
		end

		if typeInfo.tag == !(typeTags.TypeInfoType) then
			if not typeInfoForDecl then
				errorInternal(state, valueExpr, "Missing what type this constant expression represents.")
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then -- @Robustness: Actually detect whether we have a type enum and include it here above.
			-- void  For now we may or may not have a type enum and typeInfoForDecl.

		elseif typeInfo.tag == !(typeTags.TypeInfoPlaceholder) then
			-- void  Just ignore this for now. We get here when placeholders are combined with auto-baking (which produces constants).

		elseif typeInfoForDecl then
			errorInternal(
				state, valueExpr, "type=%s, typeRepresented=%s",
				getFriendlyTypeInfoName(typeInfo), getFriendlyTypeInfoName(typeInfoForDecl)
			)
		end

		-- @Robustness: Here we set the name of structs and enums. Is this a good place to do that?
		if not typeInfoForDecl then
			-- void

		elseif typeInfoForDecl.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfoForDecl
			if structInfo.name == "" then -- Is this detection ok? Need testing or another solution.
				structInfo.name = ident.name
			end

		elseif typeInfoForDecl.tag == !(typeTags.TypeInfoEnum) then
			local enumInfo = typeInfoForDecl
			if enumInfo.name == "" then -- Is this detection ok? Need testing or another solution.
				enumInfo.name = ident.name
			end
		end
	end

	if vararg then
		typeInfo = getTypeInfoForVararg(state, typeInfo)
	end

	identOrVararg.inferredType = typeInfo
	decl.valueTypeInfo         = typeInfoForDecl -- May be nil.  @Cleanup: Move this and relevant code to AstDeclaration?

	!if DEBUG then
		if debug_onlyInferTypes then
			io.stdout:write("DEFINE ", identOrVararg.name ,":", getFriendlyTypeInfoName(typeInfo))
			if decl.isConstant then  io.stdout:write(" (CONST)")  end
			if typeInfoForDecl then  io.stdout:write(" (VALUE ", getFriendlyTypeInfoName(typeInfoForDecl), ")")  end
			io.stdout:write(" IN ")
			astPrint(getClosestScopeForDeclaration(state, decl))
		end
	!end

	moveToNextRelevantPipe(state, identOrVararg)
end

!NODE_INFERRER `function nodeInferrers.AstIdentifier(state, ident)`
	inferIdentifierOrVararg(state, ident)
end
!NODE_INFERRER `function nodeInferrers.AstVararg(state, vararg)`
	inferIdentifierOrVararg(state, vararg)
end

!NODE_INFERRER `function nodeInferrers.AstBlank(state, blank)`
	if blank.parent.nodeType == !(nodeTypes.AstDeclaration) then
		local decl = blank.parent

		if decl.isConstant then
			typeError(state, blank, "Blank names cannot be constant.")
		elseif not isScopeImperative(getClosestScope(decl)) then
			typeError(state, blank, "Blank names are only allowed in imperative context.")
		end

	elseif blank.parent.nodeType == !(nodeTypes.AstAssignment) then
		local assignment = blank.parent
		if assignment.binaryOperation ~= "" then
			typeError(state, blank, "Blank names cannot be used in assignments with binary operations.")
		end

	else
		errorUnhandledNodeType(state, blank)
	end

	blank.inferredType = getTypeInfoForBuiltinType(state, "any")
	moveToNextRelevantPipe(state, blank)
end

!NODE_INFERRER `function nodeInferrers.AstType(state, typeNode)`
	-- Note: typeNode.declaration may already be filled for generated type nodes.

	local decl = nil
	local typeInfo, typeInfoRepresented

	!if DEBUG then
		--[[
		if typeNode.kind == !(TYPE_KIND_UNSET) then
			astPrintTree(typeNode)
			errorInternal(state, typeNode)
		end
		--]]
	!end

	if typeNode.kind == !(TYPE_KIND_SIMPLE_BUILTIN) then
		typeInfoRepresented = getTypeInfoForBuiltinType(state, typeNode.typeName)
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.kind == !(TYPE_KIND_FUNCTION) then
		local lambda = typeNode.functionHeader or errorInternal()

		if not lambda.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `lambda`)
		end
		assert(lambda.inferredType.tag == !(typeTags.TypeInfoFunction))

		local funcSig       = getTypeInfoForLambda(state, lambda)
		typeInfoRepresented = funcSig
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.kind == !(TYPE_KIND_ARRAY) then
		local itemTypeNode = typeNode.arrayItemType or errorInternal(state, typeNode)

		if not itemTypeNode.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `itemTypeNode`)
		end

		local itemTypeInfo = requireTypeRepresentedByExpression(state, itemTypeNode)
		if itemTypeInfo.tag == !(typeTags.TypeInfoNone) then
			typeError(state, itemTypeNode, "Arrays cannot contain nil.")
		elseif itemTypeInfo.tag == !(typeTags.TypeInfoCompound) and indexWith1(itemTypeInfo, "tag", !(typeTags.TypeInfoNone)) then
			typeError(state, itemTypeNode, "Arrays cannot contain nil. (Item type is %s)", getFriendlyTypeInfoName(itemTypeInfo))
		end

		local arraySig      = getTypeInfoForArray(state, itemTypeInfo)
		typeInfoRepresented = arraySig
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.kind == !(TYPE_KIND_COMPOUND) then
		for _, typeExpr in ipairs(typeNode.components) do
			if not typeExpr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `typeExpr`)
			end
		end

		-- Note: It's ok that these share the same table!
		local typeInfos  = {}        -- Keys are numbers.
		local typeIds    = typeInfos -- Keys are AstNode.
		local duplicates = typeInfos -- Keys are TypeInfo.

		local isFromCompound = {}

		for _, typeExpr in ipairs(typeNode.components) do
			!(
			local TEMPLATE_ERROR_DUPLICATE_TYPE = `
				printerr()
				typeMessage(io.stderr, state, typeExpr, "Error", "Duplicate type specified in $siteTitle. (%s)", getFriendlyTypeInfoName($typeInfoVar))
				if isFromCompound[$typeInfoVar] then
					typeMessage(io.stderr, state, duplicates[$typeInfoVar], "Info", "...this sub-compound type contains the same type.")
				else
					typeMessage(io.stderr, state, duplicates[$typeInfoVar], "Info", "...this is the same type.")
				end
				exitFailure()
			`
			local function ERROR_DUPLICATE_TYPE(siteTitle, typeInfoVar)
				local lua = templateToLua(TEMPLATE_ERROR_DUPLICATE_TYPE, {
					siteTitle   = siteTitle,
					typeInfoVar = typeInfoVar,
				})
				__LUA(lua)
			end
			)

			local componentType = requireTypeRepresentedByExpression(state, typeExpr)

			if componentType.tag == !(typeTags.TypeInfoCompound) then
				-- Unpack the sub-compound type so we don't end up with compound types of other compound types.
				local compound = componentType

				for _, compoundItem in ipairs(compound) do
					if duplicates[compoundItem] then
						!ERROR_DUPLICATE_TYPE("compound type (through sub-compound type)", `compoundItem`)
					end

					table.insert(typeInfos, compoundItem)
					typeIds[typeExpr]            = compoundItem.id
					duplicates[compoundItem]     = typeExpr -- @UX: Should we ignore duplicate nil types?
					isFromCompound[compoundItem] = true
				end

			else
				if duplicates[componentType] then
					!ERROR_DUPLICATE_TYPE("compound type", `componentType`)
				elseif componentType.tag == !(typeTags.TypeInfoAny) then
					typeError(state, typeExpr, "Cannot include 'any' in compound types.")
				end

				table.insert(typeInfos, componentType)
				typeIds[typeExpr]         = componentType.id
				duplicates[componentType] = typeExpr -- @UX: Should we ignore duplicate nil types?
			end
		end

		table.sort(typeNode.components, function(a, b)  return typeIds[a] < typeIds[b]  end) -- @Cleanup @Speed: This is probably unnecessary.
		table.sort(typeInfos,           function(a, b)  return a.id       < b.id        end)

		typeInfoRepresented = getTypeInfoForCompoundType(state, typeInfos)
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	else
		decl = typeNode.declaration

		if not decl then
			assert(typeNode.typeName ~= "")

			decl = findDeclaration(state, typeNode, typeNode.typeName)
			if not decl then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_DECLARATION, `typeNode.typeName`)
			elseif not decl.name.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `decl.name`)
			end
		end

		typeInfoRepresented = decl.valueTypeInfo -- May be nil, in which case we'll get an error here below.
		typeInfo            = decl.name.inferredType or errorInternal()

		-- Type enum members can be used as types, as a special case.
		if decl.isConstant and typeInfo.tag == !(typeTags.TypeInfoEnum) then
			local enum     = typeInfo.astNode     or errorInternal()
			local enumInfo = enum.representedType or errorInternal()

			if enumInfo.memberTypeInfo.tag == !(typeTags.TypeInfoType) then
				typeInfo = getTypeInfoForBuiltinType(state, "type")
			end
		end

		if typeInfo.tag ~= !(typeTags.TypeInfoType) then
			!TRACE()
			printerr()
			typeMessage(io.stderr, state, typeNode, "Error", "'%s' is not a type. (It is %s)", typeNode.typeName, getFriendlyTypeInfoName(typeInfo))
			printDeclarationChain(io.stderr, state, decl, typeNode.typeName)
			exitFailure()
		end

		for _, expr in ipairs(typeNode.arguments or EMPTY_TABLE) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		-- @Incomplete: Proper error messages here:

		if SIMPLE_TYPE_TAG[typeInfo.tag] then
			assert(not typeNode.arguments) -- This should have been caught during parsing, e.g. int(a,b).

		elseif typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			if structInfo.arguments[1] then
				errorInternal("@Incomplete: Struct arguments.")
			elseif typeNode.arguments then
				typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeNode.arguments[1]), "Parameters for structs are not supported yet.")
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			assert(not typeNode.arguments)

		elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
			assert(not typeNode.arguments) -- This should not be possible I think. The node should have been parsed as an AstCall - not an AstType without functionHeader... right? I may be wrong.

		else
			errorInternal("Incomplete: Handle type group '%s'.", TYPE_TAG_NAMES[typeInfo.tag])
		end
	end

	typeNode.representedType = typeInfoRepresented or errorInternal()
	typeNode.inferredType    = typeInfo            or errorInternal()
	typeNode.declaration     = decl

	moveToNextRelevantPipe(state, typeNode)
end

local function getArgumentNodeForError(callOrReturnNode, valueIndex, valueExpr)
	return
		callOrReturnNode.nodeType == !(nodeTypes.AstCall) and callOrReturnNode.isMethod and valueIndex == 1
		and valueExpr
		or  astGetExpressionVisuallyFurthestToTheLeft(valueExpr)
end

-- doesMatch, compatibilityScore = checkIfValuesMatchArgumentTypes( state, callOrReturnNode, values, valueTypes, typeInfos [, softCheck=false, calleeDeclarationForCurrentOverload ] )
local function checkIfValuesMatchArgumentTypes(state, callOrReturnNode, values, valueTypes, typeInfos, softCheck, calleeDecl)
	--[[
		Situations:

		two :: (x:int,   y:int) -> (x:int    y:int) -- accept in/out 2
		var :: (x:int, ...:int) -> (x:int, ...:int) -- accept in/out 1+vararg
		return  x, (two())  --- request 2
		func(   x, (two())  )-- request 2
		return  x, (var())  --- request 2
		func(   x, (var())  )-- request 2
		return  x, (...)    --- request 2  (Note: The vararg can result in nil.)
		func(   x, (...)    )-- request 2  (Note: The vararg can result in nil.)
		return  x, two()    --- request 1+list(2)
		func(   x, two()    )-- request 1+list(2)
		return  x, ...      --- request 1+vararg
		func(   x, ...      )-- request 1+vararg
		return  x, var()    --- request 1+list(1+vararg)
		func(   x, var()    )-- request 1+list(1+vararg)
	]]

	-- Get requested count.
	local valueExprLast = getLast(values)
	local valueCount    = #values
	local requestedMin  = valueCount
	local requestedMax  = valueCount
	local slotsToCheck  = valueCount -- Assuming the requested count is accepted.

	if not valueExprLast then
		--void

	elseif valueExprLast.nodeType == !(nodeTypes.AstCall) then
		local valueCall = valueExprLast

		if not valueCall.surroundedByParentheses then
			local calleeTypeInfo = valueCall.callee.inferredType

			if calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
				local listSig  = calleeTypeInfo
				calleeTypeInfo = listSig[1] or errorInternal() -- The error should have happened when inferring AstCall.
			end

			assert(calleeTypeInfo.tag == !(typeTags.TypeInfoFunction))

			local argTypesOut = calleeTypeInfo.argumentTypesOut
			local argCount    = #argTypesOut

			if argCount == 0 then
				if softCheck then  return false, 0  end
				typeError(state, valueCall, "Function call returns nothing. (Expected at least one value.)")
			end

			local returnsVararg = argCount > 0 and argTypesOut[argCount].tag == !(typeTags.TypeInfoVararg)
			local returnsMin    = returnsVararg and argCount-1 or argCount
			local returnsMax    = returnsVararg and math.huge  or argCount

			requestedMin = valueCount-1+returnsMin
			requestedMax = valueCount-1+returnsMax
			slotsToCheck = valueCount-1+argCount
		end

	elseif valueExprLast.nodeType == !(nodeTypes.AstVararg) then
		local valueVararg = valueExprLast

		if not valueVararg.surroundedByParentheses then
			requestedMin = valueCount - 1
			requestedMax = math.huge
			slotsToCheck = valueCount
		end
	end

	-- Get accepted count.
	local typeInfoCount   = #typeInfos
	local acceptingVararg = typeInfoCount > 0 and typeInfos[typeInfoCount].tag == !(typeTags.TypeInfoVararg)
	local acceptedMin     = acceptingVararg and typeInfoCount-1 or typeInfoCount
	local acceptedMax     = acceptingVararg and math.huge       or typeInfoCount

	-- Consider optional arguments for calls.
	-- @Robustness @Cleanup: We probably must have argument optionality be part of function types - not just the arguments types.
	-- @Robustness: Disallow this: local take2 :: (req:int, opt:int=0) {} ; local get1 :: () -> int {} ; take2(get1())  -- :DisallowListAsLastValueToFunctionWithOptionalArguments
	if callOrReturnNode.nodeType == !(nodeTypes.AstCall) and callOrReturnNode.callee.nodeType == !(nodeTypes.AstIdentifier) then
		calleeDecl = (calleeDecl or callOrReturnNode.callee.declaration)

		if calleeDecl.isConstant then
			local lambda = getDeclarationValue(calleeDecl) or errorInternal()
			lambda       = followIdentifiersToConstantValue(lambda)

			if lambda.nodeType ~= !(nodeTypes.AstLambda) then
				errorInternal(state, lambda)
			end

			!ASSERT `lambda.inferredType`

			if not areArraysEqual(typeInfos, lambda.inferredType.argumentTypesIn) then
				-- We should only get here if checking overloads.
				if softCheck then  return false, 0  end
				assert(false)
			end

			for i = acceptedMin, 1, -1 do
				local arg = lambda.argumentsIn.arguments[i]
				if arg.isRequired then
					break
				else
					acceptedMin = acceptedMin-1
				end
			end
		end
	end

	-- io.stdout:write(F("requested %.0f-%.0f, accepted %.0f-%.0f  ", requestedMin, requestedMax, acceptedMin, acceptedMax)) ; astPrint(callOrReturnNode)

	-- Too few values.
	-- @UX: Better error message if the last value is a call (without parentheses).
	if requestedMin < acceptedMin then
		if softCheck then  return false, 0  end

		local exprForError = values[1] and getArgumentNodeForError(callOrReturnNode, 1, values[1]) or callOrReturnNode
		local prefix       = requestedMax+acceptedMax == math.huge and "Incorrect number of" or "Missing"
		local thingsStr    = callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "arguments" or "values to return"
		local gotStr       = (requestedMax ~= math.huge and F("%d", requestedMin)) or (requestedMin == 0 and "variable amount") or F("%d + variable amount", requestedMin)

		typeError(state, exprForError, "%s %s. (Wanted %d, got %s)", prefix, thingsStr, acceptedMin, gotStr)

	-- Too many values.
	-- @UX: Better error message if the last value is a call (without parentheses).
	elseif requestedMax > acceptedMax then
		!ASSERT `not acceptingVararg`

		if softCheck then  return false, 0  end

		local valueIndex          = math.min(acceptedMax+1, valueCount)
		local firstExtraValueExpr = values[valueIndex]
		local exprForError        = getArgumentNodeForError(callOrReturnNode, valueIndex, firstExtraValueExpr)
		local prefix              = requestedMax+acceptedMax == math.huge and "Incorrect number of" or "Too many"
		local thingsStr           = callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "arguments" or "values to return"
		local gotStr              = (requestedMax ~= math.huge and F("%d", requestedMin)) or (requestedMin == 0 and "variable amount") or F("%d + variable amount", requestedMin)

		typeError(state, exprForError, "%s %s. (Wanted %d, got %s)", prefix, thingsStr, acceptedMax, gotStr) -- Note: acceptedMax is never infinite here.
	end

	local compatibilityScoreSum = 0

	for slot = 1, slotsToCheck do
		local valueIndex      = math.min(slot, valueCount)
		local valueExpr       = values[valueIndex]
		local valueTypeInfo   = valueTypes[valueIndex]

		local typeInfoIndex   = math.min(slot, typeInfoCount)
		local typeInfoToMatch = typeInfos[typeInfoIndex]

		local isCompatible, compatibilityScore

		-- Function call (0..inf values).
		if valueTypeInfo.tag == !(typeTags.TypeInfoList) then
			local listSig         = valueTypeInfo
			local callOutArgIndex = slot-valueIndex+1
			valueTypeInfo         = listSig[callOutArgIndex]

			if not valueTypeInfo then
				if softCheck then  return false, 0  end
				typeError(state, valueExpr, "Function call returns nothing. (Expected at least one value.)") -- Note: "Nothing" is not the same as vararg of zero length.
			end

			local adjustVarargToIncludeNil   = not (valueTypeInfo.tag == !(typeTags.TypeInfoVararg) and typeInfoToMatch.tag == !(typeTags.TypeInfoVararg))
			local valueTypeInfoAdjusted      = adjustTypeToOne(state, valueExpr,        valueTypeInfo, adjustVarargToIncludeNil) -- We have a value with a type.
			local typeInfoToMatchAdjusted    = adjustTypeToOne(state, callOrReturnNode, typeInfoToMatch)                         -- We want a specific type.
			isCompatible, compatibilityScore = isTypeCompatibleWith(valueTypeInfoAdjusted, typeInfoToMatchAdjusted)

			if not isCompatible then
				if softCheck then  return false, 0  end
				-- @UX: Tell the name of the call/return argument. (For calls, probably only possible for constants, and maybe not all. Not sure! Returns just depend on the output arguments being named.)
				-- @UX: Tell the name of the value call's argument. (Probably only possible for constants, and maybe not all. Not sure!)
				typeError(
					state, valueExpr,
					"Type mismatch for %s #%d (return value #%d from call). (Wanted %s, got %s)",
					callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "argument" or "return value",
					slot,
					callOutArgIndex,
					getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
					getFriendlyTypeInfoName(valueTypeInfoAdjusted)
				)
			end

		-- Vararg (0..inf values) OR other (1 value).
		else
			local adjustVarargToIncludeNil   = not (valueTypeInfo.tag == !(typeTags.TypeInfoVararg) and typeInfoToMatch.tag == !(typeTags.TypeInfoVararg))
			local valueTypeInfoAdjusted      = adjustTypeToOne(state, valueExpr,        valueTypeInfo, adjustVarargToIncludeNil) -- We have a value with a type.
			local typeInfoToMatchAdjusted    = adjustTypeToOne(state, callOrReturnNode, typeInfoToMatch)                         -- We want a specific type.
			isCompatible, compatibilityScore = isTypeCompatibleWith(valueTypeInfoAdjusted, typeInfoToMatchAdjusted)

			if not isCompatible then
				if softCheck then  return false, 0  end
				!ifDEBUG `astPrintTree(callOrReturnNode)`
				typeError(
					state, getArgumentNodeForError(callOrReturnNode, valueIndex, valueExpr),
					"Type mismatch for %s #%d. (Wanted %s, got %s)",
					callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "argument" or "return value",
					slot,
					getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
					getFriendlyTypeInfoName(valueTypeInfoAdjusted)
				)
			end
		end

		compatibilityScoreSum = compatibilityScoreSum + compatibilityScore
	end

	-- @Incomplete: Decrease compatibilityScoreSum as optional arguments are left out?

	return true, compatibilityScoreSum
end

local function getMatchingFunctions(state, call, realArguments, realArgumentTypes, declarations)
	local matches = nil

	for _, decl in ipairs(declarations) do
		local funcSig = decl.name.inferredType

		!ASSERT("funcSig.tag == "..typeTags.TypeInfoFunction)

		local doesMatch, compatibilityScore = checkIfValuesMatchArgumentTypes(
			state, call, realArguments, realArgumentTypes, funcSig.argumentTypesIn, true, decl
		)
		if doesMatch then
			matches = matches or {}
			table.insert(matches, {declaration=decl, score=compatibilityScore})
		end
	end

	return matches
end

local function getBestMatchOrTriggerError(state, call, matches, matchTerm, errorTextOnDraw)
	table.sort(matches, function(a, b)
		return a.score > b.score
	end)

	local highscore = matches[1].score

	if not matches[2] or matches[2].score < highscore then
		return matches[1].declaration
	end

	!TRACE()
	printerr()
	typeMessage(io.stderr, state, call.callee, "Error", errorTextOnDraw)
	for i, matchData in ipairs(matches) do
		if matchData.score < highscore then  break  end
		typeMessage(io.stderr, state, matchData.declaration.name, "Info", "...%s #%d.", matchTerm, i)
	end
	exitFailure()
end

local function getPathToNode(state, topNode, node, nodeContainers, nodeKeys)
	!ASSERT `topNode`
	local locations = {}

	-- while true do
	while node ~= topNode do
		local loc = {
			containerNode = node.parent,
			container     = nodeContainers[node] or errorInternal(state, node),
			key           = nodeKeys[node]       or errorInternal(state, node),
		}
		table.insert(locations, loc)
		-- if node == topNode then  break  end
		node = node.parent or errorInternal(state, topNode)
	end

	return reverseArray(locations)
end

local function handlePolymorphicCall(state, call, calleeTypeInfo, realArguments, realArgumentTypes)
	local ident = call.callee
	if ident.nodeType ~= !(nodeTypes.AstIdentifier) then
		errorInternal(state, ident, "Expected an identifier. Referring to unknown polymorphic function.")
	end

	local decl = ident.declaration
	if not decl.isConstant then
		errorInternal(state, ident, "Identifier is not a constant.")
	end

	local lambda = decl.value or errorInternal(state, decl)
	assert(lambda.nodeType == !(nodeTypes.AstLambda))

	for _, statement in ipairs(lambda.statements) do
		if statement.queued and statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	for _, morphDecl in ipairs(lambda.polymorphs) do
		if not morphDecl.name.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `morphDecl.name`)
		end
	end

	checkIfValuesMatchArgumentTypes(state, call, realArguments, realArgumentTypes, calleeTypeInfo.argumentTypesIn) -- Basically checks everything but placeholders.

	-- Prepare for auto-bake stuff.
	local autobaking               = false
	local autobakeIndex            = 0
	local nonAutobakeArguments     = realArguments
	local nonAutobakeArgumentTypes = realArgumentTypes
	local relevantPolymorphs       = lambda.polymorphs

	for argIndex, arg in ipairs(lambda.argumentsIn.arguments) do
		if arg.autobake == !(AUTOBAKE_REQUIRED) then
			autobaking    = true
			autobakeIndex = autobakeIndex+1

			if autobakeIndex == 1 then
				nonAutobakeArguments     = {unpack(nonAutobakeArguments)}
				nonAutobakeArgumentTypes = {unpack(nonAutobakeArgumentTypes)}
				relevantPolymorphs       = {unpack(relevantPolymorphs)}
			end

			if call.isMethod then
				errorInternal(state, arg, "@Incomplete: Handle method calls when auto-baking.")
			end

			local valueExpr     = realArguments    [argIndex] or errorInternal(state, call)
			local valueTypeInfo = realArgumentTypes[argIndex] or errorInternal(state, valueExpr)

			if not isExpressionConstant(state, valueExpr, false) then
				-- @UX: Better message for foreign values.
				typeError(state, valueExpr, "Argument must be constant for baking.")
			end

			for i, morphDecl in ipairsr(relevantPolymorphs) do
				local morphLambda    = morphDecl.value
				local autobakedValue = morphLambda.bakeValues[autobakeIndex] or errorInternal()

				if not areTreesEqual(state, valueExpr, autobakedValue) then
					table.remove(relevantPolymorphs, i)
				end
			end

		elseif arg.autobake == !(AUTOBAKE_ENABLED) then
			errorInternal(state, arg, "@Incomplete: Optional auto-baking.")
		end
	end

	if autobaking then
		for argIndex, arg in ipairsr(lambda.argumentsIn.arguments) do
			if arg.autobake == !(AUTOBAKE_REQUIRED) then
				table.remove(nonAutobakeArguments,     argIndex)
				table.remove(nonAutobakeArgumentTypes, argIndex)
			end
		end
	end

	-- Check for previous matching polymorph(s).
	local matchingMorphs = getMatchingFunctions(state, call, nonAutobakeArguments, nonAutobakeArgumentTypes, relevantPolymorphs)

	if matchingMorphs then
		local morphDecl = getBestMatchOrTriggerError(
			state, call, matchingMorphs, "polymorph",
			"Internal compiler error: There are several matching polymorphs."
		)

		if autobaking then
			for argIndex, arg in ipairsr(lambda.argumentsIn.arguments) do
				if arg.autobake == !(AUTOBAKE_REQUIRED) then
					local valueExpr = call.arguments[argIndex]
					unqueueChildrenRecursively(state, valueExpr)
					unqueue(valueExpr)
					table.remove(call.arguments, argIndex)
				end
			end

			for argIndexNew, valueExpr in ipairs(call.arguments) do
				valueExpr.queued.key = argIndexNew
			end
		end

		-- Update the callee to represent the correct polymorph.
		ident.declaration  = morphDecl
		ident.inferredType = nil

		queueForReinfer(state, ident) -- Re-infer callee.

		local dependency = getExistingDependency(state, call, !(DEPEND_NODE_INFERRED), ident)
		if dependency then
			call.queued.waitingOn = dependency
			return
		else
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `ident`)
		end
	end

	-- Create declaration for the morphed lambda.
	local morphDecl            = astNewNode(AstDeclaration, lambda.token, lambda)
	morphDecl.isConstant       = true
	morphDecl.addedByPolymorph = true

	local morphIdent       = astNewNode(AstIdentifier, morphDecl.token, morphDecl)
	morphIdent.name        = ident.name.."_POLY"..(#lambda.polymorphs+1)
	morphIdent.declaration = morphDecl
	morphDecl.name         = morphIdent

	local morphLambda = astCopy(lambda, nil, morphDecl)
	morphDecl.value   = morphLambda

	-- Don't keep copies of previous polymorphs we've made - that would quickly create a mess!
	-- (@Speed: Don't even copy them in the first place.)
	do
		morphLambda.isPolymorphic = false
		morphLambda.polymorphs    = {}

		for i, statement in ipairsr(morphLambda.statements) do
			if !!(anyV(`statement.nodeType`, nodeTypes.AstDeclaration,nodeTypes.AstAssignment)) and statement.addedByPolymorph then
				table.remove(morphLambda.statements, i) -- Should be fast enough. There shouldn't be that many statements in lambdas.
			end
		end

		for _, declBaked in ipairs(morphLambda.bakeDeclarations) do
			declBaked.checkedRedeclaration = true -- @Hack to prevent redeclaration errors between polymorphed lambda and base lambda.
		end
	end

	table.insert(lambda.polymorphs, morphDecl)

	astVisitAllNodes(morphLambda, function(node, container, key)
		if node == morphLambda.body then  return !(VISIT_IGNORE_CHILDREN)  end

		-- @Robustness @Robustness @Robustness: So much @Hack!
		node.inferredType    = nil
		node.valueTypeInfo   = nil
		node.representedType = nil

		-- AstBake nodes are only used before baking.
		if node.nodeType == !(nodeTypes.AstBake) then
			local bake       = node
			container[key]   = bake.name
			bake.name.parent = bake.parent
			return !(VISIT_IGNORE_CHILDREN)
		end
	end)

	-- Fill in baked values in morphed lambda.
	!ASSERT `lambda.argumentsIn`
	local bakeIndex = 0

	for argIndex, arg in ipairs(lambda.argumentsIn.arguments) do
		local declTypeExpr = arg.declaration.type -- This is probably an AstType, if anything.

		if declTypeExpr then
			local nodeContainers = {}
			local nodeKeys       = {}

			astVisitAllNodes(declTypeExpr, function(node, container, key)
				nodeContainers[node] = container or arg.declaration
				nodeKeys      [node] = key       or "type"

				if node.nodeType ~= !(nodeTypes.AstBake) then  return  end

				local bake = node
				bakeIndex  = bakeIndex+1

				if arg.autobake ~= !(AUTOBAKE_DISABLED) then
					typeError(state, bake, "Combinations of auto-baking and placeholder types are not supported yet.")
				end

				-- @Incomplete: Handle optional arguments.
				local valueExpr     = realArguments[argIndex] or errorInternal(state, call)
				local bakeValueExpr = nil
				local bakeValueType = realArgumentTypes[argIndex] or errorInternal(state, valueExpr)
				bakeValueType       = adjustTypeToOne(state, valueExpr, bakeValueType)

				!(
				local function BAKE_ERROR(messageAndParamsCode)
					TRACE()
					__LUA(templateToLua(
						trimTemplate`
							printerr()
							typeMessage(io.stderr, state, valueExpr, "Error", $message)
							if bakeValueExpr then
								typeMessage(
									io.stderr, state, bakeValueExpr, "Info",
									"...here is the current value being looked at. (Type is '%s')",
									getFriendlyTypeInfoName(bakeValueExpr.inferredType))
							end
							exitFailure()
						`,
						{message=messageAndParamsCode}
					))
				end
				)

				for _, patternLoc in ipairs(getPathToNode(state, declTypeExpr, bake, nodeContainers, nodeKeys)) do
					if patternLoc.containerNode.nodeType == !(nodeTypes.AstType) then
						local patternTypeNode = patternLoc.containerNode

						if patternTypeNode.kind == !(TYPE_KIND_ARRAY) then
							if bakeValueType.tag == !(typeTags.TypeInfoArray) then
								local arraySig = bakeValueType
								bakeValueExpr  = nil
								bakeValueType  = arraySig.itemType or errorInternal(state, valueExpr)

							elseif bakeValueType.tag == !(typeTags.TypeInfoStruct) and bakeValueType.kind == !(STRUCT_KIND_ARRAY) then
								local structInfo = bakeValueType
								bakeValueExpr    = nil
								bakeValueType    = structInfo.valueType or errorInternal(state, valueExpr)

							else
								!BAKE_ERROR`"Polymorphic call: Unexpected type. (Wanted an array, got %s)", getFriendlyTypeInfoName(bakeValueType)`
							end

						else
							errorUnhandledNodeType(state, patternTypeNode)
						end

					elseif patternLoc.containerNode.nodeType == !(nodeTypes.AstCall) then
						local patternCall = patternLoc.containerNode

						if bakeValueType.tag == !(typeTags.TypeInfoStruct) then
							-- void
						elseif bakeValueType.tag == !(typeTags.TypeInfoType) then
							-- Note sure if this is bullet proof or sane in any way...
							assert(bakeValueExpr)
							bakeValueType = requireTypeRepresentedByExpression(state, bakeValueExpr)
						else
							!BAKE_ERROR`"Polymorphic call: Expected a type to be a (polymorphic) struct. (Got %s)", getFriendlyTypeInfoName(bakeValueType)`
						end

						local structInfo = bakeValueType
						if structInfo.tag ~= !(typeTags.TypeInfoStruct) then
							!BAKE_ERROR`"Polymorphic call: Expected a type to be a (polymorphic) struct. (Got %s)", getFriendlyTypeInfoName(structInfo)`
						elseif not structInfo.astNode.polymorphSourceStruct then
							bakeValueExpr = structInfo.astNode
							!BAKE_ERROR`"Polymorphic call: Expected a type to be a polymorphic struct. (%s is not polymorphic)", getFriendlyTypeInfoName(structInfo)`
						end

						-- @Incomplete: Handle optional arguments.
						if #patternCall.arguments ~= #structInfo.astNode.bakeDeclarations then
							bakeValueExpr = structInfo.astNode
							!BAKE_ERROR`
								"Polymorphic call: Expected an argument value type to be a polymorphic struct that takes %d argument%s. (%s takes %d)  (Note: Optional arguments are not handled properly yet.)",
								#patternCall.arguments,
								patternCall.arguments[2] and "s" or "",
								getFriendlyTypeInfoName(structInfo),
								#structInfo.astNode.bakeDeclarations
							`
						end

						local declBakedOther = structInfo.astNode.bakeDeclarations[patternLoc.key] or errorInternal(state, valueExpr)

						bakeValueExpr = declBakedOther.value or errorInternal(state, declBakedOther)
						bakeValueType = bakeValueExpr.inferredType -- Note: declBakedOther.name may not be inferred yet.

						if not bakeValueType then
							!BAKE_ERROR`"Internal compiler error: Polymorphic call: Expected this to be inferred."` -- 'this' is referring to bakeValueExpr. (See BAKE_ERROR)
						end

					else
						errorUnhandledNodeType(state, patternLoc.containerNode)
					end
				end--for getPathToNode

				local declBaked = morphLambda.bakeDeclarations[bakeIndex] or errorInternal(state, bake)
				if bakeValueExpr then
					declBaked.value = astCopy(bakeValueExpr, declBaked.token, declBaked)
				else
					declBaked.value = createTypeNodeFromInfo(state, bakeValueType, declBaked.token, declBaked)
				end

				return !(VISIT_IGNORE_CHILDREN) -- There should only be an identifier inside AstBake.
			end)
		end
	end
	!ASSERT `bakeIndex == #lambda.bakeDeclarations`

	if autobaking then
		for argIndex, arg in ipairsr(morphLambda.argumentsIn.arguments) do
			if arg.autobake == !(AUTOBAKE_REQUIRED) then
				--
				-- Here we convert auto-baked arguments to hidden declarations
				-- in the lambda and update the calling site accordingly.
				--
				local declBaked  = arg.declaration
				declBaked.parent = morphLambda
				declBaked.checkedRedeclaration = true -- @Hack to prevent redeclaration errors between polymorphed lambda and base lambda.
				table.insert(morphLambda.statements,   declBaked)
				table.insert(morphLambda.declarations, declBaked)
				-- table.insert(morphLambda.bakeDeclarations, declBaked) -- Should we do this? It may be useless.

				-- Reuse valueExpr instead of making a copy. Note that this is the
				-- only thing in the morphed lambda that will already be inferred.
				local valueExpr            = realArguments[argIndex]
				declBaked.value            = valueExpr
				valueExpr.parent           = declBaked
				valueExpr.queued.container = declBaked
				valueExpr.queued.key       = "value"
				table.insert(morphLambda.bakeValues, 1, valueExpr)

				table.remove(morphLambda.argumentsIn.arguments, argIndex)
				table.remove(call.arguments,                    argIndex)

			elseif arg.autobake == !(AUTOBAKE_ENABLED) then
				errorInternal(state, arg, "@Incomplete: Optional auto-baking.")
			end
		end

		if not morphLambda.argumentsIn.arguments[1] then
			removeItem(morphLambda.statements, morphLambda.argumentsIn)
			morphLambda.argumentsIn = nil
		end

		-- !ifDEBUG `astPrintTree(call)`
		-- !ifDEBUG `astPrintTree(morphLambda)`
	end

	-- Update the source lambda, add queueds etc.
	local i              = #lambda.statements+1
	lambda.statements[i] = morphDecl

	addUnqueuedChildrenToQueueRecursively(state, morphDecl, !(PIPE_INFER))
	addToQueue(state, morphDecl, lambda.statements, i, !(PIPE_INFER))

	for _, declBaked in ipairs(morphLambda.bakeDeclarations) do
		local valueExpr         = declBaked.value
		declBaked.valueTypeInfo = getTypeRepresentedByExpression(valueExpr)
		moveToNextRelevantPipe(state, valueExpr)
	end

	-- Update the callee to represent the correct polymorph.
	ident.declaration  = morphDecl
	ident.inferredType = nil

	queueForReinfer(state, ident) -- Re-infer callee.

	local dependency = getExistingDependency(state, call, !(DEPEND_NODE_INFERRED), ident)
	if dependency then
		call.queued.waitingOn = dependency
		return
	else
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `ident`)
	end
end

local function handleOverloadedCall(state, call, realArguments, realArgumentTypes)
	local ident    = call.callee
	local declBase = ident.declaration

	while declBase.overloadOf ~= declBase do  declBase = declBase.overloadOf  end

	local matchingOverloads = getMatchingFunctions(state, call, realArguments, realArgumentTypes, declBase.overloads)

	if not matchingOverloads then
		!TRACE()
		printerr()
		typeMessage(io.stderr, state, ident, "Error", "Did not find any matching overload to call.") -- @UX: Show expected signature.
		for i, declOverload in ipairs(declBase.overloads) do
			typeMessage(io.stderr, state, declOverload.name, "Info", "...overload #%d: %s", i, getFriendlyTypeInfoName(declOverload.name.inferredType))
		end
		exitFailure()
	end

	local decl = getBestMatchOrTriggerError(
		state, call, matchingOverloads, "overload",
		"There are several matching overloads."
	)
	local calleeTypeInfo = decl.name.inferredType

	-- Update the callee to represent the correct overload.
	-- @Robustness: Is this safe? I don't think anything except the calls itself depends directly on, and uses values from, any callee.
	ident.declaration  = decl
	ident.inferredType = calleeTypeInfo

	return calleeTypeInfo
end

local function handlePolymorphicStruct(state, call)
	local typeNode = call.callee
	assert(typeNode.nodeType == !(nodeTypes.AstType))

	local structInfo = typeNode.representedType
	assert(structInfo.tag == !(typeTags.TypeInfoStruct))
	assert(structInfo.isPolymorphic)

	local struct = structInfo.astNode

	for _, morphDecl in ipairs(struct.polymorphs) do
		if not morphDecl.name.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `morphDecl.name`)
		end
	end

	-- Check arguments.
	for argIndex, argExpr in ipairs(call.arguments) do
		if not isExpressionConstant(state, argExpr, false) then
			-- @UX: Better message for foreign values.
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(argExpr), "Struct argument #%d is not constant.", argIndex)
		end
	end

	local requested   = #call.arguments
	local acceptedMax = #struct.bakeDeclarations
	local acceptedMin = acceptedMax

	for argIndex = acceptedMax, 1, -1 do
		if not struct.bakeDeclarations[argIndex].value then  break  end
		acceptedMin = acceptedMin-1
	end

	if requested < acceptedMin then
		typeError(state, call, "Too few struct arguments. (Expected %d, got %d)", acceptedMin, requested)
	elseif requested > acceptedMax then
		typeError(
			state, astGetExpressionVisuallyFurthestToTheLeft(call.arguments[acceptedMax+1]),
			"Too many struct arguments. (Expected %d, got %d)",
			acceptedMax, requested
		)
	end

	-- Check for previous matching polymorph.
	for _, morphDecl in ipairs(struct.polymorphs) do
		local morphStruct = morphDecl.value
		local isMatch     = true

		for argIndex, declBaked in ipairs(morphStruct.bakeDeclarations) do
			local valueBaked = declBaked.value
			local valueExpr  = call.arguments[argIndex] or struct.bakeDeclarations[argIndex].value

			if valueExpr.nodeType ~= valueBaked.nodeType then
				isMatch = false ; break
			elseif valueExpr.nodeType == !(nodeTypes.AstLiteral) then
				if valueExpr.value ~= valueBaked.value then -- Note: We don't need to check the literalType.
					isMatch = false ; break
				end
			elseif valueExpr.nodeType == !(nodeTypes.AstType) then
				if valueExpr.representedType ~= valueBaked.representedType then
					isMatch = false ; break
				end
			else
				errorUnhandledNodeType(state, valueExpr)
			end
		end

		if isMatch then
			-- Change the call into a type node.
			local morphTypeNode       = astNewNode(AstType, typeNode.token, call.parent)
			morphTypeNode.kind        = !(TYPE_KIND_SIMPLE_USER)
			morphTypeNode.typeName    = morphDecl.name.name
			morphTypeNode.declaration = morphDecl

			replaceQueuedNodeAndUnqueueOldTree(state, call, morphTypeNode)

			-- Stay in PIPE_INFER. Also, the next line is needed.
			!DEPEND_AND_RETURN(`morphTypeNode`, DEPEND_NODE_INFERRED, `morphDecl`)
		end
	end

	-- Create declaration for the morphed struct.
	local morphDecl            = astNewNode(AstDeclaration, struct.token, struct)
	morphDecl.isConstant       = true
	morphDecl.addedByPolymorph = true

	local morphIdent       = astNewNode(AstIdentifier, morphDecl.token, morphDecl)
	morphIdent.name        = typeNode.typeName.."_POLY"..(#struct.polymorphs+1)
	morphIdent.declaration = morphDecl
	morphDecl.name         = morphIdent

	local morphStruct                 = astCopy(struct, nil, morphDecl)
	morphStruct.inferredType          = nil
	morphStruct.representedType       = nil
	morphStruct.polymorphSourceStruct = struct
	morphDecl.value                   = morphStruct

	-- Don't keep copies of previous polymorphs we've made - that would quickly create a mess!
	-- (@Speed: Don't even copy them in the first place.)
	do
		morphStruct.isPolymorphic = false
		morphStruct.polymorphs    = {}

		for i, statement in ipairsr(morphStruct.statements) do
			if !!(anyV(`statement.nodeType`, nodeTypes.AstDeclaration,nodeTypes.AstAssignment)) and statement.addedByPolymorph then
				table.remove(morphStruct.statements, i) -- This line should only trigger at most twice per polymorph.
			end
		end
	end

	table.insert(struct.polymorphs, morphDecl)

	-- Bake values into morphed struct.
	for argIndex, declBaked in ipairs(morphStruct.bakeDeclarations) do
		local valueExpr = call.arguments[argIndex] -- Is nil for optional arguments.
		if valueExpr then
			declBaked.value = astCopy(valueExpr, nil, declBaked) -- Overwrite any old value expression.
		end
		declBaked.checkedRedeclaration = true -- @Hack to prevent redeclaration errors between polymorphed struct and base struct.
	end

	-- Update the source struct, add queueds etc.
	local i              = #struct.statements+1
	struct.statements[i] = morphDecl
	addToQueueRecursively(state, morphDecl, struct.statements, i, !(PIPE_INFER))

	-- Change the call into a type node.
	local morphTypeNode       = astNewNode(AstType, typeNode.token, call.parent)
	morphTypeNode.kind        = !(TYPE_KIND_SIMPLE_USER)
	morphTypeNode.typeName    = morphDecl.name.name
	morphTypeNode.declaration = morphDecl

	replaceQueuedNodeAndUnqueueOldTree(state, call, morphTypeNode)

	-- Stay in PIPE_INFER. Also, the next line is needed.
	!DEPEND_AND_RETURN(`morphTypeNode`, DEPEND_NODE_INFERRED, `morphDecl`)
end

local function doesExpressionRepresentPolymorphicStructType(expr)
	if expr.inferredType.tag ~= !(typeTags.TypeInfoType) then  return false  end

	local typeInfoRepresented = getTypeRepresentedByExpression(expr)
	return
		typeInfoRepresented ~= nil
		and typeInfoRepresented.tag == !(typeTags.TypeInfoStruct)
		and typeInfoRepresented.isPolymorphic
end

!NODE_INFERRER `function nodeInferrers.AstCall(state, call)`
	local callee         = call.callee
	local calleeTypeInfo = callee.inferredType

	if not calleeTypeInfo then
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `callee`)
	end

	if callee.nodeType == !(nodeTypes.AstIdentifier) and callee.declaration.overloadOf then
		-- Wait for all overloads to get inferred.
		local ident    = callee
		local declBase = ident.declaration

		while declBase.overloadOf ~= declBase do  declBase = declBase.overloadOf  end

		calleeTypeInfo = declBase.name.inferredType
		if not calleeTypeInfo then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `declBase.name`)
		end
	end

	for _, argExpr in ipairs(call.arguments) do
		if not argExpr.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `argExpr`)
		end
	end

	if calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then
		-- void

	elseif calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig  = calleeTypeInfo
		calleeTypeInfo = listSig[1]

		if not calleeTypeInfo then
			typeError(state, call, "Trying to call void.")
		elseif calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then
			-- void
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
		end

	elseif doesExpressionRepresentPolymorphicStructType(callee) then -- @Cleanup: We can/should probably just check callee.declaration.valueTypeInfo here.
		handlePolymorphicStruct(state, call)
		return

	else
		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			local ident = callee
			typeError(state, ident, "'%s' is not a function. (It is %s)", ident.name, getFriendlyTypeInfoName(ident.inferredType))
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
		end
	end

	!ASSERT("calleeTypeInfo.tag == "..typeTags.TypeInfoFunction)

	!if DEBUG then
		if call.isMethod and callee.nodeType ~= !(nodeTypes.AstAccess) then
			astPrint(callee)
			errorInternal(state, call)
		end
	!end

	local realArguments     = (call.isMethod and {callee, unpack(call.arguments)} or call.arguments)
	local realArgumentTypes = {}

	if call.isMethod then
		local typeInfo       = callee.object.inferredType
		realArgumentTypes[1] = adjustTypeToOne(state, callee.object, typeInfo, true) -- Is adjustTypeToOne necessary? @Cleanup
	end
	for _, argExpr in ipairs(call.arguments) do
		local typeInfo = argExpr.inferredType
		if !!(anyV(`argExpr.nodeType`, nodeTypes.AstVararg,nodeTypes.AstCall)) and argExpr.surroundedByParentheses then
			typeInfo = adjustTypeToOne(state, argExpr, typeInfo, true)
		end
		table.insert(realArgumentTypes, typeInfo)
	end

	-- Overloaded call.
	if callee.nodeType == !(nodeTypes.AstIdentifier) and callee.declaration.overloadOf then
		calleeTypeInfo = handleOverloadedCall(state, call, realArguments, realArgumentTypes) or errorInternal(state, call)

		if calleeTypeInfo.isPolymorphic then
			handlePolymorphicCall(state, call, calleeTypeInfo, realArguments, realArgumentTypes)
			return -- Wait for the polymorphed function to infer.
		end

	-- Polymorphic call.
	elseif calleeTypeInfo.isPolymorphic then
		handlePolymorphicCall(state, call, calleeTypeInfo, realArguments, realArgumentTypes)
		return -- Wait for the polymorphed function to infer.

	-- Plain call.
	else
		checkIfValuesMatchArgumentTypes(state, call, realArguments, realArgumentTypes, calleeTypeInfo.argumentTypesIn)
	end

	call.inferredType              = getTypeInfoForList(state, calleeTypeInfo.argumentTypesOut)
	call.couldBeTypeWithParameters = false

	moveToNextRelevantPipe(state, call)
end

!NODE_INFERRER `function nodeInferrers.AstReturn(state, returnNode)`
	for _, valueExpr in ipairs(returnNode.values) do
		if not valueExpr.inferredType then
			!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `valueExpr`)
		end
	end

	local scope = getClosestScope(returnNode) or errorInternal()

	while scope.nodeType ~= !(nodeTypes.AstLambda) do
		if not isScopeImperative(scope) then -- This may eventually be AstFileScope, at most.
			-- I think this is an internal compiler error, actually. Parsing must have goofed up or something.
			typeError(state, scope, "Return statement is not in a function.")
		end

		scope = getClosestScope(scope) or errorInternal()
	end

	local lambda = scope

	if not lambda.inferredType then
		!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `lambda`)
	end

	local typeInfos = {}
	for i, valueExpr in ipairs(returnNode.values) do
		typeInfos[i] = valueExpr.inferredType
	end

	checkIfValuesMatchArgumentTypes(state, returnNode, returnNode.values, typeInfos, lambda.inferredType.argumentTypesOut)
	moveToNextRelevantPipe(state, returnNode)
end

!NODE_INFERRER `function nodeInferrers.AstDeclaration(state, decl)`
	local valueExpr = getDeclarationValue(decl, true)
	if valueExpr and not valueExpr.inferredType then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED_FULLY, `valueExpr`) -- FULLY is needed if valueExpr is an AstTable.
	end

	local identOrVararg = decl.name
	if not identOrVararg.inferredType then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `identOrVararg`)
	end

	local typeExpr = decl.type

	if typeExpr then
		if not typeExpr.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `typeExpr`)
		end

		local typeInfoRepresented = requireTypeRepresentedByExpression(state, typeExpr)

		if decl.parent.nodeType == !(nodeTypes.AstArgument) then
			-- void  (Ignore function arguments.)
		elseif typeInfoRepresented.tag ~= !(typeTags.TypeInfoCompound) then
			-- void
		elseif decl.isConstant then
			typeError(
				state, decl.name,
				"Constants cannot be compound types. (Type is %s)",
				getFriendlyTypeInfoName(typeInfoRepresented)
			)
		elseif not valueExpr then
			typeError(
				state, decl.name,
				"An initial value is required for compound types. (Type is %s)",
				getFriendlyTypeInfoName(typeInfoRepresented)
			)
		end
	end

	-- @Incomplete: decl.notes (if we make them structured, which we should!)

	local scope = getClosestScope(decl)

	if valueExpr then
		if valueExpr.inferredType.tag == !(typeTags.TypeInfoNamespace) and not decl.isConstant then
			typeError(state, valueExpr, "References to namespaces must be constant.")
		end

		-- Validate that the assigned value is the same type as the declared name.
		--
		-- (Not needed for vararg as those only exist as arguments and don't have default values.
		-- Also, this doesn't run for enum members as those declarations never have any specified types.)
		--
		if typeExpr and identOrVararg.nodeType ~= !(nodeTypes.AstVararg) then
			local ident = identOrVararg

			if decl.assignment then
				getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, ident.inferredType, nil, nil)

			elseif not isTypeCompatibleWith(decl.value.inferredType, ident.inferredType) then -- Note: No need to call adjustTypeToOne() for decl.value.
				-- @UX: Use the same error message as getAssignmentValue().
				typeError(
					state, valueExpr, "Value type mismatch for assignment target #%d. (Wanted %s, got %s)",
					decl.assignmentIndex,
					getFriendlyTypeInfoName(ident.inferredType),
					getFriendlyTypeInfoName(decl.value.inferredType)
				)
			end
		end

		if decl.isConstant or isScopeDeclarative(scope) then
			if isExpressionConstant(state, valueExpr, false) then
				-- void

			elseif valueExpr.nodeType == !(nodeTypes.AstForeign) then
				-- void
				-- We usually treat foreign values as runtime values. The only exception is when
				-- it's placed directly on a declaration. (Can this be solved in a better way?)
				-- :SpecialForeignValueRules

			elseif astFindInTree(valueExpr, !(nodeTypes.AstForeign)) then
				local foreign = astFindInTree(valueExpr, !(nodeTypes.AstForeign))
				typeError(state, foreign, "Cannot evaluate foreign values during compile time.")

			else
				-- @UX: If the expression is/contains a table with a non-constant field, point out which field key or value!
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
					"Value for declared %s '%s' is not a constant expression.%s",
					(decl.isConstant and "constant" or "variable"),
					identOrVararg.name,
					(not decl.isConstant and isScopeDeclarative(scope) and " (All values in declarative scopes must be constant.)" or "")
				)
			end
		end

	elseif not (
		doesTypeHaveAnyDefaultValue(identOrVararg.inferredType)
		-- Ignore missing values for arguments (which are then required arguments).
		or decl.parent.nodeType == !(nodeTypes.AstArgument)
		-- Variables in foreign structs do not need initial values since those structs never get constructed locally anyway. (This also makes method declarations look nicer.)
		or (not decl.isConstant and decl.parent == scope and scope.nodeType == !(nodeTypes.AstStruct) and scope.isForeign)
	) then
		!ASSERT `not decl.isConstant` -- This should have been detected in inferIdentifierOrVararg() (I think).
		typeError(state, identOrVararg, "Variables in type group '%s' must have a specified initial value.", TYPE_TAG_NAMES[identOrVararg.inferredType.tag])
	end

	moveToNextRelevantPipe(state, decl)
end

!!local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = {
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "none",
	[LITERAL_FLOAT]   = "float",
	[LITERAL_STRING]  = "string",
}
_G.!(local )!!BUILTIN_TYPE_TAG_TO_LITERAL_TYPE = {
	[typeTags.TypeInfoBool]   = LITERAL_BOOLEAN,
	[typeTags.TypeInfoInt]    = LITERAL_INTEGER,
	[typeTags.TypeInfoNone]   = LITERAL_NIL,
	[typeTags.TypeInfoFloat]  = LITERAL_FLOAT,
	[typeTags.TypeInfoString] = LITERAL_STRING,
}

!NODE_INFERRER `function nodeInferrers.AstLiteral(state, literal)`
	local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType] or errorUnhandledNodeType(state, literal)

	literal.inferredType = getTypeInfoForBuiltinType(state, typeName)

	moveToNextRelevantPipe(state, literal)
end

!NODE_INFERRER `function nodeInferrers.AstUnary(state, unary)`
	local typeInfo = unary.expression.inferredType
	if not typeInfo then
		!DEPEND_AND_RETURN(`unary`, DEPEND_NODE_INFERRED, `unary.expression`)
	end

	typeInfo = adjustTypeToOne(state, unary.expression, typeInfo, true)

	if unary.operation == "+" or unary.operation == "-" then
		-- @Incomplete: Allow int|float compound type here (or disallow declarations of that specific compound type).
		if not isTypeNumeric(typeInfo) then
			typeError(
				state, unary.expression,
				"Unary numeric operation (%s): Expected a float or int. (Got %s)",
				unary.operation,
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "not" then
		if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
			wrapInImplicitCast(state, unary.expression, getTypeInfoForBuiltinType(state, "bool"), true)
			return
		end

	elseif unary.operation == "#" then
		if not !!(anyV(`typeInfo.tag`, typeTags.TypeInfoArray,typeTags.TypeInfoTable)) then
			typeError(
				state, unary.expression,
				"Unary length operation (#): Expected an array or a table. (Got %s)",
				getFriendlyTypeInfoName(typeInfo)
			)
		end

		typeInfo = getTypeInfoForBuiltinType(state, "int")

	else
		errorUnhandledNodeType(state, unary)
	end

	unary.inferredType = typeInfo

	moveToNextRelevantPipe(state, unary)
	simplifyExpressionIfConstant(state, unary)
end

local function isArrayItemOrTableFieldCheck(state, binary, typeInfoL, typeInfoR)
	-- Detect situations like these: myArray[i]==nil or myTable[k]==nil

	local maybeAccess = binary.left
	local nilExpr     = binary.right

	if nilExpr.inferredType.tag == !(typeTags.TypeInfoNone) then
		-- void
	elseif maybeAccess.inferredType.tag == !(typeTags.TypeInfoNone) then
		nilExpr, maybeAccess = maybeAccess, nilExpr
	else
		return false
	end

	if maybeAccess.nodeType ~= !(nodeTypes.AstAccess) then  return false  end

	local tag = maybeAccess.object.inferredType.tag
	if not !!(anyV(`tag`, typeTags.TypeInfoArray,typeTags.TypeInfoTable)) then  return false  end

	return true
end

local function isCompoundCompare(state, binary, typeInfoL, typeInfoR)
	-- Detect situations like these: local v:int|string = 0 ; if v == ""

	local compound    = typeInfoL
	local otherType   = typeInfoR

	local lIsCompound = (compound.tag  == !(typeTags.TypeInfoCompound))
	local rIsCompound = (otherType.tag == !(typeTags.TypeInfoCompound))

	if lIsCompound and rIsCompound then
		-- The compound types must be the same for a theoretical test here to pass
		-- since both compounds must contain all of the other one's types, but we
		-- should already have checked for that and thus shouldn't be here. So, we
		-- simply say they are incompatible right away.
		return false
	elseif lIsCompound then
		-- void
	elseif rIsCompound then
		compound, otherType = otherType, compound
	else
		return false
	end

	return indexOf(compound, otherType) ~= nil -- We don't use isTypeCompatibleWith() here - the compound must contain exactly otherType!
end

local function isValidEqualityCheck(state, binary, typeInfoL, typeInfoR)
	if typeInfoL     == typeInfoR               then  return true  end
	if typeInfoL.tag == !(typeTags.TypeInfoAny) then  return true  end
	if typeInfoR.tag == !(typeTags.TypeInfoAny) then  return true  end

	if isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR) then  return true  end

	if isArrayItemOrTableFieldCheck(state, binary, typeInfoL, typeInfoR) then  return true  end
	if isCompoundCompare           (state, binary, typeInfoL, typeInfoR) then  return true  end

	return false
end

-- resultingTypeInfo = checkBinaryOperation( state, expressionForError, mainExpression, leftExpression, rightExpression, binaryOperation, typeInfoL, typeInfoR, inAssignment )
-- Resurns nil if a cast was added and we're now waiting for it to infer.
function _G.checkBinaryOperation(state, exprForError, exprMain,exprL,exprR, binOp, typeInfoL,typeInfoR, inAssignment)
	!local TYPE_MISMATCH = `typeError(
		state, exprForError,
		"Binary operation (%s): Type mismatch for operands. (Left is %s, right is %s)",
		binOp,
		getFriendlyTypeInfoName(typeInfoL),
		getFriendlyTypeInfoName(typeInfoR)
	)`

	-- Numeric operation.
	if !!(anyV(`binOp`, "+","-","*","^","%","/","//")) then
		if not (isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR)) then
			typeError(
				state, exprMain,
				"Binary numeric operation (%s): Expected operands to be numeric. (Got %s and %s)",
				binOp,
				getFriendlyTypeInfoName(typeInfoL),
				getFriendlyTypeInfoName(typeInfoR)
			)
		end

		if binOp == "/" then
			return getTypeInfoForBuiltinType(state, "float")
		elseif binOp == "//" then
			return getTypeInfoForBuiltinType(state, "int")
		elseif typeInfoL.tag == !(typeTags.TypeInfoFloat) or typeInfoR.tag == !(typeTags.TypeInfoFloat) then
			return getTypeInfoForBuiltinType(state, "float")
		else
			return getTypeInfoForBuiltinType(state, "int")
		end

	-- Comparison.
	elseif !!(anyV(`binOp`, "<",">","<=",">=")) then
		if not (typeInfoL == typeInfoR or (isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR))) then
			!!(TYPE_MISMATCH)
		elseif not !!(anyV(`typeInfoL.tag`, typeTags.TypeInfoInt,typeTags.TypeInfoFloat,typeTags.TypeInfoString)) then
			typeError(
				state, exprMain,
				"Binary comparison (%s): Expected a float, int or string. (Got %s)",
				binOp,
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		return getTypeInfoForBuiltinType(state, "bool")

	-- Equality.
	elseif !!(anyV(`binOp`, "==","~=")) then
		if not isValidEqualityCheck(state, exprForError, typeInfoL, typeInfoR) then
			!!(TYPE_MISMATCH)
		end
		return getTypeInfoForBuiltinType(state, "bool")

	-- Boolean operation.
	elseif !!(anyV(`binOp`, "and","or")) then
		local bothAreBool = true
		local typeInfo    = getTypeInfoForBuiltinType(state, "bool")

		if typeInfoL.tag ~= !(typeTags.TypeInfoBool) then
			!ASSERT `not inAssignment`
			bothAreBool = false
			wrapInImplicitCast(state, exprL, typeInfo, true)
		end
		if typeInfoR.tag ~= !(typeTags.TypeInfoBool) then
			bothAreBool = false
			wrapInImplicitCast(state, exprR, typeInfo, true)
		end

		if not bothAreBool then  return nil  end
		return typeInfo

	-- String concatenation.
	elseif binOp == ".." then
		if typeInfoL.tag ~= !(typeTags.TypeInfoString) then
			typeError(state, exprL, "String concatenation expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoL))
		elseif typeInfoR.tag ~= !(typeTags.TypeInfoString) then
			typeError(state, exprR, "String concatenation expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoR))
		end
		return getTypeInfoForBuiltinType(state, "string")

	else
		errorUnhandledNodeType(state, exprForError)
	end
end

!NODE_INFERRER `function nodeInferrers.AstBinary(state, binary)`
	local typeInfoL = binary.left.inferredType
	local typeInfoR = binary.right.inferredType

	if not typeInfoL then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.left`)
	end
	if not typeInfoR then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.right`)
	end

	typeInfoL = adjustTypeToOne(state, binary.left,  typeInfoL, true)
	typeInfoR = adjustTypeToOne(state, binary.right, typeInfoR, true)

	local typeInfo = checkBinaryOperation(state, binary, binary.left,binary.left,binary.right, binary.operation, typeInfoL,typeInfoR, false)
	if not typeInfo then  return  end

	binary.inferredType = typeInfo

	moveToNextRelevantPipe(state, binary)
	simplifyExpressionIfConstant(state, binary)
end

function _G.getConstantNameOrTriggerError(state, node)
	if not (node.nodeType == !(nodeTypes.AstLiteral) and node.literalType == !(LITERAL_STRING)) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(node), "Expected a name constant as the member.")
	end

	local literal = node
	local name    = literal.value

	if not name:find"^[%a_\128-\255][%w_\128-\255]*$" then
		typeError(state, literal, "Bad format or invalid characters in name '%s'.", name)
	end

	return name
end

-- Returns nil on failure and the dependent is now waiting.
function _G.validateStructKey(state, dependent, keyExpr, structInfo, isLvalue)
	local keyExprType = keyExpr.inferredType
	local memberName  = ""
	local memberValueType, constDecl

	if structInfo.kind ~= !(STRUCT_KIND_NORMAL) and not structInfo.hasMembers then
		!DEPEND_AND_RETURN(`dependent`, DEPEND_STRUCT_MEMBERS_READY, `structInfo`, nil, `nil`)
	end

	if structInfo.kind == !(STRUCT_KIND_TABLE) and (keyExprType.tag ~= !(typeTags.TypeInfoString) or structInfo.keyType.tag == !(typeTags.TypeInfoString)) then
		if not isTypeCompatibleWith(keyExprType, structInfo.keyType) then
			typeError(state, keyExpr, "Expected struct member name or %s. (Got %s)", getFriendlyTypeInfoName(structInfo.keyType), getFriendlyTypeInfoName(keyExprType))
		end
		memberValueType = structInfo.valueType

	elseif structInfo.kind == !(STRUCT_KIND_ARRAY) and keyExprType.tag ~= !(typeTags.TypeInfoString) then
		if keyExprType.tag ~= !(typeTags.TypeInfoInt) then
			typeError(state, keyExpr, "Expected struct member name or array index. (Got %s)", getFriendlyTypeInfoName(keyExprType))
		end
		memberValueType = structInfo.valueType

	else
		if keyExprType.tag ~= !(typeTags.TypeInfoString) then
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(keyExpr),
				"Member names in struct constructors must be strings. (This is %s)",
				getFriendlyTypeInfoName(keyExprType)
			)
		elseif keyExpr.nodeType ~= !(nodeTypes.AstLiteral) then
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(keyExpr),
				"Member names in struct constructors must be constant. (Type is string)"
			)
		end

		local memberLiteral = keyExpr
		memberName          = memberLiteral.value

		local decl = findMemberDeclaration(state, structInfo.astNode, memberName)
		if not decl then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_MEMBER_DECLARATION, `memberName`, `structInfo.astNode`, `nil`)
		elseif isLvalue and decl.isConstant then
			typeError(state, memberLiteral, "Cannot assign value to constant member %s.%s", getFriendlyTypeInfoName(structInfo), memberName)
		end

		memberValueType = decl.name.inferredType
		if not memberValueType then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_INFERRED, `decl.name`, nil, `nil`)
		end

		if decl.isConstant then  constDecl = decl  end
	end

	return memberName, memberValueType, constDecl
end

local function checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode(state, topNodeToCheck, staticObjectNode)
	astVisitAllNodes(topNodeToCheck, function(node)
		if
			node.nodeType == !(nodeTypes.AstAccess)
			or (
				node.nodeType == !(nodeTypes.AstIdentifier)
				and node.parent.nodeType == !(nodeTypes.AstAccess)
				and node == node.parent.object
			)
			or (
				node.nodeType == !(nodeTypes.AstLiteral)
				and node.parent.nodeType == !(nodeTypes.AstAccess)
				and node == node.parent.member
			)
		then
			-- void

		else
			typeError2(state,
				staticObjectNode, F("Trying to access a static object using code that looks like it's supposed to do something at runtime. Ambigous intension."),
				node,             F("...this looks like a runtime expression.")
			)
		end
	end)
end

!NODE_INFERRER `function nodeInferrers.AstAccess(state, access)`
	local typeObject = access.object.inferredType
	local typeMember = access.member.inferredType

	if not typeObject then
		!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `access.object`)
	end
	if not typeMember then
		!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `access.member`)
	end

	typeObject            = adjustTypeToOne(state, access.object, typeObject, true)
	typeMember            = adjustTypeToOne(state, access.member, typeMember, true)

	local isDirectObject  = access.object.inferredType == typeObject
	local isDirectMember  = access.member.inferredType == typeMember

	local isLvalue        = access.parent.nodeType == !(nodeTypes.AstAssignment) and access.queued.container == access.parent.targets
	local typeRepresented = getTypeRepresentedByExpression(access.object)

	if typeObject.tag == !(typeTags.TypeInfoTable) then
		if typeMember.tag == !(typeTags.TypeInfoNone) then
			typeError(state, access.member, "Table keys cannot be nil.")

		elseif typeMember.tag == !(typeTags.TypeInfoCompound) and indexOf(typeMember, getTypeInfoForBuiltinType(state, "none")) then
			typeError(state, access.member, "Table keys cannot be nil. (Type is %s)", getFriendlyTypeInfoName(typeMember))

		--[[ This warning message may be too noisy in some programs.
		elseif typeMember.tag == !(typeTags.TypeInfoAny) then
			-- @Incomplete: Add a setting to suppress warnings.
			typeMessage(
				io.stderr, state, astGetExpressionVisuallyFurthestToTheLeft(access.member),
				"Warning", "Table key is 'any' and thus possibly nil."
			)
		--]]
		end

		access.inferredType = getTypeInfoForBuiltinType(state, "any")
		moveToNextRelevantPipe(state, access)

	elseif typeObject.tag == !(typeTags.TypeInfoArray) then
		local arraySig = typeObject

		if typeMember.tag == !(typeTags.TypeInfoInt) then
			-- @Incomplete: Check for isLvalue and constantness.

			if access.member.nodeType == !(nodeTypes.AstLiteral) and access.member.value < 1 then
				local indexLiteral = access.member
				typeError(state, indexLiteral, "Array index is %d.", indexLiteral.value)
			end

			access.inferredType = arraySig.itemType

			if not (isExpressionConstant(state, access.object, false) and isExpressionConstant(state, access.member, false)) then
				moveToNextRelevantPipe(state, access)
				return
			end

			-- Check that the item in the constant array exists.
			local indexLiteral = access.member
			assert(indexLiteral.nodeType == !(nodeTypes.AstLiteral))
			local i = indexLiteral.value

			local tableNode = followIdentifiersToConstantValue(access.object)
			assert(tableNode.nodeType == !(nodeTypes.AstTable))

			local itemExpr = nil

			for _, tableField in ipairs(tableNode.fields) do
				assert(tableField.key.nodeType == !(nodeTypes.AstLiteral))
				if tableField.key.value == i then
					itemExpr = tableField.value
				end
			end

			if not itemExpr then
				typeError(state, indexLiteral, "No item at index %d in constant array. (Length is %d)", i, #tableNode.fields)
			end

			moveToNextRelevantPipe(state, access)

		-- elseif not isLvalue and typeMember.tag == !(typeTags.TypeInfoString) then
		-- 	local abstractMemberLiteral = access.member
		-- 	local abstractMemberName    = getConstantNameOrTriggerError(state, abstractMemberLiteral)
		-- 	if abstractMemberName == ? then ... end

		else
			typeError(state, access.member, "Expected an array index of type int. (Got %s)", getFriendlyTypeInfoName(typeMember))
		end

	elseif typeObject.tag == !(typeTags.TypeInfoStruct) or (typeRepresented and typeRepresented.tag == !(typeTags.TypeInfoStruct)) then
		local structInfo                             = typeRepresented or typeObject
		local memberName, memberValueType, constDecl = validateStructKey(state, access, access.member, structInfo, isLvalue)

		if not memberName      then  return  end
		if not memberValueType then  errorInternal(state, access.member)  end

		if not constDecl then
			access.inferredType = memberValueType
			moveToNextRelevantPipe(state, access)
			return
		end

		if not (
			isExpressionConstant(state, access.object, false)
			or (access.parent.nodeType == !(nodeTypes.AstCall) and access.parent.isMethod) -- It's ok to do e.g. getObject().staticMethod!()
		) then
			checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode(state, access.object, access.member)
		end

		local valueExpr = constDecl.value
		local nodeType  = valueExpr.nodeType
		local replacement

		if !!(anyV(`nodeType`, nodeTypes.AstLiteral,nodeTypes.AstForeign)) then
			replacement = astCopy(valueExpr, access.member.token)

		elseif nodeType == !(nodeTypes.AstType) then
			replacement = astCopy(valueExpr, access.member.token)
			addUnqueuedChildrenToQueueRecursively(state, replacement, !(PIPE_DONE))

		elseif nodeType == !(nodeTypes.AstIdentifier) and valueExpr.inferredType.tag == !(typeTags.TypeInfoEnum) then
			replacement = astCopy(valueExpr, access.member.token)

		elseif !!(anyV(`nodeType`, nodeTypes.AstEnum,nodeTypes.AstStruct)) then
			replacement = createTypeNodeFromInfo(state, valueExpr.representedType, access.member.token, access.parent) -- Parent is temp and will change in a moment.

		elseif nodeType == !(nodeTypes.AstLambda) then
			if access.parent.nodeType == !(nodeTypes.AstCall) and access == access.parent.callee and access.parent.isMethod then
				--
				-- Change obj.staticMethod!(...) into staticMethod(obj, ...)
				--
				-- AstCall (method)
				--   CALLEE AstAccess
				--     AstIdentifier (object)
				--     AstLiteral (string)
				--   ARG1...
				--
				-- AstCall (normal)
				--   CALLEE AstIdentifier (static function)
				--   ARG1 AstIdentifier (object)
				--   ARG2...
				--
				local call = access.parent

				-- Move object from access to call arguments.
				local obj = access.object
				table.insert(call.arguments, 1, obj)
				obj.parent = call

				-- Update all argument queueds.
				for i, argExpr in ipairs(call.arguments) do
					argExpr.queued.container = call.arguments
					argExpr.queued.key       = i
				end

				-- Update callee using access. (Note: access==callee)
				local ident        = astNewNode(AstIdentifier, access.member.token, call)
				ident.name         = constDecl.name.name
				ident.declaration  = constDecl
				ident.inferredType = constDecl.name.inferredType
				replaceQueuedNode(state, access, ident)
				moveToNextRelevantPipe(state, ident)

				-- Update call.
				call.isMethod = false

				-- Unqueue now unused nodes.
				unqueue(access.member)

				return
			end

			local ident        = astNewNode(AstIdentifier, access.member.token, access.parent)
			ident.name         = constDecl.name.name
			ident.declaration  = constDecl
			ident.inferredType = constDecl.name.inferredType
			replacement        = ident

		else
			!ifDEBUG `where(state, access)`
			errorUnhandledNodeType(state, valueExpr)
		end

		assert(replacement) -- Constants must be simplified!

		replaceQueuedNodeAndUnqueueOldTree(state, access, replacement)
		moveToNextRelevantPipe(state, replacement, !(PIPE_INFER))

	elseif typeObject.tag == !(typeTags.TypeInfoEnum) or (typeRepresented and typeRepresented.tag == !(typeTags.TypeInfoEnum)) then
		local memberLiteral = access.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)

		local enumInfo      = typeRepresented or typeObject
		local decl          = findMemberDeclaration(state, enumInfo.astNode, memberName)

		if not decl then
			typeError(state, memberLiteral, "'%s' is not a member of %s.", memberName, getFriendlyTypeInfoName(enumInfo))
		elseif isLvalue then
			typeError(state, memberLiteral, "Cannot assign values to enum members. (Enum is %s)", getFriendlyTypeInfoName(enumInfo))
		end

		assert(decl.isConstant)

		local ident = astCopy(decl.name, access.token, access.parent)
		replaceQueuedNodeAndUnqueueOldTree(state, access, ident)
		-- Stay in the current pipe so we get simplified. (Needed? Or maybe we can @Speed things up here?)

	elseif typeObject.tag == !(typeTags.TypeInfoNamespace) then
		assert(isDirectObject)

		local memberLiteral = access.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)

		local namespaceInfo = typeObject
		local decl          = findPublicDeclarationInScope(state, namespaceInfo.scope, memberName)

		if not decl then
			!DEPEND_AND_RETURN(`access`, DEPEND_DECLARATION, `memberName`, `namespaceInfo.scope`)
		elseif not decl.name.inferredType then
			!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `decl.name`)
		end

		local ident = astCopy(decl.name, access.token, access.parent)
		replaceQueuedNodeAndUnqueueOldTree(state, access, ident)
		-- Stay in the current pipe so we get simplified. (Needed? Or maybe we can @Speed things up here?)

	else
		typeError(state, access, "Values of type '%s' do not have members.", getFriendlyTypeInfoName(typeObject))
	end
end

local function inferTableArray(state, tableNode, arraySig)
	for _, tableField in ipairs(tableNode.fields) do
		local indexLiteral = tableField.key

		if not indexLiteral.inferredType then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `indexLiteral`)
		elseif indexLiteral.inferredType.tag ~= !(typeTags.TypeInfoInt) then
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(indexLiteral),
				"Array indices must be integers. (This is %s)",
				getFriendlyTypeInfoName(indexLiteral.inferredType)
			)
		elseif indexLiteral.nodeType ~= !(nodeTypes.AstLiteral) then
			-- @Incomplete: Allow indices to be variable? :VariableArrayIndices
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(indexLiteral),
				"Indices must be constant in array constructors."
			)
		end

		local itemExpr     = tableField.value
		local itemTypeInfo = itemExpr.inferredType

		if itemTypeInfo then
			if not isTypeCompatibleWith(adjustTypeToOne(state, itemExpr, itemTypeInfo, true), arraySig.itemType) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
					"Array item type mismatch. (Wanted %s, got %s)",
					getFriendlyTypeInfoName(arraySig.itemType),
					getFriendlyTypeInfoName(adjustTypeToOne(state, itemExpr, itemTypeInfo, true))
				)
			end
		elseif itemExpr.nodeType == !(nodeTypes.AstTable) then
			if isTypeTableLike(arraySig.itemType) then
				-- void  (Wait with validation.)
			else
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
					"Expected array item to be %s.",
					getFriendlyTypeInfoName(arraySig.itemType)
				)
			end
		else
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `itemExpr`)
		end
	end

	tableNode.inferredType = arraySig

	local trailingExpr = tableNode.trailingExpression
	if trailingExpr then
		adjustTypeToOne(state, trailingExpr, trailingExpr.inferredType) -- Ensure this is not a call that returns nothing.
	end

	-- Validate indices and sequence. :ConstructorTrailingCall
	local indexLiterals       = {}
	local highestLiteralIndex = 0

	for _, tableField in ipairs(tableNode.fields) do
		local literal    = tableField.key
		local arrayIndex = literal.value

		if indexLiterals[arrayIndex] then
			typeError2(state,
				literal,                   F("Duplicate index %d.", arrayIndex),
				indexLiterals[arrayIndex], F("...first occurance is here.")
			)
		elseif arrayIndex <= 0 then
			typeError(state, literal, "Array index is not positive. (It is %d)", arrayIndex)
		end

		indexLiterals[arrayIndex] = literal
		highestLiteralIndex       = math.max(highestLiteralIndex, arrayIndex)
	end

	if trailingExpr and highestLiteralIndex > tableNode.highestGeneratedIndex then
		-- We get here if explicit indices are combined with a trailing expression.
		for i = tableNode.highestGeneratedIndex+1, highestLiteralIndex do
			local overlap = indexLiterals[i]
			if overlap then
				typeError2(state,
					trailingExpr, F("Potentially overlapping value(s) at or after array index %d because of this expression.", tableNode.highestGeneratedIndex+1),
					overlap,      F("...first overlap would be here.")
				)
			end
		end
		errorInternal() -- highestLiteralIndex would be incorrect if we're here.
	end

	for arrayIndex = 1, highestLiteralIndex do
		if not indexLiterals[arrayIndex] then
			typeError(state, tableNode, "Array is not a sequence. Missing item at index %d.", arrayIndex)
		end
	end

	-- Validate trailing expression.
	if not trailingExpr then
		-- void

	elseif trailingExpr.nodeType == !(nodeTypes.AstVararg) then
		if not isTypeCompatibleWith(trailingExpr.inferredType.itemType, arraySig.itemType) then
			typeError(
				state, trailingExpr,
				"Array item type mismatch for vararg. (Wanted %s, got %s)",
				getFriendlyTypeInfoName(arraySig.itemType),
				getFriendlyTypeInfoName(trailingExpr.inferredType.itemType)
			)
		end

	elseif trailingExpr.nodeType == !(nodeTypes.AstCall) then
		local call        = trailingExpr
		local argTypesOut = call.callee.inferredType.argumentTypesOut

		for i, argTypeInfo in ipairs(argTypesOut) do
			argTypeInfo = adjustTypeToOne(state, call, argTypeInfo)

			if not isTypeCompatibleWith(argTypeInfo, arraySig.itemType) then
				typeError(
					state, call,
					"Array item type mismatch for return value #%d from call. (Wanted %s, got %s)",
					i,
					getFriendlyTypeInfoName(arraySig.itemType),
					getFriendlyTypeInfoName(argTypeInfo)
				)
			end
		end

	else
		errorUnhandledNodeType(state, trailingExpr)
	end
end

local function inferTableStruct(state, tableNode, structInfo)
	if structInfo.astNode.isForeign then
		!TRACE()
		printerr()
		nodeMessage(io.stderr, state, tableNode, "Error", "Typer", "Cannot instantiate foreign struct '%s'.", getFriendlyTypeInfoName(structInfo))
		if structInfo.astNode.foreignThroughNode then
			nodeMessage(io.stderr, state, structInfo.astNode.foreignThroughNode, "Info", "Typer", "...the struct got its foreign state through this.")
		end
		exitFailure()
	end

	for _, tableField in ipairs(tableNode.fields) do
		local fieldKey     = tableField.key
		local fieldKeyType = fieldKey.inferredType

		if not fieldKeyType then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `fieldKey`)
		end

		local memberName, memberValueType = validateStructKey(state, tableNode, fieldKey, structInfo, true)
		if not memberName      then  return  end
		if not memberValueType then  errorInternal(state, fieldKey)  end

		!local TARGET_NAME   = `memberName ~= "" and F("value for struct field '%s'", memberName) or "value"`
		local fieldValue     = tableField.value
		local fieldValueType = fieldValue.inferredType

		if fieldValueType then
			if not isTypeCompatibleWith(adjustTypeToOne(state, fieldValue, fieldValueType, true), memberValueType) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(fieldValue),
					"Type mismatch for %s. (Wanted %s, got %s)",
					!!(TARGET_NAME),
					getFriendlyTypeInfoName(memberValueType),
					getFriendlyTypeInfoName(fieldValueType)
				)
			end
		elseif fieldValue.nodeType == !(nodeTypes.AstTable) then
			if isTypeTableLike(memberValueType) then
				-- void  (Wait with validation.)
			else
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
					"Expected %s to be %s.",
					!!(TARGET_NAME),
					getFriendlyTypeInfoName(memberValueType)
				)
			end
		else
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `fieldValue`)
		end
	end

	tableNode.inferredType = structInfo

	-- Check for duplicate keys.
	-- @Incomplete: Check non-string keys.
	local keyLiterals = {}

	for _, tableField in ipairs(tableNode.fields) do
		if tableField.key.nodeType == !(nodeTypes.AstLiteral) and tableField.key.literalType == !(LITERAL_STRING) then
			local memberLiteral = tableField.key
			local memberName    = memberLiteral.value

			if keyLiterals[memberName] then
				typeError2(state,
					memberLiteral,           F("Duplicate field '%s'.", memberName),
					keyLiterals[memberName], F("...first occurance is here.")
				)
			end

			keyLiterals[memberName] = memberLiteral
		end
	end

	if tableNode.trailingExpression then
		errorInternal(state, tableNode.trailingExpression, "@Incomplete: Handle trailing expression in struct constructors.") -- :ConstructorTrailingCall (and vararg)
	end
end

!NODE_INFERRER `function nodeInferrers.AstTable(state, tableNode)`
	-- Note: tableNode.inferredType may get set before all child nodes are inferred.
	local typeExpected = tableNode.inferredType or getExpectedTypeInfo(state, tableNode, false, "constructor", tableNode)
	if not typeExpected then  return  end

	if typeExpected.tag == !(typeTags.TypeInfoAny) and tableNode.parent.nodeType == !(nodeTypes.AstTable) then
		typeExpected = getTypeInfoForBuiltinType(state, "table")
	end

	local trailingExpr   = tableNode.trailingExpression
	local lastTableField = not trailingExpr and getLast(tableNode.fields) or nil

	if lastTableField and lastTableField.keyIsGenerated then
		local valueExpr = lastTableField.value

		-- Note: We don't need to check for vararg as the parser should have handled that.
		if valueExpr.nodeType == !(nodeTypes.AstCall) and not valueExpr.surroundedByParentheses then
			if not valueExpr.inferredType then
				!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `valueExpr`)
			end

			trailingExpr                        = valueExpr

			valueExpr.parent                    = tableNode
			valueExpr.queued.container          = tableNode
			valueExpr.queued.key                = "trailingExpression"

			tableNode.trailingExpression        = valueExpr
			tableNode.fields[#tableNode.fields] = nil
			tableNode.highestGeneratedIndex     = tableNode.highestGeneratedIndex-1

			unqueue(lastTableField.key) -- Note: The key should be an int literal as it's generated.
		end
	end

	if trailingExpr and not trailingExpr.inferredType then
		!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `trailingExpr`)
	end

	if typeExpected.tag == !(typeTags.TypeInfoTable) then
		-- @Incomplete: Check for duplicate fields (among constant keys).
		-- @Incomplete: Check for nil keys.
		tableNode.inferredType = typeExpected
		-- Note: We don't need to validate any types or anything (including tableNode.trailingExpression) as generic tables accept anything.

	elseif typeExpected.tag == !(typeTags.TypeInfoArray) then
		inferTableArray(state, tableNode, typeExpected)
		if tableNode.queued.waitingOn then  return  end

	elseif typeExpected.tag == !(typeTags.TypeInfoStruct) then
		inferTableStruct(state, tableNode, typeExpected)
		if tableNode.queued.waitingOn then  return  end

	else
		typeError(
			state, tableNode,
			"This constructor is trying to get inferred as %s (type group '%s') which is illegal. (The inferred type must be array, struct or table.)",
			getFriendlyTypeInfoName(typeExpected),
			TYPE_TAG_NAMES[typeExpected.tag]
		)
	end

	!ASSERT `tableNode.inferredType`

	-- Make sure all children (including table-likes) are fully(!) inferred before we advance to the next pipe.
	for _, tableField in ipairs(tableNode.fields) do
		if tableField.value.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED_FULLY, `tableField.value`)
		end
		if tableField.key.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED_FULLY, `tableField.key`)
		end
	end
	if trailingExpr and trailingExpr.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED_FULLY, `trailingExpr`)
	end

	moveToNextRelevantPipe(state, tableNode)
end

!NODE_INFERRER `function nodeInferrers.AstArgument(state, arg)`
	if arg.declaration.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`arg`, DEPEND_NODE_INFERRED, `arg.declaration`)
	end
	moveToNextRelevantPipe(state, arg)
end

!NODE_INFERRER `function nodeInferrers.AstArguments(state, args)`
	for _, arg in ipairs(args.arguments) do
		if arg.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`args`, DEPEND_NODE_INFERRED, `arg`)
		end
	end
	moveToNextRelevantPipe(state, args)
end

!NODE_INFERRER `function nodeInferrers.AstLambda(state, lambda)`
	if lambda.isPolymorphic then
		lambda.inferredType = getTypeInfoForLambda(state, lambda) or errorInternal(state, lambda)
		moveToNextRelevantPipe(state, lambda)
		return
	end

	local argsIn  = lambda.argumentsIn
	local argsOut = lambda.argumentsOut

	if argsIn and argsIn.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `argsIn`)
	end
	if argsOut and argsOut.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `argsOut`)
	end

	if lambda.bodyIsForeign and lambda.foreignSource == "method" then
		-- Validate method.
		local argIn1   = argsIn and argsIn.arguments[1]
		local argType1 = argIn1 and argIn1.declaration.name.inferredType

		if not argIn1 then
			typeError(state, lambda, "Expected a struct as first argument for foreign method.")

		elseif argType1.tag ~= !(typeTags.TypeInfoStruct) then
			typeError(
				state, argsIn.arguments[1],
				"Expected the first arguments to be a struct. Foreign methods are only supported on structs. (Type is %s)",
				getFriendlyTypeInfoName(argType1)
			)

		-- elseif not argType1.astNode.isForeign and not argType1.hasMembers then
		-- 	-- @Incomplete: We create circular dependencies in some cases by doing this. No good!
		-- 	!DEPEND_AND_RETURN(`lambda`, DEPEND_STRUCT_MEMBERS_READY, `argType1`) -- We need this for isForeign to be valid.

		elseif not argType1.astNode.isForeign then
			typeError2(state,
				argsIn.arguments[1].declaration.type, F("%s is not a foreign struct. Foreign methods only work on foreign structs.", getFriendlyTypeInfoName(argType1)),
				argType1.astNode,                     F("...here is the struct")
			)

		elseif not argIn1.isRequired then
			typeError(state, argsIn.arguments[1], "The first argument must not be optional for foreign methods.")
		end
	end

	-- Note: We don't require the body to inferred - just the "header".

	--
	-- No more dependencies for this lambda after this point!
	--

	if argsIn and not lambda.bodyIsForeign then
		for _, arg in ipairs(argsIn.arguments) do
			if arg.declaration.value and not isExpressionConstant(state, arg.declaration.value, true) then
				typeError(state, astGetExpressionVisuallyFurthestToTheLeft(arg.declaration.value), "Non-constant default values for arguments are not supported yet.")
			end
		end
	end

	local funcSig       = getTypeInfoForLambda(state, lambda) or errorInternal(state, lambda)
	lambda.inferredType = funcSig

	if lambda.bodyIsForeign then
		if lambda.foreignSourceName == "" then
			errorInternal(state, lambda, "@Incomplete: Infer lambda.foreignSourceName")
		end

		validateForeignSource(state, lambda.foreignSource, lambda.foreignSourceName, lambda)
		lambda.foreignSourceId = lambda.foreignSource.." "..lambda.foreignSourceName
	end

	moveToNextRelevantPipe(state, lambda)
end

!NODE_INFERRER `function nodeInferrers.AstTypeOf(state, typeOf)`
	-- @Robustness: Check that the expression doesn't have code that looks like it's going to be executed, because it's not!

	local exprTypeInfo = typeOf.expression.inferredType

	if not exprTypeInfo then
		!DEPEND_AND_RETURN(`typeOf`, DEPEND_NODE_INFERRED, `typeOf.expression`)
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoNamespace) then
		typeError(state, typeOf.expression, "Namespaces don't have a type.")
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoList) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeOf.expression), "Cannot get the type of function calls.")
	end

	typeOf.inferredType    = getTypeInfoForBuiltinType(state, "type")
	typeOf.representedType = exprTypeInfo

	if typeOf.representedType.tag == !(typeTags.TypeInfoVararg) then
		local varargSig        = typeOf.representedType
		typeOf.representedType = varargSig.itemType
	end

	moveToNextRelevantPipe(state, typeOf)
	simplifyTypeExpression(state, typeOf, typeOf.representedType)
end

!NODE_INFERRER `function nodeInferrers.AstTypeInfo(state, typeInfoNode)`
	-- @Robustness: Check that the expression doesn't have code that looks like it's going to be executed, because it's not!

	if not typeInfoNode.expression.inferredType then
		!DEPEND_AND_RETURN(`typeInfoNode`, DEPEND_NODE_INFERRED, `typeInfoNode.expression`)
	end

	local typeRepresented = requireTypeRepresentedByExpression(state, typeInfoNode.expression)
	local tag             = typeRepresented.tag
	local typeInfoStructName

	if tag == !(typeTags.TypeInfoArray) then
		typeInfoStructName = "TypeInfoArray"
	elseif tag == !(typeTags.TypeInfoCompound) then
		typeInfoStructName = "TypeInfoCompound"
	elseif tag == !(typeTags.TypeInfoEnum) then
		typeInfoStructName = "TypeInfoEnum"
	elseif tag == !(typeTags.TypeInfoFunction) then
		typeInfoStructName = "TypeInfoFunction"
	elseif tag == !(typeTags.TypeInfoStruct) then
		typeInfoStructName = "TypeInfoStruct"
	elseif tag == !(typeTags.TypeInfoVararg) then
		typeInfoStructName = "TypeInfoVararg"

	elseif !!(anyV(`tag`,
		typeTags.TypeInfoAny,
		typeTags.TypeInfoBool,
		typeTags.TypeInfoFloat,
		typeTags.TypeInfoInt,
		typeTags.TypeInfoNone,
		typeTags.TypeInfoPlaceholder,
		typeTags.TypeInfoString,
		typeTags.TypeInfoTable,
		typeTags.TypeInfoType,
		typeTags.TypeInfoVoid
	)) then
		typeInfoStructName = "TypeInfo"

	else
		errorUnhandledType(state, typeInfoNode, typeRepresented)
	end

	!ASSERT `typeInfoStructName`

	local module = itemWith1(state.globalScope.fileScopes, "moduleName", "preload") or errorInternal()
	local decl   = findPublicDeclarationInScope(state, module, typeInfoStructName)  or errorInternal()

	if not decl.name.inferredType then
		!DEPEND_AND_RETURN(`typeInfoNode`, DEPEND_NODE_INFERRED, `decl`)
	end

	assert(decl.valueTypeInfo)
	assert(decl.valueTypeInfo.tag == !(typeTags.TypeInfoStruct))

	typeInfoNode.declaration   = decl
	typeInfoNode.valueTypeInfo = typeRepresented
	typeInfoNode.inferredType  = decl.valueTypeInfo

	moveToNextRelevantPipe(state, typeInfoNode)
	-- @Incomplete: Allow type_info to exist in constant context and simplify it here.
end

!NODE_INFERRER `function nodeInferrers.AstCast(state, cast)`
	-- Note: For convenience, cast.targetType may be nil here for generated casts. cast.inferredType must be set in those cases.

	if cast.targetType and not cast.targetType.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.targetType`)
	end
	if not cast.expression.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.expression`)
	end

	local castType    = cast.inferredType or requireTypeRepresentedByExpression(state, cast.targetType)
	local exprType    = adjustTypeToOne(state, cast.expression, cast.expression.inferredType, true)
	local castTypeTag = castType.tag
	local exprTypeTag = exprType.tag

	!local INVALID_CAST = `
		typeError(
			state, astGetExpressionVisuallyFurthestToTheLeft(cast.expression),
			"Cannot cast from %s to %s.",
			getFriendlyTypeInfoName(exprType),
			getFriendlyTypeInfoName(castType)
		)
	`

	if castType == exprType then
		moveToPipe(state, cast, cast.expression.queued.pipe) -- @Cleanup: Maybe cutOutPartOfNodeTree()/replaceQueuedNode() should do this (or maybe we just keep the wrong queued in cutOutPartOfNodeTree()).
		cutOutPartOfNodeTree(state, cast, cast.expression)
		return

	elseif isTypeCompatibleWith(exprType, castType) or exprTypeTag == !(typeTags.TypeInfoAny) then
		-- void  Valid cast.

	elseif isTypeNumeric(castType) and isTypeNumeric(exprType) then
		-- void  Valid cast.

	elseif exprTypeTag == !(typeTags.TypeInfoStruct) and castTypeTag == !(typeTags.TypeInfoStruct) and doesStructInherit(castType, exprType) then
		-- void  Valid cast.

	elseif castTypeTag == !(typeTags.TypeInfoBool) and !!(anyV(
		`exprTypeTag`,
		typeTags.TypeInfoInt,
		typeTags.TypeInfoFloat,
		typeTags.TypeInfoString,
		typeTags.TypeInfoArray
	)) then
		-- void  Valid cast.

	elseif castTypeTag == !(typeTags.TypeInfoBool) and exprTypeTag == !(typeTags.TypeInfoStruct) and exprType.kind == !(STRUCT_KIND_ARRAY) then
		-- void  Array-like structs can pass as arrays.

	elseif exprTypeTag == !(typeTags.TypeInfoEnum) and isTypeCompatibleWith(castType, exprType.memberTypeInfo) then
		-- void  Enum members can cast to the real member type.

	elseif exprTypeTag == !(typeTags.TypeInfoEnum) and isTypeNumeric(castType) and isTypeNumeric(exprType.memberTypeInfo) then
		-- We need two casts to happen in sequence here so we wrap ourselves in another cast.
		wrapInImplicitCast(state, cast, exprType.memberTypeInfo, false)

	elseif castTypeTag ~= !(typeTags.TypeInfoCompound) and exprTypeTag == !(typeTags.TypeInfoCompound) then
		-- We get here for situations like these: local xMaybe:int|nil = 0 ; local x = cast(int) xMaybe
		-- The user better know what they're doing!
		local compound = exprType
		if not indexOf(compound, castType) then
			!!(INVALID_CAST)
		end

	else
		!!(INVALID_CAST)
	end

	cast.inferredType = castType

	moveToNextRelevantPipe(state, cast)
	simplifyExpressionIfConstant(state, cast)
end

!NODE_INFERRER `function nodeInferrers.AstAssignment(state, assignment)`
	for _, targetExpr in ipairs(assignment.targets) do
		if not targetExpr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `targetExpr`)
		end
	end
	for _, expr in ipairs(assignment.values) do
		if not expr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `expr`)
		end
	end

	-- Validate targets.
	for _, targetExpr in ipairs(assignment.targets) do
		if not !!(anyV(`targetExpr.nodeType`, nodeTypes.AstIdentifier,nodeTypes.AstAccess,nodeTypes.AstBlank)) then
			!ifDEBUG`astPrint(targetExpr)`
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(targetExpr), "Invalid assignment target. Expected a variable name or object field.")
		end
	end

	-- Validate values.
	-- Note: Enum member values are already validated by the enum itself.
	local declScope        = assignment.forDeclaration and getClosestScope(assignment) or nil
	local isEnumMemberDecl = declScope ~= nil and declScope.nodeType == !(nodeTypes.AstEnum)

	if not isEnumMemberDecl then
		for i, targetExpr in ipairs(assignment.targets) do
			getAssignmentValue(state, targetExpr, assignment.values, i, targetExpr.inferredType, assignment.binaryOperation, nil)
		end
	end

	-- @Incomplete: Check that !must args from functions have an assignment target.

	moveToNextRelevantPipe(state, assignment)
end

!NODE_INFERRER `function nodeInferrers.AstBreak(state, breakNode)`
	moveToNextRelevantPipe(state, breakNode)
end
!NODE_INFERRER `function nodeInferrers.AstContinue(state, continue)`
	moveToNextRelevantPipe(state, continue)
end

!NODE_INFERRER `function nodeInferrers.AstDefer(state, defer)`
	if defer.body.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`defer`, DEPEND_NODE_INFERRED, `defer.body`)
	end
	moveToNextRelevantPipe(state, defer)
end

!NODE_INFERRER `function nodeInferrers.AstImport(state, import)`
	local path

	if import.isLoad then
		path = isPathAbsolute(import.importName) and import.importName or state.projectDirectory.."/"..import.importName

	else
		path = COMPILER_DIRECTORY.."/modules/"..import.importName..".gloa"

		if not isReadableFile(path) then
			local pathFallback = COMPILER_DIRECTORY.."/modules/"..import.importName.."/main.gloa"

			if not isReadableFile(pathFallback) then
				typeError(state, import, "Could not read module file '%s' or '%s'.", path, pathFallback)
			end

			path = pathFallback
		end
	end

	local globalScope = state.globalScope

	if not state.fileBuffers[path] then
		!ifDEBUG `profilerPause()`

		insertToken(state.tokens, !(TOKEN_DIRECTIVE), "import",  path)
		insertToken(state.tokens, !(TOKEN_STRING),    "preload", path)

		-- @Incomplete: Include times in compilation stats.
		local timeStartLexing, timeEndLexing = readAndTokenizeFile(state, path)
		!ASSERT(`state.fileBuffers[path]`, `path`)

		local timeStartParsing = os.clock()
		local fileScope        = parseFileScope(state, globalScope, path, (not import.isLoad), import.importName)
		local timeEndParsing   = os.clock()

		if peekNextToken(state) then
			errorParsingNext(state, "Expected the end of the file.")
		end

		!ifDEBUG `profilerUnpause()`

		table.insert(globalScope.statements, fileScope)
		table.insert(globalScope.fileScopes, fileScope)

		if import.isLoad then
			astMoveRelevantThingsFromFileScopeToGlobalScope(state, fileScope)
		end

		local i = indexOf(globalScope.fileScopes, fileScope) or errorInternal()
		addToQueueRecursively(state, fileScope, globalScope.fileScopes, i)
	end

	import.fileScope    = itemWith1(globalScope.fileScopes, "path", path) or errorInternal(path)
	import.inferredType = getTypeInfoForNamespace(state, import.fileScope)

	moveToNextRelevantPipe(state, import)
end

!NODE_INFERRER `function nodeInferrers.AstUsing(state, using)`
	local expr     = using.expression
	local typeInfo = expr.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`using`, DEPEND_NODE_INFERRED, `expr`)
	end

	local usingScope

	if expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration

		if typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			usingScope       = structInfo.astNode

			if not decl.isConstant then
				using.variableDeclaration = decl
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			-- Using an enum value is the same as using the enum type. Is this good?
			local enumInfo = typeInfo
			usingScope     = enumInfo.astNode

		elseif typeInfo.tag == !(typeTags.TypeInfoNamespace) then
			local namespaceInfo = typeInfo
			usingScope          = namespaceInfo.scope

		else
			typeError(state, ident, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_TAG_NAMES[typeInfo.tag])
		end

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		typeInfo       = typeNode.representedType

		if typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			usingScope       = structInfo.astNode

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			local enumInfo = typeInfo
			usingScope     = enumInfo.astNode

		else
			typeError(state, typeNode, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_TAG_NAMES[typeInfo.tag])
		end

	else
		!ifDEBUG`astPrint(expr)`
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Invalid or unsupported 'using' expression.")
	end

	local scopeOfUsing  = getClosestScope(using)
	local usingExisting = itemWith1(scopeOfUsing.usings, "scope", usingScope)

	if usingExisting then
		local usingEarly = usingExisting
		local usingLate  = using

		if usingLate.token < usingEarly.token then
			usingEarly, usingLate = usingLate, usingEarly
		end

		typeError2(state,
			usingLate,  F("Duplicate using in the same scope."),
			usingEarly, F("...first using is here.")
		)
	end

	using.scope = usingScope

	moveToNextRelevantPipe(state, using)
end

!NODE_INFERRER `function nodeInferrers.AstForeign(state, foreign)`
	-- @Cleanup: Make AstLambda use AstForeign?
	if foreign.source == "method" then
		errorParsing(state, foreign.token+1, "Only function bodies can be marked as foreign methods.")
	end

	-- @Robustness: Further limit places the expected type can be inferred from for foreign values.
	local typeInfoExpected = getExpectedTypeInfo(state, foreign, true, "foreign value", foreign)
	if not typeInfoExpected then  return  end

	foreign.inferredType = typeInfoExpected

	assert((foreign.sourceName ~= ""), "@Incomplete: Infer foreign.sourceName")
	validateForeignSource(state, foreign.source, foreign.sourceName, foreign)
	foreign.sourceId = foreign.source.." "..foreign.sourceName

	moveToNextRelevantPipe(state, foreign)
end

!NODE_INFERRER `function nodeInferrers.AstBake(state, bake)`
	if not bake.name.inferredType then
		!DEPEND_AND_RETURN(`bake`, DEPEND_NODE_INFERRED, `bake.name`)
	end

	local scope, statement = getClosestScope(bake)
	if not (scope and (
		(scope.nodeType == !(nodeTypes.AstLambda) and statement == scope.argumentsIn)
		-- or (scope.nodeType == !(nodeTypes.AstStruct) and indexOf(scope.bakeDeclarations, statement))
	)) then
		astPrintTree(bake)
		astPrintTree(scope)
		errorParsing(state, bake.token, "Unexpected '$'.")
	end

	bake.inferredType = bake.name.inferredType
	moveToNextRelevantPipe(state, bake)
end

!NODE_INFERRER `function nodeInferrers.AstDebug(state, debugNode)`
	local expr     = debugNode.expression
	local typeInfo = expr.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`debugNode`, DEPEND_NODE_INFERRED, `expr`)
	end

	if debugNode.action == "assert" then
		if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
			wrapInImplicitCast(state, expr, getTypeInfoForBuiltinType(state, "bool"), true)
			return
		end

		if not isExpressionConstant(state, expr, true) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Expression is not constant.")
		elseif not (expr.nodeType == !(nodeTypes.AstLiteral) and expr.literalType == !(LITERAL_BOOLEAN)) then
			errorInternal(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Constant expression did not result in a boolean literal.")
		elseif not expr.value then
			typeError(state, debugNode, "Assertion failed!")
		end

	elseif debugNode.action == "print" then
		astPrintTree(expr)
		typeMessage(state, expr, "!print", "The expression above is here.")

	else
		errorInternal(state, debugNode)
	end

	moveToNextRelevantPipe(state, debugNode)
end

local function inferIfOrWhile(state, ifOrWhile)
	local cond     = ifOrWhile.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`ifOrWhile`, DEPEND_NODE_INFERRED, `cond`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
		wrapInImplicitCast(state, cond, getTypeInfoForBuiltinType(state, "bool"), true)
		return
	end

	-- @Optimize: Remove/replace the branch if the condition is statically known.

	moveToNextRelevantPipe(state, ifOrWhile)
end

!NODE_INFERRER `function nodeInferrers.AstIf(state, ifBranch)`
	inferIfOrWhile(state, ifBranch)
end
!NODE_INFERRER `function nodeInferrers.AstWhile(state, whileLoop)`
	inferIfOrWhile(state, whileLoop)
end

!NODE_INFERRER `function nodeInferrers.AstStaticIf(state, staticIf)`
	local cond     = staticIf.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`staticIf`, DEPEND_NODE_INFERRED, `cond`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
		wrapInImplicitCast(state, cond, getTypeInfoForBuiltinType(state, "bool"), true)
		return
	end

	if not isExpressionConstant(state, cond, false) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(cond), "Static if: The condition must be a constant expression.")
	elseif not (cond.nodeType == !(nodeTypes.AstLiteral) and cond.literalType == !(LITERAL_BOOLEAN)) then
		errorInternal(state, astGetExpressionVisuallyFurthestToTheLeft(cond), "Constant condition expression did not result in a boolean literal.")
	end

	local scope = staticIf.parent
	assert(isScope(scope))

	local statements     = scope.statements
	local statementIndex = indexOf(statements, staticIf) or errorInternal(state, staticIf)
	local statementsNew  = {}
	local newlyDeclared  = {}

	local branchToUse = (cond.value and staticIf.branchTrue or staticIf.branchFalse)

	if branchToUse then
		!ASSERT("branchToUse.nodeType == "..nodeTypes.AstBlock)
		addUnqueuedChildrenToQueueRecursively(state, branchToUse) -- Note: We update the queueds in a moment.

		for iNew, statement in ipairs(branchToUse.statements) do
			if statement.nodeType == !(nodeTypes.AstDeclaration) and statement.canShadow then
				-- @Incomplete: Make this work?
				typeError(state, statement, "Cannot have shadowing declarations directly inside !if blocks.")
			end
			statement.parent    = scope
			statementsNew[iNew] = statement
		end
		for _, decl in ipairs(branchToUse.declarations) do
			table.insert(scope.declarations, decl)
			newlyDeclared[decl]           = true
			newlyDeclared[decl.name.name] = true
		end
		for _, import in ipairs(branchToUse.imports) do
			table.insert(scope.imports, import)
		end
		for _, using in ipairs(branchToUse.usings) do
			table.insert(scope.usings, using)
		end
	end

	for i = statementIndex+1, #statements do
		table.insert(statementsNew, statements[i])
	end

	local iNew = 0
	for i = statementIndex, math.max(#statements, statementIndex + #statementsNew - 1) do
		iNew          = iNew+1
		statements[i] = statementsNew[iNew]
	end

	for i = statementIndex, #statements do
		local statement            = statements[i]
		statement.queued.container = statements
		statement.queued.key       = i
	end

	moveToPipe(state, staticIf, !(PIPE_DONE)) -- Not sure if needed. @Cleanup
	unqueue(staticIf) -- @Robustness: Check if the correct thing happens for things waiting on staticIf (i.e. the scope).

	-- Re-check redeclarations for already-inferred things later in the scope.
	if branchToUse and branchToUse.declarations[1] then
		for _, decl in ipairs(scope.declarations) do
			if not newlyDeclared[decl] and newlyDeclared[decl.name.name] and decl.token > staticIf.token and decl.queued.pipe > !(PIPE_INFER) then
				checkRedeclaration(state, decl.name, decl, false, scope)
			end
		end
	end
end

!NODE_INFERRER `function nodeInferrers.AstConditional(state, conditional)`
	local cond     = conditional.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `cond`)
	end
	if conditional.branchTrue and not conditional.branchTrue.inferredType then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `conditional.branchTrue`)
	end
	if not conditional.branchFalse.inferredType then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `conditional.branchFalse`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
		-- Note: This wrap will not affect conditional.conditionAndBranchTrue which is the actual expression we use in the output.
		wrapInImplicitCast(state, cond, getTypeInfoForBuiltinType(state, "bool"), true)
		return
	end

	local branchTrue    = conditional.branchTrue or conditional.conditionAndBranchTrue
	local branchFalse   = conditional.branchFalse

	local typeInfoTrue  = adjustTypeToOne(state, branchTrue,  branchTrue.inferredType,  true)
	local typeInfoFalse = adjustTypeToOne(state, branchFalse, branchFalse.inferredType, true)

	if typeInfoTrue ~= typeInfoFalse then
		typeError(
			state, conditional,
			"Type mismatch in conditional. (Left branch is %s, right branch is %s)",
			getFriendlyTypeInfoName(typeInfoTrue),
			getFriendlyTypeInfoName(typeInfoFalse)
		)
	end

	conditional.inferredType = typeInfoTrue
	moveToNextRelevantPipe(state, conditional)

	-- @Optimize: Remove/replace the branch if the condition is statically known.
end

!NODE_INFERRER `function nodeInferrers.AstSwitch(state, switch)`
	local typeInfo = switch.value.inferredType
	if not typeInfo then
		!DEPEND_AND_RETURN(`switch`, DEPEND_NODE_INFERRED, `switch.value`)
	end
	for i, case in ipairs(switch.cases) do
		if case.body.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`switch`, DEPEND_NODE_INFERRED, `case.body`)
		elseif case.value and not case.value.inferredType then
			!DEPEND_AND_RETURN(`switch`, DEPEND_NODE_INFERRED, `case.value`)
		end
	end

	for i, case in ipairs(switch.cases) do
		if not case.value then
			-- void
		elseif not isExpressionConstant(state, case.value, true) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(case.value), "Case expression must be constant.")
		elseif not isTypeCompatibleWith(case.value.inferredType, typeInfo) then
			typeError(
				state, case.value,
				"Case type mismatch. (Wanted %s, got %s)",
				getFriendlyTypeInfoName(typeInfo), getFriendlyTypeInfoName(case.value.inferredType)
			)
		end
	end

	if switch.complete then
		local enumInfo = typeInfo

		if enumInfo.tag ~= !(typeTags.TypeInfoEnum) then
			typeError(
				state, switch.value,
				"!complete requires the value to be an enum. (Got %s)",
				getFriendlyTypeInfoName(enumInfo)
			)
		end

		local coveredEnums = {}

		for _, case in ipairs(switch.cases) do
			if case.value then
				!ASSERT("case.value.nodeType == "..nodeTypes.AstIdentifier)
				coveredEnums[case.value.name] = true
			end
		end

		local missingEnums = {}

		for _, member in ipairs(enumInfo.members) do
			if not coveredEnums[member.name] then
				table.insert(missingEnums, member.name)
			end
		end

		if missingEnums[1] then
			typeError(state, switch, "Missing cases: %s", table.concat(missingEnums, ", "))
		end
	end

	moveToNextRelevantPipe(state, switch)
	-- @Incomplete: Simplify AstSwitch.
end

local function addDeclarationInForLoop(state, forLoop, name, typeInfo)
	-- @Incomplete: Care about name shadowing.

	local decl         = astNewNode(AstDeclaration, forLoop.token, forLoop)
	local ident        = astNewNode(AstIdentifier, decl.token, decl)
	ident.name         = name
	ident.declaration  = decl
	ident.inferredType = typeInfo
	decl.name          = ident

	table.insert(forLoop.statements,   decl)
	table.insert(forLoop.declarations, decl)

	addToQueueRecursively(state, decl, forLoop, #forLoop, !(PIPE_DONE))
	moveToNextRelevantPipe(state, decl, !(PIPE_INFER))
end

!NODE_INFERRER `function nodeInferrers.AstFor(state, forLoop)`
	if not forLoop.declarations[1] then
		local names  = forLoop.names
		local values = forLoop.expressions

		-- @Incomplete: Add all declarations now and infer their types later to fix confusing "undeclared identifier" errors.

		for _, expr in ipairs(values) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		-- for [ i = ] start, end [, step ]
		if forLoop.forType == !(FOR_NUMERIC) then
			!ASSERT `#names <= 1`
			!ASSERT `values[2] and not values[4]`

			for _, valueExpr in ipairs(values) do
				local typeInfo = adjustTypeToOne(state, valueExpr, valueExpr.inferredType, true)

				if typeInfo.tag ~= !(typeTags.TypeInfoInt) then
					typeError(
						state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
						"For loop: Expected an int. (Got %s)",
						getFriendlyTypeInfoName(typeInfo)
					)
				end
			end

			if values[3] and values[3].nodeType == !(nodeTypes.AstLiteral) and values[3].value == 0 then
				typeError(state, values[3], "The step value is 0.")
			end

			if
				values[1].nodeType == !(nodeTypes.AstLiteral) and
				values[2].nodeType == !(nodeTypes.AstLiteral) and
				(not values[3] or values[3].nodeType == !(nodeTypes.AstLiteral))
			then
				local i1   = values[1].value
				local i2   = values[2].value
				local step = values[3] and values[3].value or 1

				if step > 0 and i2 < i1 then
					typeError(state, values[2], "The final value is lower than the starting value in ascending loop.")
				elseif step < 0 and i2 > i1 then
					typeError(state, values[2], "The final value is higher than the starting value in descending loop.")
				end
			end

			addDeclarationInForLoop(state, forLoop, (names[1] and names[1].name or "it"), values[1].inferredType)

		-- for [ v1, ... : ] obj
		elseif forLoop.forType == !(FOR_SHORT) then
			!ASSERT `#values == 1`

			-- Note: Built-in short-form for loops have the value first and then the index/key.
			local objExpr = values[1]
			local objType = adjustTypeToOne(state, objExpr, objExpr.inferredType, true)

			if objType.tag == !(typeTags.TypeInfoArray) then
				local name1 = (names[1] and names[1].name) or "it"
				local name2 = (names[2] and names[2].name) or "itIndex"
				addDeclarationInForLoop(state, forLoop, name2, getTypeInfoForBuiltinType(state, "int"))
				addDeclarationInForLoop(state, forLoop, name1, objType.itemType)

			elseif objType.tag == !(typeTags.TypeInfoTable) then
				local name1    = (names[1] and names[1].name) or "it"
				local name2    = (names[2] and names[2].name) or "itIndex"
				local typeInfo = getTypeInfoForBuiltinType(state, "any")
				addDeclarationInForLoop(state, forLoop, name2, typeInfo)
				addDeclarationInForLoop(state, forLoop, name1, typeInfo)

			elseif objType.tag == !(typeTags.TypeInfoStruct) then
				-- We need custom iterators to work AND default iterators for structs before we can do this! @Incomplete
				-- @Incomplete: Fall back to array-like behavior if structInfo.kind==STRUCT_KIND_ARRAY and there's no default iterator.
				typeError(state, objExpr, "@Incomplete: Iterate over struct instances using custom default iterators.")

			else
				typeError(
					state, objExpr,
					"Cannot iterate over values in type group '%s'. (Type is %s)",
					TYPE_TAG_NAMES[objType.tag],
					getFriendlyTypeInfoName(objType)
				)
			end

			if forLoop.reverse and objType.tag ~= !(typeTags.TypeInfoArray) then
				typeError(
					state, objExpr,
					"Only arrays can be iterated in reverse. (This is %s)",
					getFriendlyTypeInfoName(objType)
				)
			end

		-- for v1, ... in iter [, state [, init ] ]
		else--if forType == FOR_ITERATOR
			!ASSERT `#names >= 1`
			!ASSERT `values[1]`

			-- @Incomplete: Support 'for' loops/iterators that don't require an iterator value or
			-- even a state (e.g. if values are read from somewhere else, like an event queue).

			-- @Incomplete: Complain if getAssignmentValue() can return a fourth value.

			local iterExpr, iterTypeInfo = getAssignmentValue(state, forLoop, values, 1, nil, nil, "loop value")

			if iterTypeInfo.tag ~= !(typeTags.TypeInfoFunction) then
				typeError(state, iterExpr, "Expected a function. (Got %s)", getFriendlyTypeInfoName(iterTypeInfo))

			elseif #iterTypeInfo.argumentTypesIn ~= 2 then
				-- @Incomplete: Consider optional arguments.
				typeError(
					state, iterExpr,
					"Iterators must take two arguments - an invariant state object and a control value. (The signature of this function is %s)",
					getFriendlyTypeInfoName(iterTypeInfo)
				)

			elseif not iterTypeInfo.argumentTypesOut[1] then
				typeError(state, iterExpr, "Iterator does not return anything.")

			elseif iterTypeInfo.argumentTypesOut[1].tag == !(typeTags.TypeInfoNone) then
				typeError(state, iterExpr, "The type of the first returned value from iterators cannot be simply nil. It must be a compound type where nil is included.")

			elseif not (
				iterTypeInfo.argumentTypesOut[1].tag == !(typeTags.TypeInfoAny)
				or (
					iterTypeInfo.argumentTypesOut[1].tag == !(typeTags.TypeInfoCompound)
					and itemWith1(iterTypeInfo.argumentTypesOut[1], "tag", !(typeTags.TypeInfoNone))
				)
			) then
				typeError(
					state, iterExpr,
					"The type of the first returned value from iterators must be a compound type where nil is included. (This function returns %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesOut[1])
				)

			elseif #iterTypeInfo.argumentTypesOut ~= #names then
				-- @Incomplete: Consider !must and make everything else optional.
				typeError(
					state, names[math.min(#iterTypeInfo.argumentTypesOut+1, #names)],
					"Incorrect number of names specified for iterator. (Expected %d, got %d)",
					#iterTypeInfo.argumentTypesOut,
					#names
				)
			end

			local stateExpr, stateTypeInfo = getAssignmentValue(state, forLoop, values, 2, nil, nil, "loop value")
			local initExpr,  initTypeInfo  = getAssignmentValue(state, forLoop, values, 3, nil, nil, "loop value")

			if not isTypeCompatibleWith(adjustTypeToOne(state, stateExpr, stateTypeInfo, true), iterTypeInfo.argumentTypesIn[1]) then
				typeError(
					state, stateExpr,
					"Type mismatch for iterator state (value #2). (Wanted %s, got %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[1]),
					getFriendlyTypeInfoName(adjustTypeToOne(state, stateExpr, stateTypeInfo, true))
				)
			end
			if not isTypeCompatibleWith(adjustTypeToOne(state, initExpr, initTypeInfo, true), iterTypeInfo.argumentTypesIn[2]) then
				typeError(
					state, initExpr,
					"Type mismatch for initial control value (value #3). (Wanted %s, got %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[2]),
					getFriendlyTypeInfoName(adjustTypeToOne(state, initExpr, initTypeInfo, true))
				)
			end

			for i, ident in ipairs(names) do
				local typeInfo = iterTypeInfo.argumentTypesOut[i]

				if i > 1 or typeInfo.tag == !(typeTags.TypeInfoAny) then
					-- void

				-- Strip nil from the compound type for the first value (unless it's 'any').
				elseif #typeInfo > 2 then
					local typeInfos = {unpack(typeInfo)}
					removeItem(typeInfos, getTypeInfoForBuiltinType(state, "none"))
					typeInfo = getTypeInfoForCompoundType(state, typeInfos)
				else
					typeInfo = typeInfo[2].tag == !(typeTags.TypeInfoNone) and typeInfo[1] or typeInfo[2] or errorInternal()
				end

				addDeclarationInForLoop(state, forLoop, ident.name, typeInfo)
			end
		end
	end

	for _, statement in ipairs(forLoop) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, forLoop)
end

local function checkForRecursiveStruct(state, declThatWeAreChecking, memberPath, member, structInfo, parentStructInfo)
	local typeInfo = member.typeInfo

	if typeInfo == structInfo then
		for i, member in ipairs(memberPath) do
			memberPath[i] = member.name
		end

		-- @Incomplete: In the case of compound types, trigger this error if the default value has the type of the struct.
		typeError(
			state, declThatWeAreChecking.name,
			"%s.%s is of type %s. This creates an infinite recursive loop. (Note: Compound types containing the struct are ok (unless the default value is the struct type), e.g. %s|nil)",
			getFriendlyTypeInfoName(structInfo),
			table.concat(memberPath, "."),
			getFriendlyTypeInfoName(structInfo),
			getFriendlyTypeInfoName(structInfo)
		)
	end

	if typeInfo.tag ~= !(typeTags.TypeInfoStruct) then  return  end
	local structInfoInner = typeInfo

	local memberPathIndex = #memberPath+1

	for _, member in ipairs(structInfoInner.members) do
		memberPath[memberPathIndex] = member
		checkForRecursiveStruct(state, declThatWeAreChecking, memberPath, member, structInfo, structInfoInner)
	end

	memberPath[memberPathIndex] = nil
end

local function getEarlyAndLateExpression(expr1, expr2)
	if expr1.token < expr2.token then  return expr1, expr2  end
	return expr2, expr1
end

!NODE_INFERRER `function nodeInferrers.AstStruct(state, struct)`
	if struct.isPolymorphic then
		local structInfo         = newTypeInfo(state, TypeInfoStruct)
		structInfo.astNode       = struct
		-- structInfo.kind          = ?
		structInfo.isPolymorphic = true
		structInfo.hasMembers    = true -- Probably doesn't matter.

		table.insert(state.allTypeInfos, structInfo)

		struct.representedType = structInfo
		struct.inferredType    = getTypeInfoForBuiltinType(state, "type")

		moveToNextRelevantPipe(state, struct)
		return
	end

	local structInfo = struct.representedType

	if not structInfo then
		structInfo         = newTypeInfo(state, TypeInfoStruct)
		structInfo.astNode = struct

		if struct.valueType then
			structInfo.kind = struct.keyType and !(STRUCT_KIND_TABLE) or !(STRUCT_KIND_ARRAY)
		elseif struct.keyType then
			typeError(state, struct.keyType, "Missing a corresponding !value type for structured table.")
		end

		-- Note: We don't populate structInfo.members just yet. (Is this gonna a problem?)

		table.insert(state.allTypeInfos, structInfo)

		struct.representedType = structInfo
		struct.inferredType    = getTypeInfoForBuiltinType(state, "type")
	end

	for _, statement in ipairs(struct.statements) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	if struct.keyType and not struct.keyType.inferredType then
		!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `struct.keyType`)
	end
	if struct.valueType and not struct.valueType.inferredType then
		!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `struct.valueType`)
	end

	for i, typeExpr in ipairs(struct.inherits) do
		while typeExpr.replacedBy do  typeExpr = typeExpr.replacedBy  end
		struct.inherits[i] = typeExpr

		local structInfoToInherit = requireTypeRepresentedByExpression(state, typeExpr)
		if structInfoToInherit.tag ~= !(typeTags.TypeInfoStruct) then
			typeError(state, typeExpr, "Expected the type of a struct to inherit members from.")
		end
		if not structInfoToInherit.hasMembers then
			!DEPEND_AND_RETURN(`struct`, DEPEND_STRUCT_MEMBERS_READY, `structInfoToInherit`)
		end
		if doesStructInherit(structInfoToInherit, structInfo) then
			typeError(state, typeExpr, "Struct is trying to inherit members from itself.")
		end
	end

	--
	-- No more dependencies for this struct after this point!
	--

	local typeSourceNodeK = struct.keyType
	local typeSourceNodeV = struct.valueType

	if typeSourceNodeK then  structInfo.keyType   = requireTypeRepresentedByExpression(state, typeSourceNodeK)  end
	if typeSourceNodeV then  structInfo.valueType = requireTypeRepresentedByExpression(state, typeSourceNodeV)  end

	-- Inherit members from other structs.
	if struct.inherits[1] then
		for i, typeExpr in ipairs(struct.inherits) do
			local structInfoToInherit  = requireTypeRepresentedByExpression(state, typeExpr)
			local insertIndexStatement = indexOf(struct.statements, typeExpr) or errorInternal(state, typeExpr)
			table.remove(struct.statements, insertIndexStatement)

			for j = 1, i-1 do
				local typeExprPrevious   = struct.inherits[j]
				local structInfoPrevious = requireTypeRepresentedByExpression(state, typeExprPrevious)
				if
					structInfoToInherit == structInfoPrevious
					-- @Speed?
					or doesStructInherit(structInfoToInherit, structInfoPrevious)
					or doesStructInherit(structInfoPrevious, structInfoToInherit)
				then
					typeError2(state,
						typeExpr,         F("Two inherited structs are the same or share a base struct."),
						typeExprPrevious, F("...here is the other inheritance.")
					)
				end
			end

			local insertIndexDecl = 1

			for i, decl in ipairs(struct.declarations) do
				if decl.token > typeExpr.token then  break  end
				insertIndexDecl = i+1
			end

			local structToInherit = structInfoToInherit.astNode

			for _, declToInherit in ipairs(structToInherit.declarations) do
				local decl = findMemberDeclaration(state, struct, declToInherit.name.name)
				if not decl or decl.parent ~= struct then
					table.insert(struct.declarations, insertIndexDecl, declToInherit)
				elseif decl.isConstant and declToInherit.isConstant then
					-- void  Shadowing/overriding static declarations is permitted. (Should we limit this to only functions, methods, or even foreign methods?)
				else
					typeError2(state,
						typeExpr, F("Trying to inherit a member called '%s' but the struct already has a member with that name.", decl.name.name),
						decl,     F("...previous member was added here.") -- This may be an inherited member too.
					)
				end
			end

			if structToInherit.isForeign then
				struct.isForeign          = true
				struct.foreignThroughNode = typeExpr
			end

			if structInfoToInherit.keyType then
				if structInfo.keyType then
					local ealy, late = getEarlyAndLateExpression(typeExpr, typeSourceNodeK)
					typeError2(state, late, "Key type is already defined.", ealy, "...key type was defined here.")
				end
				typeSourceNodeK    = typeExpr
				structInfo.keyType = structInfoToInherit.keyType
			end
			if structInfoToInherit.valueType then
				if structInfo.valueType then
					local ealy, late = getEarlyAndLateExpression(typeExpr, typeSourceNodeV)
					typeError2(state, late, "Value type is already defined.", ealy, "...value type was defined here.")
				end
				typeSourceNodeV      = typeExpr
				structInfo.valueType = structInfoToInherit.valueType
			end
			-- @Incomplete: Handle structInfo.kind==STRUCT_KIND_ARRAY and structInfoToInherit.kind==STRUCT_KIND_TABLE, and vice versa.
			if structInfoToInherit.kind ~= !(STRUCT_KIND_NORMAL) then
				assert(structInfo.kind == !(STRUCT_KIND_NORMAL))
				structInfo.kind = structInfoToInherit.kind
			end
		end

		for i, expr in ipairs(struct.statements) do
			expr.queued.key = i
		end
	end

	-- Add members to structInfo.
	for _, decl in ipairs(struct.declarations) do
		if not decl.isConstant then
			local member          = TypeInfoStructMember()
			member.name           = decl.name.name
			member.typeInfo       = decl.name.inferredType or errorInternal()
			table.insert(structInfo.members, member)

			checkForRecursiveStruct(state, decl, {member}, member, structInfo, structInfo)

			-- Inherit foreign state from foreign-marked members in certain situations.

			if struct.isForeign then
				-- void

			elseif decl.value and !!(anyV(`decl.value.nodeType`, nodeTypes.AstForeign,nodeTypes.AstNull)) then
				-- void

			elseif member.typeInfo.tag == !(typeTags.TypeInfoStruct) then
				if member.typeInfo.astNode.isForeign then
					struct.isForeign          = true
					struct.foreignThroughNode = decl
				end

			elseif member.typeInfo.tag == !(typeTags.TypeInfoCompound) then
				!ASSERT("decl.value.inferredType.tag ~= "..typeTags.TypeInfoCompound)

				if decl.value.inferredType.tag == !(typeTags.TypeInfoStruct) and decl.value.inferredType.astNode.isForeign then
					struct.isForeign          = true
					struct.foreignThroughNode = decl
					break
				end
			end
		end
	end
	structInfo.hasMembers = true

	if structInfo.keyType and (structInfo.members[1] or struct.declarations[1]) and structInfo.keyType.tag == !(typeTags.TypeInfoString) then
		-- Note: We trigger this error for static members too, not just dynamic, as some lookups would otherwise be ambigous.
		typeError(state, typeSourceNodeK, "Strongly typed tables with string keys cannot also have members.")
	end

	moveToNextRelevantPipe(state, struct)
end

!NODE_INFERRER `function nodeInferrers.AstEnum(state, enum)`
	for _, statement in ipairs(enum.statements) do
		if statement.nodeType == !(nodeTypes.AstDeclaration) then
			local decl = statement
			!ASSERT `decl.value`
			if not decl.value.inferredType then
				!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `decl.value`)
			end

		elseif statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	assert(enum.declarations[1]) -- This should have been caught during parsing.

	local enumMemberInfo

	if enum.memberType then
		!ASSERT `enum.memberType.typeName`
		enumMemberInfo = getTypeInfoForBuiltinType(state, enum.memberType.typeName)
	else
		-- Just use the type of the first member as the wanted type for the enum.
		enumMemberInfo = enum.declarations[1].value.inferredType
		if not !!(anyV(`enumMemberInfo.tag`, typeTags.TypeInfoInt,typeTags.TypeInfoString,typeTags.TypeInfoType,typeTags.TypeInfoBool,typeTags.TypeInfoFloat)) then
			typeError(state, enum, "Supported enum member types are: int, string, type, bool, float")
		end
	end

	local enumInfo          = newTypeInfo(state, TypeInfoEnum)
	enumInfo.astNode        = enum
	enumInfo.memberTypeInfo = enumMemberInfo or errorInternal()

	for i, decl in ipairs(enum.declarations) do
		local valueExpr = decl.value

		if valueExpr.nodeType == !(nodeTypes.AstForeign) then
			-- @UX @Bug: This should be possible but something swaps the enum type with the member type somewhere.
			typeError(state, valueExpr, "Enum values cannot be foreign.")
		elseif not isExpressionConstant(state, valueExpr, false) then
			typeError(state, valueExpr, "Enum value is not constant.")
		elseif not isTypeCompatibleWith(valueExpr.inferredType, enumMemberInfo) then
			typeError(state, valueExpr,
				"Value type mismatch for '%s'. (Wanted %s, got %s)",
				decl.name.name,
				getFriendlyTypeInfoName(enumMemberInfo),
				getFriendlyTypeInfoName(valueExpr.inferredType)
			)
		end

		-- Note: valueExpr may not be a constant expression, but the
		-- declaration will check that after this enum gets inferred.

		local member        = TypeInfoEnumMember()
		member.name         = decl.name.name
		enumInfo.members[i] = member
	end

	table.insert(state.allTypeInfos, enumInfo)

	enum.representedType = enumInfo
	enum.inferredType    = getTypeInfoForBuiltinType(state, "type")

	moveToNextRelevantPipe(state, enum)
end

!NODE_INFERRER `function nodeInferrers.AstFileScope(state, fileScope)`
	for _, statement in ipairs(fileScope.statements) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`fileScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	moveToNextRelevantPipe(state, fileScope)
end

!NODE_INFERRER `function nodeInferrers.AstGlobalScope(state, globalScope)`
	for _, statement in ipairs(globalScope.statements) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`globalScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	moveToNextRelevantPipe(state, globalScope)
end

!NODE_INFERRER `function nodeInferrers.AstBlock(state, block)`
	for _, statement in ipairs(block.statements) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`block`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	moveToNextRelevantPipe(state, block)
end

local function visitNodesForRunning(state, runNode, unit, visited)
	astVisitAllNodes(unit, function(node)
		visited[node] = true

		if not node.queued then
			return !(VISIT_IGNORE_CHILDREN)

		elseif node.queued.pipe <= !(PIPE_BYTECODE) then
			!DEPEND_AND_RETURN(`runNode`, DEPEND_NODE_EMITTED, `node`, nil, toLua(VISIT_BREAK))

		elseif node.nodeType == !(nodeTypes.AstIdentifier) then
			local decl = node.declaration or errorInternal()

			if not visited[decl] then
				visitNodesForRunning(state, runNode, decl, visited)
				if runNode.queued.waitingOn then  return !(VISIT_BREAK)  end

				local valueExpr = getDeclarationValue(decl)

				if valueExpr then
					visitNodesForRunning(state, runNode, valueExpr, visited)
					if runNode.queued.waitingOn then  return !(VISIT_BREAK)  end
				end
			end
		end
	end)
end

local function createRunReplacementFromTypeAndLuaValue(state, runNode, parent, typeInfo, v)
	local tag = typeInfo.tag

	if tag == !(typeTags.TypeInfoInt) or (tag == !(typeTags.TypeInfoAny) and type(v) == "number" and v == math.floor(v)) then
		local n = v
		assert(type(n) == "number" and n == math.floor(n))
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = n
		literal.inferredType = getTypeInfoForBuiltinType(state, "int")
		return literal

	elseif tag == !(typeTags.TypeInfoFloat) or (tag == !(typeTags.TypeInfoAny) and type(v) == "number") then
		local n = v
		assert(type(n) == "number")
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = n
		literal.inferredType = getTypeInfoForBuiltinType(state, "float")
		return literal

	elseif tag == !(typeTags.TypeInfoString) or (tag == !(typeTags.TypeInfoAny) and type(v) == "string") then
		local s = v
		assert(type(s) == "string")
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_STRING)
		literal.value        = s
		literal.inferredType = getTypeInfoForBuiltinType(state, "string")
		return literal

	elseif tag == !(typeTags.TypeInfoBool) or (tag == !(typeTags.TypeInfoAny) and type(v) == "boolean") then
		local flag = v
		assert(type(flag) == "boolean")
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = flag
		literal.inferredType = getTypeInfoForBuiltinType(state, "bool")
		return literal

	elseif tag == !(typeTags.TypeInfoNone) or (tag == !(typeTags.TypeInfoAny) and v == nil) then
		assert(v == nil)
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_NIL)
		literal.value        = nil
		literal.inferredType = getTypeInfoForBuiltinType(state, "none")
		return literal

	elseif tag == !(typeTags.TypeInfoTable) or (tag == !(typeTags.TypeInfoAny) and type(v) == "table") then
		local t = v
		assert(type(t) == "table")
		local tableNode = astNewNode(AstTable, runNode.token, parent)
		local anyType   = getTypeInfoForBuiltinType(state, "any")

		for k, v in pairsSorted(t, naturalCompare) do
			local tableField    = TableField()
			tableField.key      = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, anyType, k)
			tableField.value    = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, anyType, v)
			table.insert(tableNode.fields, tableField)
		end

		tableNode.inferredType = getTypeInfoForBuiltinType(state, "table")
		return tableNode

	elseif tag == !(typeTags.TypeInfoArray) then
		local t = v
		assert(type(t) == "table")
		local arraySig  = typeInfo
		local tableNode = astNewNode(AstTable, runNode.token, parent)
		local intType   = getTypeInfoForBuiltinType(state, "int")

		-- @Robustness: Check that all keys in 't' are valid.
		for i, v in ipairs(t) do
			local tableField          = TableField()

			local indexLiteral        = astNewNode(AstLiteral, runNode.token, tableNode)
			indexLiteral.literalType  = !(LITERAL_INTEGER)
			indexLiteral.value        = i
			indexLiteral.inferredType = intType
			tableField.key            = indexLiteral

			tableField.value          = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, arraySig.itemType, v)

			tableNode.fields[i]       = tableField
		end

		tableNode.inferredType = arraySig
		return tableNode

	elseif tag == !(typeTags.TypeInfoStruct) then
		local t = v
		assert(type(t) == "table")
		local structInfo = typeInfo
		local tableNode  = astNewNode(AstTable, runNode.token, parent)
		local stringType = getTypeInfoForBuiltinType(state, "string")
		assert(structInfo.hasMembers)

		-- @Robustness: Check that all keys in 't' are valid.
		for _, member in ipairs(structInfo.members) do
			local tableField           = TableField()

			local memberLiteral        = astNewNode(AstLiteral, runNode.token, tableNode)
			memberLiteral.literalType  = !(LITERAL_STRING)
			memberLiteral.value        = member.name
			memberLiteral.inferredType = stringType
			tableField.key             = memberLiteral

			tableField.value           = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, member.typeInfo, t[member.name])

			table.insert(tableNode.fields, tableField)
		end

		tableNode.inferredType = structInfo
		return tableNode

	elseif tag == !(typeTags.TypeInfoEnum) then
		local enumInfo     = typeInfo
		local ident        = astNewNode(AstIdentifier, runNode.token, parent)
		ident.inferredType = enumInfo

		if !!(anyV(`enumInfo.memberTypeInfo.tag`, typeTags.TypeInfoInt,typeTags.TypeInfoString,typeTags.TypeInfoBool,typeTags.TypeInfoFloat)) then
			for _, decl in ipairs(enumInfo.astNode.declarations) do
				local literal = decl.value
				assert(literal.nodeType == !(nodeTypes.AstLiteral))
				if literal.value == v then
					ident.name        = decl.name.name
					ident.declaration = decl
					break
				end
			end

		elseif enumInfo.memberTypeInfo.tag == !(typeTags.TypeInfoType) then
			for _, decl in ipairs(enumInfo.astNode.declarations) do
				if requireTypeRepresentedByExpression(state, decl.value).id == v then
					ident.name        = decl.name.name
					ident.declaration = decl
					break
				end
			end

		else
			errorUnhandledType(state, runNode, enumInfo.memberTypeInfo)
		end

		if not ident.declaration then
			typeError(state, runNode, "Got an invalid enum value. (Enum '%s', value: %s)", getFriendlyTypeInfoName(enumInfo), tostring(v))
		end

		return ident

	elseif tag == !(typeTags.TypeInfoFunction) then
		local func = v
		assert(type(func) == "function")

		local theConst = nil

		for _, const in ipairs(state.constants) do
			if const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(typeTags.TypeInfoFunction) and state.runnerEnvironment[const.name] == func then
				theConst = const
				break
			end
		end

		if not theConst then
			errorInternal(state, runNode, "The resulting function is no an existing constant for some reason.")
		end

		local lambda = theConst.value

		if lambda.parent.nodeType == !(nodeTypes.AstDeclaration) then
			local decl  = lambda.parent
			local ident = astCopy(decl.name, runNode.token, parent)
			return ident
		else
			local copy = astCopy(lambda, nil, parent)
			copy.token = runNode.token
			return copy
		end

	elseif tag == !(typeTags.TypeInfoType) then
		local typeId = v
		assert(type(typeId) == "number" and typeId == math.floor(typeId))

		local typeRepresented = itemWith1(state.allTypeInfos, "id", typeId)
		if not typeRepresented then
			typeError(state, runNode, "Got the ID of a type that doesn't exist. (Type ID %d)", typeId)
		end

		local typeNode = createTypeNodeFromInfo(state, typeRepresented, runNode.token, parent)
		return typeNode

	elseif tag == !(typeTags.TypeInfoCompound) then
		typeError(state, runNode, "!run expression is, or contains something, of a compound type which is illegal. (Type is %s)", getFriendlyTypeInfoName(typeInfo))
	elseif tag == !(typeTags.TypeInfoNamespace) then
		typeError(state, runNode, "!run expression is a namespace which is illegal here.")
	else
		errorUnhandledType(state, runNode, typeInfo)
	end
end

!NODE_INFERRER `function nodeInferrers.AstRun(state, runNode)`
	local lambda = runNode.lambda

	if lambda.queued.pipe <= !(PIPE_BYTECODE) then
		!DEPEND_AND_RETURN(`runNode`, DEPEND_NODE_EMITTED, `lambda`)
	end
	--[[ This is currently not needed as only functions may be waiting. 2020-02-26
	for _, const in ipairs(state.constants) do
		if not const.isReady and not (const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(typeTags.TypeInfoFunction)) then
			!DEPEND_AND_RETURN(`runNode`, DEPEND_CONSTANT_READY, `const`)
		end
	end
	--]]

	local visited = {}

	visitNodesForRunning(state, runNode, lambda, visited)
	if runNode.queued.waitingOn then  return  end

	for _, const in ipairs(state.constants) do
		if not const.isReady and (const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(typeTags.TypeInfoFunction)) and visited[const.value] then
			!DEPEND_AND_RETURN(`runNode`, DEPEND_CONSTANT_READY, `const`)
		end
	end

	!ifDEBUG `profilerPause()`
	runnerSetup(state)

	local newConstants            = {}
	local newTopScopeDeclarations = {}

	for _, const in ipairs(state.constants) do
		if not state.runnerWrittenObjects[const] and const.isReady then
			state.runnerWrittenObjects[const] = true
			table.insert(newConstants, const)
			const.nameLocked = true -- @UX: Update constant names as they are allocated (and not when declarations pass PIPE_BYTECODE).
		end
	end

	for _, decl in ipairs(state.globalScope.declarations) do
		if visited[decl] and not state.runnerWrittenObjects[decl] then
			state.runnerWrittenObjects[decl] = true
			table.insert(newTopScopeDeclarations, decl)
		end
	end
	for _, fileScope in ipairs(state.globalScope.fileScopes) do
		for __, decl in ipairs(fileScope.declarations) do
			if visited[decl] and not state.runnerWrittenObjects[decl] then
				state.runnerWrittenObjects[decl] = true
				table.insert(newTopScopeDeclarations, decl)
			end
		end
	end

	local writer = state.runnerWriter

	writeLuaPreloads(state, writer, state.runnerWrittenPreloads+1)
	state.runnerWrittenPreloads = #state.luaPreloads

	writeForeignImports                (state, writer, newConstants, true)
	writeConstantObjectsExceptFunctions(state, writer, newConstants, true)
	writeFunctionObjects               (state, writer, newConstants)
	writeTopScopeDeclarations          (state, writer, newTopScopeDeclarations)

	-- !ifDEBUG `print(writer.file:getBuffer())`
	runnerRunBufferAsChunk(state)
	!ifDEBUG `profilerUnpause()`

	local constName = lambda.valueConstant.name
	local func      = state.runnerEnvironment[constName]

	if type(func) ~= "function" then
		errorInternal(state, runNode, "Missing the compiled object to run for some reason. (Constant '%s')", constName)
	end

	local v = func() -- @Incomplete: Better error messages using xpcall().

	if not isAnExpressionExpected(state, runNode) then
		runNode.inferredType = getTypeInfoForBuiltinType(state, "void")
		moveToNextRelevantPipe(state, runNode)
		return
	end

	-- Replace the directive with a constant value.

	local returnNode = getLast(lambda.body.statements)
	assert(returnNode.nodeType == !(nodeTypes.AstReturn))

	local typeInfo = returnNode.values[1].inferredType
	typeInfo       = adjustTypeToOne(state, runNode, typeInfo, true)

	local replacement = createRunReplacementFromTypeAndLuaValue(state, runNode, runNode.parent, typeInfo, v)
	addUnqueuedChildrenToQueueRecursively(state, replacement, !(PIPE_INFER))

	replaceQueuedNodeAndUnqueueOldTree(state, runNode, replacement)
	if typeInfo.tag == !(typeTags.TypeInfoAny) and replacement.inferredType.tag ~= !(typeTags.TypeInfoAny) then
		replacement = wrapInImplicitCast(state, replacement, typeInfo, true)
	end

	moveChildrenToNextRelevantPipe(state, replacement)
	moveToNextRelevantPipe(state, replacement)
end

!NODE_INFERRER `function nodeInferrers.AstNull(state, null)`
	local typeInfoExpected = getExpectedTypeInfo(state, null, false, "NULL value", null)
	if not typeInfoExpected then  return  end

	-- if not isTypeTableLike(typeInfoExpected) then
	-- 	typeError(state, null, "Null only works in place of table-like objects.")
	-- end

	null.inferredType = typeInfoExpected
	moveToNextRelevantPipe(state, null)
end

!NODE_INFERRER `function nodeInferrers.AstNamespace(state, namespace)`
	namespace.inferredType = getTypeInfoForNamespace(state, namespace)
	moveToNextRelevantPipe(state, namespace)
end

function _G.inferNode(state, node)
	local nodeInferrer = nodeInferrers[node.nodeType] or errorUnhandledNodeType(state, node)
	nodeInferrer(state, node)
end

function _G.queueForReinfer(state, node)
	!ASSERT `node.queued`
	moveToPipe(state, node, !(PIPE_INFER))
	table.insert(state.queueActive, node.queued)
end



-- Note: It's assumed that the expression tree has all types figured out.
local ALWAYS_CONST = !(Set{
	nodeTypes.AstBake,
	nodeTypes.AstImport, -- Namespaces, just like types, are always constant.
	nodeTypes.AstLambda, -- Lambdas (which are function signatures) are types too, thus constant.
	nodeTypes.AstLiteral,
	nodeTypes.AstNamespace,
	nodeTypes.AstNull,
	nodeTypes.AstStruct, nodeTypes.AstEnum,   -- Structs and enums are types (which are constant).
	nodeTypes.AstType,   nodeTypes.AstTypeOf, -- All types are constant, just like literals.
})
local NEVER_CONST = !(Set{
	nodeTypes.AstCall,
	nodeTypes.AstTypeInfo, -- @Incomplete: Make type_info() a constant expression.
	nodeTypes.AstVararg,
})
function _G.isExpressionConstant(state, expr, foreignIsConst)
	local nodeType = expr.nodeType

	if ALWAYS_CONST[nodeType] then
		return true
	elseif NEVER_CONST[nodeType] then
		return false

	elseif nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration or errorInternal(state, ident)
		return decl.isConstant and isExpressionConstant(state, decl.value, foreignIsConst)

	elseif nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		return isExpressionConstant(state, cast.expression, foreignIsConst)

	elseif nodeType == !(nodeTypes.AstUnary) then
		local unary = expr
		return isExpressionConstant(state, unary.expression, foreignIsConst)
	elseif nodeType == !(nodeTypes.AstBinary) then
		local binary = expr
		return isExpressionConstant(state, binary.left, foreignIsConst) and isExpressionConstant(state, binary.right, foreignIsConst)

	elseif nodeType == !(nodeTypes.AstConditional) then
		local conditional = expr
		return (
			isExpressionConstant(state, conditional.condition, foreignIsConst)
			and (conditional.branchTrue == nil or isExpressionConstant(state, conditional.branchTrue, foreignIsConst))
			and isExpressionConstant(state, conditional.branchFalse, foreignIsConst)
		)

	elseif nodeType == !(nodeTypes.AstAccess) then
		local access = expr
		return isExpressionConstant(state, access.object, foreignIsConst) and isExpressionConstant(state, access.member, foreignIsConst)

	elseif nodeType == !(nodeTypes.AstTable) then
		local tableNode = expr
		if tableNode.trailingExpression then  return false  end

		for _, tableField in ipairs(tableNode.fields) do
			if not isExpressionConstant(state, tableField.key,   foreignIsConst) then  return false  end
			if not isExpressionConstant(state, tableField.value, foreignIsConst) then  return false  end
		end

		return true

	elseif nodeType == !(nodeTypes.AstForeign) then
		-- Technically foreign values are seen as constant at runtime, but since we don't
		-- know what they are at compile-time we (usually) treat them as runtime values.
		return foreignIsConst

	else
		errorUnhandledNodeType(state, expr)
	end
end



-- expression, typeInfo = getAssignmentValue( state, assignmentTarget, values, valueIndex, expectedTypeInfo=any, extraBinaryOperation="", targetTerm="assignment target" )
-- Note: Vararg node/type may be returned.
function _G.getAssignmentValue(state, targetExpr, values, i, typeInfoExpected, binOp, targetTerm)
	!(
	local TEMPLATE_TARGET_NAME = trimTemplate`
		targetExpr.nodeType == $nodeTypeIdent  and " ('"..targetExpr.name.."')" or
		targetExpr.nodeType == $nodeTypeAccess and targetExpr.member.nodeType == $nodeTypeLiteral and targetExpr.member.literalType == $literalTypeString and " ('"..targetExpr.member.value.."')" or
		""
	`
	local TARGET_NAME = templateToLua(TEMPLATE_TARGET_NAME, {
		nodeTypeIdent     = nodeTypes.AstIdentifier,
		nodeTypeAccess    = nodeTypes.AstAccess,
		nodeTypeLiteral   = nodeTypes.AstLiteral,
		literalTypeString = LITERAL_STRING,
	})

	local TEMPLATE_CALL_RETURNS_NOTHING = trimTemplate`
		typeError(state, call, "Called function returns nothing for %s #%d%s (return value #%d).", targetTerm, i, $targetName, argIndex)
	`
	local CALL_RETURNS_NOTHING = templateToLua(TEMPLATE_CALL_RETURNS_NOTHING, {
		targetName = TARGET_NAME,
	})

	local TEMPLATE_CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN = `
		if binOp == "" then
			if isTypeCompatibleWith($valueTypeInfoAdjusted, typeInfoExpected) then  return $valueExpr, $valueTypeInfo  end

		else
			$valueTypeInfoAdjusted = checkBinaryOperation(
				state,
				targetExpr,
				$valueExpr, targetExpr, $valueExpr,
				binOp,
				typeInfoExpected, $valueTypeInfoAdjusted,
				true
			) or errorInternal()

			if not isTypeCompatibleWith($valueTypeInfoAdjusted, typeInfoExpected) then
				typeError(
					state, targetExpr,
					"Type mismatch between %s #%d%s (%s) and result of binary operation (%s) (%s).",
					targetTerm, i, $targetName, getFriendlyTypeInfoName(typeInfoExpected),
					binOp, getFriendlyTypeInfoName($valueTypeInfoAdjusted))
			end

			return $valueExpr, $valueTypeInfo
		end
	`
	local function CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(valueExprVar, typeInfoVar, typeInfoAdjustedVar)
		local lua = templateToLua(TEMPLATE_CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN, {
			valueExpr             = valueExprVar,
			valueTypeInfo         = typeInfoVar,
			valueTypeInfoAdjusted = typeInfoAdjustedVar,
			targetName            = TARGET_NAME,
		})
		__LUA(lua)
	end
	)

	binOp      = binOp      or ""
	targetTerm = targetTerm or "assignment target"

	local valueExpr = values[i]

	if valueExpr then
		local valueTypeInfo = valueExpr.inferredType

		if valueTypeInfo.tag == !(typeTags.TypeInfoList) then
			valueTypeInfo = valueTypeInfo[1]

			if not valueTypeInfo then
				local call     = valueExpr
				local argIndex = 1
				!!(CALL_RETURNS_NOTHING)
			end
		end

		if not typeInfoExpected then  return valueExpr, valueTypeInfo  end

		local valueTypeInfoAdjusted = adjustTypeToOne(state, valueExpr, valueTypeInfo, true)
		!CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(`valueExpr`, `valueTypeInfo`, `valueTypeInfoAdjusted`)

		local messageFormat
			=   valueTypeInfoAdjusted.tag == !(typeTags.TypeInfoFunction) and typeInfoExpected.tag == !(typeTags.TypeInfoFunction)
			and "Function signature is different from %s #%d%s. (Wanted %s, got %s)"
			or  "Value type mismatch for %s #%d%s. (Wanted %s, got %s)"

		typeError(
			state, valueExpr, messageFormat,
			targetTerm, i, !!(TARGET_NAME),
			getFriendlyTypeInfoName(typeInfoExpected),
			getFriendlyTypeInfoName(valueTypeInfoAdjusted)
		)
	end

	valueExpr = values[#values]

	if not valueExpr then
		typeError(state, targetExpr, "Missing a value for %s #%d%s.", targetTerm, i, !!(TARGET_NAME))

	elseif valueExpr.nodeType == !(nodeTypes.AstCall) and not valueExpr.surroundedByParentheses then
		local call      = valueExpr
		local lastIndex = #values
		local argIndex  = i-lastIndex+1

		local typeInfoForCall = call.inferredType
		local listSig

		if typeInfoForCall.tag == !(typeTags.TypeInfoList) then
			listSig = typeInfoForCall
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfoForCall))
		end

		local typeInfoForOutArg = listSig[argIndex]

		if typeInfoForOutArg then
			-- void
		elseif listSig[1] and listSig[#listSig].tag == !(typeTags.TypeInfoVararg) then
			typeInfoForOutArg = listSig[#listSig]
		else
			!!(CALL_RETURNS_NOTHING)
		end

		if not typeInfoExpected then  return call, typeInfoForOutArg  end

		local typeInfoForOutArgAdjusted = adjustTypeToOne(state, call, typeInfoForOutArg, true)
		!CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(`call`, `typeInfoForOutArg`, `typeInfoForOutArgAdjusted`)

		local calleeName = (call.callee.nodeType == !(nodeTypes.AstIdentifier) and " of '"..call.callee.name.."'" or "")

		typeError(
			state, call,
			"The type of return value #%d%s (%s) does not match the type of %s #%d%s (%s).",
			argIndex, calleeName, getFriendlyTypeInfoName(typeInfoForOutArgAdjusted),
			targetTerm, i, !!(TARGET_NAME), getFriendlyTypeInfoName(typeInfoExpected)
		)

	elseif valueExpr.nodeType == !(nodeTypes.AstVararg) and not valueExpr.surroundedByParentheses then
		local vararg = valueExpr
		return vararg, vararg.inferredType

	else
		typeError(state, targetExpr, "Missing a value for %s #%d%s.", targetTerm, i, !!(TARGET_NAME))
	end
end



local function createLambdaArgumentsFromTypes(state, typeInfos, lambda)
	local args = astNewNode(AstArguments, lambda.token, lambda)

	for i, argTypeInfo in ipairs(typeInfos) do
		local arg          = astNewNode(AstArgument,    lambda.token, args)
		local decl         = astNewNode(AstDeclaration, lambda.token, arg)
		local ident        = astNewNode(AstIdentifier,  lambda.token, decl)

		ident.name         = "_"..i
		ident.declaration  = decl
		ident.inferredType = argTypeInfo

		decl.name          = ident

		arg.declaration    = decl
		arg.group          = i

		-- @Incomplete: Handle default values for input arguments. (Needed?)

		args.arguments[i] = arg
	end

	return args
end

local function createLambdaFromSignature(state, funcSig, parent)
	local lambda = astNewNode(AstLambda, parent.token, parent)

	if funcSig.argumentTypesIn[1] then
		lambda.argumentsIn = createLambdaArgumentsFromTypes(state, funcSig.argumentTypesIn, lambda)
		table.insert(lambda.statements, lambda.argumentsIn)
	end
	if funcSig.argumentTypesOut[1] then
		lambda.argumentsOut = createLambdaArgumentsFromTypes(state, funcSig.argumentTypesOut, lambda)
		table.insert(lambda.statements, lambda.argumentsOut)
	end

	return lambda
end

function _G.createTypeNodeFromInfo(state, typeRepresented, token, parent)
	local typeNode            = astNewNode(AstType, token, parent)
	local isBuiltin, typeName = isTypeBuiltin(typeRepresented)

	typeNode.inferredType    = getTypeInfoForBuiltinType(state, "type")
	typeNode.representedType = typeRepresented

	if isBuiltin then
		typeNode.kind           = !(TYPE_KIND_SIMPLE_BUILTIN)
		typeNode.typeName       = typeName

	elseif typeRepresented.tag == !(typeTags.TypeInfoStruct) then
		local structInfo        = typeRepresented
		typeNode.kind           = structInfo.isPolymorphic and !(TYPE_KIND_POLY_STRUCT) or !(TYPE_KIND_SIMPLE_USER)
		typeNode.typeName       = structInfo.name

	elseif typeRepresented.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo          = typeRepresented
		typeNode.kind           = !(TYPE_KIND_SIMPLE_USER)
		typeNode.typeName       = enumInfo.name

	elseif typeRepresented.tag == !(typeTags.TypeInfoFunction) then
		local funcSig           = typeRepresented
		typeNode.kind           = !(TYPE_KIND_FUNCTION)
		typeNode.functionHeader = createLambdaFromSignature(state, funcSig, typeNode) -- Is this really needed? I doubt it. @Cleanup

	elseif typeRepresented.tag == !(typeTags.TypeInfoCompound) then
		typeNode.kind           = !(TYPE_KIND_COMPOUND)

	elseif typeRepresented.tag == !(typeTags.TypeInfoArray) then
		local arraySig          = typeRepresented
		typeNode.kind           = !(TYPE_KIND_ARRAY)
		typeNode.arrayItemType  = createTypeNodeFromInfo(state, arraySig.itemType, token, typeNode)

	elseif typeRepresented.tag == !(typeTags.TypeInfoVararg) then
		errorInternal() -- When do we get here?
	else
		!ifDEBUG `print(getFriendlyTypeInfoName(typeRepresented))`
		errorInternal("Incomplete: Handle type group '%s'.", TYPE_TAG_NAMES[typeRepresented.tag])
	end

	return typeNode
end

local function isTypeOrDoesTypeContainPlaceholder(typeInfo)
	if typeInfo.tag == !(typeTags.TypeInfoPlaceholder) then
		return true

	elseif typeInfo.tag == !(typeTags.TypeInfoCompound) then
		local compound = typeInfo
		return itemWith1(compound, "tag", !(typeTags.TypeInfoPlaceholder)) ~= nil

	elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
		local funcSig = typeInfo
		for _, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			if isTypeOrDoesTypeContainPlaceholder(argTypeInfo) then  return true  end
		end
		for _, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			if isTypeOrDoesTypeContainPlaceholder(argTypeInfo) then  return true  end
		end
		return false

	else
		return false
	end
end

function _G.simplifyTypeExpression(state, expr, typeRepresented)
	!ASSERT("expr.nodeType ~= "..nodeTypes.AstType)
	!ASSERT("typeRepresented")

	if isTypeOrDoesTypeContainPlaceholder(typeRepresented) then  return nil  end

	local typeNode = createTypeNodeFromInfo(state, typeRepresented, expr.token, expr.parent)

	if expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident          = expr
		typeNode.declaration = ident.declaration
	end

	addUnqueuedChildrenToQueueRecursively(state, typeNode, !(PIPE_INFER))
	moveChildrenToNextRelevantPipe(state, typeNode)

	replaceQueuedNodeAndUnqueueOldTree(state, expr, typeNode)

	return typeNode
end

local function simplifyCast(state, cast)
	if cast.expression.nodeType == !(nodeTypes.AstAccess) then  return  end -- Cannot simplify views.

	local exprTypeInfo = cast.expression.inferredType
	local castTypeInfo = cast.inferredType

	local parent = cast.parent
	if
		parent.nodeType == !(nodeTypes.AstConditional)
		and parent.conditionAndBranchTrue
		and parent.conditionAndBranchTrue ~= parent.condition
		and cast == parent.condition
	then
		-- Simplifying this cast would mess up the output. Example situation:
		-- local x = if myString "a" else "b"
		return
	end

	if exprTypeInfo == castTypeInfo then
		errorInternal(state, cast) -- This should have been simplified away already.

	-- int -> float
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoInt) and castTypeInfo.tag == !(typeTags.TypeInfoFloat) then
		!ASSERT("cast.expression.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("type(cast.expression.value) == 'number'")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = cast.expression.value
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- float -> int
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoFloat) and castTypeInfo.tag == !(typeTags.TypeInfoInt) then
		!ASSERT("cast.expression.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("type(cast.expression.value) == 'number'")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = math.modf(cast.expression.value)
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- (numeric) -> bool
	elseif isTypeNumeric(exprTypeInfo) and castTypeInfo.tag == !(typeTags.TypeInfoBool) then
		!ASSERT("cast.expression.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("type(cast.expression.value) == 'number'")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = cast.expression.value ~= 0
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- string -> bool
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoString) and castTypeInfo.tag == !(typeTags.TypeInfoBool) then
		!ASSERT("cast.expression.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("type(cast.expression.value) == 'string'")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = cast.expression.value ~= ""
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- array -> bool
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoArray) and castTypeInfo.tag == !(typeTags.TypeInfoBool) then
		local tableNode = followIdentifiersToConstantValue(cast.expression)
		assert(tableNode.nodeType == !(nodeTypes.AstTable))

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = tableNode.fields[1] ~= nil -- (Assume the array constructor is valid.)
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- enum -> enumMemberType (int, float, string, bool or type)
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoEnum) and isTypeCompatibleWith(exprTypeInfo.memberTypeInfo, castTypeInfo) then
		local castIsDirect = (castTypeInfo == exprTypeInfo.memberTypeInfo)

		local enumInfo = exprTypeInfo
		local ident    = cast.expression

		assert(ident.nodeType == !(nodeTypes.AstIdentifier)) -- All enums should have been simplified to identifiers.

		!ASSERT `ident.declaration.isConstant`
		local valueExpr = ident.declaration.value

		if BUILTIN_TYPE_TAG_TO_LITERAL_TYPE[castTypeInfo.tag] then
			local literal = valueExpr
			assert(literal.nodeType == !(nodeTypes.AstLiteral))

			local literalCopy = astCopy(literal, cast.token)

			if castIsDirect then
				assert(literalCopy.inferredType == castTypeInfo)

			elseif exprTypeInfo.memberTypeInfo.tag == !(typeTags.TypeInfoInt) and castTypeInfo.tag == !(typeTags.TypeInfoFloat) then
				literalCopy.literalType  = !(LITERAL_FLOAT)
				literalCopy.inferredType = castTypeInfo

			else
				errorInternal(
					state, cast,
					"Incomplete: Implicitly cast enum from %s to %s.",
					getFriendlyTypeInfoName(exprTypeInfo.memberTypeInfo),
					getFriendlyTypeInfoName(castTypeInfo)
				)
			end

			replaceQueuedNodeAndUnqueueOldTree(state, cast, literalCopy)
			moveToNextRelevantPipe(state, literalCopy, !(PIPE_INFER))

		elseif castTypeInfo.tag == !(typeTags.TypeInfoType) then
			assert(castIsDirect)

			local typeNode = valueExpr
			assert(typeNode.nodeType == !(nodeTypes.AstType))

			local typeNodeCopy = astCopy(typeNode, cast.token)

			addUnqueuedChildrenToQueueRecursively(state, typeNodeCopy, !(PIPE_DONE)) -- Only does something if the type has parameters.
			replaceQueuedNodeAndUnqueueOldTree(state, cast, typeNodeCopy)
			moveToNextRelevantPipe(state, typeNodeCopy, !(PIPE_INFER))

		else
			errorInternal(state, cast, "Incomplete: Handle casting enum to %s.", getFriendlyTypeInfoName(castTypeInfo))
		end

	-- (whatever) -> compound
	elseif castTypeInfo.tag == !(typeTags.TypeInfoCompound) then
		typeError(state, cast, "Cannot cast constants to compound types. (Target type is %s)", getFriendlyTypeInfoName(castTypeInfo))

	-- (whatever) -> any
	-- any -> (whatever)
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoAny) or castTypeInfo.tag == !(typeTags.TypeInfoAny) then -- Handle this last!
		-- void

	else
		errorInternal(
			state, cast,
			"Incomplete: Handle casting constant from %s to %s.",
			getFriendlyTypeInfoName(exprTypeInfo),
			getFriendlyTypeInfoName(castTypeInfo)
		)
	end
end

local function simplifyUnary(state, unary)
	-- @Incomplete: Simplify these kinds of expressions (including implicit casts): not (str ~= "") => str == ""

	if unary.expression.nodeType == !(nodeTypes.AstAccess) then  return  end -- Cannot simplify views.

	local typeInfo = unary.inferredType

	if nil then

	!for _, opArithmetic in ipairs{"+","-"} do
	elseif unary.operation == !(opArithmetic) then
		!ASSERT("unary.expression.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("type(unary.expression.value) == 'number'")

		local literal = astNewNode(AstLiteral, unary.token, unary.parent)

		literal.literalType
			=  typeInfo.tag == !(typeTags.TypeInfoInt)   and !(LITERAL_INTEGER)
			or typeInfo.tag == !(typeTags.TypeInfoFloat) and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = !!(opArithmetic ~= "+" and opArithmetic or "") unary.expression.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	elseif unary.operation == "not" then
		!ASSERT("unary.expression.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("type(unary.expression.value) == 'boolean'")

		local literal        = astNewNode(AstLiteral, unary.token, unary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = not unary.expression.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	elseif unary.operation == "#" then
		local tableNode = followIdentifiersToConstantValue(unary.expression)
		local length    = 0
		assert(tableNode.nodeType == !(nodeTypes.AstTable))

		if tableNode.inferredType.tag == !(typeTags.TypeInfoArray) then
			for _, tableField in ipairs(tableNode.fields) do
				length = math.max(length, tableField.key.value)
			end

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoTable) then
			errorUnhandledNodeType(state, unary)

		else
			errorInternal(state, tableNode)
		end

		local literal        = astNewNode(AstLiteral, unary.token, unary.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = length
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	else
		errorUnhandledNodeType(state, unary)
	end
end

local function simplifyBinary(state, binary)
	local l  = binary.left
	local r  = binary.right
	local op = binary.operation

	if l.nodeType == !(nodeTypes.AstAccess) or r.nodeType == !(nodeTypes.AstAccess) then  return  end -- Cannot simplify views.

	!local ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS = templateToLua(
		`
			if l.nodeType    ~= $nodeTypeLiteral then  errorInternal()  end
			if r.nodeType    ~= $nodeTypeLiteral then  errorInternal()  end
			if type(l.value) ~= "number"         then  errorInternal()  end
			if type(r.value) ~= "number"         then  errorInternal()  end
		`, {
			nodeTypeLiteral = toLua(nodeTypes.AstLiteral),
		}
	)

	-- @Incomplete: Simplify these kinds of expressions: (1+x)+2 => (1+2)+x => 3+x
	-- @Incomplete: Simplify these kinds of expressions: 1 + -x => 1 - x
	local typeInfo = binary.inferredType

	if nil then
		-- void

	!for _, opArithmeticKeepType in ipairs{"+","-","*","^","%"} do
	elseif op == !(opArithmeticKeepType) then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		local literal = astNewNode(AstLiteral, binary.token, binary.parent)

		literal.literalType
			=  typeInfo.tag == !(typeTags.TypeInfoInt)   and !(LITERAL_INTEGER)
			or typeInfo.tag == !(typeTags.TypeInfoFloat) and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = l.value !!(opArithmeticKeepType) r.value -- This should produce the correct result for any combination of int and float.
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	elseif op == "/" then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = l.value / r.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	elseif op == "//" then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = math.floor(l.value / r.value)
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	!for _, opComparison in ipairs{"<",">","<=",">="} do
	elseif op == !(opComparison) then
		!ASSERT("l.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("r.nodeType == "..nodeTypes.AstLiteral)

		!if DEBUG then
			local lType = type(l.value)
			!ASSERT("lType == type(r.value)")
			!ASSERT("lType == 'number' or lType == 'string'")
		!end

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = l.value !!(opComparison) r.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	!for _, opEquality in ipairs{"==","~="} do
	elseif op == !(opEquality) then
		local valueL, valueR

		if l.inferredType.tag == !(typeTags.TypeInfoType) then
			!ASSERT("r.inferredType.tag == "..typeTags.TypeInfoType)
			valueL = getTypeRepresentedByExpression(l).id
			valueR = getTypeRepresentedByExpression(r).id

		elseif l.inferredType.tag == !(typeTags.TypeInfoEnum) then
			!ASSERT("r.inferredType.tag == "..typeTags.TypeInfoEnum)
			!ASSERT("l.nodeType == "..nodeTypes.AstIdentifier)
			!ASSERT("r.nodeType == "..nodeTypes.AstIdentifier)
			valueL = l.name
			valueR = r.name

		elseif l.nodeType == !(nodeTypes.AstLiteral) then
			!ASSERT("r.nodeType == "..nodeTypes.AstLiteral)
			!ASSERT("type(l.value) == type(r.value)")
			valueL = l.value
			valueR = r.value

		else
			!ifDEBUG `astPrintTree(binary)`
			errorInternal(state, binary)
		end

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = valueL !!(opEquality) valueR
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	!for _, opLogical in ipairs{"and","or"} do
	elseif op == !(opLogical) then
		!ASSERT("l.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("r.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("type(l.value) == 'boolean'")
		!ASSERT("type(r.value) == 'boolean'")

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = l.value !!(opLogical) r.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	elseif op == ".." then
		!ASSERT("l.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("r.nodeType == "..nodeTypes.AstLiteral)
		!ASSERT("type(l.value) == 'string'")
		!ASSERT("type(r.value) == 'string'")

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_STRING)
		literal.value        = l.value .. r.value -- @Speed: Concatinate more than two values at a time. (Should maybe update parsing stage.)
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	else
		errorUnhandledNodeType(state, binary)
	end
end

function _G.simplifyExpressionIfConstant(state, expr)
	if not isExpressionConstant(state, expr, false) then
		if
			-- :SpecialForeignValueRules
			expr.nodeType == !(nodeTypes.AstIdentifier)
			and expr.declaration.isConstant
			and expr.declaration.value.nodeType == !(nodeTypes.AstForeign)
		then
			local ident       = expr
			local foreign     = ident.declaration.value
			local foreignCopy = astCopy(foreign, ident.token, ident.parent)

			replaceQueuedNodeAndUnqueueOldTree(state, ident, foreignCopy)
			moveToNextRelevantPipe(state, foreignCopy, !(PIPE_INFER))
		end

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration or errorInternal(state, ident)

		if not decl.isConstant then  return  end

		local typeInfo = ident.inferredType

		if typeInfo.tag == !(typeTags.TypeInfoEnum) then
			if ident.name ~= decl.name.name then
				-- @Cleanup: Is this necessary? Can't we just do ident.name=decl.name.name?
				local copy = astCopy(decl.name, ident.token, ident.parent)
				replaceQueuedNodeAndUnqueueOldTree(state, ident, copy)
				moveToNextRelevantPipe(state, copy, !(PIPE_INFER))
			end
			return
		end

		local typeInfoRepresented = decl.valueTypeInfo

		if typeInfoRepresented then
			simplifyTypeExpression(state, ident, typeInfoRepresented)
			return
		end

		!ASSERT("typeInfo.tag ~= "..typeTags.TypeInfoType)
		if not isTypeSimple(typeInfo) then  return  end

		if decl.value.nodeType == !(nodeTypes.AstAccess) then  return  end -- This will create a constant lookup (AKA view).

		-- At this point we should have a literal to copy. Hopefully the expression we copy
		-- has been simplified into a literal if it wasn't a literal to begin with.
		local literal = decl.value
		if literal.nodeType ~= !(nodeTypes.AstLiteral) then
			errorInternal(state, literal)
		end

		local copy = astCopy(literal, ident.token, ident.parent)
		replaceQueuedNodeAndUnqueueOldTree(state, ident, copy)
		moveToNextRelevantPipe(state, copy, !(PIPE_INFER))

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		simplifyCast(state, expr)
	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		simplifyUnary(state, expr)
	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		simplifyBinary(state, expr)

	else
		-- void
	end
end



-- Values of simple types are non-objects (e.g. ints) in the outputted Lua code.
-- Note: Glóa types are represented as ints in Lua and thus are 'simple'.
function _G.isTypeSimple(typeInfo)
	local tag = typeInfo.tag
	return !!(anyV(`tag`,
		typeTags.TypeInfoBool,
		typeTags.TypeInfoInt,
		typeTags.TypeInfoNone,
		typeTags.TypeInfoFloat,
		typeTags.TypeInfoString,
		typeTags.TypeInfoType,
		typeTags.TypeInfoEnum -- All enum member types are simple.
	))
end

function _G.isTypeNumeric(typeInfo)
	return !!(anyV(`typeInfo.tag`, typeTags.TypeInfoInt,typeTags.TypeInfoFloat))
end

function _G.isTypeTableLike(typeInfo)
	return !!(anyV(`typeInfo.tag`, typeTags.TypeInfoTable,typeTags.TypeInfoStruct,typeTags.TypeInfoArray))
end

-- isCompatible, compatibilityScore = isTypeCompatibleWith( typeToCheck, otherType )
function _G.isTypeCompatibleWith(typeToCheck, otherType)
	!local SCORE = 0x10000
	if typeToCheck == otherType then  return true, !(SCORE)  end

	-- Namespaces are never compatible with anything but themselves as they're not allowed in most places.
	if typeToCheck.tag == !(typeTags.TypeInfoNamespace) or otherType.tag == !(typeTags.TypeInfoNamespace) then  return false, 0  end

	-- Placeholders cannot actually be checked - we just say they are compatible with
	-- everything (except namespaces) until the situation is handled elsewhere.
	!local SCORE = .1
	if typeToCheck.tag == !(typeTags.TypeInfoPlaceholder) or otherType.tag == !(typeTags.TypeInfoPlaceholder) then  return true, !(SCORE)  end

	-- Everything is compatible with the 'any' type. The user better know what they're doing!
	!local SCORE = 0x1
	if otherType.tag == !(typeTags.TypeInfoAny) then  return true, !(SCORE)  end

	-- Ints are always compatible with floats (but the opposite is false).
	-- This should be safe as all numbers are 64-bit floats in Lua 5.1 (I think).
	!local SCORE = 0x1000
	if typeToCheck.tag == !(typeTags.TypeInfoInt) and otherType.tag == !(typeTags.TypeInfoFloat) then  return true, !(SCORE)  end

	-- Substructs are compatible with base structs.
	!local SCORE = 0x1000
	if typeToCheck.tag == !(typeTags.TypeInfoStruct) and otherType.tag == !(typeTags.TypeInfoStruct) then
		if doesStructInherit(typeToCheck, otherType) then  return true, !(SCORE)  end
		return false, 0
	end

	-- Structs and arrays are outputted as tables in Lua, so they are always compatible with tables in Glóa.
	!local SCORE = 0x10
	if
		otherType.tag == !(typeTags.TypeInfoTable)
		and !!(anyV(`typeToCheck.tag`, typeTags.TypeInfoStruct,typeTags.TypeInfoArray))
	then
		return true, !(SCORE)
	end

	!local SCORE = 0x100
	if typeToCheck.tag == !(typeTags.TypeInfoCompound) then
		-- All compound items has to match the target. (If only one item matches, an explicit cast is needed.)
		local compoundToCheck = typeToCheck
		for _, compoundItemToCheck in ipairs(compoundToCheck) do
			if not isTypeCompatibleWith(compoundItemToCheck, otherType) then  return false, 0  end
		end
		return true, !(SCORE)
	end

	!local SCORE = 0x100
	if otherType.tag == !(typeTags.TypeInfoCompound) then
		-- typeToCheck has to match at least one compound item.
		local otherCompound = otherType
		for _, otherCompoundItem in ipairs(otherCompound) do
			if isTypeCompatibleWith(typeToCheck, otherCompoundItem) then  return true, !(SCORE)  end
		end
		return false, 0
	end

	-- Array compatability completely depends on the item type.
	if otherType.tag == !(typeTags.TypeInfoArray) then
		if typeToCheck.tag == !(typeTags.TypeInfoArray) then
			return isTypeCompatibleWith(typeToCheck.itemType, otherType.itemType)
		elseif typeToCheck.tag == !(typeTags.TypeInfoStruct) and typeToCheck.kind == !(STRUCT_KIND_ARRAY) then
			return isTypeCompatibleWith(typeToCheck.valueType, otherType.itemType)
		end
	end

	return false, 0
end

function _G.doesStructInherit(structInfoToCheck, otherStructInfo)
	!ASSERT `otherStructInfo`

	for _, typeExpr in ipairs(structInfoToCheck.astNode.inherits) do
		local structInfoInherited = getTypeRepresentedByExpression(typeExpr)

		if structInfoInherited == otherStructInfo or doesStructInherit(structInfoInherited, otherStructInfo) then
			return true
		end
	end

	return false
end

-- singleTypeInfo = adjustTypeToOne( state, expressionForError, typeInfo [, adjustVarargToIncludeNil=false ] )
-- Types that aren't single: TypeInfoVararg and TypeInfoList.
do
	local function compareIdsOfTypes(a, b)
		return a.id < b.id
	end

	local function adjustVarargItemTypeToOneAndToIncludeNil(state, itemType)
		if !!(anyV(`itemType.tag`, typeTags.TypeInfoNone,typeTags.TypeInfoAny)) then
			return itemType
		end

		local nilTypeInfo = getTypeInfoForBuiltinType(state, "none")

		if itemType.tag ~= !(typeTags.TypeInfoCompound) then
			local typeInfos = {itemType, nilTypeInfo}
			table.sort(typeInfos, compareIdsOfTypes)
			return getTypeInfoForCompoundType(state, typeInfos)
		end

		local compound = itemType
		if indexOf(compound, nilTypeInfo) then  return compound  end

		local typeInfos = {nilTypeInfo, unpack(compound)}
		table.sort(typeInfos, compareIdsOfTypes)
		return getTypeInfoForCompoundType(state, typeInfos)
	end

	function _G.adjustTypeToOne(state, exprForError, typeInfo, adjustVarargToIncludeNil)
		if typeInfo.tag == !(typeTags.TypeInfoList) then
			typeInfo = typeInfo[1]
			if not typeInfo then
				typeError(state, exprForError, "Function call returns nothing. (Expected at least one value.)") -- Note: "Nothing" is not the same as vararg of zero length.
			end
		end

		if typeInfo.tag == !(typeTags.TypeInfoVararg) then
			typeInfo = typeInfo.itemType
			if adjustVarargToIncludeNil then
				typeInfo = adjustVarargItemTypeToOneAndToIncludeNil(state, typeInfo)
			end
		end

		return typeInfo
	end
end



local function getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError)
	!(
	local NO_EXPECTATION = 'typeError(state, nodeForError, "Could not determine the type of this %s.", expectantTerm)'
	if DEBUG then
		NO_EXPECTATION = 'astPrintTree(node) ; '..NO_EXPECTATION
	end
	)

	if node.nodeType == !(nodeTypes.AstTable) then
		-- Detect constructors that look like arrays.
		local tableNode   = node
		local tableField1 = tableNode.fields[1]
		if not tableField1 then  !!(NO_EXPECTATION)  end

		local fieldKey = tableField1.key

		if fieldKey.nodeType == !(nodeTypes.AstLiteral) and fieldKey.literalType == !(LITERAL_INTEGER) then
			local fieldValue = tableField1.value
			if fieldValue.nodeType == !(nodeTypes.AstTable) then  !!(NO_EXPECTATION)  end

			if not fieldValue.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `fieldValue`, nil, `nil`)
			end

			return getTypeInfoForArray(state, fieldValue.inferredType)

		elseif not fieldKey.inferredType then
			if fieldKey.nodeType ~= !(nodeTypes.AstTable) then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `fieldKey`, nil, `nil`)
			end
		end
	end

	!!(NO_EXPECTATION)
end

-- Returns nil if we're now waiting for something. Errors on failure.
function _G.getExpectedTypeInfo(state, node, strict, expectantTerm, nodeForError)
	local parentNodeType = node.parent.nodeType

	if parentNodeType == !(nodeTypes.AstAssignment) then
		local assignment = node.parent
		local i          = indexOf(assignment.values, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		if assignment.forDeclaration then
			local decl = assignment.declarations[i] or errorInternal()

			if decl.name.inferredType then
				return decl.name.inferredType
			elseif not decl.type then
				return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			elseif not decl.type.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
			else
				return getTypeRepresentedByExpression(decl.type) or errorInternal()
			end

		else
			if not assignment.targets[i].inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `assignment.targets[i]`, nil, `nil`)
			end
			return assignment.targets[i].inferredType
		end

	elseif parentNodeType == !(nodeTypes.AstDeclaration) then
		local decl = node.parent
		if node ~= decl.value then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		if decl.name.inferredType then
			return decl.name.inferredType

		elseif decl.parent.nodeType == !(nodeTypes.AstEnum) then
			local enum     = decl.parent
			local enumInfo = enum.representedType
			if enumInfo then
				return enumInfo
			elseif enum.memberType or decl ~= enum.declarations[1] then
				-- @Incomplete: This doesn't work right now as enums wait for their members. Enums need to be more like structs!
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `enum`, nil, `nil`)
			else
				return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			end

		elseif decl.type then
			if not decl.type.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
			else
				return getTypeRepresentedByExpression(decl.type) or errorInternal(state, decl.type)
			end

		elseif node.nodeType == !(nodeTypes.AstTable) then
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))

		else
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end

	elseif parentNodeType == !(nodeTypes.AstAssignment) then
		local assignment = node.parent
		local i          = indexOf(assignment.values, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		if assignment.forDeclaration then
			local decl = assignment.declarations[i] or errorInternal(state, node)

			if decl.name.inferredType then
				return decl.name.inferredType

			elseif decl.parent.nodeType == !(nodeTypes.AstEnum) then
				local enum     = decl.parent
				local enumInfo = enum.representedType
				if enumInfo then
					return enumInfo
				elseif enum.memberType or decl ~= enum.declarations[1] then
					-- @Incomplete: This doesn't work right now as enums wait for their members. Enums need to be more like structs!
					!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `enum`, nil, `nil`)
				else
					return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
				end

			elseif decl.type then
				if not decl.type.inferredType then
					!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
				else
					return getTypeRepresentedByExpression(decl.type) or errorInternal(state, decl.type)
				end

			elseif node.nodeType == !(nodeTypes.AstTable) then
				return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))

			else
				return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			end

		else
			-- @Incomplete: Get type from assignment target.
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end

	elseif parentNodeType == !(nodeTypes.AstCast) then
		local cast = node.parent
		if node ~= cast.expression then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		if not cast.targetType.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `cast.targetType`, nil, `nil`)
		end

		return getTypeRepresentedByExpression(cast.targetType) or errorInternal(state, cast.targetType)

	elseif parentNodeType == !(nodeTypes.AstBinary) then
		local binary = node.parent
		local other  = node == binary.left and binary.right or binary.left

		if not other.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `other`, nil, `nil`)
		end

		return other.inferredType

	elseif parentNodeType == !(nodeTypes.AstTable) then
		local tableNode = node.parent
		if not tableNode.inferredType then
			-- Note: Tables will always get inferred before child tables.
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `tableNode`, nil, `nil`)
		end

		local tableField = nil
		local isKey      = false

		for _, _tableField in ipairs(tableNode.fields) do
			if node == _tableField.key then
				isKey      = true
				tableField = _tableField
				break
			elseif node == _tableField.value then
				tableField = _tableField
				break
			end
		end

		!ASSERT `tableField`

		if tableNode.inferredType.tag == !(typeTags.TypeInfoTable) then
			return getTypeInfoForBuiltinType(state, "any")

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoArray) then
			if isKey then  return getTypeInfoForBuiltinType(state, "int")  end

			local arraySig = tableNode.inferredType
			return arraySig.itemType

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoStruct) then
			if isKey then  return getTypeInfoForBuiltinType(state, "string")  end

			local structInfo = tableNode.inferredType
			if not structInfo.hasMembers then
				!DEPEND_AND_RETURN(`node`, DEPEND_STRUCT_MEMBERS_READY, `structInfo`)
			end

			local memberLiteral = tableField.key
			if not memberLiteral.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `memberLiteral`)
			end

			local memberName = memberLiteral.value
			local member     = itemWith1(structInfo.members, "name", memberName) or errorInternal(state, memberLiteral, memberName)

			return member.typeInfo

		else
			errorInternal(getFriendlyTypeInfoName(tableNode.inferredType))
		end

	elseif parentNodeType == !(nodeTypes.AstReturn) then
		local returnNode = node.parent

		if returnNode.runDirective then
			return getExpectedTypeInfo(state, returnNode.runDirective, strict, expectantTerm, nodeForError)
		end

		local i = indexOf(returnNode.values, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		local lambda  = getLambda(returnNode)
		local funcSig = lambda.inferredType

		if not funcSig then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `lambda`, nil, `nil`)
		end

		local argTypesOut = funcSig.argumentTypesOut
		local argTypeInfo = argTypesOut[i]

		if
			(not argTypeInfo and argTypesOut[1] and argTypesOut[#argTypesOut].tag == !(typeTags.TypeInfoVararg))
			or (argTypeInfo.tag == !(typeTags.TypeInfoVararg))
		then
			local varargSig = argTypeInfo or argTypesOut[#argTypesOut]
			argTypeInfo     = varargSig.itemType
		end

		-- Note: We don't need to get too fancy with validation here as the return is validated later.
		if not argTypeInfo then
			typeError(state, returnNode, "Too many values specified for return.")
		end

		return argTypeInfo

	elseif strict then
		return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))

	elseif parentNodeType == !(nodeTypes.AstCall) then
		local call = node.parent
		local i    = indexOf(call.arguments, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		local calleeTypeInfo = call.callee.inferredType

		if not calleeTypeInfo then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `call.callee`, nil, `nil`)
		end

		if not call.inferredType and call.callee.nodeType == !(nodeTypes.AstIdentifier) and call.callee.declaration.overloadOf then
			-- We have a circular dependency here. Overloaded calls must have all args inferred
			-- before being valid and constructors etc. must know the correct overload.
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end

		local argTypesIn  = calleeTypeInfo.argumentTypesIn
		local argTypeInfo = argTypesIn[i]

		if
			(argTypeInfo and argTypeInfo.tag == !(typeTags.TypeInfoVararg))
			or (not argTypeInfo and argTypesIn[1] and argTypesIn[#argTypesIn].tag == !(typeTags.TypeInfoVararg))
		then
			local varargSig = argTypeInfo or argTypesIn[#argTypesIn]
			argTypeInfo     = varargSig.itemType
		end

		-- Note: We don't need to get too fancy with validation here as the call is validated later.
		if not argTypeInfo then
			!ifDEBUG `astPrintTree(call)`
			typeError(state, call, "Too many arguments specified for call.")
		end

		return argTypeInfo

	else
		return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
	end
	errorInternal()
end



-- Note: The expression must be constant!
function _G.followIdentifiersToConstantValue(constExpr)
	while constExpr.nodeType == !(nodeTypes.AstIdentifier) do
		local decl = constExpr.declaration
		constExpr  = decl.value
	end
	return constExpr
end



function _G.wrapInImplicitCast(state, nodeToWrap, resultingTypeInfo, addToInferPipe)
	local cast        = astNewNode(AstCast, nodeToWrap.token, nodeToWrap.parent)
	cast.isImplicit   = true
	cast.inferredType = resultingTypeInfo
	pokeAndQueueUnqueuedNodeIntoTree(state, nodeToWrap, cast, cast,"expression", (addToInferPipe and !(PIPE_INFER) or !(PIPE_DONE)))
	return cast
end



local EXPRESSION_EXPECTED = !(Set{
	nodeTypes.AstType,
	nodeTypes.AstUnary,
	nodeTypes.AstBinary,
	nodeTypes.AstAccess,
	nodeTypes.AstTable,
	nodeTypes.AstCall,
	nodeTypes.AstTypeOf,
	nodeTypes.AstCast,
	nodeTypes.AstConditional,
	nodeTypes.AstBake,
	nodeTypes.AstRun, -- Good?
	nodeTypes.AstUsing,
	nodeTypes.AstDebug,
	nodeTypes.AstAssignment,
	nodeTypes.AstReturn,
})
local EXPRESSION_NOT_EXPECTED = !(Set{
	nodeTypes.AstArgument,
	nodeTypes.AstArguments,
	nodeTypes.AstDefer,
	nodeTypes.AstBlock,
	nodeTypes.AstFileScope,
	nodeTypes.AstGlobalScope,
	nodeTypes.AstStruct,
	nodeTypes.AstEnum,
	nodeTypes.AstLambda,
})

function _G.isAnExpressionExpected(state, node)
	local parent         = node.parent
	local parentNodeType = parent.nodeType

	if EXPRESSION_EXPECTED[parentNodeType] then
		return true
	elseif EXPRESSION_NOT_EXPECTED[parentNodeType] then
		return false
	elseif parentNodeType == !(nodeTypes.AstDeclaration) then
		return node == parent.name or node == parent.type or node == parent.value
	elseif parentNodeType == !(nodeTypes.AstFor) then
		return node ~= parent.body
	elseif !!(anyV(`parentNodeType`, nodeTypes.AstIf,nodeTypes.AstStaticIf,nodeTypes.AstWhile)) then
		return node == parent.condition
	else
		errorUnhandledNodeType(state, node.parent)
	end
end



-- Note: The expressions must already be inferred!
function _G.areTreesEqual(state, expr1, expr2)
	if expr1 == expr2 then
		return true
	elseif expr1.nodeType ~= expr2.nodeType then
		return false
	elseif expr1.nodeType == !(nodeTypes.AstLiteral) then
		return expr1.literalType == expr2.literalType and expr1.value == expr2.value
	elseif expr1.nodeType == !(nodeTypes.AstType) then
		return expr1.representedType.id == expr2.representedType.id
	else
		errorUnhandledNodeType(state, expr1)
	end
end



-- valueExpression = getDeclarationValue( declaration [, fallBackToLastAssignmentValue=false ] )
function _G.getDeclarationValue(decl, fallBackToLastAssignmentValue)
	return decl.value or decl.assignment and (
		decl.assignment.values[decl.assignmentIndex]
		or (fallBackToLastAssignmentValue and getLast(decl.assignment.values) or nil)
	)
end

function _G.isDeclarationGlobal(decl)
	return decl.isExported and decl.parent.nodeType == !(nodeTypes.AstFileScope) and not decl.parent.isModule
end


