--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	typeError, typeMessage, errorUnhandledNodeType
	inferType*

--============================================================]]

!(
local function WAITING_OR_ERROR(errCode)
	__LUA("if state.mustInfer then ")
		__LUA("state.errorStep = state.errorStep-1 ")
		__LUA("if state.errorStep <= 0 then ")
			__LUA(errCode," ")
		__LUA("end ")
	__LUA("end ")
	__LUA("state.waiting = state.waiting+1 ")
end
)



_G.!struct"TyperState"{
	fileBuffers = {},
	tokens      = {},

	progress    = 0,
	waiting     = 0,

	mustInfer   = false,
	errorStep   = 0,

	functionSignatureTypes = {},
}



!(
_G.typeInfoKinds    = {}
local typeInfoN     = 0
local typeInfoNames = {}

local function structTypeInfo(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			typeInfoN              = typeInfoN+1
			fields._overrides      = fields._overrides or {}
			fields._overrides.kind = typeInfoN

			typeInfoKinds[name]      = typeInfoN
			typeInfoNames[typeInfoN] = name
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_TypeInfo"{
	kind       = 0,
	group      = 0,
	id         = 0,
	definition = NIL, -- AstTypeDefinition (This node has the scope.)
}

!structTypeInfo"_TypeInfoPrimitive:_TypeInfo"{
	_overrides = {group=TYPEDEF_BUILTIN},
}
local !structTypeInfo"TypeInfoBool:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoInt:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoNil:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoNumber:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoString:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoTable:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoType:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoAny:_TypeInfoPrimitive"{}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{
	_overrides       = {group=TYPEDEF_FUNCTION},
	argumentTypesIn  = {}, -- []TypeInfo
	argumentTypesOut = {}, -- []TypeInfo
	polymorphic      = false,
	inline           = false,
}

local !struct"TypeInfoStructMember"{
	name     = "",
	typeInfo = NIL,
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	_overrides            = {group=TYPEDEF_STRUCT},
	name                  = "",
	members               = {},  -- []TypeInfoStructMember
	polymorphSourceStruct = NIL, -- TypeInfoStruct
}

local !struct"TypeInfoEnumMember"{
	name = "",
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	_overrides            = {group=TYPEDEF_ENUM},
	name                  = "",
	members               = {}, -- []TypeInfoEnumMember
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	_overrides = {group=TYPEDEF_BUILTIN},
	-- [1]=typeInfo1, ...
}

local TYPEDEF_NAMES = !(typeInfoNames)



-- typeInfo = newTypeInfo( TypeInfoCreator [, definition=internal ] )
do
	local lastTypeId = 0

	function _G.newTypeInfo(TypeInfoCreator, defn)
		if not TypeInfoCreator then  error("No TypeInfoCreator specified.", 2)  end

		lastTypeId = lastTypeId+1

		local typeInfo      = TypeInfoCreator()
		typeInfo.id         = lastTypeId
		typeInfo.definition = defn

		--[[
		if lastTypeId == 22 then
			error("DEBUG")
		end
		--]]

		return typeInfo
	end
end

do
	local builtinTypeInfos = {}

	local BUILTIN_TYPE_STRUCTS = {
		["bool"]   = TypeInfoBool,
		["int"]    = TypeInfoInt,
		["nil"]    = TypeInfoNil,
		["number"] = TypeInfoNumber,
		["string"] = TypeInfoString,
		["table"]  = TypeInfoTable,
		["type"]   = TypeInfoType,
	}

	function _G.getTypeInfoForBuiltinType(state, typeName)
		local typeInfo = builtinTypeInfos[typeName]

		if not typeInfo then
			local TypeInfoCreator      = BUILTIN_TYPE_STRUCTS[typeName] or error(typeName)
			typeInfo                   = newTypeInfo(TypeInfoCreator)
			builtinTypeInfos[typeName] = typeInfo
		end

		return typeInfo
	end
end

-- typeInfo, definition = getTypeInfo( state, identType )
-- Can return nil. The definition is always nil for built-in types.
function _G.getTypeInfo(state, identType)
	-- print(">>>>>>>>>") astPrint(identType) print("<<<<<<<<<")

	if not identType.isUserType then
		return getTypeInfoForBuiltinType(state, identType.typeName), nil

	elseif identType.functionSignature then
		local lambda = identType.functionSignature

		for _, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
			if not arg.declaration.inferredTypes[1] then  return nil  end
		end
		for _, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
			if not arg.declaration.inferredTypes[1] then  return nil  end
		end

		-- Have we encountered an equal signature before?
		for _, funcSigCached in ipairs(state.functionSignatureTypes) do
			if doesLambdaHaveSignature(lambda, funcSigCached) then
				return funcSigCached, nil
			end
		end

		funcSig = newTypeInfo(TypeInfoFunction)

		for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
			funcSig.argumentTypesIn[i] = arg.declaration.inferredTypes[1]
		end
		for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
			funcSig.argumentTypesOut[i] = arg.declaration.inferredTypes[1]
		end

		table.insert(state.functionSignatureTypes, funcSig)

		return funcSig, nil

	else
		assert(identType.typeName ~= "")

		local defn     = findDefinition(state, identType, identType.typeName)
		local typeInfo = defn and defn.typeInfo

		if not typeInfo then  return nil  end

		-- @Incomplete: Check stuff with typeInfo.group, I think is needed?
		--[[
		for _, typeData in ipairs(state.allTypes) do
			if identType.typeName == typeData.name then
				local typeInfo = typeData.typeInfo

				if typeInfo.group == !(TYPEDEF_BUILTIN) then
					assert(not identType.arguments) -- This should have been prevented during parsing. Builtin types don't have parameters.
					return typeInfo

				elseif typeInfo.group == !(TYPEDEF_STRUCT) then
					error("@Incomplete: Handle group==TYPEDEF_STRUCT")

				elseif typeInfo.group == !(TYPEDEF_ENUM) then
					error("@Incomplete: Handle group==TYPEDEF_ENUM")

				elseif typeInfo.group == !(TYPEDEF_FUNCTION) then
					error("@Incomplete: Handle group==TYPEDEF_FUNCTION")

				else
					error(typeInfo.group)
				end
			end
		end
		]]

		return typeInfo, defn
	end
end



function _G.doesLambdaHaveSignature(lambda, funcSig)
	if #(lambda.argumentsIn  or EMPTY_TABLE) ~= #funcSig.argumentTypesIn  then  return false  end
	if #(lambda.argumentsOut or EMPTY_TABLE) ~= #funcSig.argumentTypesOut then  return false  end

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if arg.declaration.inferredTypes[1] ~= funcSig.argumentTypesIn[i] then  return false  end
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if arg.declaration.inferredTypes[1] ~= funcSig.argumentTypesIn[i] then  return false  end
	end

	-- @Incomplete: Check for required input args.

	return true
end



function _G.getClosestScope(node)
	return astFindParent(node, !(nodeTypes.AstFileScope),!(nodeTypes.AstBlock),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum),!(nodeTypes.AstFor),!(nodeTypes.AstLambda))
end



function _G.findDefinition(state, startNode, name)
	local scope = startNode

	while true do
		scope = getClosestScope(scope)
		if not scope then  return nil  end

		assert(scope.definitions, scope.nodeType)

		for _, defn in ipairs(scope.definitions) do
			if defn.name.name == name then  return defn  end
		end
	end
end

function _G.defineInClosestScope(state, ident, typeInfo)
	local defnExisting = findDefinition(state, ident, ident.name)

	if defnExisting then
		-- @Incomplete: We're not following imperative scope rules for name shadowing (if that's what happening here).
		typeMessage(state, ident,             "Error", "'%s' has already been defined.", ident.name)
		typeMessage(state, defnExisting.name, "Info",  "...it was defined here.")
		exitFailure()
	end

	local scope = getClosestScope(ident)
	if not scope then
		typeError(state, ident, "Could not find what scope '%s' is in.", ident.name)
	end

	local defn    = astNewNode(AstTypeDefinition, ident.token, scope)
	defn.name     = ident
	defn.scope    = scope
	defn.typeInfo = typeInfo

	table.insert(scope.definitions, defn)
end

function _G.printDefinitionChain(state, defn, typeName)
	!local MAX_CHAIN_LENGTH = 10

	for i = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(state, defn.name, "Info", "...here is '%s' defined.", typeName)

		local placeDeclared = defn.name.placeDeclared
		if not placeDeclared then  break  end

		defn = nil

		if placeDeclared.nodeType == !(nodeTypes.AstDeclaration) then
			local decl      = placeDeclared
			local i         = indexWith1(decl.names, "name", typeName)
			local valueNode = decl.values[i]

			if valueNode and valueNode.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = valueNode
				typeName    = ident.name
				defn        = findDefinition(state, ident, typeName)
			end
		end

		if not defn then  break  end
	end
end



local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = !({
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "nil",
	[LITERAL_NUMBER]  = "number",
	[LITERAL_STRING]  = "string",
})

function _G.inferExpression(state, expr)
	local typeInfo

	if expr.nodeType == !(nodeTypes.AstType) then
		local identType = expr

		if identType.functionSignature and not identType.functionSignature.inferredType then
			inferExpression(state, identType.functionSignature)
		end

		if not getTypeInfo(state, identType) then
			!WAITING_OR_ERROR `typeError(state, identType, "No type '%s'.", identType.typeName)` -- @Incomplete: typeName is empty for lambdas.
			return
		end

		typeInfo = getTypeInfoForBuiltinType(state, "type")

	elseif expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal  = expr
		local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType]

		if typeName then
			typeInfo = getTypeInfoForBuiltinType(state, typeName)
		else
			errorUnhandledNodeType(expr)
		end

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local defn  = findDefinition(state, ident, ident.name)

		if defn then
			typeInfo = defn.typeInfo
		else
			!WAITING_OR_ERROR `typeError(state, ident, "Undeclared identifier '%s'.", ident.name)`
			return
		end

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda          = expr
		local argsAreInferred = true

		-- Infer arguments.
		!for argsVarI, argsVar in ipairs{`lambda.argumentsIn`,`lambda.argumentsOut`} do
			local args = !!(argsVar)

			for i, arg in ipairs(args or EMPTY_TABLE) do
				local decl = arg.declaration

				if not decl.inferredTypes[1] then
					inferDeclaration(state, decl, !(argsVarI == 2))

					if decl.inferredTypes[1] then
						for i = i+1, #args do
							local arg2 = args[i]
							if arg2.group ~= arg.group then  break  end
							arg2.declaration.inferredTypes[1] = decl.inferredTypes[1]
						end
					else
						argsAreInferred = false
					end
				end
			end
		!end

		if not argsAreInferred then
			-- Should we have WAITING_OR_ERROR here?
			return
		end

		typeInfo = newTypeInfo(TypeInfoFunction--[[, defn]])

		for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
			typeInfo.argumentTypesIn[i] = arg.declaration.inferredTypes[1]
		end
		for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
			typeInfo.argumentTypesOut[i] = arg.declaration.inferredTypes[1]
		end

		-- @Incomplete: typeInfo.polymorphic
		-- @Incomplete: typeInfo.inline

	else
		errorUnhandledNodeType(expr)
	end

	assert(typeInfo)
	expr.inferredType = typeInfo
end

-- inferDeclaration( state, declaration [, isOutArg=false ] )
function _G.inferDeclaration(state, decl, isOutArg)
	-- @Incomplete: Check that the values (if there are any) are of the same type as the inferred type of the name.
	--              Maybe we wait with inferring the type of the expressions if type(s) are specified.

	-- Infer values.
	for i, expr in ipairs(decl.values) do
		if not expr.inferredType then
			inferExpression(state, expr)
		end
	end

	-- Infer names and declare them.
	for i, ident in ipairs(decl.names) do
		local typeInfo = nil

		-- @Incomplete: Look out for imports/loads.
		if not decl.inferredTypes[i] then
			-- Specified compound type.
			-- local x:int|string
			if decl.types[2] then
				error("@Incomplete: TypeInfoCompound")

			-- Single specified type.
			-- local x:int
			elseif decl.types[1] then
				local typeNode = decl.types[1]

				-- local x:int
				if typeNode.nodeType == !(nodeTypes.AstType) then
					local identType = typeNode
					local typeName  = identType.typeName

					if not identType.inferredType then
						inferExpression(state, identType)
					end

					if not identType.inferredType then
						!WAITING_OR_ERROR `typeError(state, identType, "Undeclared type '%s'.", typeName)`

					else
						typeInfo, defn = getTypeInfo(state, identType)

						if identType.isUserType and typeInfo.kind ~= !(typeInfoKinds.TypeInfoType) then -- Do we need to include TypeInfoStruct etc here?
							typeMessage(state, identType, "Error", "'%s' is not a type. (It is '%s')", typeName, getKindOfFriendlyTypeInfoName(typeInfo))
							printDefinitionChain(state, defn, typeName)
							exitFailure()
						end
					end

				-- local x:[]int
				elseif typeNode.nodeType == !(nodeTypes.AstLiteral) then
					local literal = typeNode
					assert(literal.literalType == !(LITERAL_ARRAY))
					errorUnhandledNodeType(typeNode) -- @Incomplete

				-- local x:typeOf(y)
				elseif typeNode.nodeType == !(nodeTypes.AstTypeOf) then
					local typeOf = typeNode
					local expr   = typeOf.expression

					inferExpression(state, expr)

					typeInfo            = expr.inferredType
					typeOf.inferredType = typeInfo

					if not typeInfo then
						-- !WAITING_OR_ERROR `typeError(state, expr, "Could not infer type of expression.")` -- Unhelpful...
					end

				else
					errorUnhandledNodeType(typeNode)
				end

			-- Infer types from initial values.
			else
				-- local x, y, z = expr, func()
				if i > #decl.values then
					error("@Incomplete: Handle initial assignment from (what hopefully is) a multi-value return.")

				-- local x, y = expr1, expr2
				else
					local expr = decl.values[i]
					typeInfo   = expr.inferredType

					if not typeInfo then
						-- !WAITING_OR_ERROR `typeError(state, expr, "Could not infer type of expression.")` -- Unhelpful...
					end
				end
			end

			if typeInfo then
				state.progress        = state.progress+1
				decl.inferredTypes[i] = typeInfo

				if not isOutArg then
					defineInClosestScope(state, ident, typeInfo)
				end
			end

			-- [[ DEBUG
			if typeInfo then
				print("DECLARE "..ident.name..":"..getKindOfFriendlyTypeInfoName(typeInfo)..(isOutArg and " (isOutArg)" or ""))
			else
				print("(declare failed "..ident.name..")")
			end
			--]]
		end
	end
end

function _G.inferFileScope(state, fileScope)
	for _, decl in ipairs(fileScope.declarations) do
		inferDeclaration(state, decl)
	end
end



-- typeError( typerState, node, formatString, ... )
function _G.typeError(state, node, s, ...)
	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	errorInFile(buffer, path, tokens.position1[token], "Typer", s, ...)
end

-- typeMessage( typerState, node, label, formatString, ... )
function _G.typeMessage(state, node, label, s, ...)
	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	reportMessageInFile(buffer, path, tokens.position1[token], label, "Typer", s, ...)
end

function _G.errorUnhandledNodeType(node)
	astPrint(node)
	errorInternal(2, "Incomplete: Unhandled node type '%s'.", (AST_NODE_TYPE_NAMES[node.nodeType] or node.nodeType))
end



function _G.getKindOfFriendlyTypeInfoName(typeInfo)
	-- @Cleanup: This just ain't nice.
	return TYPEDEF_NAMES[typeInfo.kind]:gsub("^TypeInfo", ""):lower()
end


