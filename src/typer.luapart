--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	findDeclaration, findDeclarationInScope, findMemberDeclaration, isDeclarationVisibleToNode, printDeclarationChain
	followIdentifiersToConstantValue
	getAssignmentValue
	getClosestScope, getClosestScopeForDeclaration, isScope, isScopeDeclarative, isScopeImperative
	inferNode
	isExpressionConstant, getLiteralValueFromExpressionIfConstant
	isPartOfAnyDeclaration
	isTypeSimple, isTypeCompatibleWith, adjustTypeToOne
	newTypeInfo, isTypeBuiltin, getTypeInfo*
	simplifyExpressionIfConstant, simplifyTypeExpression
	typeError, typeMessage

--============================================================]]



!(
_G.typeTags        = {}
local lastTypeTag  = 0
local typeTagNames = {}

local function structTypeInfo(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			lastTypeTag               = lastTypeTag+1

			fields._overrides         = fields._overrides or {}
			fields._overrides.tag     = lastTypeTag

			typeTags[name]            = lastTypeTag
			typeTagNames[lastTypeTag] = name:gsub("^TypeInfo", ""):lower()
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_TypeInfo"{
	tag = 0, -- This is like a "type of type info". The word "type" is used in so many places so we call it "tag" here to make it less confusing...
	id  = 0,
}

local !structTypeInfo"TypeInfoAny:_TypeInfo"{}
local !structTypeInfo"TypeInfoBool:_TypeInfo"{}
local !structTypeInfo"TypeInfoInt:_TypeInfo"{}
local !structTypeInfo"TypeInfoNone:_TypeInfo"{}
local !structTypeInfo"TypeInfoFloat:_TypeInfo"{}
local !structTypeInfo"TypeInfoString:_TypeInfo"{}
local !structTypeInfo"TypeInfoTable:_TypeInfo"{}
local !structTypeInfo"TypeInfoType:_TypeInfo"{}

local !structTypeInfo"TypeInfoForeignDummy:_TypeInfo"{}

_G.!(local )!!SIMPLE_TYPE_TAG = {
	-- These small type infos don't have any extra information.
	[typeTags.TypeInfoAny]    = true,
	[typeTags.TypeInfoBool]   = true,
	[typeTags.TypeInfoInt]    = true,
	[typeTags.TypeInfoNone]   = true,
	[typeTags.TypeInfoFloat]  = true,
	[typeTags.TypeInfoString] = true,
	[typeTags.TypeInfoTable]  = true,
	[typeTags.TypeInfoType]   = true,
}

local !structTypeInfo"TypeInfoArray:_TypeInfo"{
	itemType = NIL, -- TypeInfo
}

local !structTypeInfo"TypeInfoVararg:_TypeInfo"{
	itemType = NIL, -- TypeInfo
}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{ -- AKA function signature.
	argumentTypesIn      = {}, -- []TypeInfo  @Cleanup: Use TypeInfoList here.
	argumentTypesOut     = {}, -- []TypeInfo  @Cleanup: Use TypeInfoList here.
	requiredArgumentsIn  = {}, -- []bool
	requiredArgumentsOut = {}, -- []bool
	polymorphic          = false,
	inline               = false,
}

local !struct"TypeInfoStructMember"{
	name     = "",
	typeInfo = NIL,
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	astNode               = NIL, -- AstStruct
	name                  = "",  -- Filled in during definition.
	arguments             = {},  -- []TypeInfo  @Incomplete: Polymorphism.  @Cleanup: Use TypeInfoList here.
	members               = {},  -- []TypeInfoStructMember
	hasMembers            = false,
	polymorphSourceStruct = NIL, -- TypeInfoStruct  @Incomplete: Polymorphism.
}

local !struct"TypeInfoEnumMember"{
	name = "",
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	astNode        = NIL, -- AstEnum
	name           = "",
	memberTypeInfo = NIL, -- Must be one of these primitive types: int, string, type, bool or float.
	members        = {},  -- []TypeInfoEnumMember
}

local !structTypeInfo"TypeInfoNamespace:_TypeInfo"{
	scope = NIL, -- AstScope
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	-- [1]=typeInfo1, ...
}

local !structTypeInfo"TypeInfoList:_TypeInfo"{ -- Special type used for returns from calls (both when sending and receiving).
	-- [1]=typeInfo1, ...
}

_G.TYPE_TAG_NAMES = !(typeTagNames)



-- typeInfo = newTypeInfo( TypeInfoCreator )
do
	local lastTypeId = 0

	function _G.newTypeInfo(TypeInfoCreator)
		!ifDEBUG `if not TypeInfoCreator then  errorInternal(2, "No TypeInfoCreator specified.")  end`

		lastTypeId = lastTypeId+1

		local typeInfo = TypeInfoCreator()
		typeInfo.id    = lastTypeId

		--[[
		if lastTypeId == 22 then
			errorInternal("DEBUG")
		end
		--]]

		return typeInfo
	end
end

do
	local builtinTypeInfos = {}

	local BUILTIN_TYPE_STRUCTS = {
		["any"]     = TypeInfoAny,
		["bool"]    = TypeInfoBool,
		["int"]     = TypeInfoInt,
		["none"]    = TypeInfoNone,
		["float"]   = TypeInfoFloat,
		["string"]  = TypeInfoString,
		["table"]   = TypeInfoTable,
		["type"]    = TypeInfoType, -- The result of e.g. type_of(int) or type_of(type_of(expression)).
		["foreign"] = TypeInfoForeignDummy, -- Dummy type used for foreign constants in bytecode pipe and forward.
	}

	function _G.getTypeInfoForBuiltinType(state, typeName)
		local typeInfo = builtinTypeInfos[typeName]

		if not typeInfo then
			local TypeInfoCreator      = BUILTIN_TYPE_STRUCTS[typeName] or errorInternal(tostring(typeName))
			typeInfo                   = newTypeInfo(TypeInfoCreator)
			builtinTypeInfos[typeName] = typeInfo

			table.insert(state.allTypeInfos, typeInfo)
		end

		return typeInfo
	end

	-- bool, typeName = isTypeBuiltin( typeInfo )
	function _G.isTypeBuiltin(typeInfo)
		!ASSERT `typeInfo`
		if typeInfo == builtinTypeInfos["any"]    then  return true, "any"     end
		if typeInfo == builtinTypeInfos["bool"]   then  return true, "bool"    end
		if typeInfo == builtinTypeInfos["int"]    then  return true, "int"     end
		if typeInfo == builtinTypeInfos["none"]   then  return true, "none"    end
		if typeInfo == builtinTypeInfos["float"]  then  return true, "float"   end
		if typeInfo == builtinTypeInfos["string"] then  return true, "string"  end
		if typeInfo == builtinTypeInfos["table"]  then  return true, "table"   end
		if typeInfo == builtinTypeInfos["type"]   then  return true, "type"    end
		return false, ""
	end
end

local function doesLambdaHaveSignature(lambda, funcSig)
	if #(lambda.argumentsIn  or EMPTY_TABLE) ~= #funcSig.argumentTypesIn  then  return false  end
	if #(lambda.argumentsOut or EMPTY_TABLE) ~= #funcSig.argumentTypesOut then  return false  end

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if arg.declaration.name.inferredType ~= funcSig.argumentTypesIn[i]      then  return false  end
		if arg.isRequired                    ~= funcSig.requiredArgumentsIn[i]  then  return false  end
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if arg.declaration.name.inferredType ~= funcSig.argumentTypesOut[i] then  return false  end
	end

	return true
end

function _G.getTypeInfoForLambda(state, lambda)
	for _, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if not arg.declaration.name.inferredType then  return nil  end
	end
	for _, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if not arg.declaration.name.inferredType then  return nil  end
	end

	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoFunction) and doesLambdaHaveSignature(lambda, typeInfoCached) then
			return typeInfoCached
		end
	end

	local funcSig = newTypeInfo(TypeInfoFunction)

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		funcSig.argumentTypesIn[i]      = arg.declaration.name.inferredType
		funcSig.requiredArgumentsIn[i]  = arg.isRequired
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		funcSig.argumentTypesOut[i]     = arg.declaration.name.inferredType
		funcSig.requiredArgumentsOut[i] = arg.isRequired
	end

	table.insert(state.allTypeInfos, funcSig)
	return funcSig
end

do
	local function getTypeInfoForListOrCompoundType(state, typeInfos, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfos) do
			if typeInfoCached.tag == tag and areArraysEqual(typeInfos, typeInfoCached) then
				return typeInfoCached
			end
		end

		local typeInfo = newTypeInfo(schematicForTypeInfo)
		copyToArray(typeInfos, typeInfo)
		table.insert(state.allTypeInfos, typeInfo)

		return typeInfo
	end

	function _G.getTypeInfoForList(state, typeInfos)
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(typeTags.TypeInfoList), TypeInfoList)
	end

	-- Note: typeInfos is expected to be sorted by type ID.
	function _G.getTypeInfoForCompoundType(state, typeInfos)
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(typeTags.TypeInfoCompound), TypeInfoCompound)
	end
end

do
	local function getTypeInfoForArrayOrVararg(state, itemType, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfos) do
			if typeInfoCached.tag == tag and itemType == typeInfoCached.itemType then
				return typeInfoCached
			end
		end

		local typeInfo    = newTypeInfo(schematicForTypeInfo)
		typeInfo.itemType = itemType
		table.insert(state.allTypeInfos, typeInfo)

		return typeInfo
	end

	function _G.getTypeInfoForArray(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(typeTags.TypeInfoArray), TypeInfoArray)
	end

	function _G.getTypeInfoForVararg(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(typeTags.TypeInfoVararg), TypeInfoVararg)
	end
end

function _G.getTypeInfoForNamespace(state, scope)
	!ASSERT `scope`

	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoNamespace) and scope == typeInfoCached.scope then
			return typeInfoCached
		end
	end

	local namespace = newTypeInfo(TypeInfoNamespace)
	namespace.scope = scope
	table.insert(state.allTypeInfos, namespace)

	return namespace
end



-- Note: The expression must already be inferred!
function _G.getTypeRepresentedByExpression(expr)
	!ASSERT `expr.inferredType`

	if expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		return typeNode.representedType
	elseif expr.nodeType == !(nodeTypes.AstStruct) then
		local struct = expr
		return struct.representedType
	elseif expr.nodeType == !(nodeTypes.AstEnum) then
		local enum = expr
		return enum.representedType
	elseif expr.nodeType == !(nodeTypes.AstTypeOf) then
		local typeOf = expr
		return typeOf.representedType
	elseif expr.nodeType == !(nodeTypes.AstLookup) then -- Not sure if this is needed. @Cleanup
		local lookup = expr
		return lookup.representedType -- May be nil.

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		return
			cast.inferredType.tag == !(typeTags.TypeInfoType)
			and getTypeRepresentedByExpression(cast.expression)
			or  nil

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		return ident.declaration.valueTypeInfo -- May be nil.

	elseif expr.inferredType.tag == !(typeTags.TypeInfoType) then
		errorUnhandledNodeType(state, expr)
	else
		return nil
	end
end



-- scope, childClosestToScope = getClosestScope( node )
function _G.getClosestScope(node)
	-- @Incomplete: Treat global declarations differently and depricate
	-- getClosestScopeForDeclaration() (or simply change the parent of
	-- globals to the actual globalScope, though that has problems too).
	return astFindParent(node,
		!outputCommaSeparatedValues(unpack(scopeNodeTypes))
	)
end

-- Since the physical parent of global declarations actually is a file scope
-- we have to treat these declarations differently sometimes. This function
-- returns the correct scope for global declarations.
function _G.getClosestScopeForDeclaration(state, decl)
	-- do return getClosestScope(decl) end
	if decl.isGlobalOrExported then
		local fileScope = astFindParent(decl, !(nodeTypes.AstFileScope))
		if fileScope and not fileScope.isModule then  return state.globalScope  end
	end
	return (getClosestScope(decl))
end

function _G.isScope           (node)   return SCOPE_SET            [node .nodeType] or false  end
function _G.isScopeDeclarative(scope)  return SCOPE_SET_DECLARATIVE[scope.nodeType] or false  end
function _G.isScopeImperative (scope)  return SCOPE_SET_IMPERATIVE [scope.nodeType] or false  end



-- declaration, fromUsing = findDeclaration( state, startNode, name [, declarationToIgnore ] )
function _G.findDeclaration(state, startNode, name, declToIgnore)
	local scope = isScope(startNode) and startNode or getClosestScope(startNode)

	while scope do
		for _, decl in ipairs(scope.declarations) do
			if decl ~= declToIgnore and decl.name.name == name and isDeclarationVisibleToNode(decl, startNode) then
				return decl, nil
			end
		end

		-- @Speed: Don't re-check already checked declarations. (Any potential speed-up may be neglectable though. Need to test with a bigger program.)

		for _, import in ipairs(scope.imports) do
			if import.fileScope then
				for _, decl in ipairs(import.fileScope.declarations) do
					if decl ~= declToIgnore and decl.isGlobalOrExported and decl.name.name == name then
						return decl, nil
					end
				end
			end
		end

		for _, using in ipairs(scope.usings) do
			if using.scope then
				for _, decl in ipairs(using.scope.declarations) do
					if
						decl ~= declToIgnore and decl.name.name == name and (
							decl.isConstant or (
								using.variableDeclaration
								and isDeclarationVisibleToNode(using.variableDeclaration, startNode)
							)
						)
					then
						return decl, using
					end
				end
			end
		end

		for _, decl in ipairs(scope.declarationsInTree[name] or EMPTY_TABLE) do
			if decl ~= declToIgnore and isDeclarationVisibleToNode(decl, startNode) then
				return decl, nil
			end
		end

		-- Don't cross any module boundary!
		if scope.nodeType == !(nodeTypes.AstFileScope) and scope.isModule then
			break
		end

		scope = getClosestScope(scope)
	end

	return nil, nil
end

function _G.findDeclarationInScope(state, scope, name, onlyLookInExportsIfScopeIsModule)
	!ASSERT `type(onlyLookInExportsIfScopeIsModule) == "boolean"`

	if onlyLookInExportsIfScopeIsModule and scope.nodeType == !(nodeTypes.AstFileScope) and scope.isModule then
		for _, decl in ipairs(scope.declarations) do
			if decl.isGlobalOrExported and decl.name.name == name then  return decl  end
		end
	else
		for _, decl in ipairs(scope.declarations) do
			if decl.name.name == name then  return decl  end
		end
	end

	return nil
end

function _G.findMemberDeclaration(state, scope, name)
	for _, decl in ipairs(scope.declarations) do
		if not decl.isConstant and decl.name.name == name then  return decl  end
	end
	return nil
end

function _G.isDeclarationVisibleToNode(decl, node)
	if decl.isGlobalOrExported then  return true  end

	local nodeScope, nodeScopeChild = getClosestScope(node)
	local canSeeImperativeVariables = not decl.isConstant -- It doesn't matter if this is true and we're in a declarative scope because we check that in the loop below.

	while true do
		if not indexOf(nodeScope.declarations, decl) then
			-- void  (Keep looking through parent scopes and update canSeeImperativeVariables as we go.)

		elseif decl.isConstant or isScopeDeclarative(nodeScope) then
			return true

		elseif not canSeeImperativeVariables then
			return false

		elseif isAny(nodeScope.nodeType, !(nodeTypes.AstFor),!(nodeTypes.AstLambda)) then -- These are really a combination of declarative and imperative scopes.
			return true

		elseif nodeScope.nodeType == !(nodeTypes.AstBlock) then
			local block = nodeScope

			-- Note: If the node is inside the initial assignment then we need to treat the declaration
			-- and the assignment as if they were the same statement. Otherwise the assignment will be
			-- able to see it's own declarations, which is illegal!
			local declScope, declScopeChild = getClosestScope(decl.assignment or decl)

			if declScope == block then
				local imperativeIndexForDecl = indexOf(block, declScopeChild) or errorInternal()
				local imperativeIndexForNode = indexOf(block, nodeScopeChild) or errorInternal()

				return (imperativeIndexForDecl < imperativeIndexForNode)

			else
				-- The declaration is probably from a using. The only things you can use right
				-- now are structs and enums, both being declarative scopes. 2020-01-03
				assert(isScopeDeclarative(declScope))
				return true
			end

		else
			errorUnhandledNodeType(state, nodeScope)
		end

		if canSeeImperativeVariables and nodeScope.nodeType == !(nodeTypes.AstLambda) then
			-- Lambdas act as the only boundary between imperative and declarative
			-- scopes right now. Maybe this will change in the future? 2019-12-07
			canSeeImperativeVariables = false
		end

		nodeScope, nodeScopeChild = getClosestScope(nodeScope)
		if not nodeScope then  return false  end -- This shouldn't happen I don't think, unless decl and node is not part of the same tree.
	end
end

-- printDeclarationChain( [ file=io.stdout, ] state, declaration, typeName )
function _G.printDeclarationChain(file, state, decl, typeName)
	if type(file) ~= "userdata" then  return printDeclarationChain(io.stdout, file, state, decl)  end

	!local MAX_CHAIN_LENGTH = 10

	for _ = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(file, state, decl.name, "Info", "...here is '%s' declared.", typeName)

		local placeDeclared = decl.name.placeDeclared -- @Cleanup: Can we use decl.name.declaration instead here?
		if not placeDeclared then  break  end

		decl = nil

		if placeDeclared.nodeType == !(nodeTypes.AstDeclaration) then
			local declCurrent = placeDeclared
			local valueNode   = declCurrent.assignment and declCurrent.assignment.values[declCurrent.assignmentIndex]

			if valueNode then
				while valueNode.replacing do
					valueNode = valueNode.replacing -- Caused by simplifications of constants.
				end

				if valueNode.nodeType == !(nodeTypes.AstIdentifier) then
					local ident = valueNode
					typeName    = ident.name
					decl        = ident.declaration or findDeclaration(state, ident, typeName, declCurrent)
				end
			end
		end

		if not decl then  break  end
	end
end



function _G.typeError(state, node, s, ...)
	return nodeError(state, node, "Typer", s, ...)
end

-- typeMessage( [ outputFile=io.stdout, ] compilationState, node, label, formatString, ... )
function _G.typeMessage(file, state, node, label, s, ...)
	if type(file) ~= "userdata" then  return typeMessage(io.stdout, file, state, node, label, s, ...)  end
	return nodeMessage(file, state, node, label, "Typer", s, ...)
end



function _G.getFriendlyTypeInfoName(typeInfo)
	local name = ""

	if typeInfo.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		name             = structInfo.name -- @Incomplete: Include parameters for parameterized structs.

	elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo = typeInfo
		name           = enumInfo.name

	elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
		local funcSig      = typeInfo
		local typeTextsIn  = {}
		local typeTextsOut = {}

		for i, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			if i > 1 then
				table.insert(typeTextsIn, ",")
			end
			table.insert(typeTextsIn, getFriendlyTypeInfoName(argTypeInfo))
			if not funcSig.requiredArgumentsIn[i] then
				table.insert(typeTextsIn, "?")
			end
		end

		for i, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			typeTextsOut[i] = getFriendlyTypeInfoName(argTypeInfo)
		end

		name = typeTextsOut[1]
			and F("function(%s)->(%s)", table.concat(typeTextsIn), table.concat(typeTextsOut, ","))
			or  F("function(%s)->void", table.concat(typeTextsIn))

	elseif typeInfo.tag == !(typeTags.TypeInfoCompound) then
		local compound  = typeInfo
		local typeTexts = {}

		for i, compoundItem in ipairs(compound) do
			typeTexts[i] = getFriendlyTypeInfoName(compoundItem)
		end

		name = table.concat(typeTexts, "|")

	elseif typeInfo.tag == !(typeTags.TypeInfoArray) then
		local arraySig = typeInfo
		name           = "array("..getFriendlyTypeInfoName(arraySig.itemType)..")"

	elseif typeInfo.tag == !(typeTags.TypeInfoVararg) then
		local varargSig = typeInfo
		name            = "..."..getFriendlyTypeInfoName(varargSig.itemType)
	end

	if name == "" then
		name = TYPE_TAG_NAMES[typeInfo.tag] or errorInternal("%d", typeInfo.tag)
	end

	-- !(if DEBUG then)  name = name.."@"..typeInfo.id  !(end)

	return name
end



local nodeInferrers = {}

!(
-- DEPEND_AND_RETURN( dependentCode, dependType, dependOnCode [, extraDataCode, valueToReturnCode ] )
local function DEPEND_AND_RETURN(dependentCode, dependType, dependOnCode, extraDataCode, valueToReturnCode)
	__LUA("addDependency(state, ",dependentCode,", ",toLua(dependType),", ",dependOnCode)
	if extraDataCode then
		__LUA(", ",extraDataCode)
	end
	__LUA(") ; return")
	if valueToReturnCode then
		__LUA(" ", valueToReturnCode)
	end
end

local nodeNames = {}

local function NODE_INFERRER(funcHeaderCode)
	local replacements

	funcHeaderCode, replacements = funcHeaderCode:gsub("function +nodeInferrers%.(Ast%w+)", function(nodeName)
		if nodeNames[nodeName] then
			error("Duplicate node inferrer: "..nodeName)
		end
		nodeNames[nodeName] = true

		local nodeType = nodeTypes[nodeName] or error(nodeName)
		return "nodeInferrers[--[["..nodeName.."]]"..nodeType.."] = function"
	end)

	assert(replacements == 1, funcHeaderCode)

	__LUA(funcHeaderCode)
end
)

function _G.isPartOfAnyDeclaration(identOrVararg)
	local parent = identOrVararg.parent

	if parent.nodeType == !(nodeTypes.AstDeclaration) then
		local decl = parent
		return identOrVararg == decl.name

	elseif parent.nodeType == !(nodeTypes.AstAssignment) then
		local assignment = parent
		return assignment.forDeclaration and indexOf(assignment.targets, identOrVararg) ~= nil

	else
		return false
	end
end

-- identifierEarly, identifierLate, extraShadowMessageEarly, extraShadowMessageLate = getEarlyAndLateForRedeclarationError( state, identifier1, identifier2 )
local function getEarlyAndLateForRedeclarationError(state, identEarly, identLate)
	local extraMessageEarly = ""
	local extraMessageLate  = ""

	-- Globals before locals.
	if identEarly.declaration.isGlobalOrExported ~= identLate.declaration.isGlobalOrExported then
		if identLate.declaration.isGlobalOrExported then
			identEarly, identLate = identLate, identEarly
		end

	-- Constants before variables.
	elseif identEarly.declaration.isConstant ~= identLate.declaration.isConstant then
		if identLate.declaration.isConstant then
			identEarly, identLate = identLate, identEarly
		end

		if isScopeImperative(getClosestScopeForDeclaration(state, identLate.declaration)) then
			extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope, unlike variables.)"
		end

	-- Low depth before high depth.
	-- Early in file before late in file.
	else
		local depthEarly = astGetDepth(identEarly)
		local depthLate  = astGetDepth(identLate)

		if depthLate < depthEarly or (depthLate == depthEarly and identLate.token < identEarly.token) then
			-- @Incomplete: Explicitly handle the identifiers being declared in different files. (May be unnecessary.)
			identEarly, identLate = identLate, identEarly
		end

		if identEarly.declaration.isConstant and isScopeImperative(getClosestScopeForDeclaration(state, identEarly.declaration)) then
			extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope.)"
		end
	end

	return identEarly, identLate, extraMessageEarly, extraMessageLate
end

local function checkRedeclaration(state, ident, decl, isMember, scope)
	decl.checkedRedeclaration = true

	local declExisting = findDeclaration(state, ident, ident.name, decl)
	if not declExisting then  return  end
	!ASSERT `declExisting ~= decl`

	local scopeExisting = getClosestScopeForDeclaration(state, declExisting)

	-- Member.
	if isMember and not decl.isConstant and scope ~= scopeExisting then
		-- void  (Variable members never shadow anything.)

	-- Function overload. (Note: Overloads have to be registered before the identifier DEPEND_AND_RETURN on anything.)
	elseif
		decl            .isConstant
		and declExisting.isConstant
		and decl        .assignment.values[decl        .assignmentIndex].nodeType == !(nodeTypes.AstLambda)
		and declExisting.assignment.values[declExisting.assignmentIndex].nodeType == !(nodeTypes.AstLambda)
	then
		while declExisting.overloadOf and declExisting.overloadOf ~= declExisting do  declExisting = declExisting.overloadOf  end

		if declExisting == decl then
			-- This simplifies finding an overload later.
			declExisting.overloadOf = declExisting
			table.insert(declExisting.overloads, declExisting)

		elseif scope ~= scopeExisting then
			local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, declExisting.name, ident)
			printerr()
			typeMessage(
				io.stderr, state, identLate,
				"Error", "Trying to add a new overload to '%s' which is in another scope. Overloads must currently be declared in the same scope.",
				ident.name
			)
			typeMessage(io.stderr, state, identEarly, "Info", "...here is the previous function.")
			exitFailure()

		elseif declExisting.overloadsLocked then
			printerr()
			typeMessage(
				io.stderr, state, declExisting.name,
				"Error", "Trying to add a new overload to '%s' after it's type has been inferred. Overloads currently has to happen in the same 'parsing cycle'.",
				ident.name
			)
			typeMessage(io.stderr, state, ident, "Info", "...this is the new overload.")
			exitFailure()

		else
			decl.overloadOf = declExisting
			table.insert(declExisting.overloads, decl)

			local lambda         = decl        .assignment.values[decl        .assignmentIndex]
			local lambdaExisting = declExisting.assignment.values[declExisting.assignmentIndex]

			assert(not lambdaExisting.inferredType)

			-- This dependency means lambdaExisting won't get inferred until earliest next cycle
			-- by which time all overloads should have been added (I think). This should work as
			-- the first occurence of a name will make the second occurence wait before the
			-- second has been able to do anything. (This is true even when we remove unordered
			-- from the queue.)
			addDependency(state, lambdaExisting, !(DEPEND_NODE_INFERRED), lambda)
		end

	-- Non-shadow.
	elseif not decl.canShadow then
		local identEarly, identLate, extraMessageEarly, extraMessageLate = getEarlyAndLateForRedeclarationError(state, declExisting.name, ident)
		printerr()
		typeMessage(io.stderr, state, identLate,  "Error", "'%s' has already been declared.%s", ident.name, extraMessageLate)
		typeMessage(io.stderr, state, identEarly, "Info",  "...it was declared here.%s", extraMessageEarly)
		exitFailure()

	-- Shadow in same scope.
	elseif
		scope == scopeExisting
		or (
			-- We do not allow declarations on lambda bodies to shadow the lambda's arguments.
			scope.nodeType                      == !(nodeTypes.AstBlock)
			and getClosestScope(scope).nodeType == !(nodeTypes.AstLambda)
			and getClosestScope(scope)          == scopeExisting
		)
	then
		printerr()
		typeMessage(io.stderr, state, ident,             "Error", "'%s' has already been declared in the same scope (which means name shadowing does not work).", ident.name)
		typeMessage(io.stderr, state, declExisting.name, "Info",  "...it was declared here.")
		exitFailure()

	-- Shadowing something in an outer (or inner?) scope.
	-- @Robustness: Don't allow file-scope variables to be shadows (just like constants)?
	else
		-- void  (Valid shadow.)
	end
end

local function inferIdentifierOrVararg(state, identOrVararg)
	local vararg = identOrVararg.nodeType == !(nodeTypes.AstVararg) and identOrVararg or nil
	local ident  = not vararg                                       and identOrVararg or nil
	local decl   = identOrVararg.declaration

	-- 1. Loose identifier.
	if not isPartOfAnyDeclaration(identOrVararg) then
		if not decl then
			local using
			decl, using = findDeclaration(state, identOrVararg, identOrVararg.name)

			if not decl then
				!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_DECLARATION, `identOrVararg.name`)
			end

			identOrVararg.declaration = decl
			identOrVararg.fromUsing   = using
		end

		-- Overloaded names refer to multiple things, so that's an error!
		-- @Incomplete: Add a way to refer to a specific overload.
		if decl.overloadOf and ident and ident.parent.nodeType ~= !(nodeTypes.AstCall) then
			local declBase = ident.declaration
			while declBase.overloadOf and declBase.overloadOf ~= declBase do  declBase = declBase.overloadOf  end

			if not declBase.name.inferredType then
				-- This is just so we get a better overload list in the error message.
				!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `declBase.name`)
			end

			printerr()
			typeMessage(io.stderr, state, ident, "Error", "'%s' has multiple overloads and we don't know which one this is referring to.", ident.name)
			for i, declOverload in ipairs(declBase.overloads) do
				typeMessage(io.stderr, state, declOverload.name, "Info", "...overload #%d.", i)
			end
			exitFailure()
		end

		local identInDecl = decl.name
		if not identInDecl.inferredType then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `identInDecl`)
		end
		identOrVararg.inferredType = identInDecl.inferredType

		if identOrVararg.fromUsing then
			-- @Cleanup: Move this to simplifyExpressionIfConstant()?
			!ASSERT `ident`
			local lookup        = astNewNode(AstLookup, ident.token, ident.parent)
			lookup.object       = astCopy(ident.fromUsing.expression, lookup.token, lookup)

			local literal       = astNewNode(AstLiteral, lookup.token, lookup)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = ident.name
			lookup.member       = literal

			addUnqueuedChildrenToQueueRecursively(state, lookup)
			replaceQueuedNodeAndUnqueueOldTree(state, ident, lookup)
			-- Stay in the current pipe.

		else
			moveToPipe(state, identOrVararg, !(PIPE_DONE))
			if ident then
				simplifyExpressionIfConstant(state, ident) -- @Check: Are we in the right pipe after simplification?
			end
		end

		return
	end

	!ASSERT `decl`
	!ASSERT("isAny(identOrVararg.parent.nodeType, "..nodeTypes.AstDeclaration..","..nodeTypes.AstAssignment..")")

	-- 2. Assignment target in declaration (which is a copy of the identifier in the declaration).
	if identOrVararg.parent.nodeType == !(nodeTypes.AstAssignment) then
		local identInDecl = decl.name
		if not identInDecl.inferredType then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `identInDecl`)
		end
		identOrVararg.inferredType = identInDecl.inferredType

		moveToPipe(state, identOrVararg, !(PIPE_DONE))
		return
	end

	-- 3. At this point we're defining a declared identifier.

	local scope = getClosestScopeForDeclaration(state, decl)

	if not scope then
		astPrint(identOrVararg)
		printTraceback(io.stderr)
		typeError(state, identOrVararg, "Internal compiler error: Could not find what scope '%s' is in.", identOrVararg.name)
	end

	local isEnumMember = scope.nodeType == !(nodeTypes.AstEnum)
	local isMember     = isEnumMember or scope.nodeType == !(nodeTypes.AstStruct)

	local isLambdaArgOut = (
		not isMember
		and scope.nodeType == !(nodeTypes.AstLambda)
		and scope.argumentsOut ~= nil
		and indexOf(scope.argumentsOut, astFindParent(decl, !(nodeTypes.AstArgument))) ~= nil
	)

	-- Check for redeclaration/shadowing (before we DEPEND_AND_RETURN).
	if not (isLambdaArgOut or vararg or decl.checkedRedeclaration) then
		checkRedeclaration(state, ident, decl, isMember, scope)
	end

	local typeExpr = decl.type
	if typeExpr and not typeExpr.inferredType then
		!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `typeExpr`)
	end

	if isEnumMember then
		local enum = scope
		if not enum.representedType then
			-- AstEnum is the only scope that gets inferred before it's declarations.
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `enum`)
		end
	end

	local assignment = decl.assignment

	if not typeExpr or decl.isConstant then
		!ASSERT `assignment`
		for _, valueExpr in ipairs(assignment.values) do
			if not valueExpr.inferredType then
				!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `valueExpr`)
			end
		end
	end

	--
	-- No more dependencies for this identifier after this point!
	--

	decl.overloadsLocked = true

	-- Check that call signatures aren't too similar. Optional arguments could make several overloads match calls, i.e.:
	--   local func :: () {}
	--   local func :: (n:int=0) {}
	--   func() -- First or second?
	if decl.overloadOf == decl then
		for i = 1, #decl.overloads-1 do
			local decl1         = decl.overloads[i]
			local funcSig1      = decl1.assignment.values[decl1.assignmentIndex].inferredType
			local argTypes1     = funcSig1.argumentTypesIn
			local argRequireds1 = funcSig1.requiredArgumentsIn

			for i = i+1, #decl.overloads do
				local decl2         = decl.overloads[i]
				local funcSig2      = decl2.assignment.values[decl2.assignmentIndex].inferredType
				local argTypes2     = funcSig2.argumentTypesIn
				local argRequireds2 = funcSig2.requiredArgumentsIn

				if funcSig1 == funcSig2 then
					local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
					printerr()
					typeMessage(
						io.stderr, state, identLate,
						"Error", "Call signatures for function overloads for '%s' are identical. (%s)",
						ident.name, getFriendlyTypeInfoName(funcSig1)
					)
					typeMessage(io.stderr, state, identEarly, "Info",  "...here is the other function.")
					exitFailure()
				end

				-- local requiredCount1 = 0
				-- local requiredCount2 = 0

				-- @Incomplete @Robustness: Check that vararg works.
				for argIndex = 1, math.min(#argTypes1, #argTypes2)+1 do
					local argTypeInfo1 = argTypes1[argIndex]
					local argTypeInfo2 = argTypes2[argIndex]
					argTypeInfo1       = argTypeInfo1 and adjustTypeToOne(state, argTypeInfo1)
					argTypeInfo2       = argTypeInfo2 and adjustTypeToOne(state, argTypeInfo2)

					local isRequired1  = argTypeInfo1 ~= nil and argRequireds1[argIndex]
					local isRequired2  = argTypeInfo2 ~= nil and argRequireds2[argIndex]

					-- if isRequired1 then  requiredCount1 = requiredCount1+1  end
					-- if isRequired2 then  requiredCount2 = requiredCount2+1  end

					if not (isRequired1 or isRequired2) then
						local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
						printerr()
						typeMessage(io.stderr, state, identEarly, "Error", "Call signatures for function overloads (%s) are too similar.", ident.name)
						typeMessage(io.stderr, state, identLate,  "Info",  "...here is the other function.")
						exitFailure()
					end

					if not (argTypeInfo1 and argTypeInfo1 == argTypeInfo2) then  break  end
				end

				--[[ This is a bit too restrictive!
				if requiredCount1 == requiredCount2 then
					for argIndex = 1, requiredCount1 do
						local argTypeInfo1 = adjustTypeToOne(state, argTypes1[argIndex])
						local argTypeInfo2 = adjustTypeToOne(state, argTypes2[argIndex])
						if
							isTypeCompatibleWith(argTypeInfo1, argTypeInfo2) or
							isTypeCompatibleWith(argTypeInfo2, argTypeInfo1)
						then
							local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
							printerr()
							typeMessage(
								io.stderr, state, identEarly,
								"Error", "Call signatures for function overloads (%s) are too similar. (Argument #%d, %s vs. %s)",
								ident.name,
								argIndex,
								getFriendlyTypeInfoName(argTypeInfo1),
								getFriendlyTypeInfoName(argTypeInfo2)
							)
							typeMessage(io.stderr, state, identLate, "Info", "...here is the other function.")
							exitFailure()
						end
					end
				end
				--]]
			end
		end
	end

	-- Tell parents that this declaration exists so we can detect more cases of shadowing.
	if not (isLambdaArgOut or decl.canShadow or vararg) then -- Should vararg do this? I think it's not needed.
		local parentScope = scope

		repeat
			local declarationsInTree = parentScope.declarationsInTree[ident.name]

			if not declarationsInTree then
				declarationsInTree = {}
				parentScope.declarationsInTree[ident.name] = declarationsInTree
			end

			table.insert(declarationsInTree, decl)

			if parentScope.nodeType == !(nodeTypes.AstFileScope) and parentScope.isModule then  break  end

			parentScope = getClosestScope(parentScope)
		until not parentScope
	end

	local typeInfo

	-- Specified type.
	if typeExpr then
		typeInfo = getTypeRepresentedByExpression(typeExpr)
		if not typeInfo then
			typeError(state, typeExpr, "This is not a type. (It is %s)", getFriendlyTypeInfoName(typeExpr.inferredType))
		end

	-- Infer type from value.
	else
		!ASSERT `assignment, "Missing both assignment and types from declaration."`
		!ASSERT `not vararg`

		local _, valueTypeInfo = getAssignmentValue(state, ident, assignment.values, decl.assignmentIndex)
		typeInfo               = adjustTypeToOne(state, valueTypeInfo, true)
	end

	assert(typeInfo)
	local typeInfoForDecl = nil

	-- Check if the value is constant.
	if decl.isConstant then
		local valueExpr, valueTypeInfo = getAssignmentValue(state, ident, assignment.values, decl.assignmentIndex)
		typeInfoForDecl = getTypeRepresentedByExpression(valueExpr)

		if isEnumMember then
			-- Note: AstEnum already validated that valueTypeInfo is compatible with the enum.
			local enum     = scope
			local enumInfo = enum.representedType
			typeInfo       = enumInfo -- Kind of a @Hack, but maybe it's fine for enum members!

			if enumInfo.memberTypeInfo.tag == !(typeTags.TypeInfoType) then
				-- This means you can for example say: local myVar:MyEnum.MY_TYPE
				assert(typeInfoForDecl)
			end
		end

		if typeInfo.tag == !(typeTags.TypeInfoType) then
			if not typeInfoForDecl then
				astPrint(valueExpr)
				printTraceback(io.stderr)
				typeError(state, valueExpr, "Internal compiler error: Missing what type this constant expression represents.")
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then -- @Robustness: Actually detect whether we have a type enum and include it here above.
			-- void  (For now we may or may not have a type enum and typeInfoForDecl.)

		else
			assert(not typeInfoForDecl)
		end

		-- @Robustness: Here we set the name of structs and enums. Is this a good place to do that?
		if not typeInfoForDecl then
			-- void

		elseif typeInfoForDecl.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfoForDecl
			if structInfo.name == "" then -- Is this detection ok? Need testing or another solution.
				structInfo.name = ident.name
			end

		elseif typeInfoForDecl.tag == !(typeTags.TypeInfoEnum) then
			local enumInfo = typeInfoForDecl
			if enumInfo.name == "" then -- Is this detection ok? Need testing or another solution.
				enumInfo.name = ident.name
			end
		end
	end

	if vararg then
		typeInfo = getTypeInfoForVararg(state, typeInfo)
	end

	identOrVararg.inferredType = typeInfo
	decl.valueTypeInfo         = typeInfoForDecl -- May be nil.  @Cleanup: Move this and relevant code to AstDeclaration?

	!if DEBUG then
		if debug_onlyInferTypes then
			io.stdout:write("DEFINE ", identOrVararg.name ,":", getFriendlyTypeInfoName(typeInfo))
			if decl.isConstant then  io.stdout:write(" (CONST)")  end
			if typeInfoForDecl then  io.stdout:write(" (VALUE ", getFriendlyTypeInfoName(typeInfoForDecl), ")")  end
			io.stdout:write(" IN ")
			if decl.name.placeDeclared ~= getClosestScopeForDeclaration(state, decl) then
				io.stdout:write(AST_NODE_TYPE_NAMES[decl.name.placeDeclared.nodeType], " > ")
			end
			astPrint(getClosestScopeForDeclaration(state, decl))
		end
	!end

	moveToPipe(state, identOrVararg, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstIdentifier(state, ident)`
	inferIdentifierOrVararg(state, ident)
end
!NODE_INFERRER `function nodeInferrers.AstVararg(state, vararg)`
	inferIdentifierOrVararg(state, vararg)
end

!NODE_INFERRER `function nodeInferrers.AstType(state, typeNode)`
	local decl = nil
	local typeInfo, typeInfoRepresented

	!if DEBUG then
		if typeNode.kind == !(TYPE_KIND_UNSET) then
			astPrintTree(typeNode)
			where(state, typeNode)
			errorInternal()
		end
	!end

	if typeNode.kind == !(TYPE_KIND_SIMPLE_BUILTIN) then
		typeInfoRepresented = getTypeInfoForBuiltinType(state, typeNode.typeName)
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.kind == !(TYPE_KIND_FUNCTION) then
		local lambda = typeNode.functionHeader or errorInternal()

		if not lambda.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `lambda`)
		end
		assert(lambda.inferredType.tag == !(typeTags.TypeInfoFunction))

		local funcSig       = getTypeInfoForLambda(state, lambda)
		typeInfoRepresented = funcSig
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.kind == !(TYPE_KIND_ARRAY) then
		local itemTypeNode = typeNode.arrayItemType or errorInternal()

		if not itemTypeNode.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `itemTypeNode`)
		end

		local itemTypeInfo = getTypeRepresentedByExpression(itemTypeNode)
		if not itemTypeInfo then
			typeError(state, itemTypeNode, "This is not a type. (It is %s)", getFriendlyTypeInfoName(itemTypeNode.inferredType))
		elseif itemTypeInfo.tag == !(typeTags.TypeInfoNone) then
			typeError(state, itemTypeNode, "Arrays cannot contain nil.")
		end

		local arraySig      = getTypeInfoForArray(state, itemTypeInfo)
		typeInfoRepresented = arraySig
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.kind == !(TYPE_KIND_COMPOUND) then
		for _, typeExpr in ipairs(typeNode.components) do
			if not typeExpr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `typeExpr`)
			end
		end

		-- Note: It's ok that these share the same table!
		local typeInfos  = {}        -- Keys are numbers.
		local typeIds    = typeInfos -- Keys are AstNode.
		local duplicates = typeInfos -- Keys are TypeInfo.

		local isFromCompound = {}

		for _, typeExpr in ipairs(typeNode.components) do
			!(
			local ERROR_DUPLICATE_TYPE_CODE = `
				printerr()
				typeMessage(io.stderr, state, typeExpr, "Error", "Duplicate type specified in $siteTitle.")
				if isFromCompound[$typeInfoVar] then
					typeMessage(
						io.stderr, state, duplicates[$typeInfoVar],
						"Info", "...this sub-compound type contains the same type. (%s)",
						getFriendlyTypeInfoName($typeInfoVar)
					)
				else
					typeMessage(
						io.stderr, state, duplicates[$typeInfoVar],
						"Info", "...this is the same type. (%s)",
						getFriendlyTypeInfoName($typeInfoVar)
					)
				end
				exitFailure()
			`
			local function ERROR_DUPLICATE_TYPE(siteTitle, typeInfoVar)
				local lua = ERROR_DUPLICATE_TYPE_CODE:gsub("$(%w+)", {
					siteTitle   = siteTitle,
					typeInfoVar = typeInfoVar,
				})
				__LUA(lua)
			end
			)

			local componentType = getTypeRepresentedByExpression(typeExpr)
			if not componentType then
				typeError(state, typeExpr, "This is not a type. (It is %s)", getFriendlyTypeInfoName(typeExpr.inferredType))
			end

			if componentType.tag == !(typeTags.TypeInfoCompound) then
				-- Unpack the sub-compound type so we don't end up with compound types of other compound types.
				local compound = componentType

				for _, compoundItem in ipairs(compound) do
					if duplicates[compoundItem] then
						!ERROR_DUPLICATE_TYPE("compound type (through sub-compound type)", `compoundItem`)
					end

					table.insert(typeInfos, compoundItem)
					typeIds[typeExpr]            = compoundItem.id
					duplicates[compoundItem]     = typeExpr -- @UX: Should we ignore duplicate nil types?
					isFromCompound[compoundItem] = true
				end

			else
				if duplicates[componentType] then
					!ERROR_DUPLICATE_TYPE("compound type", `componentType`)
				elseif componentType.tag == !(typeTags.TypeInfoAny) then
					typeError(state, typeExpr, "Cannot include 'any' in compound types.")
				end

				table.insert(typeInfos, componentType)
				typeIds[typeExpr]         = componentType.id
				duplicates[componentType] = typeExpr -- @UX: Should we ignore duplicate nil types?
			end
		end

		table.sort(typeNode.components, function(a, b)  return typeIds[a] < typeIds[b]  end) -- @Cleanup @Speed: This is probably unnecessary.
		table.sort(typeInfos,           function(a, b)  return a.id       < b.id        end)

		typeInfoRepresented = getTypeInfoForCompoundType(state, typeInfos)
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	else
		assert(typeNode.typeName ~= "")

		decl = findDeclaration(state, typeNode, typeNode.typeName)
		if not decl then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_DECLARATION, `typeNode.typeName`)
		elseif not decl.name.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `decl.name`)
		end

		typeInfoRepresented = decl.valueTypeInfo -- May be nil, in which case we'll get an error here below.
		typeInfo            = decl.name.inferredType or errorInternal()

		-- Type enum members can be used as types, as a special case.
		if decl.isConstant and typeInfo.tag == !(typeTags.TypeInfoEnum) then
			local enum     = typeInfo.astNode     or errorInternal()
			local enumInfo = enum.representedType or errorInternal()

			if enumInfo.memberTypeInfo.tag == !(typeTags.TypeInfoType) then
				typeInfo = getTypeInfoForBuiltinType(state, "type")
			end
		end

		if typeInfo.tag ~= !(typeTags.TypeInfoType) then
			printerr()
			typeMessage(io.stderr, state, typeNode, "Error", "'%s' is not a type. (It is %s)", typeNode.typeName, getFriendlyTypeInfoName(typeInfo))
			printDeclarationChain(io.stderr, state, decl, typeNode.typeName)
			exitFailure()
		end

		for _, expr in ipairs(typeNode.arguments or EMPTY_TABLE) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		-- @Incomplete: Proper error messages here:

		if SIMPLE_TYPE_TAG[typeInfo.tag] then
			assert(not typeNode.arguments) -- This should have been caught during parsing, e.g. int(a,b).

		elseif typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			if structInfo.arguments[1] then
				errorInternal("@Incomplete: Struct arguments.")
			elseif typeNode.arguments then
				typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeNode.arguments[1]), "Parameters for structs are not supported yet.")
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			assert(not typeNode.arguments)

		elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
			assert(not typeNode.arguments) -- This should not be possible I think. The node should have been parsed as an AstCall - not an AstType without functionHeader... right? I may be wrong.

		else
			errorInternal("Incomplete: Handle type tag '%s'.", TYPE_TAG_NAMES[typeInfo.tag])
		end
	end

	typeNode.representedType = typeInfoRepresented or errorInternal()
	typeNode.inferredType    = typeInfo            or errorInternal()
	typeNode.declaration     = decl

	moveToPipe(state, typeNode, !(PIPE_DONE))
end

local function getArgumentNodeForError(callOrReturnNode, valueIndex, valueExpr)
	return
		callOrReturnNode.nodeType == !(nodeTypes.AstCall) and callOrReturnNode.isMethod and valueIndex == 1
		and valueExpr
		or  astGetExpressionVisuallyFurthestToTheLeft(valueExpr)
end

-- doesMatch, compatibilityScore = checkIfValuesMatchArgumentTypes( state, callOrReturnNode, values, valueTypes, typeInfos [, softCheck=false, calleeDeclarationForCurrentOverload ] )
local function checkIfValuesMatchArgumentTypes(state, callOrReturnNode, values, valueTypes, typeInfos, softCheck, calleeDecl)
	--[[
		Situations:

		two :: (x:int,   y:int) -> (x:int    y:int) -- accept in/out 2
		var :: (x:int, ...:int) -> (x:int, ...:int) -- accept in/out 1+vararg
		return  x, (two())  --- request 2
		func(   x, (two())  )-- request 2
		return  x, (var())  --- request 2
		func(   x, (var())  )-- request 2
		return  x, (...)    --- request 2  (Note: The vararg can result in nil.)
		func(   x, (...)    )-- request 2  (Note: The vararg can result in nil.)
		return  x, two()    --- request 1+list(2)
		func(   x, two()    )-- request 1+list(2)
		return  x, ...      --- request 1+vararg
		func(   x, ...      )-- request 1+vararg
		return  x, var()    --- request 1+list(1+vararg)
		func(   x, var()    )-- request 1+list(1+vararg)
	]]

	-- Get requested count.
	local valueExprLast = getLast(values)
	local valueCount    = #values
	local requestedMin  = valueCount
	local requestedMax  = valueCount
	local slotsToCheck  = valueCount -- Assuming the requested count is accepted.

	if valueExprLast then
		if valueExprLast.nodeType == !(nodeTypes.AstCall) then
			local valueCall = valueExprLast

			if not valueCall.surroundedByParenthesis then
				local calleeTypeInfo = valueCall.callee.inferredType

				if calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
					local listSig  = calleeTypeInfo
					calleeTypeInfo = listSig[1] or errorInternal() -- The error should have happened when inferring AstCall.
				end

				assert(calleeTypeInfo.tag == !(typeTags.TypeInfoFunction))

				local argTypesOut = calleeTypeInfo.argumentTypesOut
				local argCount    = #argTypesOut

				if argCount == 0 then
					if softCheck then  return false, 0  end
					typeError(state, valueCall, "Function call returns nothing. (Expected at least one value.)")
				end

				local returnsVararg = argCount > 0 and argTypesOut[argCount].tag == !(typeTags.TypeInfoVararg)
				local returnsMin    = returnsVararg and argCount-1 or argCount
				local returnsMax    = returnsVararg and math.huge  or argCount

				requestedMin = valueCount-1+returnsMin
				requestedMax = valueCount-1+returnsMax
				slotsToCheck = valueCount-1+argCount
			end

		elseif valueExprLast.nodeType == !(nodeTypes.AstVararg) then
			local valueVararg = valueExprLast

			if not valueVararg.surroundedByParenthesis then
				requestedMin = valueCount - 1
				requestedMax = math.huge
				slotsToCheck = valueCount
			end
		end
	end

	-- Get accepted count.
	local typeInfoCount   = #typeInfos
	local acceptingVararg = typeInfoCount > 0 and typeInfos[typeInfoCount].tag == !(typeTags.TypeInfoVararg)
	local acceptedMin     = acceptingVararg and typeInfoCount-1 or typeInfoCount
	local acceptedMax     = acceptingVararg and math.huge       or typeInfoCount

	-- Consider optional arguments for calls.
	-- @Robustness @Cleanup: We probably must have argument optionality be part of function types - not just the arguments types.
	-- @Robustness: Disallow this: local take2 :: (req:int, opt:int=0) {} ; local get1 :: () -> int {} ; take2(get1())  -- :DisallowListAsLastValueToFunctionWithOptionalArguments
	if callOrReturnNode.nodeType == !(nodeTypes.AstCall) and callOrReturnNode.callee.nodeType == !(nodeTypes.AstIdentifier) then
		calleeDecl = (calleeDecl or callOrReturnNode.callee.declaration)

		if calleeDecl.isConstant then
			local assignment = calleeDecl.assignment
			local lambda     = assignment.values[calleeDecl.assignmentIndex] or errorInternal()

			assert(lambda.nodeType == !(nodeTypes.AstLambda))
			assert(lambda.inferredType)

			if not areArraysEqual(typeInfos, lambda.inferredType.argumentTypesIn) then
				-- We should only get here if checking overloads.
				if softCheck then  return false, 0  end
				assert(false)
			end

			for i = acceptedMin, 1, -1 do
				local arg = lambda.argumentsIn[i]
				if arg.isRequired then
					break
				else
					acceptedMin = acceptedMin-1
				end
			end
		end
	end

	-- io.stdout:write(F("requested %.0f-%.0f, accepted %.0f-%.0f  ", requestedMin, requestedMax, acceptedMin, acceptedMax)) ; astPrint(callOrReturnNode)

	-- Too few values.
	-- @UX: Better error message if the last value is a call (without parenthesis).
	if requestedMin < acceptedMin then
		if softCheck then  return false, 0  end

		local exprForError = values[1] and getArgumentNodeForError(callOrReturnNode, 1, values[1]) or callOrReturnNode
		local prefix       = requestedMax+acceptedMax == math.huge and "Incorrect number of" or "Missing"
		local thingsStr    = callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "arguments" or "values to return"
		local gotStr       = (requestedMax ~= math.huge and F("%d", requestedMin)) or (requestedMin == 0 and "variable amount") or F("%d + variable amount", requestedMin)
		typeError(state, exprForError, "%s %s. (Wanted %d, got %s)", prefix, thingsStr, acceptedMin, gotStr)

	-- Too many values.
	-- @UX: Better error message if the last value is a call (without parenthesis).
	elseif requestedMax > acceptedMax then
		!ASSERT `not acceptingVararg`

		if softCheck then  return false, 0  end

		local valueIndex          = math.min(acceptedMax+1, valueCount)
		local firstExtraValueExpr = values[valueIndex]
		local exprForError        = getArgumentNodeForError(callOrReturnNode, valueIndex, firstExtraValueExpr)
		local prefix              = requestedMax+acceptedMax == math.huge and "Incorrect number of" or "Too many"
		local thingsStr           = callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "arguments" or "values to return"
		local gotStr              = requestedMax == math.huge and "variable amount" or F("%d", requestedMax)

		typeError(state, exprForError, "%s %s. (Wanted %d, got %s)", prefix, thingsStr, acceptedMax, gotStr) -- Note: acceptedMax is never infinite here.
	end

	local compatibilityScoreSum = 0

	for slot = 1, slotsToCheck do
		local valueIndex      = math.min(slot, valueCount)
		local valueExpr       = values[valueIndex]
		local valueTypeInfo   = valueTypes[valueIndex]

		local typeInfoIndex   = math.min(slot, typeInfoCount)
		local typeInfoToMatch = typeInfos[typeInfoIndex]

		local isCompatible, compatibilityScore

		-- Function call (0..inf values).
		if valueTypeInfo.tag == !(typeTags.TypeInfoList) then
			local listSig         = valueTypeInfo
			local callOutArgIndex = slot-valueIndex+1
			valueTypeInfo         = listSig[callOutArgIndex]

			if not valueTypeInfo then
				if softCheck then  return false, 0  end
				typeError(state, valueExpr, "Function call returns nothing. (Expected at least one value.)") -- Note: "Nothing" is not the same as vararg of zero length.
			end

			local adjustVarargToIncludeNil   = not (valueTypeInfo.tag == !(typeTags.TypeInfoVararg) and typeInfoToMatch.tag == !(typeTags.TypeInfoVararg))
			local valueTypeInfoAdjusted      = adjustTypeToOne(state, valueTypeInfo, adjustVarargToIncludeNil) -- We have a value with a type.
			local typeInfoToMatchAdjusted    = adjustTypeToOne(state, typeInfoToMatch) -- We want a specific type.
			isCompatible, compatibilityScore = isTypeCompatibleWith(valueTypeInfoAdjusted, typeInfoToMatchAdjusted)

			if not isCompatible then
				if softCheck then  return false, 0  end
				-- @UX: Tell the name of the call/return argument. (For calls, probably only possible for constants, and maybe not all. Not sure! Returns just depend on the output arguments being named.)
				-- @UX: Tell the name of the value call's argument. (Probably only possible for constants, and maybe not all. Not sure!)
				typeError(
					state, valueExpr,
					"Type mismatch for %s #%d (return value #%d from call). (Wanted %s, got %s)",
					callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "argument" or "return value",
					slot,
					callOutArgIndex,
					getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
					getFriendlyTypeInfoName(valueTypeInfoAdjusted)
				)
			end

		-- Vararg (0..inf values) OR other (1 value).
		else
			local adjustVarargToIncludeNil   = not (valueTypeInfo.tag == !(typeTags.TypeInfoVararg) and typeInfoToMatch.tag == !(typeTags.TypeInfoVararg))
			local valueTypeInfoAdjusted      = adjustTypeToOne(state, valueTypeInfo, adjustVarargToIncludeNil) -- We have a value with a type.
			local typeInfoToMatchAdjusted    = adjustTypeToOne(state, typeInfoToMatch) -- We want a specific type.
			isCompatible, compatibilityScore = isTypeCompatibleWith(valueTypeInfoAdjusted, typeInfoToMatchAdjusted)

			if not isCompatible then
				if softCheck then  return false, 0  end
				typeError(
					state, getArgumentNodeForError(callOrReturnNode, valueIndex, valueExpr),
					"Type mismatch for %s #%d. (Wanted %s, got %s)",
					callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "argument" or "return value",
					slot,
					getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
					getFriendlyTypeInfoName(valueTypeInfoAdjusted)
				)
			end
		end

		compatibilityScoreSum = compatibilityScoreSum + compatibilityScore
	end

	-- @Incomplete: Decrease compatibilityScoreSum as optional arguments are left out?

	return true, compatibilityScoreSum
end

!NODE_INFERRER `function nodeInferrers.AstCall(state, call)`
	local callee         = call.callee
	local calleeTypeInfo = callee.inferredType

	if not calleeTypeInfo then
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `callee`)
	end

	if callee.nodeType == !(nodeTypes.AstIdentifier) and callee.declaration.overloadOf then
		-- Wait for all overloads to get inferred.
		local ident    = callee
		local declBase = ident.declaration

		while declBase.overloadOf ~= declBase do  declBase = declBase.overloadOf  end

		calleeTypeInfo = declBase.name.inferredType
		if not calleeTypeInfo then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `declBase.name`)
		end
	end

	for _, arg in ipairs(call.arguments) do
		if not arg.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `arg`)
		end
	end

	if calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then -- @Incomplete: Parameterized structs.
		-- void

	elseif calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig  = calleeTypeInfo
		calleeTypeInfo = listSig[1]

		if not calleeTypeInfo then
			typeError(state, call, "Trying to call void.")
		elseif calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then
			-- void
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
		end

	else
		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			local ident = callee
			typeError(state, ident, "'%s' is not a function. (It is %s)", ident.name, getFriendlyTypeInfoName(ident.inferredType))
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
		end
	end

	!ASSERT("calleeTypeInfo.tag == "..typeTags.TypeInfoFunction) -- @Incomplete: Handle parameterized structs.

	!if DEBUG then
		if call.isMethod and callee.nodeType ~= !(nodeTypes.AstLookup) then
			astPrint(callee)
			where(state, call)
			errorInternal()
		end
	!end

	local realArguments     = (call.isMethod and {call, unpack(call.arguments)} or call.arguments)
	local realArgumentTypes = {}

	if call.isMethod then
		local typeInfo = callee.object.inferredType
		realArgumentTypes[1] = adjustTypeToOne(state, typeInfo) -- Is adjustTypeToOne necessary? @Cleanup
	end
	for _, arg in ipairs(call.arguments) do
		table.insert(realArgumentTypes, arg.inferredType)
	end

	-- Handle overloads.
	if callee.nodeType == !(nodeTypes.AstIdentifier) and callee.declaration.overloadOf then
		local ident             = callee
		local declBase          = ident.declaration
		local matchingOverloads = {}

		while declBase.overloadOf ~= declBase do  declBase = declBase.overloadOf  end

		for _, declOverload in ipairs(declBase.overloads) do
			local calleeTypeInfoOverload = declOverload.name.inferredType

			!ASSERT("calleeTypeInfoOverload.tag == "..typeTags.TypeInfoFunction)

			local doesMatch, compatibilityScore = checkIfValuesMatchArgumentTypes(
				state, call, realArguments, realArgumentTypes, calleeTypeInfoOverload.argumentTypesIn, true, declOverload
			)
			if doesMatch then
				table.insert(matchingOverloads, {declaration=declOverload, score=compatibilityScore})
			end
		end

		if not matchingOverloads[1] then
			printerr()
			typeMessage(io.stderr, state, ident, "Error", "Did not find any matching overload to call.")
			for i, declOverload in ipairs(declBase.overloads) do
				typeMessage(io.stderr, state, declOverload.name, "Info", "...overload #%d.", i)
			end
			exitFailure()
		end

		table.sort(matchingOverloads, function(a, b)
			return a.score > b.score
		end)

		local highscore = matchingOverloads[1].score

		if matchingOverloads[2] and matchingOverloads[2].score == highscore then
			printerr()
			typeMessage(io.stderr, state, ident, "Error", "There are several matching overloads.")
			for i, overloadData in ipairs(matchingOverloads) do
				if overloadData.score < highscore then  break  end
				typeMessage(io.stderr, state, overloadData.declaration.name, "Info", "...overload #%d.", i)
			end
			exitFailure()
		end

		local decl     = matchingOverloads[1].declaration
		calleeTypeInfo = decl.name.inferredType

		-- Update the callee to represent the correct overload.
		-- @Robustness: Is this safe? I don't think anything except the calls itself depends directly on, and uses values from, any callee.
		ident.declaration  = decl
		ident.inferredType = calleeTypeInfo

	else
		checkIfValuesMatchArgumentTypes(state, call, realArguments, realArgumentTypes, calleeTypeInfo.argumentTypesIn)
	end

	call.inferredType              = getTypeInfoForList(state, calleeTypeInfo.argumentTypesOut)
	call.couldBeTypeWithParameters = false

	moveToPipe(state, call, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstReturn(state, returnNode)`
	for _, valueExpr in ipairs(returnNode.values) do
		if not valueExpr.inferredType then
			!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `valueExpr`)
		end
	end

	local scope = getClosestScope(returnNode) or errorInternal()

	while scope.nodeType ~= !(nodeTypes.AstLambda) do
		if not isScopeImperative(scope) then -- This may eventually be AstFileScope, at most.
			-- I think this is an internal compiler error, actually. Parsing must have goofed up or something.
			typeError(state, scope, "Return statement is not in a function.")
		end

		scope = getClosestScope(scope) or errorInternal()
	end

	local lambda = scope

	if not lambda.inferredType then
		!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `lambda`)
	end

	local typeInfos = {}
	for i, valueExpr in ipairs(returnNode.values) do
		typeInfos[i] = valueExpr.inferredType
	end

	checkIfValuesMatchArgumentTypes(state, returnNode, returnNode.values, typeInfos, lambda.inferredType.argumentTypesOut)
	moveToPipe(state, returnNode, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstDeclaration(state, decl)`
	if decl.assignment and decl.assignment.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `decl.assignment`)
	end

	local identOrVararg = decl.name
	if not identOrVararg.inferredType then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `identOrVararg`)
	end

	local typeExpr = decl.type

	if typeExpr then
		if not typeExpr.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `typeExpr`)
		end

		local typeInfoRepresented = getTypeRepresentedByExpression(typeExpr)
		if not typeInfoRepresented then
			typeError(state, typeExpr, "This is not a type. (It is %s)", getFriendlyTypeInfoName(typeExpr.inferredType))
		end

		if decl.parent.nodeType == !(nodeTypes.AstArgument) then
			-- void  (Ignore function arguments.)
		elseif typeInfoRepresented.tag ~= !(typeTags.TypeInfoCompound) then
			-- void
		elseif decl.isConstant then
			typeError(
				state, decl.name,
				"Constants cannot be compound types. (Type is %s)",
				getFriendlyTypeInfoName(typeInfoRepresented)
			)
		elseif not decl.assignment then
			typeError(
				state, decl.name,
				"An initial value is required for compound types. (Type is %s)",
				getFriendlyTypeInfoName(typeInfoRepresented)
			)
		end
	end

	-- @Incomplete: decl.notes (if we make them structured, which we should!)

	if decl.assignment then
		local scope              = getClosestScope(decl) or errorInternal()
		local scopeIsDeclarative = isScopeDeclarative(scope)
		local valueExpr

		-- Validate that the assigned value is the same type as the declared name.
		--
		-- (Not needed for vararg as those only exist as arguments and don't have default values.
		-- Also, this doesn't run for enum members as those declarations never have any specified types.)
		--
		if typeExpr and identOrVararg.nodeType ~= !(nodeTypes.AstVararg) then
			local ident = identOrVararg
			valueExpr = getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, ident.inferredType)
		end

		if scopeIsDeclarative or decl.isConstant then
			valueExpr = valueExpr or getAssignmentValue(state, identOrVararg, decl.assignment.values, decl.assignmentIndex)

			if isExpressionConstant(state, valueExpr) then
				-- void

			elseif valueExpr.nodeType == !(nodeTypes.AstForeign) then
				-- void
				-- We usually treat foreign values as runtime values. The only exception is when
				-- it's placed directly on a declaration. (Can this be solved in a better way?)
				-- :SpecialForeignValueRules

			elseif astFindInTree(valueExpr, !(nodeTypes.AstForeign)) then
				local foreign = astFindInTree(valueExpr, !(nodeTypes.AstForeign))
				typeError(state, foreign, "Cannot evaluate foreign values during compile time.")

			else
				-- @UX: If the expression is/contains a table with a non-constant field, point out which field key or value!
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
					"Value for declared %s '%s' is not a constant expression.%s",
					(decl.isConstant and "constant" or "variable"),
					identOrVararg.name,
					(scopeIsDeclarative and not decl.isConstant and " (All values in declarative scopes must be constant.)" or "")
				)
			end
		end

	elseif identOrVararg.parent.parent.nodeType ~= !(nodeTypes.AstArgument) and not doesTypeHaveAnyDefaultValue(identOrVararg.inferredType) then
		astPrintTree(identOrVararg.parent.parent)
		!ASSERT `not decl.isConstant` -- This should have been detected in inferIdentifierOrVararg() (I think).
		typeError(state, identOrVararg, "Variables in type group '%s' must have a specified initial value.", TYPE_TAG_NAMES[identOrVararg.inferredType.tag])
	end

	if decl.name.inferredType.tag == !(typeTags.TypeInfoNamespace) then
		moveToPipe(state, decl, !(PIPE_DONE))
	else
		moveToPipe(state, decl, !(PIPE_BYTECODE))
	end
end

!!local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = {
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "none",
	[LITERAL_FLOAT]   = "float",
	[LITERAL_STRING]  = "string",
}
_G.!(local )!!BUILTIN_TYPE_TAG_TO_LITERAL_TYPE = {
	[typeTags.TypeInfoBool]   = LITERAL_BOOLEAN,
	[typeTags.TypeInfoInt]    = LITERAL_INTEGER,
	[typeTags.TypeInfoNone]   = LITERAL_NIL,
	[typeTags.TypeInfoFloat]  = LITERAL_FLOAT,
	[typeTags.TypeInfoString] = LITERAL_STRING,
}

!NODE_INFERRER `function nodeInferrers.AstLiteral(state, literal)`
	local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType] or errorUnhandledNodeType(state, literal)

	literal.inferredType = getTypeInfoForBuiltinType(state, typeName)

	moveToNextPipe(state, literal, !(PIPE_BYTECODE))
end

!NODE_INFERRER `function nodeInferrers.AstUnary(state, unary)`
	if not unary.expression.inferredType then
		!DEPEND_AND_RETURN(`unary`, DEPEND_NODE_INFERRED, `unary.expression`)
	end

	local typeInfo = adjustTypeToOne(state, unary.expression.inferredType, true)

	if isAny(unary.operation, "+","-") then
		-- @Incomplete: Allow int|float compound type here (or disallow declarations of that specific compound type).
		if not isAny(typeInfo.tag, !(typeTags.TypeInfoInt),!(typeTags.TypeInfoFloat)) then
			typeError(
				state, unary.expression,
				"Unary numeric operation (%s): Expected a float or int. (Got %s)",
				unary.operation,
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "not" then
		if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
			typeError(
				state, unary.expression,
				"Unary boolean operation (not): Expected a bool. (Got %s)",
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "#" then
		if not isAny(typeInfo.tag, !(typeTags.TypeInfoArray),!(typeTags.TypeInfoTable)) then
			typeError(
				state, unary.expression,
				"Unary length operation (#): Expected an array or a table. (Got %s)",
				getFriendlyTypeInfoName(typeInfo)
			)
		end

		typeInfo = getTypeInfoForBuiltinType(state, "int")

	else
		errorUnhandledNodeType(state, unary)
	end

	unary.inferredType = typeInfo

	--
	-- Inferring complete! Now simplify the expression if it's constant.
	--

	local isConst, literalValue = getLiteralValueFromExpressionIfConstant(state, unary.expression)
	if not isConst then
		moveToPipe(state, unary, !(PIPE_DONE))

	!for _, opArithmetic in ipairs{"+","-"} do
	elseif unary.operation == !(opArithmetic) then
		local literal = astNewNode(AstLiteral, unary.token, unary.parent)

		literal.literalType
			=  typeInfo.tag == !(typeTags.TypeInfoInt)   and !(LITERAL_INTEGER)
			or typeInfo.tag == !(typeTags.TypeInfoFloat) and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = !!(opArithmetic ~= "+" and opArithmetic or "") literalValue
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))
	!end

	elseif unary.operation == "not" then
		local literal        = astNewNode(AstLiteral, unary.token, unary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = not literalValue
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))

	elseif unary.operation == "#" then
		local tableNode = followIdentifiersToConstantValue(unary.expression)
		local length    = 0

		assert(tableNode.nodeType == !(nodeTypes.AstTable))

		if tableNode.inferredType.tag == !(typeTags.TypeInfoArray) then
			for _, tableField in ipairs(tableNode) do
				length = math.max(length, tableField.key.value)
			end

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoTable) then
			errorUnhandledNodeType(state, unary)

		else
			errorInternal()
		end

		local literal        = astNewNode(AstLiteral, unary.token, unary.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = length
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))

	else
		errorUnhandledNodeType(state, unary)
	end

	-- astPrintTree(unary.parent)
end

local function isArrayItemOrTableFieldCheck(state, binary, typeInfoL, typeInfoR)
	-- Detect situations like these: myArray[i]==nil or myTable[k]==nil

	local maybeLookup = binary.left
	local nilExpr     = binary.right

	if nilExpr.inferredType.tag == !(typeTags.TypeInfoNone) then
		-- void
	elseif maybeLookup.inferredType.tag == !(typeTags.TypeInfoNone) then
		nilExpr, maybeLookup = maybeLookup, nilExpr
	else
		return false
	end

	if maybeLookup.nodeType ~= !(nodeTypes.AstLookup) then  return false  end
	if not isAny(maybeLookup.object.inferredType.tag, !(typeTags.TypeInfoArray),!(typeTags.TypeInfoTable)) then  return false  end

	return true
end

local function isCompoundCompare(state, binary, typeInfoL, typeInfoR)
	-- Detect situations like these: local v:int|string = 0 ; if v == ""

	local compound    = typeInfoL
	local otherType   = typeInfoR

	local lIsCompound = (compound.tag  == !(typeTags.TypeInfoCompound))
	local rIsCompound = (otherType.tag == !(typeTags.TypeInfoCompound))

	if lIsCompound and rIsCompound then
		-- The compound types must be the same for a theoretical test here to pass
		-- since both compounds must contain all of the other one's types, but we
		-- should already have checked for that and thus shouldn't be here. So, we
		-- simply say they are incompatible right away.
		return false
	elseif lIsCompound then
		-- void
	elseif rIsCompound then
		compound, otherType = otherType, compound
	else
		return false
	end

	return indexOf(compound, otherType) ~= nil -- We don't use isTypeCompatibleWith() here - the compound must contain exactly otherType!
end

local function isValidEqualityCheck(state, binary, typeInfoL, typeInfoR)
	if typeInfoL     == typeInfoR               then  return true  end
	if typeInfoL.tag == !(typeTags.TypeInfoAny) then  return true  end
	if typeInfoR.tag == !(typeTags.TypeInfoAny) then  return true  end

	if isArrayItemOrTableFieldCheck(state, binary, typeInfoL, typeInfoR) then  return true  end
	if isCompoundCompare           (state, binary, typeInfoL, typeInfoR) then  return true  end

	return false
end

!NODE_INFERRER `function nodeInferrers.AstBinary(state, binary)`
	local typeInfoL = binary.left.inferredType
	local typeInfoR = binary.right.inferredType

	!local TYPE_MISMATCH = `typeError(
		state, binary,
		"Binary operation (%s): Type mismatch for operands. (Left is %s, right is %s)",
		binary.operation,
		getFriendlyTypeInfoName(typeInfoL),
		getFriendlyTypeInfoName(typeInfoR)
	)`

	if not typeInfoL then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.left`)
	end
	if not typeInfoR then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.right`)
	end

	if typeInfoL.tag == !(typeTags.TypeInfoList) and not typeInfoL[1] then
		typeError(state, binary.left, "Function call returns nothing. (Expected at least one value.)")
	end
	if typeInfoR.tag == !(typeTags.TypeInfoList) and not typeInfoR[1] then
		typeError(state, binary.right, "Function call returns nothing. (Expected at least one value.)")
	end

	typeInfoL = adjustTypeToOne(state, typeInfoL, true)
	typeInfoR = adjustTypeToOne(state, typeInfoR, true)

	-- Numeric operation.
	if isAny(binary.operation, "+","-","*","^","%","/","//") then
		if not (isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR)) then
			typeError(
				state, binary.left,
				"Binary numeric operation (%s): Expected operands to be numeric. (Got %s and %s)",
				binary.operation,
				getFriendlyTypeInfoName(typeInfoL),
				getFriendlyTypeInfoName(typeInfoR)
			)
		end

		if binary.operation == "/" then
			typeInfo = getTypeInfoForBuiltinType(state, "float")
		elseif binary.operation == "//" then
			typeInfo = getTypeInfoForBuiltinType(state, "int")
		elseif isAny(!(typeTags.TypeInfoFloat), typeInfoL.tag,typeInfoR.tag) then
			typeInfo = getTypeInfoForBuiltinType(state, "float")
		else
			typeInfo = getTypeInfoForBuiltinType(state, "int")
		end

	-- Comparison.
	elseif isAny(binary.operation, "<",">","<=",">=") then
		if typeInfoL ~= typeInfoR then
			!!(TYPE_MISMATCH)
		elseif not isAny(typeInfoL.tag, !(typeTags.TypeInfoInt),!(typeTags.TypeInfoFloat),!(typeTags.TypeInfoString)) then
			typeError(
				state, binary.left,
				"Binary comparison (%s): Expected a float, int or string. (Got %s)",
				binary.operation,
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		typeInfo = getTypeInfoForBuiltinType(state, "bool")

	-- Equality.
	elseif isAny(binary.operation, "==","~=") then
		if not isValidEqualityCheck(state, binary, typeInfoL, typeInfoR) then
			!!(TYPE_MISMATCH)
		end
		typeInfo = getTypeInfoForBuiltinType(state, "bool")

	-- Boolean operation.
	elseif isAny(binary.operation, "and","or") then
		if typeInfoL ~= typeInfoR then
			!!(TYPE_MISMATCH)
		elseif typeInfoL.tag ~= !(typeTags.TypeInfoBool) then
			typeError(state, binary.left, "Binary boolean operation (%s): Expected a bool. (Got %s)", binary.operation, getFriendlyTypeInfoName(typeInfoL))
		end
		typeInfo = getTypeInfoForBuiltinType(state, "bool")

	-- String concatenation.
	elseif binary.operation == ".." then
		if typeInfoL ~= typeInfoR then
			!!(TYPE_MISMATCH)
		elseif typeInfoL.tag ~= !(typeTags.TypeInfoString) then
			typeError(state, binary.left, "String concatenation expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoL))
		end
		typeInfo = getTypeInfoForBuiltinType(state, "string")

	else
		errorUnhandledNodeType(state, binary)
	end

	assert(typeInfo)
	binary.inferredType = typeInfo

	--
	-- Inferring complete! Now simplify the expression if it's constant.
	--
	-- @Incomplete: Simplify these kinds of expressions: (1+x)+2 => (1+2)+x => 3+x
	-- @Incomplete: Simplify these kinds of expressions: 1 + -x => 1 - x
	--

	local isConstL, valueL = getLiteralValueFromExpressionIfConstant(state, binary.left)
	local isConstR, valueR = getLiteralValueFromExpressionIfConstant(state, binary.right)

	if not (isConstL and isConstR) then
		moveToPipe(state, binary, !(PIPE_DONE))

	!for _, opArithmeticKeepType in ipairs{"+","-","*","^","%"} do
	elseif binary.operation == !(opArithmeticKeepType) then
		local literal = astNewNode(AstLiteral, binary.token, binary.parent)

		literal.literalType
			=  typeInfo.tag == !(typeTags.TypeInfoInt)   and !(LITERAL_INTEGER)
			or typeInfo.tag == !(typeTags.TypeInfoFloat) and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = valueL !!(opArithmeticKeepType) valueR -- This should produce the correct result for any combination of int and float.
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))
	!end

	elseif binary.operation == "/" then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = valueL/valueR
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))

	elseif binary.operation == "//" then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = math.floor(valueL/valueR)
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))

	!for _, opComparison in ipairs{"<",">","<=",">=","==","~=","and","or"} do
	elseif binary.operation == !(opComparison) then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = valueL !!(opComparison) valueR
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))
	!end

	elseif binary.operation == ".." then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_STRING)
		literal.value        = valueL..valueR -- @Speed: Concatinate more than two values at a time. (Probably need to update parsing stage.)
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))

	else
		errorUnhandledNodeType(state, binary)
	end

	-- astPrintTree(binary.parent)
end

function _G.getConstantNameOrTriggerError(state, node)
	if not (node.nodeType == !(nodeTypes.AstLiteral) and node.literalType == !(LITERAL_STRING)) then
		typeError(
			state, astGetExpressionVisuallyFurthestToTheLeft(node),
			"Expected a name constant after %s.",
			getFriendlyTypeInfoName(node.inferredType)
		)
	end

	local literal = node
	local name    = literal.value

	if not name:find"^[%a_\128-\255][%w_\128-\255]*$" then
		typeError(state, literal, "Bad format or invalid characters in name '%s'.", name)
	end

	return name
end

local function checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode(state, topNodeToCheck, staticObjectNode)
	astVisitAllNodes(topNodeToCheck, function(node)
		if not (
			node.nodeType == !(nodeTypes.AstLookup)
			or (
				node.nodeType == !(nodeTypes.AstIdentifier)
				and node == node.parent.object -- We know this is a lookup because astVisitAllNodes() visit parents first.
			)
			or (
				node.nodeType == !(nodeTypes.AstLiteral)
				and node == node.parent.member -- We know this is a lookup because astVisitAllNodes() visit parents first.
			)
		) then
			printerr()
			typeMessage(io.stderr, state, staticObjectNode, "Error", "Trying to access a static object using code that looks like it's supposed to do something at runtime. Ambigous intension.")
			typeMessage(io.stderr, state, node,             "Info",  "...this looks like a runtime expression.")
			exitFailure()
		end
	end)
end

!NODE_INFERRER `function nodeInferrers.AstLookup(state, lookup)`
	local typeInfoObject = lookup.object.inferredType
	local typeInfoMember = lookup.member.inferredType

	if not typeInfoObject then
		!DEPEND_AND_RETURN(`lookup`, DEPEND_NODE_INFERRED, `lookup.object`)
	end
	if not typeInfoMember then
		!DEPEND_AND_RETURN(`lookup`, DEPEND_NODE_INFERRED, `lookup.member`)
	end

	if typeInfoObject.tag == !(typeTags.TypeInfoList) and not typeInfoObject[1] then
		typeError(state, lookup.object, "Function call returns nothing. (Expected at least one value.)")
	end
	if typeInfoMember.tag == !(typeTags.TypeInfoList) and not typeInfoMember[1] then
		typeError(state, lookup.member, "Function call returns nothing. (Expected at least one value.)")
	end

	typeInfoObject = adjustTypeToOne(state, typeInfoObject, true)
	typeInfoMember = adjustTypeToOne(state, typeInfoMember, true)

	local isDirectObj    = lookup.object.inferredType == typeInfoObject
	local isDirectMember = lookup.member.inferredType == typeInfoMember

	local isLeftValue         = lookup.parent.nodeType == !(nodeTypes.AstAssignment) and indexOf(lookup.parent.targets, lookup) ~= nil
	local typeInfoRepresented = getTypeRepresentedByExpression(lookup.object)

	if typeInfoObject.tag == !(typeTags.TypeInfoTable) then
		local tableNode = typeInfoObject

		if typeInfoMember.tag == !(typeTags.TypeInfoNone) then
			typeError(state, lookup.member, "Table keys cannot be nil.")

		elseif typeInfoMember.tag == !(typeTags.TypeInfoCompound) and indexOf(typeInfoMember, getTypeInfoForBuiltinType(state, "none")) then
			typeError(state, lookup.member, "Table keys cannot be nil. (Type is %s)", getFriendlyTypeInfoName(typeInfoMember))

		--[[ This warning message may be too noisy in some programs.
		elseif typeInfoMember.tag == !(typeTags.TypeInfoAny) then
			-- @Incomplete: Add a setting to suppress warnings.
			typeMessage(
				io.stderr, state, astGetExpressionVisuallyFurthestToTheLeft(lookup.member),
				"Warning", "Table key is 'any' and thus possibly nil."
			)
		--]]
		end

		lookup.inferredType = getTypeInfoForBuiltinType(state, "any")
		moveToPipe(state, lookup, !(PIPE_DONE))
		return

	elseif typeInfoObject.tag == !(typeTags.TypeInfoArray) then
		local arraySig = typeInfoObject

		if typeInfoMember.tag == !(typeTags.TypeInfoInt) then
			-- @Incomplete: Check for isLeftValue and constantness.

			if lookup.member.nodeType == !(nodeTypes.AstLiteral) and lookup.member.value < 1 then
				local literal = lookup.member
				typeError(state, literal, "Array index is %d.", literal.value)
			end

			lookup.inferredType = arraySig.itemType
			moveToPipe(state, lookup, !(PIPE_DONE))

		-- elseif not isLeftValue and typeInfoMember.tag == !(typeTags.TypeInfoString) then
		-- 	local abstractMemberLiteral = lookup.member
		-- 	local abstractMemberName    = getConstantNameOrTriggerError(state, abstractMemberLiteral)
		-- 	if abstractMemberName == ? then ... end

		else
			typeError(state, lookup.member, "Expected an array index.")
		end

		return
	end

	-- @Cleanup @Robustness: The way we move things in pipes (after astCopy() and elsewhere)
	-- is not very good. Use moveToNextRelevantPipe()!

	if typeInfoObject.tag == !(typeTags.TypeInfoStruct) or (typeInfoRepresented and typeInfoRepresented.tag == !(typeTags.TypeInfoStruct)) then
		local structInfo = typeInfoRepresented or typeInfoObject
		if not structInfo.hasMembers then
			!DEPEND_AND_RETURN(`lookup`, DEPEND_STRUCT_MEMBERS_READY, `structInfo`)
		end

		local memberLiteral = lookup.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)
		local decl          = findDeclarationInScope(state, structInfo.astNode, memberName, false)

		if not decl then
			typeError(state, memberLiteral, "'%s' is not a member of %s.", memberName, getFriendlyTypeInfoName(structInfo))
		elseif isLeftValue and decl.isConstant then
			typeError(state, memberLiteral, "Cannot assign value to constant member %s.%s", getFriendlyTypeInfoName(structInfo), memberName)
		end

		if not decl.isConstant then
			lookup.inferredType    = decl.name.inferredType or errorInternal()
			lookup.representedType = decl.valueTypeInfo -- May be nil.

			moveToPipe(state, lookup, !(PIPE_DONE))
			return
		end

		if not isExpressionConstant(state, lookup.object) then
			checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode(state, lookup.object, lookup.member)
		end

		local valueExpr = getAssignmentValue(state, decl.name, decl.assignment.values, decl.assignmentIndex)
		local replacement

		if valueExpr.nodeType == !(nodeTypes.AstLiteral) then
			replacement = astCopy(valueExpr, memberLiteral.token)

		elseif valueExpr.nodeType == !(nodeTypes.AstType) then
			replacement = astCopy(valueExpr, memberLiteral.token)
			addUnqueuedChildrenToQueueRecursively(state, replacement, !(PIPE_DONE))

		elseif valueExpr.nodeType == !(nodeTypes.AstIdentifier) and valueExpr.inferredType.tag == !(typeTags.TypeInfoEnum) then
			replacement = astCopy(valueExpr, memberLiteral.token)

		elseif valueExpr.nodeType == !(nodeTypes.AstLambda) then
			if lookup.parent.nodeType == !(nodeTypes.AstCall) and lookup == lookup.parent.callee and lookup.parent.isMethod then
				--
				-- Change obj.staticMethod!(...) into staticMethod(obj, ...)
				--
				-- AstCall (method)
				--   CALLEE AstLookup
				--     AstIdentifier (object)
				--     AstLiteral (string)
				--   ARG1...
				--
				-- AstCall (normal)
				--   CALLEE AstIdentifier (static function)
				--   ARG1 AstIdentifier (object)
				--   ARG2...
				--
				local call = lookup.parent

				-- Move object from lookup to call arguments.
				local obj = lookup.object
				table.insert(call.arguments, 1, obj)
				obj.parent = call

				-- Update all argument queueds.
				for i, arg in ipairs(call.arguments) do
					arg.queued.container = call.arguments
					arg.queued.key       = i
				end

				-- Update callee using lookup. (Note: lookup==callee)
				local ident        = astNewNode(AstIdentifier, memberLiteral.token, call)
				ident.name         = decl.name.name
				ident.declaration  = decl
				ident.inferredType = decl.name.inferredType
				replaceQueuedNode(state, lookup, ident)
				moveToNextRelevantPipe(state, ident)

				-- Update call.
				call.isMethod = false

				-- Unqueue now unused nodes.
				unqueue(memberLiteral)

				astPrintTree(call)
				return

			else
				local ident        = astNewNode(AstIdentifier, memberLiteral.token, lookup.parent)
				ident.name         = decl.name.name
				ident.declaration  = decl
				ident.inferredType = decl.name.inferredType
				replacement        = ident
			end

		else
			where(state, valueExpr)
			errorUnhandledNodeType(state, valueExpr)
		end

		assert(replacement) -- Constants must be simplified!

		replaceQueuedNodeAndUnqueueOldTree(state, lookup, replacement)
		moveToPipe(state, replacement, !(PIPE_DONE))

	elseif typeInfoObject.tag == !(typeTags.TypeInfoEnum) or (typeInfoRepresented and typeInfoRepresented.tag == !(typeTags.TypeInfoEnum)) then
		local memberLiteral = lookup.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)

		local enumInfo      = typeInfoRepresented or typeInfoObject
		local decl          = findDeclarationInScope(state, enumInfo.astNode, memberName, false)

		if not decl then
			typeError(state, memberLiteral, "'%s' is not a member of %s.", memberName, getFriendlyTypeInfoName(enumInfo))
		elseif isLeftValue then
			typeError(state, memberLiteral, "Cannot assign values to enum members. (Enum is %s)", getFriendlyTypeInfoName(enumInfo))
		end

		assert(decl.isConstant)

		local ident         = astCopy(decl.name, lookup.token, lookup.parent)
		ident.placeDeclared = nil

		-- addUnqueuedChildrenToQueueRecursively(state, ident, !(PIPE_BYTECODE)) -- Not needed for identifiers.
		replaceQueuedNodeAndUnqueueOldTree(state, lookup, ident)
		-- Stay in the current pipe so we get simplified. (Needed? Or maybe we can @Speed things up here?)

	elseif typeInfoObject.tag == !(typeTags.TypeInfoNamespace) then
		assert(isDirectObj)

		local memberLiteral = lookup.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)

		local namespace     = typeInfoObject
		local decl          = findDeclarationInScope(state, namespace.scope, memberName, true)

		if not decl then
			!DEPEND_AND_RETURN(`lookup`, DEPEND_DECLARATION, `memberName`, `namespace.scope`)
		elseif not decl.name.inferredType then
			!DEPEND_AND_RETURN(`lookup`, DEPEND_NODE_INFERRED, `decl.name`)
		end

		local ident         = astCopy(decl.name, lookup.token, lookup.parent)
		ident.placeDeclared = nil

		-- addUnqueuedChildrenToQueueRecursively(state, ident, !(PIPE_BYTECODE)) -- Not needed for identifiers.
		replaceQueuedNodeAndUnqueueOldTree(state, lookup, ident)
		-- Stay in the current pipe so we get simplified. (Needed? Or maybe we can @Speed things up here?)

	else
		typeError(state, lookup, "Values of type '%s' do not have members.", getFriendlyTypeInfoName(typeInfoObject))
	end
end

!NODE_INFERRER `function nodeInferrers.AstTable(state, tableNode)`
	for _, tableField in ipairs(tableNode) do
		if not tableField.value.inferredType then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `tableField.value`)
		elseif not tableField.key.inferredType then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `tableField.key`)
		end
	end

	local typeInfoExpected = getExpectedTypeInfo(state, tableNode)
	if not typeInfoExpected then  return  end

	-- If a table-like is expected as an argument to a call then we're fine without an
	-- explicit cast. Otherwise, we don't want to get any expectation through a call.
	if not isAny(typeInfoExpected.tag, !(typeTags.TypeInfoTable),!(typeTags.TypeInfoStruct),!(typeTags.TypeInfoArray)) then
		typeInfoExpected = getExpectedTypeInfo(state, tableNode, true) or errorInternal()
	end

	if typeInfoExpected.tag == !(typeTags.TypeInfoTable) then
		-- @Incomplete: Check for duplicate fields (among constant keys).
		-- @Incomplete: Check for nil keys.
		tableNode.inferredType = typeInfoExpected

	elseif typeInfoExpected.tag == !(typeTags.TypeInfoArray) then
		local arraySig            = typeInfoExpected
		local indexLiterals       = {}
		local highestLiteralIndex = 0

		for _, tableField in ipairs(tableNode) do
			if tableField.key.inferredType.tag ~= !(typeTags.TypeInfoInt) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(tableField.key),
					"Array indices must be integers. (This is %s)",
					getFriendlyTypeInfoName(tableField.key.inferredType)
				)
			elseif tableField.key.nodeType ~= !(nodeTypes.AstLiteral) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(tableField.key),
					"Indices must be constant in array literals."
				)
			end

			local literal    = tableField.key
			local arrayIndex = literal.value

			if indexLiterals[arrayIndex] then
				printerr()
				typeMessage(io.stderr, state, literal,                   "Error", "Duplicate index %d.", arrayIndex)
				typeMessage(io.stderr, state, indexLiterals[arrayIndex], "Info",  "...first occurance is here.")
				exitFailure()
			end

			indexLiterals[arrayIndex] = literal
			highestLiteralIndex       = math.max(highestLiteralIndex, arrayIndex)

			if not isTypeCompatibleWith(adjustTypeToOne(state, tableField.value.inferredType, true), arraySig.itemType) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(tableField.value),
					"Array item type mismatch. (Wanted %s, got %s)",
					getFriendlyTypeInfoName(arraySig.itemType),
					getFriendlyTypeInfoName(adjustTypeToOne(state, tableField.value.inferredType, true))
				)
			end
		end

		for arrayIndex = 1, highestLiteralIndex do
			if not indexLiterals[arrayIndex] then
				typeError(state, tableNode, "Array is not a sequence. Missing item at index %d.", arrayIndex)
			end
		end

		tableNode.inferredType = arraySig

	elseif typeInfoExpected.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfoExpected

		-- @Incomplete: This dependency is problematic in these cases:
		-- local Struct :: struct{ bad:Struct = {} }
		-- local Struct :: struct{ bad = cast(Struct) {} }
		if not structInfo.hasMembers then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_STRUCT_MEMBERS_READY, `structInfo`)
		end

		local keyLiterals = {}

		for _, tableField in ipairs(tableNode) do
			if tableField.key.inferredType.tag ~= !(typeTags.TypeInfoString) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(tableField.key),
					"Struct initializer keys must be strings. (This is %s)",
					getFriendlyTypeInfoName(tableField.key.inferredType)
				)
			elseif tableField.key.nodeType ~= !(nodeTypes.AstLiteral) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(tableField.key),
					"Keys must be constant in struct initializers."
				)
			end

			local memberLiteral = tableField.key
			local memberName    = memberLiteral.value

			if keyLiterals[memberName] then
				printerr()
				typeMessage(io.stderr, state, memberLiteral,           "Error", "Duplicate field '%s'.", memberName)
				typeMessage(io.stderr, state, keyLiterals[memberName], "Info",  "...first occurance is here.")
				exitFailure()
			end

			keyLiterals[memberName] = memberLiteral
			local member            = itemWith1(structInfo.members, "name", memberName)

			if member then
				-- void
			elseif findDeclarationInScope(state, structInfo.astNode, memberName, false) then
				typeError(state, memberLiteral, "'%s' is a static member in %s.", memberName, getFriendlyTypeInfoName(structInfo))
			else
				typeError(state, memberLiteral, "'%s' is not a member of %s.", memberName, getFriendlyTypeInfoName(structInfo))
			end

			if not isTypeCompatibleWith(adjustTypeToOne(state, tableField.value.inferredType, true), member.typeInfo) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(tableField.value),
					"Type mismatch for struct field '%s'. (Wanted %s, got %s)",
					tableField.key.value,
					getFriendlyTypeInfoName(member.typeInfo),
					getFriendlyTypeInfoName(tableField.value.inferredType)
				)
			end
		end

		tableNode.inferredType = structInfo

	else
		typeError(
			state, tableNode,
			"Table literal is expecting to get inferred as %s (type group '%s'), which is illegal. (The inferred type must be array, struct or table.)",
			getFriendlyTypeInfoName(typeInfoExpected),
			TYPE_TAG_NAMES[typeInfoExpected.tag]
		)
	end

	moveToPipe(state, tableNode, !(PIPE_DONE)) -- Bytecode for table-likes is generated by declarations.
end

!NODE_INFERRER `function nodeInferrers.AstArgument(state, arg)`
	if arg.declaration.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`arg`, DEPEND_NODE_INFERRED, `arg.declaration`)
	end
	moveToPipe(state, arg, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstArguments(state, args)`
	for _, arg in ipairs(args) do
		if arg.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`args`, DEPEND_NODE_INFERRED, `arg`)
		end
	end
	moveToPipe(state, args, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstLambda(state, lambda)`
	if lambda.argumentsIn and lambda.argumentsIn.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.argumentsIn`)
	end
	if lambda.argumentsOut and lambda.argumentsOut.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.argumentsOut`)
	end

	-- Note: We don't require the body to inferred - just the "header".

	if lambda.argumentsIn then
		for _, arg in ipairs(lambda.argumentsIn) do
			if arg.assignment and not isExpressionConstant(state, arg.assignment.values[1]) then
				typeError(state, astGetExpressionVisuallyFurthestToTheLeft(arg.assignment.values[1]), "Non-constant default values for arguments are not supported yet.")
			end
		end
	end

	lambda.inferredType = getTypeInfoForLambda(state, lambda) or errorInternal()

	if lambda.bodyIsForeign then
		assert((lambda.foreignSourceName ~= ""), "@Incomplete: Infer lambda.foreignSourceName")
		validateForeignSource(state, lambda.foreignSource, lambda.foreignSourceName, lambda)
		lambda.foreignSourceId = lambda.foreignSource.." "..lambda.foreignSourceName
	end

	if lambda.body then
		moveToNextPipe(state, lambda, !(PIPE_BYTECODE))
	else
		moveToPipe(state, lambda, !(PIPE_DONE))
	end
end

!NODE_INFERRER `function nodeInferrers.AstTypeOf(state, typeOf)`
	-- @Robustness: Check that the expression doesn't have code that looks like it's going to be executed, because it's not!

	local exprTypeInfo = typeOf.expression.inferredType

	if not exprTypeInfo then
		!DEPEND_AND_RETURN(`typeOf`, DEPEND_NODE_INFERRED, `typeOf.expression`)
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoNamespace) then
		typeError(state, typeOf.expression, "Namespaces don't have a type.")
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoList) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeOf.expression), "Cannot get the type of function calls.")
	end

	typeOf.inferredType    = getTypeInfoForBuiltinType(state, "type")
	typeOf.representedType = exprTypeInfo

	if typeOf.representedType.tag == !(typeTags.TypeInfoVararg) then
		local varargSig        = typeOf.representedType
		typeOf.representedType = varargSig.itemType
	end

	moveToPipe(state, typeOf, !(PIPE_DONE))
	simplifyTypeExpression(state, typeOf, typeOf.representedType) -- @Check: Are we in the right pipe after simplification?
end

!NODE_INFERRER `function nodeInferrers.AstCast(state, cast)`
	-- Note: For convenience, cast.targetType may be nil here for generated casts. cast.inferredType must be set in those cases.

	!local INVALID_CAST = `
		typeError(
			state, astGetExpressionVisuallyFurthestToTheLeft(cast.expression),
			"Cannot cast from %s to %s.",
			getFriendlyTypeInfoName(exprTypeInfo),
			getFriendlyTypeInfoName(castTypeInfo)
		)
	`

	if cast.targetType and not cast.targetType.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.targetType`)
	end
	if not cast.expression.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.expression`)
	end

	local castTypeInfo = cast.inferredType or getTypeRepresentedByExpression(cast.targetType)
	if not castTypeInfo then
		!ASSERT `cast.targetType`
		typeError(state, cast.targetType, "This is not a type. (It is %s)", getFriendlyTypeInfoName(cast.targetType.inferredType))
	end

	local exprTypeInfo = adjustTypeToOne(state, cast.expression.inferredType, true)

	if castTypeInfo == exprTypeInfo then
		cutOutPartOfNodeTree(state, cast, cast.expression)
		return

	elseif isTypeCompatibleWith(exprTypeInfo, castTypeInfo) then
		-- void  (Valid cast.)

	elseif
		isAny(castTypeInfo.tag, !(typeTags.TypeInfoFloat),!(typeTags.TypeInfoInt)) and
		isAny(exprTypeInfo.tag, !(typeTags.TypeInfoFloat),!(typeTags.TypeInfoInt))
	then
		-- void  (Valid cast.)

	elseif exprTypeInfo.tag == !(typeTags.TypeInfoEnum) and isTypeCompatibleWith(castTypeInfo, exprTypeInfo.memberTypeInfo) then
		-- void  (Enum members can cast to the real member type.)

	elseif
		exprTypeInfo.tag == !(typeTags.TypeInfoEnum) and
		isAny(castTypeInfo.tag,                !(typeTags.TypeInfoFloat),!(typeTags.TypeInfoInt)) and
		isAny(exprTypeInfo.memberTypeInfo.tag, !(typeTags.TypeInfoFloat),!(typeTags.TypeInfoInt))
	then
		-- We need two casts to happen in sequence here so we wrap ourselves in another cast.
		local wrappingCast        = astNewNode(AstCast, cast.token, cast.parent)
		wrappingCast.inferredType = exprTypeInfo.memberTypeInfo
		pokeAndQueueUnqueuedNodeIntoTree(state, cast, wrappingCast, wrappingCast, "expression", !(PIPE_DONE))

	elseif castTypeInfo.tag ~= !(typeTags.TypeInfoCompound) and exprTypeInfo.tag == !(typeTags.TypeInfoCompound) then
		-- We get here for situations like these: local xMaybe:int|nil = 0 ; local x = cast(int) xMaybe
		-- The user better know what they're doing!
		local compound = exprTypeInfo
		if not indexOf(compound, castTypeInfo) then
			!!(INVALID_CAST)
		end

	else
		!!(INVALID_CAST)
	end

	cast.inferredType = castTypeInfo

	moveToPipe(state, cast, !(PIPE_DONE))
	simplifyExpressionIfConstant(state, cast)
end

!NODE_INFERRER `function nodeInferrers.AstAssignment(state, assignment)`
	for _, targetExpr in ipairs(assignment.targets) do
		if not targetExpr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `targetExpr`)
		end
	end
	for _, expr in ipairs(assignment.values) do
		if not expr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `expr`)
		end
	end

	-- Validate targets.
	for _, targetExpr in ipairs(assignment.targets) do
		if not isAny(targetExpr.nodeType, !(nodeTypes.AstIdentifier),!(nodeTypes.AstLookup)) then
			!ifDEBUG`astPrint(targetExpr)`
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(targetExpr), "Invalid assignment target. Expected a variable name or field.")
		end
	end

	-- Validate values.
	-- Note: Enum member values are already validated by the enum itself.
	local declScope        = assignment.forDeclaration and getClosestScope(assignment) or nil
	local isEnumMemberDecl = declScope ~= nil and declScope.nodeType == !(nodeTypes.AstEnum)

	if not isEnumMemberDecl then
		for i, targetExpr in ipairs(assignment.targets) do
			getAssignmentValue(state, targetExpr, assignment.values, i, targetExpr.inferredType)
		end
	end

	-- @Incomplete: Check that !must args from functions have an assignment target.

	moveToPipe(state, assignment, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstBreak(state, breakNode)`
	if breakNode.loopName then
		typeError(state, breakNode, "@Incomplete: Break from named loops.")
	end
	moveToPipe(state, breakNode, !(PIPE_DONE))
end

-- !NODE_INFERRER `function nodeInferrers.AstContinue(state, continue)`
-- 	continue.loopName
-- end

-- !NODE_INFERRER `function nodeInferrers.AstDefer(state, defer)`
-- 	defer.body
-- end

!NODE_INFERRER `function nodeInferrers.AstImport(state, import)`
	local path
	if import.isLoad then
		path = isPathAbsolute(import.importName) and import.importName or state.projectDirectory.."/"..import.importName
	else
		path = COMPILER_DIRECTORY.."/modules/"..import.importName..".gloa"
	end

	local globalScope = state.globalScope

	if not state.fileBuffers[path] then
		-- @Incomplete: Include times in compilation stats.
		local timeStartLexing, timeEndLexing = readAndTokenizeFile(state, path)
		!ASSERT `state.fileBuffers[path], path`

		local timeStartParsing = os.clock()
		local fileScope        = parseFileScope(state, globalScope, path, (not import.isLoad), import.importName)
		local timeEndParsing   = os.clock()

		if peekNextToken(state) then
			errorParsingNext(state, "Expected the end of the file.")
		end

		if import.isLoad then
			astMoveGlobalDeclarationsToGlobalScope(state, fileScope)
		else
			table.insert(globalScope.fileScopes, fileScope) -- @Cleanup: Don't do this in astMoveGlobalDeclarationsToGlobalScope()!
		end
		local i = indexOf(globalScope.fileScopes, fileScope) or errorInternal()
		addToQueueRecursively(state, fileScope, globalScope.fileScopes, i)
	end

	import.fileScope    = itemWith1(globalScope.fileScopes, "path", path) or errorInternal(path)
	import.inferredType = getTypeInfoForNamespace(state, import.fileScope)

	moveToPipe(state, import, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstUsing(state, using)`
	local expr     = using.expression
	local typeInfo = expr.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`using`, DEPEND_NODE_INFERRED, `expr`)
	end

	local usingScope

	if expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration

		if typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			usingScope       = structInfo.astNode

			if not decl.isConstant then
				using.variableDeclaration = decl
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			-- Using an enum value is the same as using the enum type. Is this good?
			local enumInfo = typeInfo
			usingScope     = enumInfo.astNode

		else
			typeError(state, ident, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_TAG_NAMES[typeInfo.tag])
		end

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		typeInfo       = typeNode.representedType

		if typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			usingScope       = structInfo.astNode

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			local enumInfo = typeInfo
			usingScope     = enumInfo.astNode

		else
			typeError(state, typeNode, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_TAG_NAMES[typeInfo.tag])
		end

	else
		!ifDEBUG`astPrint(expr)`
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Invalid or unsupported 'using' expression.")
	end

	local scopeOfUsing  = getClosestScope(using)
	local usingExisting = itemWith(scopeOfUsing.usings, "scope", usingScope)

	if usingExisting then
		local usingEarly = usingExisting
		local usingLate  = using

		if usingLate.token < usingEarly.token then
			usingEarly, usingLate = usingLate, usingEarly
		end

		printerr()
		typeMessage(io.stderr, state, usingLate,  "Error", "Duplicate using in the same scope.")
		typeMessage(io.stderr, state, usingEarly, "Info",  "...first using is here.")
		exitFailure()
	end

	using.scope = usingScope

	moveToPipe(state, using, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstForeign(state, foreign)`
	-- @Robustness: Limit places the "expected" type can be inferred from.
	local typeInfoExpected = getExpectedTypeInfo(state, foreign, true)
	if not typeInfoExpected then  return  end

	foreign.inferredType = typeInfoExpected

	assert((foreign.sourceName ~= ""), "@Incomplete: Infer foreign.sourceName")
	validateForeignSource(state, foreign.source, foreign.sourceName, foreign)
	foreign.sourceId = foreign.source.." "..foreign.sourceName

	moveToPipe(state, foreign, !(PIPE_BYTECODE))
end

local function inferIfOrWhile(state, ifOrWhile)
	local typeInfo = ifOrWhile.condition.inferredType
	if not typeInfo then
		!DEPEND_AND_RETURN(`ifOrWhile`, DEPEND_NODE_INFERRED, `ifOrWhile.condition`)
	end

	if typeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig = typeInfo
		typeInfo      = listSig[1]

		if not typeInfo then
			typeError(state, ifOrWhile.condition, "Function call returns nothing. (Expected a boolean.)")
		end
	end

	if typeInfo.tag == !(typeTags.TypeInfoVararg) then
		errorUnhandledNodeType(state, ifOrWhile.condition)
	end

	-- @Incomplete: Make if conditions better! Handle compound types and stuff in a nice way!
	if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
		typeError(
			state, astGetExpressionVisuallyFurthestToTheLeft(ifOrWhile.condition),
			"Expected condition expression to result in a boolean. (Got %s)",
			getFriendlyTypeInfoName(typeInfo)
		)
	end

	-- @Optimize: Remove/replace the branch if the condition is statically known.

	moveToPipe(state, ifOrWhile, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstIf(state, ifBranch)`
	inferIfOrWhile(state, ifBranch)
end
!NODE_INFERRER `function nodeInferrers.AstWhile(state, whileLoop)`
	inferIfOrWhile(state, whileLoop)
end

local function addDeclarationInForLoop(state, forLoop, name, typeInfo)
	-- @Incomplete: Care about name shadowing.

	local decl          = astNewNode(AstDeclaration, forLoop.token, forLoop)

	local ident         = astNewNode(AstIdentifier, decl.token, decl)
	ident.name          = name
	ident.placeDeclared = forLoop
	ident.declaration   = decl
	ident.inferredType  = typeInfo
	decl.name           = ident

	table.insert(forLoop,              decl)
	table.insert(forLoop.declarations, decl)

	addToQueueRecursively(state, decl, forLoop, #forLoop, !(PIPE_DONE))
	moveToPipe(state, decl, !(PIPE_BYTECODE))
end

!NODE_INFERRER `function nodeInferrers.AstFor(state, forLoop)`
	if not forLoop.declarations[1] then
		local names  = forLoop.names
		local values = forLoop.expressions

		-- @Incomplete: Add all declarations now and infer their types later to fix confusing "undeclared identifier" errors.

		for _, expr in ipairs(values) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		-- for [ i = ] start, end [, step ]
		if forLoop.forType == !(FOR_NUMERIC) then
			!ASSERT `#names <= 1`
			!ASSERT `values[2] and not values[4]`

			for _, valueExpr in ipairs(values) do
				if valueExpr.inferredType.tag ~= !(typeTags.TypeInfoInt) then
					typeError(
						state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
						"For loop: Expected an int. (Got %s)",
						getFriendlyTypeInfoName(valueExpr.inferredType)
					)
				end
			end

			addDeclarationInForLoop(state, forLoop, (names[1] and names[1].name or "it"), values[1].inferredType)

		-- for [ v1, ... : ] obj
		elseif forLoop.forType == !(FOR_SHORT) then
			!ASSERT `#values == 1`

			-- Note: Built-in short-form for loops have the value first and then the index/key.
			local objExpr = values[1]

			if objExpr.inferredType.tag == !(typeTags.TypeInfoArray) then
				local name1 = (names[1] and names[1].name) or "it"
				local name2 = (names[2] and names[2].name) or "itIndex"
				addDeclarationInForLoop(state, forLoop, name2, getTypeInfoForBuiltinType(state, "int"))
				addDeclarationInForLoop(state, forLoop, name1, values[1].inferredType.itemType)

			elseif objExpr.inferredType.tag == !(typeTags.TypeInfoTable) then
				local name1    = (names[1] and names[1].name) or "it"
				local name2    = (names[2] and names[2].name) or "itIndex"
				local typeInfo = getTypeInfoForBuiltinType(state, "any")
				addDeclarationInForLoop(state, forLoop, name2, typeInfo)
				addDeclarationInForLoop(state, forLoop, name1, typeInfo)

			elseif objExpr.inferredType.tag == !(typeTags.TypeInfoStruct) then
				-- We need custom iterators to work AND default iterators for structs before we can do this!
				typeError(state, objExpr, "@Incomplete: Iterate over struct instances using custom default iterators.")

			else
				typeError(
					state, objExpr,
					"Cannot iterate over values in type group '%s'. (Type is %s)",
					TYPE_TAG_NAMES[objExpr.inferredType.tag],
					getFriendlyTypeInfoName(objExpr.inferredType)
				)
			end

		-- for v1, ... in iter [, state [, init ] ]
		else--if forType == FOR_ITERATOR
			!ASSERT `#names >= 1`
			!ASSERT `values[1]`

			-- @Incomplete: Support 'for' loops/iterators that don't require an iterator value or
			-- even a state (e.g. if values are read from somewhere else, like an event queue).

			-- @Incomplete: Complain if getAssignmentValue() can return a fourth value.

			local iterExpr, iterTypeInfo = getAssignmentValue(state, forLoop, values, 1, nil, "loop value")

			if iterTypeInfo.tag ~= !(typeTags.TypeInfoFunction) then
				typeError(state, iterExpr, "Expected a function. (Got %s)", getFriendlyTypeInfoName(iterTypeInfo))

			elseif #iterTypeInfo.argumentTypesIn ~= 2 then
				-- @Incomplete: Consider optional arguments.
				typeError(
					state, iterExpr,
					"Iterators must take two arguments - an invariant state object and a control value. (The signature of this function is %s)",
					getFriendlyTypeInfoName(iterTypeInfo)
				)

			elseif not iterTypeInfo.argumentTypesOut[1] then
				typeError(state, iterExpr, "Iterator does not return anything.")

			elseif iterTypeInfo.argumentTypesOut[1].tag == !(typeTags.TypeInfoNone) then
				typeError(state, iterExpr, "The type of the first returned value from iterators cannot be simply nil. It must be a compound type where nil is included.")

			elseif not (
				iterTypeInfo.argumentTypesOut[1].tag == !(typeTags.TypeInfoAny)
				or (
					iterTypeInfo.argumentTypesOut[1].tag == !(typeTags.TypeInfoCompound)
					and itemWith1(iterTypeInfo.argumentTypesOut[1], "tag", !(typeTags.TypeInfoNone))
				)
			) then
				typeError(
					state, iterExpr,
					"The type of the first returned value from iterators must be a compound type where nil is included. (This function returns %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesOut[1])
				)

			elseif #iterTypeInfo.argumentTypesOut ~= #names then
				-- @Incomplete: Consider !must and make everything else optional.
				typeError(
					state, names[math.min(#iterTypeInfo.argumentTypesOut+1, #names)],
					"Incorrect number of names specified for iterator. (Expected %d, got %d)",
					#iterTypeInfo.argumentTypesOut,
					#names
				)
			end

			local stateExpr, stateTypeInfo = getAssignmentValue(state, forLoop, values, 2, nil, "loop value")
			local initExpr,  initTypeInfo  = getAssignmentValue(state, forLoop, values, 3, nil, "loop value")

			if not isTypeCompatibleWith(adjustTypeToOne(state, stateTypeInfo, true), iterTypeInfo.argumentTypesIn[1]) then
				typeError(
					state, stateExpr,
					"Type mismatch for iterator state (value #2). (Wanted %s, got %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[1]),
					getFriendlyTypeInfoName(adjustTypeToOne(state, stateTypeInfo, true))
				)
			end
			if not isTypeCompatibleWith(adjustTypeToOne(state, initTypeInfo, true), iterTypeInfo.argumentTypesIn[2]) then
				typeError(
					state, initExpr,
					"Type mismatch for initial control value (value #3). (Wanted %s, got %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[2]),
					getFriendlyTypeInfoName(adjustTypeToOne(state, initTypeInfo, true))
				)
			end

			for i, ident in ipairs(names) do
				local typeInfo = iterTypeInfo.argumentTypesOut[i]

				if i > 1 or typeInfo.tag == !(typeTags.TypeInfoAny) then
					-- void

				-- Strip nil from the compound type for the first value (unless it's 'any').
				elseif #typeInfo > 2 then
					local typeInfos = {unpack(typeInfo)}
					removeItem(typeInfos, getTypeInfoForBuiltinType(state, "none"))
					typeInfo = getTypeInfoForCompoundType(state, typeInfos)
				else
					typeInfo = typeInfo[2].tag == !(typeTags.TypeInfoNone) and typeInfo[1] or typeInfo[2] or errorInternal()
				end

				addDeclarationInForLoop(state, forLoop, ident.name, typeInfo)
			end
		end
	end

	for _, statement in ipairs(forLoop) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToPipe(state, forLoop, !(PIPE_DONE))
end

local function checkForRecursiveStruct(state, declThatWeAreChecking, memberPath, member, structInfo, parentStructInfo)
	local typeInfo = member.typeInfo

	if typeInfo == structInfo then
		for i, member in ipairs(memberPath) do
			memberPath[i] = member.name
		end

		-- @Incomplete: In the case of compound types, trigger this error if the default value has the type of the struct.
		typeError(
			state, declThatWeAreChecking.name,
			"%s.%s is of type %s. This creates an infinite recursive loop. (Note: Compound types containing the struct are ok (unless the default value is the struct type), e.g. %s|nil)",
			getFriendlyTypeInfoName(structInfo),
			table.concat(memberPath, "."),
			getFriendlyTypeInfoName(structInfo),
			getFriendlyTypeInfoName(structInfo)
		)
	end

	if typeInfo.tag ~= !(typeTags.TypeInfoStruct) then  return  end
	local structInfoInner = typeInfo

	local memberPathIndex = #memberPath+1

	for _, member in ipairs(structInfoInner.members) do
		memberPath[memberPathIndex] = member
		checkForRecursiveStruct(state, declThatWeAreChecking, memberPath, member, structInfo, structInfoInner)
	end

	memberPath[memberPathIndex] = nil
end

!NODE_INFERRER `function nodeInferrers.AstStruct(state, struct)`
	local structInfo = struct.representedType

	if not structInfo then
		structInfo         = newTypeInfo(TypeInfoStruct)
		structInfo.astNode = struct

		-- Note: We don't populate structInfo.members just yet. (Is this gonna a problem?)

		table.insert(state.allTypeInfos, structInfo)

		struct.representedType = structInfo
		struct.inferredType    = getTypeInfoForBuiltinType(state, "type")
	end

	for _, statement in ipairs(struct) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	-- @Incomplete: struct.arguments

	for i, decl in ipairs(struct.declarations) do
		if not decl.isConstant then
			local member          = TypeInfoStructMember()
			member.name           = decl.name.name
			member.typeInfo       = decl.name.inferredType or errorInternal()
			table.insert(structInfo.members, member)

			checkForRecursiveStruct(state, decl, {member}, member, structInfo, structInfo)
		end
	end
	structInfo.hasMembers = true

	moveToPipe(state, struct, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstEnum(state, enum)`
	for _, statement in ipairs(enum) do
		if statement.nodeType == !(nodeTypes.AstDeclaration) then
			-- Ignore declarations. We only need the assigned values to be inferred.

		elseif statement.nodeType == !(nodeTypes.AstAssignment) and statement.forDeclaration then
			-- We only need the assigned values to be inferred.
			local assignment = statement
			local valueExpr  = assignment.values[1] -- Note: Struct member declarations only have one name per assignment.

			if not valueExpr.inferredType then
				!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `valueExpr`)
			end

		elseif statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	assert(enum.declarations[1], "Enums must have members.") -- This should have been caught during parsing.

	local enumMemberInfo

	if enum.memberType then
		enumMemberInfo = getTypeInfoForBuiltinType(state, enum.memberType.typeName)
	else
		-- Just use the type of the first member as the wanted type for the enum.
		enumMemberInfo = enum.declarations[1].assignment.values[1].inferredType
		if not isAny(enumMemberInfo.tag, !(typeTags.TypeInfoInt),!(typeTags.TypeInfoString),!(typeTags.TypeInfoType),!(typeTags.TypeInfoBool),!(typeTags.TypeInfoFloat)) then
			typeError(state, enum, "Supported enum member types are: int, string, type, bool, float")
		end
	end

	local enumInfo          = newTypeInfo(TypeInfoEnum)
	enumInfo.astNode        = enum
	enumInfo.memberTypeInfo = enumMemberInfo or errorInternal()

	for i, decl in ipairs(enum.declarations) do
		local valueExpr = decl.assignment.values[1]

		if not isTypeCompatibleWith(valueExpr.inferredType, enumMemberInfo) then
			typeError(state, valueExpr,
				"Value type mismatch for '%s'. (Wanted %s, got %s)",
				decl.name.name,
				getFriendlyTypeInfoName(enumMemberInfo),
				getFriendlyTypeInfoName(valueExpr.inferredType)
			)
		end

		-- Note: valueExpr may not be a constant expression, but the
		-- declaration will check that after this enum gets inferred.

		local member        = TypeInfoEnumMember()
		member.name         = decl.name.name
		enumInfo.members[i] = member
	end

	table.insert(state.allTypeInfos, enumInfo)

	enum.representedType = enumInfo
	enum.inferredType    = getTypeInfoForBuiltinType(state, "type")

	moveToPipe(state, enum, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstFileScope(state, fileScope)`
	for _, statement in ipairs(fileScope) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`fileScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToPipe(state, fileScope, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstGlobalScope(state, globalScope)`
	for _, statement in ipairs(globalScope) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`globalScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToPipe(state, globalScope, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstBlock(state, block)`
	for _, statement in ipairs(block) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`block`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	moveToPipe(state, block, !(PIPE_DONE))
end

function _G.inferNode(state, node)
	local nodeInferrer = nodeInferrers[node.nodeType] or errorUnhandledNodeType(state, node)
	return nodeInferrer(state, node)
end



-- expressionIsConstant, literalValue = getLiteralValueFromExpressionIfConstant( compilationState, expression )
-- Note: It's assumed that the expression tree has all types figured out.
--
-- @Cleanup: All constant expressions that can result in a literal value should have been simplified into an AstLiteral.
-- That means we don't really need to return a literal here - the caller can just grab it from the literal node.
-- We also return a number for types which is not very good but currently needed for binary simplifications...
-- @Refactor this function to only figure out whether the expression is constant and move the code into isExpressionConstant().
--
function _G.getLiteralValueFromExpressionIfConstant(state, expr)
	-- @Incomplete: Return an AstNode?

	if expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		return true, literal.value

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration or errorInternal()

		if not decl.isConstant then  return false, nil  end

		!ASSERT `decl.assignment` -- Constant declarations must have a value.

		local valueExpr = getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex)
		return getLiteralValueFromExpressionIfConstant(state, valueExpr)

	elseif isAny(expr.nodeType, !(nodeTypes.AstType),!(nodeTypes.AstTypeOf)) then
		return true, expr.representedType.id -- All types are constant, just like literals.

	elseif isAny(expr.nodeType, !(nodeTypes.AstStruct),!(nodeTypes.AstEnum)) then
		return true, expr.representedType.id -- Structs and enums are types (which are constant, just like literals).
	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda = expr
		return true, lambda.inferredType.id -- Lambdas (which are function signatures) are types too.

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast       = expr
		local isConst, v = getLiteralValueFromExpressionIfConstant(state, cast.expression)
		if not isConst then  return false, nil  end

		if cast.inferredType.tag == !(typeTags.TypeInfoInt) then
			return true, (math.modf(v))
		elseif cast.inferredType.tag == !(typeTags.TypeInfoFloat) then
			return true, v
		elseif cast.inferredType.tag == !(typeTags.TypeInfoType) then
			return true, getTypeRepresentedByExpression(cast.targetType).id
		else
			errorInternal("Unhandled cast type: %s", getFriendlyTypeInfoName(cast.inferredType))
		end

	elseif isAny(expr.nodeType, !(nodeTypes.AstUnary),!(nodeTypes.AstBinary)) then
		return false, nil -- We don't check child nodes as these operations should have been simplified into 'expr' where this function is called.

	elseif expr.nodeType == !(nodeTypes.AstCall) then
		return false, nil -- Calls are always a runtime operation.

	elseif expr.nodeType == !(nodeTypes.AstLookup) then
		local lookup              = expr
		local typeInfoRepresented = getTypeRepresentedByExpression(lookup.object)

		if typeInfoRepresented and typeInfoRepresented.tag == !(typeTags.TypeInfoEnum) then
			return true, nil
		else
			return false, nil -- Other lookups resolving to constants should have simplified to something else already (I think).
		end

	elseif expr.nodeType == !(nodeTypes.AstImport) then
		return true, nil -- Namespaces, just like types, are always constant.

	elseif expr.nodeType == !(nodeTypes.AstTable) then
		local tableNode = expr
		for _, tableField in ipairs(tableNode) do
			if not isExpressionConstant(state, tableField.key)   then  return false, nil  end
			if not isExpressionConstant(state, tableField.value) then  return false, nil  end
		end
		return true, nil

	elseif expr.nodeType == !(nodeTypes.AstVararg) then
		return false, nil

	elseif expr.nodeType == !(nodeTypes.AstForeign) then
		-- Technically foreign values are constant at runtime, but since we don't know
		-- what they are at compile-time we (usually) treat them as runtime values.
		return false, nil

	else
		errorUnhandledNodeType(state, expr)
	end
end

function _G.isExpressionConstant(state, expr)
	return (getLiteralValueFromExpressionIfConstant(state, expr))
end



-- expression, typeInfo = getAssignmentValue( state, assignmentTarget, values, valueIndex [, expectedTypeInfo=any, targetTerm="assignment target" ] )
-- Note: Vararg node/type may be returned.
function _G.getAssignmentValue(state, targetExpr, values, i, typeInfoExpected, targetTerm)
	!(
		local TEMPLATE_TARGET_NAME = trimTemplate`(
			targetExpr.nodeType == $nodeTypeIdent  and " ('"..targetExpr.name.."')" or
			targetExpr.nodeType == $nodeTypeLookup and targetExpr.member.nodeType == $nodeTypeLiteral and targetExpr.member.literalType == $literalTypeString and " ('"..targetExpr.member.value.."')" or
			""
		)`
		local TARGET_NAME = templateToLua(TEMPLATE_TARGET_NAME, {
			nodeTypeIdent     = nodeTypes.AstIdentifier,
			nodeTypeLookup    = nodeTypes.AstLookup,
			nodeTypeLiteral   = nodeTypes.AstLiteral,
			literalTypeString = LITERAL_STRING,
		})
		local TEMPLATE_CALL_RETURNS_NOTHING = trimTemplate`
			typeError(state, call, "Called function returns nothing for %s #%d%s (return value #%d).", targetTerm, i, $targetName, argIndex)
		`
		local CALL_RETURNS_NOTHING = templateToLua(TEMPLATE_CALL_RETURNS_NOTHING, {
			targetName = TARGET_NAME,
		})
	)

	targetTerm      = targetTerm or "assignment target"
	local valueExpr = values[i]

	if valueExpr then
		local valueTypeInfoToReturn = valueExpr.inferredType

		if valueTypeInfoToReturn.tag == !(typeTags.TypeInfoList) then
			valueTypeInfoToReturn = valueTypeInfoToReturn[1]

			if not valueTypeInfoToReturn then
				local call     = valueExpr
				local argIndex = 1
				!!(CALL_RETURNS_NOTHING)
			end
		end

		if not typeInfoExpected then
			return valueExpr, valueTypeInfoToReturn
		end

		local valueTypeInfo = adjustTypeToOne(state, valueTypeInfoToReturn, true)

		if isTypeCompatibleWith(valueTypeInfo, typeInfoExpected) then
			return valueExpr, valueTypeInfoToReturn
		end

		if valueTypeInfo.tag == !(typeTags.TypeInfoFunction) and typeInfoExpected.tag == !(typeTags.TypeInfoFunction) then
			typeError(
				state, valueExpr,
				"Function signature is different from %s #%d%s. (Wanted %s, got %s)",
				targetTerm,
				i,
				!!(TARGET_NAME),
				getFriendlyTypeInfoName(typeInfoExpected),
				getFriendlyTypeInfoName(valueTypeInfo)
			)
		else
			typeError(
				state, valueExpr,
				"Value type mismatch for %s #%d%s. (Wanted %s, got %s)",
				targetTerm,
				i,
				!!(TARGET_NAME),
				getFriendlyTypeInfoName(typeInfoExpected),
				getFriendlyTypeInfoName(valueTypeInfo)
			)
		end
	end

	valueExpr = values[#values]

	if not valueExpr then
		typeError(state, targetExpr, "Missing a value for %s #%d%s.", targetTerm, i, !!(TARGET_NAME))

	elseif valueExpr.nodeType == !(nodeTypes.AstCall) and not valueExpr.surroundedByParenthesis then
		local call      = valueExpr
		local lastIndex = #values
		local argIndex  = i-lastIndex+1

		local typeInfoForCall = call.inferredType
		local listSig

		if typeInfoForCall.tag == !(typeTags.TypeInfoList) then
			listSig = typeInfoForCall
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfoForCall))
		end

		local typeInfoForOutArg = listSig[argIndex]

		if typeInfoForOutArg then
			-- void
		elseif listSig[1] and listSig[#listSig].tag == !(typeTags.TypeInfoVararg) then
			typeInfoForOutArg = listSig[#listSig]
		else
			!!(CALL_RETURNS_NOTHING)
		end

		if typeInfoExpected and not isTypeCompatibleWith(adjustTypeToOne(state, typeInfoForOutArg, true), typeInfoExpected) then
			local calleeName = (call.callee.nodeType == !(nodeTypes.AstIdentifier) and " of '"..call.callee.name.."'" or "")
			typeError(
				state, call,
				"The type of return value #%d%s (%s) does not match the type of %s #%d%s (%s).",
				argIndex,
				calleeName,
				getFriendlyTypeInfoName(adjustTypeToOne(state, typeInfoForOutArg, true)),
				targetTerm,
				i,
				!!(TARGET_NAME),
				getFriendlyTypeInfoName(typeInfoExpected)
			)
		end

		return call, typeInfoForOutArg

	elseif valueExpr.nodeType == !(nodeTypes.AstVararg) and not valueExpr.surroundedByParenthesis then
		local vararg = valueExpr
		return vararg, vararg.inferredType

	else
		typeError(state, targetExpr, "Missing a value for %s #%d%s.", targetTerm, i, !!(TARGET_NAME))
	end
end



local function createLambdaArgumentsFromTypes(state, typeInfos, lambda)
	local args = astNewNode(AstArguments, lambda.token, lambda)

	for i, argTypeInfo in ipairs(typeInfos) do
		local arg           = astNewNode(AstArgument,    lambda.token, args)
		local decl          = astNewNode(AstDeclaration, lambda.token, arg)
		local ident         = astNewNode(AstIdentifier,  lambda.token, decl)

		ident.name          = "_"..i
		ident.placeDeclared = lambda
		ident.declaration   = declaration
		ident.inferredType  = argTypeInfo

		decl.name           = ident

		arg.declaration     = decl
		arg.group           = i

		-- @Incomplete: Handle default values for input arguments. (Needed?)

		args[i] = arg
	end

	return args
end

local function createLambdaFromSignature(state, funcSig, parent)
	local lambda = astNewNode(AstLambda, parent.token, parent)

	if funcSig.argumentTypesIn[1] then
		lambda.argumentsIn = createLambdaArgumentsFromTypes(state, funcSig.argumentTypesIn, lambda)
		table.insert(lambda, lambda.argumentsIn)
	end
	if funcSig.argumentTypesOut[1] then
		lambda.argumentsOut = createLambdaArgumentsFromTypes(state, funcSig.argumentTypesOut, lambda)
		table.insert(lambda, lambda.argumentsOut)
	end

	return lambda
end

function _G.simplifyTypeExpression(state, expr, typeInfoRepresented)
	!ASSERT `typeInfoRepresented`

	local typeInfo            = expr.inferredType
	local typeNode            = astNewNode(AstType, expr.token, expr.parent)
	local isBuiltin, typeName = isTypeBuiltin(typeInfoRepresented)

	typeNode.isUserType      = not isBuiltin
	typeNode.inferredType    = typeInfo
	typeNode.representedType = typeInfoRepresented

	if isBuiltin then
		typeNode.kind     = !(TYPE_KIND_SIMPLE_BUILTIN)
		typeNode.typeName = typeName

	elseif typeInfoRepresented.tag == !(typeTags.TypeInfoStruct) then
		local structInfo  = typeInfoRepresented
		typeNode.kind     = !(TYPE_KIND_SIMPLE_USER)
		typeNode.typeName = structInfo.name

	elseif typeInfoRepresented.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo    = typeInfoRepresented
		typeNode.kind     = !(TYPE_KIND_SIMPLE_USER)
		typeNode.typeName = enumInfo.name

	elseif typeInfoRepresented.tag == !(typeTags.TypeInfoFunction) then
		-- local decl = typeInfo.declaration
		-- if decl then
		-- 	local lambda = getAssignmentValue(state, decl.name, decl.assignment.values, decl.assignmentIndex)
		-- 	assert(lambda.nodeType == !(nodeTypes.AstLambda))
		-- 	assert(not lambda.body)
		-- 	typeNode.functionHeader = astCopy(lambda) -- Do we need to update the location info of the lambda to where typeNode/expr is?
		-- else
			local funcSig           = typeInfoRepresented
			typeNode.kind           = !(TYPE_KIND_FUNCTION)
			typeNode.functionHeader = createLambdaFromSignature(state, funcSig, typeNode)
		-- end

		addUnqueuedChildrenToQueueRecursively(state, typeNode, !(PIPE_BYTECODE))

		astVisitAllNodes(typeNode.functionHeader, function(node)
			if node ~= typeNode and node.nodeType ~= !(nodeTypes.AstDeclaration) then
				moveToPipe(state, node, !(PIPE_DONE))
			end
		end)

	elseif typeInfoRepresented.tag == !(typeTags.TypeInfoCompound) then
		typeNode.kind = !(TYPE_KIND_COMPOUND)

	elseif typeInfoRepresented.tag == !(typeTags.TypeInfoVararg) then
		errorInternal() -- When do we get here?

	else
		errorInternal("Incomplete: Handle type tag '%s'.", TYPE_TAG_NAMES[typeInfoRepresented.tag])
	end

	replaceQueuedNodeAndUnqueueOldTree(state, expr, typeNode)
end

function _G.simplifyExpressionIfConstant(state, expr)
	if not isExpressionConstant(state, expr) then
		if
			-- :SpecialForeignValueRules
			expr.nodeType == !(nodeTypes.AstIdentifier)
			and expr.declaration.isConstant
			and expr.declaration.assignment.values[expr.declaration.assignmentIndex].nodeType == !(nodeTypes.AstForeign)
		then
			local ident       = expr
			local foreignCopy = astCopy(ident.declaration.assignment.values[ident.declaration.assignmentIndex], ident.token)

			replaceQueuedNodeAndUnqueueOldTree(state, ident, foreignCopy)
			moveToPipe(state, foreignCopy, !(PIPE_DONE))
		end

		return
	end

	if expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration or errorInternal()

		if not decl.isConstant then  return  end

		local typeInfo = ident.inferredType

		if typeInfo.tag ~= !(typeTags.TypeInfoEnum) then
			local typeInfoRepresented = decl.valueTypeInfo

			if typeInfoRepresented then
				simplifyTypeExpression(state, ident, typeInfoRepresented)
				return
			end
		end

		!ASSERT("typeInfo.tag ~= "..typeTags.TypeInfoType)
		if not isTypeSimple(typeInfo) then  return  end

		-- At this point we should have a literal to copy. Hopefully the expression we copy
		-- has been simplified into a literal if it wasn't a literal to begin with.
		local valueExpr = getAssignmentValue(state, decl.name, decl.assignment.values, decl.assignmentIndex)
		assert(valueExpr.nodeType == !(nodeTypes.AstLiteral))

		local copy = astCopy(valueExpr, ident.token)

		replaceQueuedNodeAndUnqueueOldTree(state, ident, copy)
		moveToPipe(state, copy, !(PIPE_BYTECODE))
		--[[ Not needed here:
		addUnqueuedChildrenToQueueRecursively(state, copy, !(PIPE_INFER))
		replaceQueuedNodeAndUnqueueOldTree(state, ident, copy)
		moveToPipe(state, copy, !(PIPE_INFER)) -- Revert any previous move before we call moveTreeToNextRelevantPipe().
		moveTreeToNextRelevantPipe(state, copy)
		--]]

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast       = expr
		local isConst, v = getLiteralValueFromExpressionIfConstant(state, cast.expression)

		!ASSERT `isConst`

		local typeInfoSource = cast.expression.inferredType
		local typeInfoTarget = cast.inferredType

		if typeInfoSource == typeInfoTarget then
			errorInternal() -- This should have been simlified away.

		-- int -> float
		elseif typeInfoSource.tag == !(typeTags.TypeInfoInt) and typeInfoTarget.tag == !(typeTags.TypeInfoFloat) then
			assert(type(v) == "number")
			local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
			literal.literalType  = !(LITERAL_FLOAT)
			literal.value        = v
			literal.inferredType = typeInfoTarget
			replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
			moveToPipe(state, literal, !(PIPE_BYTECODE))

		-- float -> int
		elseif typeInfoSource.tag == !(typeTags.TypeInfoFloat) and typeInfoTarget.tag == !(typeTags.TypeInfoInt) then
			assert(type(v) == "number")
			local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
			literal.literalType  = !(LITERAL_INTEGER)
			literal.value        = math.modf(v)
			literal.inferredType = typeInfoTarget
			replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
			moveToPipe(state, literal, !(PIPE_BYTECODE))

		-- enum -> enumMemberType (int, float, string, bool or type)
		elseif typeInfoSource.tag == !(typeTags.TypeInfoEnum) and isTypeCompatibleWith(typeInfoSource.memberTypeInfo, typeInfoTarget) then
			local castIsDirect = (typeInfoTarget == typeInfoSource.memberTypeInfo)

			local enumInfo = typeInfoSource
			local ident    = cast.expression
			assert(ident.nodeType == !(nodeTypes.AstIdentifier)) -- All constant enum member references should have been simplified to an identifier.

			local memberName = ident.name
			local decl       = findDeclarationInScope(state, enumInfo.astNode, memberName, false)
			local valueExpr  = decl.assignment.values[1]

			if BUILTIN_TYPE_TAG_TO_LITERAL_TYPE[typeInfoTarget.tag] then
				local literal = valueExpr
				assert(literal.nodeType == !(nodeTypes.AstLiteral))

				local literalCopy = astCopy(literal, cast.token)

				if castIsDirect then
					assert(literalCopy.inferredType == typeInfoTarget)

				elseif typeInfoSource.memberTypeInfo.tag == !(typeTags.TypeInfoInt) and typeInfoTarget.tag == !(typeTags.TypeInfoFloat) then
					literalCopy.literalType  = !(LITERAL_FLOAT)
					literalCopy.inferredType = typeInfoTarget

				else
					errorInternal(
						"Incomplete: Implicitly cast enum from %s to %s.",
						getFriendlyTypeInfoName(typeInfoSource.memberTypeInfo),
						getFriendlyTypeInfoName(typeInfoTarget)
					)
				end

				replaceQueuedNodeAndUnqueueOldTree(state, cast, literalCopy)
				moveToPipe(state, literalCopy, !(PIPE_BYTECODE))

			elseif typeInfoTarget.tag == !(typeTags.TypeInfoType) then
				assert(castIsDirect)

				local typeNode = valueExpr
				assert(typeNode.nodeType == !(nodeTypes.AstType))

				local typeNodeCopy = astCopy(typeNode, cast.token)

				addUnqueuedChildrenToQueueRecursively(state, typeNodeCopy, !(PIPE_DONE)) -- Only does something if the type has parameters.
				replaceQueuedNodeAndUnqueueOldTree(state, cast, typeNodeCopy)
				moveToPipe(state, typeNodeCopy, !(PIPE_DONE))

			else
				errorInternal("Incomplete: Handle casting enum to %s.", getFriendlyTypeInfoName(typeInfoTarget))
			end

		else
			errorInternal("Incomplete: Handle casting constant from %s to %s.", getFriendlyTypeInfoName(typeInfoSource), getFriendlyTypeInfoName(typeInfoTarget))
		end

	else
		-- void
	end
end



-- Values of simple types are non-objects (e.g. ints) in the outputted Lua code.
-- Note: Glóa types are represented as ints in Lua and thus are 'simple'.
function _G.isTypeSimple(typeInfo)
	return isAny(typeInfo.tag, !(typeTags.TypeInfoBool),!(typeTags.TypeInfoInt),!(typeTags.TypeInfoNone),!(typeTags.TypeInfoFloat),!(typeTags.TypeInfoString),!(typeTags.TypeInfoType))
end

function _G.isTypeNumeric(typeInfo)
	return isAny(typeInfo.tag, !(typeTags.TypeInfoInt),!(typeTags.TypeInfoFloat))
end

-- isCompatible, compatibilityScore = isTypeCompatibleWith( typeToCheck, otherType )
function _G.isTypeCompatibleWith(typeToCheck, otherType)
	!local SCORE = 0x10000
	if typeToCheck == otherType then  return true, !(SCORE)  end

	-- Everything is compatible with the 'any' type. The user better know what they're doing!
	!local SCORE = 0x1
	if typeToCheck.tag == !(typeTags.TypeInfoAny) or otherType.tag == !(typeTags.TypeInfoAny) then  return true, !(SCORE)  end

	-- Ints are always compatible with floats (but the opposite is false).
	-- This should be safe as all numbers are 64-bit floats in Lua 5.1 (I think).
	!local SCORE = 0x1000
	if typeToCheck.tag == !(typeTags.TypeInfoInt) and otherType.tag == !(typeTags.TypeInfoFloat) then  return true, !(SCORE)  end

	-- Structs and arrays are outputted as tables in Lua, so they are always compatible with tables in Glóa.
	!local SCORE = 0x10
	if
		otherType.tag == !(typeTags.TypeInfoTable)
		and isAny(typeToCheck.tag, !(typeTags.TypeInfoStruct),!(typeTags.TypeInfoArray))
	then
		return true, !(SCORE)
	end

	!local SCORE = 0x100
	if typeToCheck.tag == !(typeTags.TypeInfoCompound) then
		-- All compound items has to match the target. (If only one item matches, an explicit cast is needed.)
		local compoundToCheck = typeToCheck
		for _, compoundItemToCheck in ipairs(compoundToCheck) do
			if not isTypeCompatibleWith(compoundItemToCheck, otherType) then  return false, 0  end
		end
		return true, !(SCORE)
	end

	!local SCORE = 0x100
	if otherType.tag == !(typeTags.TypeInfoCompound) then
		-- typeToCheck has to match at least one compound item.
		local otherCompound = otherType
		for _, otherCompoundItem in ipairs(otherCompound) do
			if isTypeCompatibleWith(typeToCheck, otherCompoundItem) then  return true, !(SCORE)  end
		end
		return false, 0
	end

	-- Array compatability completely depends on the item type.
	if typeToCheck.tag == !(typeTags.TypeInfoArray) and otherType.tag == !(typeTags.TypeInfoArray) then
		return isTypeCompatibleWith(typeToCheck.itemType, otherType.itemType)
	end

	return false, 0
end

-- singleTypeInfo = adjustTypeToOne( state, typeInfo [, adjustVarargToIncludeNil=false ] )
-- Types that aren't single: TypeInfoVararg and TypeInfoList.
do
	local function compareIdsOfTypes(a, b)
		return a.id < b.id
	end

	local function adjustVarargItemTypeToOneAndToIncludeNil(state, itemType)
		if isAny(itemType.tag, !(typeTags.TypeInfoNone),!(typeTags.TypeInfoAny)) then
			return itemType
		end

		local nilTypeInfo = getTypeInfoForBuiltinType(state, "none")

		if itemType.tag ~= !(typeTags.TypeInfoCompound) then
			local typeInfos = {itemType, nilTypeInfo}
			table.sort(typeInfos, compareIdsOfTypes)
			return getTypeInfoForCompoundType(state, typeInfos)
		end

		local compound = itemType
		if indexOf(compound, nilTypeInfo) then  return compound  end

		local typeInfos = {nilTypeInfo, unpack(compound)}
		table.sort(typeInfos, compareIdsOfTypes)
		return getTypeInfoForCompoundType(state, typeInfos)
	end

	function _G.adjustTypeToOne(state, typeInfo, adjustVarargToIncludeNil)
		if typeInfo.tag == !(typeTags.TypeInfoList) then
			typeInfo = typeInfo[1]
		end

		if typeInfo.tag == !(typeTags.TypeInfoVararg) then
			typeInfo = typeInfo.itemType

			if adjustVarargToIncludeNil then
				typeInfo = adjustVarargItemTypeToOneAndToIncludeNil(state, typeInfo)
			end
		end

		return typeInfo
	end
end



-- Returns nil if we're now waiting for something. Errors on failure.
-- typeInfo = getExpectedTypeInfo( state, node [, strict=false ] )
function _G.getExpectedTypeInfo(state, node, strict)
	!local NO_EXPECTATION = `typeError(state, node, "Could not determine what type is expected here.")`
	local nodeType        = node.parent.nodeType

	if nodeType == !(nodeTypes.AstAssignment) then
		local assignment = node.parent
		local i          = indexOf(assignment.values, node) or !!(NO_EXPECTATION)

		if assignment.forDeclaration then
			local decl = assignment.declarations[i] or errorInternal()

			if not decl.type then
				!!(NO_EXPECTATION)
			elseif not decl.type.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
			end
			return getTypeRepresentedByExpression(decl.type) or errorInternal()

		else
			if not assignment.targets[i].inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `assignment.targets[i]`, nil, `nil`)
			end
			return assignment.targets[i].inferredType
		end

	elseif nodeType == !(nodeTypes.AstCast) then
		local cast = node.parent
		if node ~= cast.expression then  !!(NO_EXPECTATION)  end

		if not cast.targetType.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `cast.targetType`, nil, `nil`)
		end

		return getTypeRepresentedByExpression(cast.targetType) or errorInternal()

	elseif nodeType == !(nodeTypes.AstBinary) then
		local binary = node.parent
		local other  = node == binary.left and binary.right or binary.left

		if not other.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `other`, nil, `nil`)
		end

		return other.inferredType

	elseif nodeType == !(nodeTypes.AstReturn) then
		local returnNode = node.parent
		local i          = indexOf(returnNode.values, node) or !!(NO_EXPECTATION)
		local lambda     = astFindParent(returnNode, !(nodeTypes.AstLambda))
		local funcSig    = lambda.inferredType

		if not funcSig then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `lambda`, nil, `nil`)
		end

		local argTypesOut = funcSig.argumentTypesOut
		local argTypeInfo = argTypesOut[i]

		if
			(not argTypeInfo and argTypesOut[1] and argTypesOut[#argTypesOut].tag == !(typeTags.TypeInfoVararg))
			or (argTypeInfo.tag == !(typeTags.TypeInfoVararg))
		then
			local varargSig = argTypeInfo or argTypesOut[#argTypesOut]
			argTypeInfo     = varargSig.itemType
		end

		-- Note: We don't need to get too fancy with validation here as the return is validated later.
		if not argTypeInfo then
			typeError(state, returnNode, "Too many values specified for return.")
		end

		return argTypeInfo

	elseif strict then
		!!(NO_EXPECTATION)

	elseif nodeType == !(nodeTypes.AstCall) then
		local call           = node.parent
		local i              = indexOf(call.arguments, node) or !!(NO_EXPECTATION)
		local calleeTypeInfo = call.callee.inferredType

		if not calleeTypeInfo then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `call.callee`, nil, `nil`)
		end

		local argTypesIn  = calleeTypeInfo.argumentTypesIn
		local argTypeInfo = argTypesIn[i]

		if
			(not argTypeInfo and argTypesIn[1] and argTypesIn[#argTypesIn].tag == !(typeTags.TypeInfoVararg))
			or (argTypeInfo.tag == !(typeTags.TypeInfoVararg))
		then
			local varargSig = argTypeInfo or argTypesIn[#argTypesIn]
			argTypeInfo     = varargSig.itemType
		end

		-- Note: We don't need to get too fancy with validation here as the call is validated later.
		if not argTypeInfo then
			typeError(state, call, "Too many arguments specified for call.")
		end

		return argTypeInfo

	else
		!!(NO_EXPECTATION)
	end
	errorInternal()
end



--[[
function _G.getDeclarationThatExpressionIsConstantValueFor(expr)
	local scope, statement = getClosestScope(expr)

	if not (statement.nodeType == !(nodeTypes.AstAssignment) and statement.forDeclaration) then  return  end

	local assignment = statement
	local i          = indexOf(assignment.values, expr)
	local decl       = assignment.declarations[i]

	if not (decl and decl.isConstant) then  return nil  end

	return decl
end
]]



function _G.followIdentifiersToConstantValue(constExpr)
	while constExpr.nodeType == !(nodeTypes.AstIdentifier) do
		local decl = constExpr.declaration
		constExpr  = decl.assignment.values[decl.assignmentIndex]
	end
	return constExpr
end


