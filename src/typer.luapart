--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	areConstantTreesEqual
	areMultipleValuesEnabledAtPosition
	checkBinaryOperation
	crawl
	createTypeNodeFromInfo
	findDeclaration, findPublicDeclarationInScope, findMemberDeclaration, findDynamicMemberDeclaration, canNodeSeeDeclaration, printDeclarationChain
	findInferredPreloadDeclaration
	followIdentifiersToConstantValue
	getAssignmentValue
	getDeclarationValue, isDeclarationGlobal, isDeclarationConstant, isDeclarationWritable, isDeclarationImperative, shouldDeclarationValueDefinitivelyBeConstant
	getLambda
	inferNode, queueForReinfer
	isExpressionConstant, isExpressionExactlyOneValue
	isPartOfAnyDeclaration
	isScope, isScopeDeclarative, isScopeImperative
	isTypeSimple, isTypeNumeric, isTypeTableLike, isTypePublic, isTypeCompatibleWith, doesStructInherit, adjustTypeToOne, compareIdsOfTypes
	newTypeInfo, markTypeAsReady, isTypeBuiltin, getTypeInfo*
	prepareToRun
	simplifyExpressionIfConstant, simplifyTypeExpression
	typeError*, typeErrorAfter, typeMessage
	wrapInImplicitCast

--============================================================]]



!local structTypeInfo = struct

!struct"_TypeInfo"{
	{`tag`,     0}, -- This is like the "type of type" or the "type group". The word "type" is used in so many places so we call it "tag" here to make it less confusing.
	{`id`,      0},
	{`isReady`, false},
}

local !structTypeInfo"TypeInfoAny:_TypeInfo"   {_overrides={{`tag`,TYPE_ANY}}}
local !structTypeInfo"TypeInfoBool:_TypeInfo"  {_overrides={{`tag`,TYPE_BOOL}}}
local !structTypeInfo"TypeInfoInt:_TypeInfo"   {_overrides={{`tag`,TYPE_INT}}}
local !structTypeInfo"TypeInfoNone:_TypeInfo"  {_overrides={{`tag`,TYPE_NONE}}}
local !structTypeInfo"TypeInfoFloat:_TypeInfo" {_overrides={{`tag`,TYPE_FLOAT}}}
local !structTypeInfo"TypeInfoString:_TypeInfo"{_overrides={{`tag`,TYPE_STRING}}}
local !structTypeInfo"TypeInfoTable:_TypeInfo" {_overrides={{`tag`,TYPE_TABLE}}}
local !structTypeInfo"TypeInfoType:_TypeInfo"  {_overrides={{`tag`,TYPE_TYPE}}}

local !structTypeInfo"TypeInfoVoid:_TypeInfo"       {_overrides={{`tag`,TYPE_VOID}}}
local !structTypeInfo"TypeInfoPlaceholder:_TypeInfo"{_overrides={{`tag`,TYPE_PLACEHOLDER}}}

_G.SIMPLE_TYPES = !({
	-- These small type infos don't have any extra information.
	[TYPE_ANY]    = true,
	[TYPE_BOOL]   = true,
	[TYPE_INT]    = true,
	[TYPE_NONE]   = true,
	[TYPE_FLOAT]  = true,
	[TYPE_STRING] = true,
	[TYPE_TABLE]  = true,
	[TYPE_TYPE]   = true,
})

local !structTypeInfo"TypeInfoArray:_TypeInfo"{
	_overrides={{`tag`,TYPE_ARRAY}},
	{`itemType`, nil}, -- TypeInfo
}

local !structTypeInfo"TypeInfoVararg:_TypeInfo"{
	_overrides={{`tag`,TYPE_VARARG}},
	{`itemType`, nil}, -- TypeInfo
}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{ -- AKA function signature.
	_overrides={{`tag`,TYPE_FUNCTION}},
	{`argumentTypesIn`,  {}}, -- []TypeInfo  @Cleanup: Use TypeInfoList here?
	{`argumentTypesOut`, {}}, -- []TypeInfo  @Cleanup: Use TypeInfoList here?
	{`isPolymorphic`,    false},
}

local !struct"TypeInfoStructMember"{
	{`name`,     ""},
	{`typeInfo`, nil},
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	_overrides={{`tag`,TYPE_STRUCT}},

	{`astNode`,       nil}, -- AstStruct
	{`name`,          ""},  -- Filled in during definition.

	{`kind`,          STRUCT_KIND_NORMAL}, -- STRUCT_KIND_NORMAL|STRUCT_KIND_TABLE|STRUCT_KIND_ARRAY
	{`keyType`,       nil}, -- TypeInfo  Used if kind==STRUCT_KIND_TABLE.
	{`valueType`,     nil}, -- TypeInfo  Used if kind==STRUCT_KIND_TABLE or kind==STRUCT_KIND_ARRAY.

	{`members`,       {}},  -- []TypeInfoStructMember
	{`hasMembers`,    false},

	{`isPolymorphic`, false},
}

local !struct"TypeInfoEnumMember"{
	{`name`, ""},
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	_overrides={{`tag`,TYPE_ENUM}},
	{`astNode`,        nil}, -- AstEnum
	{`name`,           ""},
	{`memberTypeInfo`, nil}, -- Must be one of these primitive types: int, string, type, bool or float.
	{`members`,        {}},  -- []TypeInfoEnumMember
}

local !structTypeInfo"TypeInfoNamespace:_TypeInfo"{
	_overrides={{`tag`,TYPE_NAMESPACE}},
	{`scope`, nil}, -- AstScope
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	_overrides={{`tag`,TYPE_COMPOUND}},
	-- [1]=typeInfo1, ...
}

local !structTypeInfo"TypeInfoList:_TypeInfo"{ -- Special type used for returns from calls (both when sending and receiving).
	_overrides={{`tag`,TYPE_LIST}},
	-- [1]=typeInfo1, ...
}



-- typeInfo = newTypeInfo( compilationState, TypeInfoCreator )
function _G.newTypeInfo(state, TypeInfoCreator)
	!ifDEBUG `if not TypeInfoCreator then  errorInternal(2, "No TypeInfoCreator specified.")  end`

	state.lastTypeId = state.lastTypeId+1

	local typeInfo   = TypeInfoCreator()
	typeInfo.id      = state.lastTypeId

	--[[
	if typeInfo.id == 22 then
		errorInternal("DEBUG")
	end
	--]]

	return typeInfo
end

function _G.markTypeAsReady(state, typeInfo)
	typeInfo.isReady = true
	if state.runnerWriter and isTypePublic(typeInfo) then
		getPublicType(state, typeInfo)
	end
end

do
	local BUILTIN_TYPE_STRUCTS = {
		["any"]         = TypeInfoAny,
		["bool"]        = TypeInfoBool,
		["int"]         = TypeInfoInt,
		["none"]        = TypeInfoNone,
		["float"]       = TypeInfoFloat,
		["string"]      = TypeInfoString,
		["table"]       = TypeInfoTable,
		["Type"]        = TypeInfoType,        -- The result of e.g. type_of(int) or type_of(type_of(expression)).
		["void"]        = TypeInfoVoid,        -- Used when no useful type is expected or available.
		["placeholder"] = TypeInfoPlaceholder, -- Used in polymorphic functions.
	}
	local BUILTIN_TYPE_TAG_TO_NAME = {
		[!(TYPE_ANY)]         = "any",
		[!(TYPE_BOOL)]        = "bool",
		[!(TYPE_INT)]         = "int",
		[!(TYPE_NONE)]        = "none",
		[!(TYPE_FLOAT)]       = "float",
		[!(TYPE_STRING)]      = "string",
		[!(TYPE_TABLE)]       = "table",
		[!(TYPE_TYPE)]        = "Type",
		[!(TYPE_PLACEHOLDER)] = "placeholder",
	}

	function _G.getTypeInfoForBuiltinType(state, typeName)
		local typeInfo = state.builtinTypeInfos[typeName]

		if not typeInfo then
			local TypeInfoCreator            = BUILTIN_TYPE_STRUCTS[typeName] or errorInternal(tostring(typeName))
			typeInfo                         = newTypeInfo(state, TypeInfoCreator)
			state.builtinTypeInfos[typeName] = typeInfo

			table.insert(state.allTypeInfos,                    typeInfo)
			table.insert(state.allTypeInfosByTag[typeInfo.tag], typeInfo)
			markTypeAsReady(state, typeInfo)
		end

		return typeInfo
	end

	-- bool, typeName = isTypeBuiltin( typeInfo )
	function _G.isTypeBuiltin(typeInfo)
		local typeName = BUILTIN_TYPE_TAG_TO_NAME[typeInfo.tag]
		if not typeName then  return false, ""  end

		return true, typeName
	end
end

local function doesLambdaHaveSignature(lambda, funcSig)
	local argsIn     = lambda.argumentsIn
	local argTypesIn = funcSig.argumentTypesIn
	if (argsIn and #argsIn.arguments or 0) ~= #argTypesIn then  return false  end

	local argsOut     = lambda.argumentsOut
	local argTypesOut = funcSig.argumentTypesOut
	if (argsOut and #argsOut.arguments or 0) ~= #argTypesOut then  return false  end

	if argsIn then
		for i, arg in ipairs(argsIn.arguments) do
			if arg.declaration.name.inferredType ~= argTypesIn[i] then  return false  end
		end
	end
	if argsOut then
		for i, arg in ipairs(argsOut.arguments) do
			if arg.declaration.name.inferredType ~= argTypesOut[i] then  return false  end
		end
	end

	-- if lambda.isPolymorphic ~= funcSig.isPolymorphic then  return false  end  -- Not needed when using dumbHash.

	return true
end

function _G.getTypeInfoForLambda(state, lambda)
	local argsIn   = lambda.argumentsIn
	local argsOut  = lambda.argumentsOut
	local dumbHash = 0

	if lambda.isPolymorphic then
		dumbHash = -(1 + (argsIn and #argsIn.arguments or 0) + (argsOut and #argsOut.arguments*0x100 or 0))

	else
		if argsIn then
			for argIndex, arg in ipairs(argsIn.arguments) do
				local argType = arg.declaration.name.inferredType
				if not argType then  return nil  end
				dumbHash = dumbHash+argType.id*argIndex*argIndex
			end
		end
		if argsOut then
			for argIndex, arg in ipairs(argsOut.arguments) do
				local argType = arg.declaration.name.inferredType
				if not argType then  return nil  end
				dumbHash = dumbHash+argType.id*argIndex*argIndex*0x1000
			end
		end
	end

	local byTagAndValue      = state.allTypeInfosByTagAndValue[!(TYPE_FUNCTION)]
	local typeInfoCached     = byTagAndValue[dumbHash] -- Linked list where the first key is the hash and the rest are type infos.
	local typeInfoCachedLast = nil

	while typeInfoCached do
		if doesLambdaHaveSignature(lambda, typeInfoCached) then  return typeInfoCached  end
		typeInfoCachedLast = typeInfoCached
		typeInfoCached     = byTagAndValue[typeInfoCached]
	end

	local funcSig         = newTypeInfo(state, TypeInfoFunction)
	funcSig.isPolymorphic = lambda.isPolymorphic

	local placeholderType       = lambda.isPolymorphic and getTypeInfoForBuiltinType(state, "placeholder"  ) or nil
	local placeholderTypeVararg = placeholderType      and getTypeInfoForVararg     (state, placeholderType) or nil

	if argsIn then
		for i, arg in ipairs(argsIn.arguments) do
			funcSig.argumentTypesIn[i]
				=   placeholderType
				and (arg.declaration.name.nodeType == !(AST_VARARG) and placeholderTypeVararg or placeholderType)
				or  arg.declaration.name.inferredType
				or  errorInternal(state, arg)
		end
	end
	if argsOut then
		for i, arg in ipairs(argsOut.arguments) do
			funcSig.argumentTypesOut[i]
				=   placeholderType
				and (arg.declaration.name.nodeType == !(AST_VARARG) and placeholderTypeVararg or placeholderType)
				or  arg.declaration.name.inferredType
				or  errorInternal(state, arg)
		end
	end

	table.insert(state.allTypeInfos,                        funcSig)
	table.insert(state.allTypeInfosByTag[!(TYPE_FUNCTION)], funcSig)
	byTagAndValue[typeInfoCachedLast or dumbHash] = funcSig
	markTypeAsReady(state, funcSig)
	return funcSig
end

do
	local function getTypeInfoForListOrCompoundType(state, typeInfos, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfosByTag[tag]) do
			if areArraysEqual(typeInfos, typeInfoCached) then  return typeInfoCached  end
		end

		local typeInfo = newTypeInfo(state, schematicForTypeInfo)
		copyToArray(typeInfos, typeInfo)

		table.insert(state.allTypeInfos,           typeInfo)
		table.insert(state.allTypeInfosByTag[tag], typeInfo)
		markTypeAsReady(state, typeInfo)
		return typeInfo
	end

	function _G.getTypeInfoForList(state, typeInfos)
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(TYPE_LIST), TypeInfoList)
	end

	-- Note: typeInfos is expected to be sorted by type ID already if doSort is false.
	function _G.getTypeInfoForCompoundType(state, typeInfos, doSort)
		!ASSERT `type(doSort) == "boolean"`
		if doSort then
			table.sort(typeInfos, compareIdsOfTypes)
		end
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(TYPE_COMPOUND), TypeInfoCompound)
	end
end

do
	local function getTypeInfoForArrayOrVararg(state, itemType, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfosByTag[tag]) do
			if itemType == typeInfoCached.itemType then  return typeInfoCached  end
		end

		local typeInfo    = newTypeInfo(state, schematicForTypeInfo)
		typeInfo.itemType = itemType or errorInternal()

		table.insert(state.allTypeInfos,           typeInfo)
		table.insert(state.allTypeInfosByTag[tag], typeInfo)
		markTypeAsReady(state, typeInfo)
		return typeInfo
	end

	function _G.getTypeInfoForArray(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(TYPE_ARRAY), TypeInfoArray)
	end

	function _G.getTypeInfoForVararg(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(TYPE_VARARG), TypeInfoVararg)
	end
end

function _G.getTypeInfoForNamespace(state, scope)
	!ASSERT `scope`

	local byTagAndValue  = state.allTypeInfosByTagAndValue[!(TYPE_NAMESPACE)]
	local typeInfoCached = byTagAndValue[scope]
	if typeInfoCached then  return typeInfoCached  end

	local namespaceInfo = newTypeInfo(state, TypeInfoNamespace)
	namespaceInfo.scope = scope

	table.insert(state.allTypeInfos,                         namespaceInfo)
	table.insert(state.allTypeInfosByTag[!(TYPE_NAMESPACE)], namespaceInfo)
	byTagAndValue[scope] = namespaceInfo
	markTypeAsReady(state, namespaceInfo)
	return namespaceInfo
end



-- Note: The expression must already be inferred!
function _G.getTypeRepresentedByExpression(expr)
	!ASSERT `expr.inferredType`

	if expr.nodeType == !(AST_TYPE) then
		local typeNode = expr
		return typeNode.representedType
	elseif expr.nodeType == !(AST_STRUCT) then
		local struct = expr
		return struct.representedType
	elseif expr.nodeType == !(AST_ENUM) then
		local enum = expr
		return enum.representedType
	elseif expr.nodeType == !(AST_TYPE_OF) then
		local typeOf = expr
		return typeOf.representedType
	elseif expr.nodeType == !(AST_ACCESS) then -- Not sure if this is needed. @Cleanup
		local access = expr
		return access.representedType -- May be nil.

	elseif expr.nodeType == !(AST_CAST) then
		local cast = expr
		return
			cast.inferredType.tag == !(TYPE_TYPE) -- Is this check needed?
			and getTypeRepresentedByExpression(cast.expression)
			or  nil

	elseif expr.nodeType == !(AST_IDENTIFIER) then
		local ident = expr
		return ident.declaration.valueTypeInfo -- May be nil.
	elseif expr.nodeType == !(AST_BAKE) then
		local bake = expr
		return bake.name.declaration.valueTypeInfo -- May be nil.

	elseif expr.inferredType.tag == !(TYPE_TYPE) then
		errorInternal("Incomplete: Unhandled node type: %s", getFriendlyTypeInfoName(expr.inferredType))
	else
		return nil
	end
end

-- Note: The expression must already be inferred!
function _G.requireTypeRepresentedByExpression(state, expr)
	local typeInfoRepresented = getTypeRepresentedByExpression(expr)
	if typeInfoRepresented then  return typeInfoRepresented  end

	local typeInfo = expr.inferredType

	if typeInfo.tag == !(TYPE_LIST) then
		typeError(state, expr, "Expected a type. This is a function call.")
	elseif typeInfo.tag ~= !(TYPE_TYPE) then
		typeError(state, expr, "Expected a type. (Got %s)", getFriendlyTypeInfoName(typeInfo))
	elseif not isExpressionConstant(state, expr, false) then
		-- @UX: Better message for foreign values.
		typeError(state, expr, "Expected a constant. (Got variable of type '%s')", getFriendlyTypeInfoName(typeInfo))
	else
		!ifDEBUG `print(getFriendlyTypeInfoName(typeInfo))`
		errorInternal(state, expr, "The expression should represent a type but we somehow don't have any TypeInfo.")
	end
end



function _G.isScope(node)  return SCOPE_SET[node.nodeType] or false  end

function _G.isScopeDeclarative(scope)  return SCOPE_SET_DECLARATIVE[scope.nodeType] or false  end
function _G.isScopeImperative (scope)  return SCOPE_SET_IMPERATIVE [scope.nodeType] or false  end



function _G.getLambda(node)
	return astFindParent1(node, !(AST_LAMBDA))
end



-- declaration, fromUsing = findDeclaration( compilationState, startNode, name [, declarationToIgnore ] )
function _G.findDeclaration(state, startNode, name, declToIgnore)
	local scope = isScope(startNode) and startNode or astFindParentScope(startNode)

	while scope do
		-- This seem a little bit @Ugly maybe. How does this compare to polymorphic functions regarding declarations
		-- existing directly in the scope? (Baked values in functions probably set decl.checkedRedeclaration.)
		while scope.nodeType == !(AST_STRUCT) and scope.isPolymorphic do
			scope = astFindParentScope(scope)
			if not scope then  return  end
		end

		for _, decl in ipairs(scope.declarations) do
			if decl ~= declToIgnore and decl.name.name == name and canNodeSeeDeclaration(state, startNode, decl) then
				return decl, nil
			end
		end

		-- @Speed: Don't re-check already checked declarations. (Any potential speed-up may be neglectable though. Need to test with a bigger program.)

		for _, import in ipairs(scope.imports) do
			if import.fileScope then
				for _, decl in ipairs(import.fileScope.declarations) do
					if decl ~= declToIgnore and isDeclarationExported(decl) and decl.name.name == name then
						return decl, nil
					end
				end
			end
		end

		for _, using in ipairs(scope.usings) do
			if using.scope then
				local nodeType    = using.scope.nodeType
				local onlyExports = !!(CONST_SET{ AST_FILE_SCOPE, AST_GLOBAL_SCOPE, AST_NAMESPACE })[nodeType]

				for _, decl in ipairs(using.scope.declarations) do
					if
						decl.name.name == name
						and (not onlyExports or isDeclarationExported(decl))
						and decl ~= declToIgnore
						and (
							isDeclarationConstant(decl)
							or (
								using.variableDeclaration
								and canNodeSeeDeclaration(state, startNode, using.variableDeclaration)
							)
						)
					then
						return decl, using
					end
				end
			end
		end

		for _, decl in ipairs(scope.declarationsInTree[name] or EMPTY_TABLE) do
			if decl ~= declToIgnore and canNodeSeeDeclaration(state, startNode, decl) then
				return decl, nil
			end
		end

		-- Don't cross any module boundary!
		if scope.nodeType == !(AST_FILE_SCOPE) and scope.isModule then
			break
		end

		scope = astFindParentScope(scope)
	end

	return nil, nil
end

function _G.findPublicDeclarationInScope(state, scope, name)
	!ASSERT `name`
	if (scope.nodeType == !(AST_FILE_SCOPE) and scope.isModule) or scope.nodeType == !(AST_NAMESPACE) then
		for _, decl in ipairs(scope.declarations) do
			if isDeclarationExported(decl) and decl.name.name == name then  return decl  end
		end
	else
		for _, decl in ipairs(scope.declarations) do
			if decl.name.name == name then  return decl  end
		end
	end

	return nil
end
function _G.findMemberDeclaration(state, scope, name)
	!ASSERT `name`
	for _, decl in ipairs(scope.declarations) do
		if decl.name.name == name then  return decl  end
	end
	return nil
end
function _G.findDynamicMemberDeclaration(state, scope, name)
	!ASSERT `name`
	for _, decl in ipairs(scope.declarations) do
		if decl.name.name == name then
			return decl.kind == !(DECL_KIND_LOCAL_VAR) and decl or nil
		end
	end
	return nil
end

function _G.findDeclarationInEnumForValue(state, enum, constValueExpr)
	for _, decl in ipairs(enum.declarations) do
		assert(constValueExpr.nodeType == decl.value.nodeType)

		if decl.value.nodeType == !(AST_LITERAL) then
			if decl.value.value == constValueExpr.value then  return decl  end

		elseif decl.value.nodeType == !(AST_TYPE) then
			if decl.value.representedType == constValueExpr.representedType then  return decl  end

		else
			errorUnhandledNodeType(state, constValueExpr)
		end
	end

	return nil
end

function _G.canNodeSeeDeclaration(state, node, decl)
	-- It doesn't matter if this is true and we're in a declarative scope because we check that in the loop below.
	local canSeeImperativeVariables = (decl.kind == !(DECL_KIND_LOCAL_VAR) --[[or decl.kind == !(DECL_KIND_READ_ONLY)]])

	local name                     = decl.name.name
	local nodeScope, nodeStatement = astFindParentScope(node)
	local nodeScope0               = nodeScope

	if nodeStatement.nodeType == !(AST_DECLARATION) then
		nodeStatement = nodeStatement.assignment or nodeStatement -- Not sure if needed. See :DeclarationAssignment
	elseif nodeStatement.nodeType == !(AST_ARGUMENTS) then
		nodeStatement = astFindParent1(node, !(AST_ARGUMENT)) or errorInternal()
	end

	while true do
		if not indexOf(nodeScope.declarations, decl) then
			-- void  (Keep looking through parent scopes and update canSeeImperativeVariables as we go.)

		-- Non-static declarations are always visible.
		elseif not (decl.kind == !(DECL_KIND_LOCAL_VAR) --[[or decl.kind == !(DECL_KIND_READ_ONLY)]]) then
			return true

		-- Everything in declarative scopes is always visible EXCEPT (variable) struct members
		-- (and enum members but those don't matter as they're always constant).
		elseif isScopeDeclarative(nodeScope) then
			return not (
				nodeScope.nodeType == !(AST_STRUCT)
				and nodeScope ~= nodeScope0
			)

		elseif not canSeeImperativeVariables then
			return false

		-- Imperative scopes
		----------------------------------------------------------------

		elseif nodeScope.nodeType == !(AST_FOR) then
			-- This is really a combination of a declarative scope and an imperative scope. (Not sure if this is good. 2020-03-19)
			-- @Robustness: Give a makeover similar to AST_LAMBDA here below? 2020-04-27
			return true

		elseif nodeScope.nodeType == !(AST_LAMBDA) then
			-- Lambdas act as imperative scopes for arguments, but declarative scopes otherwise. (Could maybe use some @Cleanup.)
			local lambda = nodeScope
			if lambda ~= nodeScope0 then  return true  end

			-- We should only get here if both node and decl is inside arguments.
			local arg = decl.parent
			!ASSERT("arg.nodeType           == "..AST_ARGUMENT)
			!ASSERT("nodeStatement.nodeType == "..AST_ARGUMENT)

			!if DEBUG then
				if state.tokens.file[arg.token] ~= state.tokens.file[node.token] then
					typeError2(state, node, "Internal compiler error: node", arg, "arg")
				end
			!end

			return (arg.token < nodeStatement.token)

		elseif nodeScope.nodeType == !(AST_BLOCK) then
			local block = nodeScope

			-- Note: If the node is inside the initial assignment then we need to treat the declaration
			-- and the assignment as if they were the same statement. Otherwise the assignment will be
			-- able to see it's own declarations, which is illegal! :DeclarationAssignment
			local declScope, declStatement = astFindParentScope(decl.assignment or decl)
			assert(declScope == block)

			return (declStatement.token < nodeStatement.token)

		----------------------------------------------------------------

		else
			errorUnhandledNodeType(state, nodeScope)
		end

		if canSeeImperativeVariables and nodeScope.nodeType == !(AST_LAMBDA) and not itemWith1(nodeScope.captures, `name`, name) then
			-- Lambdas act as the only boundary between imperative and declarative
			-- scopes right now. Maybe this will change in the future? 2019-12-07
			canSeeImperativeVariables = false
		end

		nodeScope, nodeStatement = astFindParentScope(nodeScope)
		if not nodeScope then  return false  end -- This shouldn't happen I don't think, unless decl and node is not part of the same tree.
	end
end

-- printDeclarationChain( [ file=io.stdout, ] compilationState, declaration, typeName )
function _G.printDeclarationChain(file, state, decl, typeName)
	if type(file) ~= "userdata" then  return printDeclarationChain(io.stdout, file, state, decl)  end

	!local MAX_CHAIN_LENGTH = 10

	for _ = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(file, state, decl.name, "Info", "...here is '%s' declared.", typeName)

		local declCurrent = decl.name.declaration -- @Cleanup: Can we use decl.name.declaration instead here?
		if not declCurrent then  break  end

		decl            = nil
		local valueExpr = getDeclarationValue(declCurrent)

		if valueExpr then
			while valueExpr.replacing do  valueExpr = valueExpr.replacing  end

			if valueExpr.nodeType == !(AST_IDENTIFIER) then
				local ident = valueExpr
				typeName    = ident.name
				decl        = ident.declaration or findDeclaration(state, ident, typeName, declCurrent)
			end
		end

		if not decl then  break  end
	end
end



-- declaration = findInferredPreloadDeclaration( state, dependent, name, tag )
-- Returns nil if waiting.
function _G.findInferredPreloadDeclaration(state, dependent, name, tag)
	local module = itemWith2(state.globalScope.fileScopes, "isModule",true, "moduleName","preload")
		or errorInternal(2, state, dependent, "'preload' module not loaded.")

	local decl = findPublicDeclarationInScope(state, module, name)
		or errorInternal(2, state, dependent, "No declaration '%s' in 'preload' module.", name)

	if not decl.name.inferredType then
		!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_INFERRED, `decl`, `nil`)
	end

	!ASSERT(`decl.valueTypeInfo`,            nil, `decl`)
	!ASSERT(`decl.valueTypeInfo.tag == tag`, nil, `decl`)

	return decl
end



function _G.typeError(state, node, s, ...)
	nodeError(state, node, "Typer", s, ...)
end
function _G.typeErrorAfter(state, node, s, ...)
	nodeErrorAfter(state, node, "Typer", s, ...)
end

function _G.typeError2(state, node1,s1, node2,s2)
	!TRACE(2)
	printerr()
	!ifDEBUG `astPrint(node1)`
	typeMessage(io.stderr, state, node1, "Error", "%s", s1)
	!ifDEBUG `astPrint(node2)`
	typeMessage(io.stderr, state, node2, "Info",  "%s", s2)
	exitFailure()
end
function _G.typeError3(state, node1,s1, node2,s2, node3,s3)
	!TRACE(2)
	printerr()
	!ifDEBUG `astPrint(node1)`
	typeMessage(io.stderr, state, node1, "Error", "%s", s1)
	!ifDEBUG `astPrint(node2)`
	typeMessage(io.stderr, state, node2, "Info",  "%s", s2)
	!ifDEBUG `astPrint(node3)`
	typeMessage(io.stderr, state, node3, "Info",  "%s", s3)
	exitFailure()
end

-- typeMessage( [ outputFile=io.stdout, ] compilationState, node, label, formatString, ... )
function _G.typeMessage(file, state, node, label, s, ...)
	if type(file) ~= "userdata" then  return typeMessage(io.stdout, file, state, node, label, s, ...)  end
	return nodeMessage(file, state, node, label, "Typer", s, ...)
end



function _G.getFriendlyTypeInfoName(typeInfo)
	local name = ""

	if typeInfo.tag == !(TYPE_STRUCT) then
		local structInfo = typeInfo
		name             = structInfo.name

		if structInfo.astNode.polymorphSourceStruct then
			local params = {}

			for argIndex, declBaked in ipairs(structInfo.astNode.bakeDeclarations) do
				local valueExpr = declBaked.value

				if valueExpr.nodeType == !(AST_LITERAL) then
					local literal    = valueExpr
					params[argIndex] = literal.literalType == !(LITERAL_STRING) and F("%q", literal.value) or tostring(literal.value)

				elseif valueExpr.nodeType == !(AST_TYPE) then
					local typeNode   = valueExpr
					params[argIndex] = getFriendlyTypeInfoName(typeNode.representedType)

				else
					params[argIndex] = "~"
				end
			end

			name
				= structInfo.astNode.polymorphSourceStruct.representedType.name
				.."("..table.concat(params, ",")..")"
		end

	elseif typeInfo.tag == !(TYPE_ENUM) then
		local enumInfo = typeInfo
		name           = enumInfo.name

	elseif typeInfo.tag == !(TYPE_FUNCTION) then
		local funcSig      = typeInfo
		local typeTextsIn  = {}
		local typeTextsOut = {}

		for i, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			if i > 1 then  table.insert(typeTextsIn, ",")  end
			table.insert(typeTextsIn, getFriendlyTypeInfoName(argTypeInfo))
		end

		for i, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			typeTextsOut[i] = getFriendlyTypeInfoName(argTypeInfo)
		end

		name = typeTextsOut[1]
			and F("function(%s)->(%s)", table.concat(typeTextsIn), table.concat(typeTextsOut, ","))
			or  F("function(%s)->void", table.concat(typeTextsIn))

	elseif typeInfo.tag == !(TYPE_COMPOUND) then
		local compound  = typeInfo
		local typeTexts = {}

		for i, compoundItem in ipairs(compound) do
			typeTexts[i] = getFriendlyTypeInfoName(compoundItem)
		end

		name = table.concat(typeTexts, "|")

	elseif typeInfo.tag == !(TYPE_LIST) then
		local listSig   = typeInfo
		local typeTexts = {}

		for i, typeInfo in ipairs(listSig) do
			typeTexts[i] = getFriendlyTypeInfoName(typeInfo)
		end

		name = "list("..table.concat(typeTexts, ", ")..")"

	elseif typeInfo.tag == !(TYPE_ARRAY) then
		local arraySig = typeInfo
		name           = "array("..getFriendlyTypeInfoName(arraySig.itemType)..")"

	elseif typeInfo.tag == !(TYPE_VARARG) then
		local varargSig = typeInfo
		name            = "..."..getFriendlyTypeInfoName(varargSig.itemType)

	elseif typeInfo.tag == !(TYPE_NAMESPACE) then
		local namespaceInfo = typeInfo
		local scope         = namespaceInfo.scope
		local scopeParent   = scope.parent

		if scopeParent.nodeType == !(AST_DECLARATION) and isDeclarationConstant(scopeParent) and scope == scopeParent.value then
			name = 'namespace("'..scopeParent.name.name..'")'
		else
			name = 'namespace'
		end
	end

	if name == "" then
		name = TYPE_NAMES[typeInfo.tag] or errorInternal("%d", typeInfo.tag)
	end

	-- !(if DEBUG then)  name = name.."@"..typeInfo.id  !(end)

	return name
end



local nodeInferrers = {}

!(
local nodeNames = {}

local function NODE_INFERRER(funcHeaderCode)
	local replacements

	funcHeaderCode, replacements = funcHeaderCode:gsub("function +nodeInferrers%.(Ast%w+)", function(nodeName)
		if nodeNames[nodeName] then
			error("Duplicate node inferrer: "..nodeName)
		end
		nodeNames[nodeName] = true

		local nodeType = astStructNameToType[nodeName] or error(nodeName)
		return "nodeInferrers[--[["..nodeName.."]]"..nodeType.."] = function"
	end)

	assert(replacements == 1, funcHeaderCode)

	__LUA(funcHeaderCode)
end
)

function _G.isPartOfAnyDeclaration(identOrVararg)
	local parent = identOrVararg.parent

	if parent.nodeType == !(AST_DECLARATION) then
		local decl = parent
		return identOrVararg == decl.name

	elseif parent.nodeType == !(AST_ASSIGNMENT) then
		local assignment = parent
		if not assignment.forDeclaration then  return false  end

		local i = indexOf(assignment.targets, identOrVararg) -- Nil if identOrVararg is a value.
		return assignment.declarations[i] ~= nil

	else
		return false
	end
end

-- identifierEarly, identifierLate, extraShadowMessageEarly, extraShadowMessageLate = getEarlyAndLateForRedeclarationError( state, identifier1, identifier2 )
local function getEarlyAndLateForRedeclarationError(state, identEarly, identLate)
	local extraMessageEarly = ""
	local extraMessageLate  = ""

	-- Globals before locals.  @Incomplete: May need update since globals refactor. 2020-03-26
	if isDeclarationGlobal(identEarly.declaration) ~= isDeclarationGlobal(identLate.declaration) then
		if isDeclarationGlobal(identLate.declaration) then
			identEarly, identLate = identLate, identEarly
		end

	-- Static before dynamic.
	elseif isDeclarationStatic(identEarly.declaration) ~= isDeclarationStatic(identLate.declaration) then
		if isDeclarationStatic(identLate.declaration) then
			identEarly, identLate = identLate, identEarly
		end
		if isScopeImperative(astFindParentScope(identLate.declaration)) then
			extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope, unlike variables.)"
		end

	-- Low depth before high depth.
	-- Early in file before late in file.
	else
		local depthEarly = astGetDepth(identEarly)
		local depthLate  = astGetDepth(identLate)

		if depthLate < depthEarly or (depthLate == depthEarly and identLate.token < identEarly.token) then
			-- @Incomplete: Explicitly handle the identifiers being declared in different files. (May be unnecessary.)
			identEarly, identLate = identLate, identEarly
		end

		if isDeclarationConstant(identEarly.declaration) then
			if isScopeImperative(astFindParentScope(identEarly.declaration)) then
				extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope.)"
			end
		elseif identEarly.declaration.kind == !(DECL_KIND_STATIC) then
			extraMessageEarly = " (Note that static variables are visible to the whole scope.)" -- @Design: Not sure if this rule is good.
		end
	end

	return identEarly, identLate, extraMessageEarly, extraMessageLate
end

local function checkRedeclaration(state, ident, decl, isMember, scope)
	decl.checkedRedeclaration = true

	local declExisting = findDeclaration(state, ident, ident.name, decl)
	if not declExisting then  return  end
	!ASSERT `declExisting ~= decl`

	local scopeExisting = astFindParentScope(declExisting)

	-- Member.
	if isMember and decl.kind == !(DECL_KIND_LOCAL_VAR) and scope ~= scopeExisting then
		-- void  (Variable members never shadow anything.)

	-- Function overload. (Note: Overloads have to be registered before the identifier DEPEND_AND_RETURN on anything.)
	elseif
		isDeclarationConstant(decl) and isDeclarationConstant(declExisting)
		and decl        .value.nodeType == !(AST_LAMBDA)
		and declExisting.value.nodeType == !(AST_LAMBDA)
	then
		declExisting = getOverloadBase(declExisting) or declExisting

		if declExisting == decl then
			-- This simplifies finding an overload later.
			declExisting.overloadOf = declExisting
			table.insert(declExisting.overloads, declExisting)

		elseif scope ~= scopeExisting then
			-- void  Update: We now allow constant function declarations to shadow functions in other scopes. Overload "clusters" will continue being separated by scope.
			--[[
			local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, declExisting.name, ident)
			typeError2(state,
				identLate,  F("Trying to add a new overload to '%s' which is in another scope. Overloads must currently be declared in the same scope.", ident.name),
				identEarly, F("...here is the previous function.")
			)
			--]]

		elseif declExisting.overloadsLocked then
			typeError2(state,
				declExisting.name, F("Trying to add a new overload to '%s' after it's type has been inferred. Overloads currently has to happen in the same 'parsing cycle'.", ident.name),
				ident,             F("...this is the new overload.")
			)

		else
			decl.overloadOf = declExisting
			table.insert(declExisting.overloads, decl)

			local lambda         = decl.value
			local lambdaExisting = declExisting.value

			assert(not lambdaExisting.inferredType)

			-- This dependency means lambdaExisting won't get inferred until earliest next cycle
			-- by which time all overloads should have been added (I think). This should work as
			-- the first occurence of a name will make the second occurence wait before the
			-- second has been able to do anything. (This is true even when we remove unordered
			-- from the queue.)
			addDependency(state, lambdaExisting, !(DEPEND_NODE_INFERRED), lambda)
		end

	-- Non-shadow.
	elseif not decl.canShadow then
		local identEarly, identLate, extraMessageEarly, extraMessageLate = getEarlyAndLateForRedeclarationError(state, declExisting.name, ident)
		-- !ifDEBUG `identEarly, identLate = declExisting.name, ident`
		-- !ifDEBUG `astPrintTree(astFindCommonParent(identEarly, identLate))`
		typeError2(state,
			identLate,  F("'%s' has already been declared.%s", ident.name, extraMessageLate),
			identEarly, F("...it was declared here.%s", extraMessageEarly)
		)

	-- Shadow in same scope.
	elseif
		scope == scopeExisting
		or (
			-- We do not allow declarations on lambda bodies to shadow the lambda's arguments.
			scope.nodeType                         == !(AST_BLOCK)
			and astFindParentScope(scope).nodeType == !(AST_LAMBDA)
			and astFindParentScope(scope)          == scopeExisting
		)
	then
		typeError2(state,
			ident,             F("'%s' has already been declared in the same scope (which means name shadowing does not work).", ident.name),
			declExisting.name, F("...it was declared here.")
		)

	-- Shadowing something in an outer (or inner?) scope.
	-- @Robustness: Don't allow file-scope variables to be shadows (just like constants)?
	else
		-- void  (Valid shadow.)
	end
end

local function isPolymorphicLambda(node)
	return node.nodeType == !(AST_LAMBDA) and node.isPolymorphic
end
local function isPolymorphicStruct(node)
	return node.nodeType == !(AST_STRUCT) and node.isPolymorphic
end

local function inferIdentifierOrVararg(state, identOrVararg)
	local vararg    = identOrVararg.nodeType == !(AST_VARARG) and identOrVararg or nil
	local ident     = not vararg                              and identOrVararg or nil
	local parent    = identOrVararg.parent
	local decl      = identOrVararg.declaration
	local container = identOrVararg.queued.container

	-- 0. Things to ignore.  @Cleanup
	if ident and parent.nodeType == !(AST_CALL) and container ~= parent and container ~= parent.arguments and identOrVararg.queued.key == "key" and indexOf(parent.argumentsNamed, container) then
		moveToNextRelevantPipe(state, ident)
		return
	end

	-- 1. Loose identifier.
	if not isPartOfAnyDeclaration(identOrVararg) then
		if not decl then
			local using
			decl, using = findDeclaration(state, identOrVararg, identOrVararg.name)

			if not decl then
				!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_DECLARATION, `identOrVararg.name`)
			end

			identOrVararg.declaration = decl
			identOrVararg.fromUsing   = using
		end

		if
			-- Don't care about polymorphism/overloads in these contexts.
			vararg
			or (parent.nodeType == !(AST_LOCATION))
			or (parent.nodeType == !(AST_CALL)  and ident == parent.callee)
			or (parent.nodeType == !(AST_DEBUG) and parent.action == "print")
		then
			-- void

		-- Overloaded names refer to multiple things, so that's an error!
		elseif decl.overloadOf then
			local declBase = ident.declaration
			declBase       = getOverloadBase(declBase) or declBase

			if not declBase.name.inferredType then
				-- This is just so we get a better overload list in the error message.
				!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `declBase.name`)
			end

			!TRACE()
			printerr()
			typeMessage(io.stderr, state, ident, "Error", "'%s' has multiple overloads and we don't know which one this is referring to.", ident.name)
			for i, declOverload in ipairs(declBase.overloads) do
				typeMessage(io.stderr, state, declOverload.name, "Info", "...overload #%d.", i)
			end
			exitFailure()

		-- Polymorphic functions also contain the polymorphed functions and are thus a collection of functions, so referring to them may be a bad idea!
		-- (How does this work when calling a function from a module or a static struct member function? @Incomplete @Robustness)
		elseif isPolymorphicLambda(getDeclarationValue(decl) or decl) then
			typeError(state, ident, "Cannot refer to polymorphic function '%s' outside calls.", ident.name)

		-- Polymorphic structs are similar to polymorphed functions as they are collections of structs, so referring to them may be a bad idea too!
		-- (Also, like with the functions, think about modules. @Incomplete @Robustness)
		elseif isPolymorphicStruct(getDeclarationValue(decl) or decl) then
			typeErrorAfter(state, ident, "Missing arguments for polymorphic struct '%s'.", ident.name)
		end

		local typeInfo = decl.name.inferredType
		if not typeInfo then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `decl`)
		end
		if vararg and (vararg.surroundedByParentheses or not areMultipleValuesEnabledAtPosition(state, vararg)) then
			vararg.surroundedByParentheses = true
			typeInfo                       = adjustTypeToOne(state, vararg, typeInfo, true)
		end

		identOrVararg.inferredType = typeInfo

		if identOrVararg.fromUsing then
			-- @Cleanup: Move this to simplifyExpressionIfConstant()?
			!ASSERT `ident`
			local access        = astNewNode(AstAccess, ident.token, parent)
			access.object       = astCopy(ident.fromUsing.expression, access.token, access)

			local literal       = astNewNode(AstLiteral, access.token, access)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = ident.name
			access.member       = literal

			addUnqueuedChildrenToQueueRecursively(state, access)
			replaceQueuedNodeAndUnqueueOldTree(state, ident, access)
			-- Stay in the current pipe.

		else
			moveToNextRelevantPipe(state, identOrVararg)
			if ident then
				simplifyExpressionIfConstant(state, ident)
			end
		end

		return
	end

	!ASSERT("decl")
	!ASSERT("parent.nodeType == "..AST_DECLARATION.." or parent.nodeType == "..AST_ASSIGNMENT)

	-- 2. Assignment target in declaration (which is a copy of the identifier in the declaration).
	if parent.nodeType == !(AST_ASSIGNMENT) then
		local identInDecl = decl.name
		if not identInDecl.inferredType then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `identInDecl`)
		end
		identOrVararg.inferredType = identInDecl.inferredType

		moveToNextRelevantPipe(state, identOrVararg)
		return
	end

	-- 3. At this point we're defining a declared identifier.

	local scope = astFindParentScope(decl)

	if not scope then
		typeError(state, identOrVararg, "Internal compiler error: Could not find what scope '%s' is in.", identOrVararg.name)
	end

	local isEnumMember = scope.nodeType == !(AST_ENUM)
	local isMember     = isEnumMember or scope.nodeType == !(AST_STRUCT)

	-- Check for redeclaration/shadowing (before we DEPEND_AND_RETURN).
	if not (decl.checkedRedeclaration or decl.isDocumentation or vararg) then
		checkRedeclaration(state, ident, decl, isMember, scope)
	end

	local typeExpr = decl.type
	if typeExpr and not typeExpr.inferredType then
		!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `typeExpr`)
	end

	if isEnumMember then
		local enum = scope
		if not enum.representedType then
			-- AstEnum is the only scope that gets inferred before its declarations.
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `enum`)
		end
	end

	local valueExpr = getDeclarationValue(decl, true)
	if (not typeExpr or isDeclarationConstant(decl)) and not valueExpr.inferredType then
		!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `valueExpr`)
	end

	--
	-- No more dependencies for this identifier after this point!
	--

	decl.overloadsLocked = true

	-- Check that call signatures aren't too similar. Optional arguments could make several overloads match calls, i.e.:
	--   local func :: () {}
	--   local func :: (n:int=0) {}
	--   func() -- First or second?
	if decl.overloadOf == decl then
		for i = 1, #decl.overloads-1 do
			local decl1     = decl.overloads[i]
			local lambda1   = decl1.value
			local args1     = lambda1.argumentsIn and lambda1.argumentsIn.arguments
			local funcSig1  = lambda1.inferredType
			local argTypes1 = funcSig1.argumentTypesIn

			for i = i+1, #decl.overloads do
				local decl2     = decl.overloads[i]
				local lambda2   = decl2.value
				local args2     = lambda2.argumentsIn and lambda2.argumentsIn.arguments
				local funcSig2  = lambda2.inferredType
				local argTypes2 = funcSig2.argumentTypesIn

				if funcSig1 == funcSig2 then
					local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
					typeError2(state,
						identLate,  F("Call signatures for function overloads for '%s' are identical. (%s)", ident.name, getFriendlyTypeInfoName(funcSig1)),
						identEarly, F("...here is the other function.")
					)
				end

				-- local requiredCount1 = 0
				-- local requiredCount2 = 0

				-- @Incomplete @Robustness: Check that vararg works.
				for argIndex = 1, math.min(#argTypes1, #argTypes2)+1 do
					local argTypeInfo1 = argTypes1[argIndex]
					local argTypeInfo2 = argTypes2[argIndex]
					argTypeInfo1       = argTypeInfo1 and adjustTypeToOne(state, decl1.name, argTypeInfo1)
					argTypeInfo2       = argTypeInfo2 and adjustTypeToOne(state, decl2.name, argTypeInfo2)

					local isRequired1  = argTypeInfo1 ~= nil and args1[argIndex].isRequired
					local isRequired2  = argTypeInfo2 ~= nil and args2[argIndex].isRequired

					-- if isRequired1 then  requiredCount1 = requiredCount1+1  end
					-- if isRequired2 then  requiredCount2 = requiredCount2+1  end

					if not (isRequired1 or isRequired2) then
						local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
						typeError2(state,
							identEarly, F("Call signatures for function overloads (%s) are too similar.", ident.name),
							identLate,  F("...here is the other function.")
						)
					end

					if not (argTypeInfo1 and argTypeInfo1 == argTypeInfo2) then  break  end
				end

				--[[ This is a bit too restrictive!
				if requiredCount1 == requiredCount2 then
					for argIndex = 1, requiredCount1 do
						local argTypeInfo1 = adjustTypeToOne(state, decl1.name, argTypes1[argIndex])
						local argTypeInfo2 = adjustTypeToOne(state, decl2.name, argTypes2[argIndex])
						if
							isTypeCompatibleWith(argTypeInfo1, argTypeInfo2) or
							isTypeCompatibleWith(argTypeInfo2, argTypeInfo1)
						then
							local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
							typeError2(state,
								identEarly, F("Call signatures for function overloads (%s) are too similar. (Argument #%d, %s vs. %s)",
									ident.name,
									argIndex,
									getFriendlyTypeInfoName(argTypeInfo1),
									getFriendlyTypeInfoName(argTypeInfo2)
								)
								identLate, F("...here is the other function.")
							)
						end
					end
				end
				--]]
			end
		end
	end

	-- Tell parents that this declaration exists so we can detect more cases of shadowing.
	if not (decl.isDocumentation or decl.canShadow or vararg) then -- Should vararg do this? I think it's not needed.
		local parentScope = scope

		repeat
			local declarationsInTree = parentScope.declarationsInTree[ident.name]

			if not declarationsInTree then
				declarationsInTree = {}
				parentScope.declarationsInTree[ident.name] = declarationsInTree
			end

			table.insert(declarationsInTree, decl)

			if parentScope.nodeType == !(AST_FILE_SCOPE) and parentScope.isModule then  break  end

			parentScope = astFindParentScope(parentScope)
		until not parentScope
	end

	local typeInfo

	-- Specified type.
	if typeExpr then
		typeInfo = requireTypeRepresentedByExpression(state, typeExpr)

	-- Infer type from value.
	else
		!ASSERT(`valueExpr`, toLua("Missing both type and value from declaration."))
		!ASSERT(`not vararg`)

		if decl.value then
			typeInfo = valueExpr.inferredType
		else
			valueExpr, typeInfo = getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, nil, nil, nil)
		end
		typeInfo = adjustTypeToOne(state, valueExpr, typeInfo, true)
	end

	assert(typeInfo)
	local typeInfoForDecl = nil

	-- Do extra stuff in constant declarations.
	if isDeclarationConstant(decl) then
		valueExpr       = valueExpr or getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, nil, nil, nil)
		typeInfoForDecl = getTypeRepresentedByExpression(valueExpr)

		if isEnumMember then
			-- Note: AstEnum already validated that valueExpr's type is compatible with the enum.
			local enum     = scope
			local enumInfo = enum.representedType
			typeInfo       = enumInfo -- Kind of a @Hack, but maybe it's fine for enum members!

			if enumInfo.memberTypeInfo.tag == !(TYPE_TYPE) then
				-- This means you can for example say: local myVar:MyEnum.MY_TYPE
				assert(typeInfoForDecl)
			end
		end

		if typeInfo.tag == !(TYPE_TYPE) then
			if not typeInfoForDecl then
				errorInternal(state, valueExpr, "Missing what type this constant expression represents.")
			end

		elseif typeInfo.tag == !(TYPE_ENUM) then -- @Robustness: Actually detect whether we have a type enum and include it here above.
			-- void  For now we may or may not have a type enum and typeInfoForDecl.

		elseif typeInfo.tag == !(TYPE_PLACEHOLDER) then
			-- void  Just ignore this for now. We get here when placeholders are combined with auto-baking (which produces constants).

		elseif typeInfoForDecl then
			errorInternal(
				state, valueExpr, "type=%s, typeRepresented=%s",
				getFriendlyTypeInfoName(typeInfo), getFriendlyTypeInfoName(typeInfoForDecl)
			)
		end
	end

	if vararg then
		typeInfo = getTypeInfoForVararg(state, typeInfo)

		if vararg.surroundedByParentheses or not areMultipleValuesEnabledAtPosition(state, vararg) then
			vararg.surroundedByParentheses = true
			typeInfo                       = adjustTypeToOne(state, vararg, typeInfo, true)
		end
	end

	identOrVararg.inferredType = typeInfo
	decl.valueTypeInfo         = typeInfoForDecl -- May be nil.  @Cleanup: Move this and relevant code to nodeInferrers.AstDeclaration().

	!if DEBUG then
		if debug_onlyInferTypes then
			io.stdout:write("DEFINE ", identOrVararg.name ,":", getFriendlyTypeInfoName(typeInfo), " (", DECL_KIND_TITLES[decl.kind], ")")
			if typeInfoForDecl then  io.stdout:write(" (VALUE ", getFriendlyTypeInfoName(typeInfoForDecl), ")")  end
			io.stdout:write(" IN ")
			astPrint(astFindParentScope(decl))
		end
	!end

	moveToNextRelevantPipe(state, identOrVararg)
end

!NODE_INFERRER `function nodeInferrers.AstIdentifier(state, ident)`
	inferIdentifierOrVararg(state, ident)
end
!NODE_INFERRER `function nodeInferrers.AstVararg(state, vararg)`
	inferIdentifierOrVararg(state, vararg)
end

!NODE_INFERRER `function nodeInferrers.AstBlank(state, blank)`
	if blank.parent.nodeType == !(AST_DECLARATION) then
		local decl = blank.parent

		if not (decl.kind == !(DECL_KIND_LOCAL_VAR) --[[or decl.kind == !(DECL_KIND_READ_ONLY)]]) then
			typeError(state, blank, "Blank names in declarations require the declarations to be declarations of local variables.")
		elseif not isScopeImperative(astFindParentScope(decl)) then
			typeError(state, blank, "Blank names are only allowed in imperative contexts.")
		end

	elseif blank.parent.nodeType == !(AST_ASSIGNMENT) then
		local assignment = blank.parent
		if assignment.binaryOperation ~= "" then
			typeError(state, blank, "Blank names cannot be used in assignments with binary operations. (The operation here is '%s')", assignment.binaryOperation)
		end

	else
		errorUnhandledNodeType(state, blank)
	end

	blank.inferredType = getTypeInfoForBuiltinType(state, "any")
	moveToNextRelevantPipe(state, blank)
end

!NODE_INFERRER `function nodeInferrers.AstType(state, typeNode)`
	-- Note: typeNode.declaration may already be filled for generated type nodes.

	local decl = nil
	local typeInfo, typeInfoRepresented

	!if DEBUG then
		--[[
		if typeNode.kind == !(TYPE_KIND_UNSET) then
			astPrintTree(typeNode)
			errorInternal(state, typeNode)
		end
		--]]
	!end

	if typeNode.kind == !(TYPE_KIND_SIMPLE_BUILTIN) then
		typeInfoRepresented = getTypeInfoForBuiltinType(state, typeNode.typeName)
		typeInfo            = getTypeInfoForBuiltinType(state, "Type")

	elseif typeNode.kind == !(TYPE_KIND_FUNCTION) then
		local lambda = typeNode.functionHeader or errorInternal()

		if not lambda.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `lambda`)
		end
		assert(lambda.inferredType.tag == !(TYPE_FUNCTION))

		local funcSig       = getTypeInfoForLambda(state, lambda)
		typeInfoRepresented = funcSig
		typeInfo            = getTypeInfoForBuiltinType(state, "Type")

	elseif typeNode.kind == !(TYPE_KIND_ARRAY) then
		local itemTypeNode = typeNode.arrayItemType or errorInternal(state, typeNode)

		if not itemTypeNode.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `itemTypeNode`)
		end

		local itemTypeInfo = requireTypeRepresentedByExpression(state, itemTypeNode)
		if itemTypeInfo.tag == !(TYPE_NONE) then
			typeError(state, itemTypeNode, "Arrays cannot contain nil.")
		elseif itemTypeInfo.tag == !(TYPE_COMPOUND) and indexWith1(itemTypeInfo, "tag", !(TYPE_NONE)) then
			typeError(state, itemTypeNode, "Arrays cannot contain nil. (Item type is %s)", getFriendlyTypeInfoName(itemTypeInfo))
		end

		local arraySig      = getTypeInfoForArray(state, itemTypeInfo)
		typeInfoRepresented = arraySig
		typeInfo            = getTypeInfoForBuiltinType(state, "Type")

	elseif typeNode.kind == !(TYPE_KIND_COMPOUND) then
		for _, typeExpr in ipairs(typeNode.components) do
			if not typeExpr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `typeExpr`)
			end
		end

		-- Note: It's ok that these share the same table!
		local typeInfos  = {}        -- Keys are numbers.
		local typeIds    = typeInfos -- Keys are AstNode.
		local duplicates = typeInfos -- Keys are TypeInfo.

		local isFromCompound = {}

		for _, typeExpr in ipairs(typeNode.components) do
			!(
			local TEMPLATE_ERROR_DUPLICATE_TYPE = `
				printerr()
				typeMessage(io.stderr, state, typeExpr, "Error", "Duplicate type specified in $siteTitle. (%s)", getFriendlyTypeInfoName($typeInfoVar))
				if isFromCompound[$typeInfoVar] then
					typeMessage(io.stderr, state, duplicates[$typeInfoVar], "Info", "...this sub-compound type contains the same type.")
				else
					typeMessage(io.stderr, state, duplicates[$typeInfoVar], "Info", "...this is the same type.")
				end
				exitFailure()
			`
			local function ERROR_DUPLICATE_TYPE(siteTitle, typeInfoVar)
				local lua = templateToLua(TEMPLATE_ERROR_DUPLICATE_TYPE, {
					siteTitle   = siteTitle,
					typeInfoVar = typeInfoVar,
				})
				__LUA(lua)
			end
			)

			local componentType = requireTypeRepresentedByExpression(state, typeExpr)

			if componentType.tag == !(TYPE_COMPOUND) then
				-- Unpack the sub-compound type so we don't end up with compound types of other compound types.
				local compound = componentType

				for _, compoundItem in ipairs(compound) do
					if duplicates[compoundItem] then
						!ERROR_DUPLICATE_TYPE("compound type (through sub-compound type)", `compoundItem`)
					end

					table.insert(typeInfos, compoundItem)
					typeIds[typeExpr]            = compoundItem.id
					duplicates[compoundItem]     = typeExpr -- @UX: Should we ignore duplicate nil types?
					isFromCompound[compoundItem] = true
				end

			else
				if duplicates[componentType] then
					!ERROR_DUPLICATE_TYPE("compound type", `componentType`)
				elseif componentType.tag == !(TYPE_ANY) then
					typeError(state, typeExpr, "Cannot include 'any' in compound types.")
				end

				table.insert(typeInfos, componentType)
				typeIds[typeExpr]         = componentType.id
				duplicates[componentType] = typeExpr -- @UX: Should we ignore duplicate nil types?
			end
		end

		table.sort(typeNode.components, function(a, b)  return typeIds[a] < typeIds[b]  end) -- @Cleanup @Speed: This is probably unnecessary.

		typeInfoRepresented = getTypeInfoForCompoundType(state, typeInfos, true)
		typeInfo            = getTypeInfoForBuiltinType(state, "Type")

	else
		decl = typeNode.declaration

		if not decl then
			assert(typeNode.typeName ~= "")

			decl = findDeclaration(state, typeNode, typeNode.typeName)
			if not decl then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_DECLARATION, `typeNode.typeName`)
			elseif not decl.name.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `decl.name`)
			end
		end

		typeInfoRepresented = decl.valueTypeInfo -- May be nil, in which case we'll get an error here below.
		typeInfo            = decl.name.inferredType or errorInternal()

		-- Type enum members can be used as types, as a special case.
		if isDeclarationConstant(decl) and typeInfo.tag == !(TYPE_ENUM) then
			local enum     = typeInfo.astNode     or errorInternal()
			local enumInfo = enum.representedType or errorInternal()

			if enumInfo.memberTypeInfo.tag == !(TYPE_TYPE) then
				typeInfo = getTypeInfoForBuiltinType(state, "Type")
			end
		end

		if typeInfo.tag ~= !(TYPE_TYPE) then
			!TRACE()
			printerr()
			typeMessage(io.stderr, state, typeNode, "Error", "'%s' is not a type. (It is %s)", typeNode.typeName, getFriendlyTypeInfoName(typeInfo))
			printDeclarationChain(io.stderr, state, decl, typeNode.typeName)
			exitFailure()
		end

		for _, expr in ipairs(typeNode.arguments or EMPTY_TABLE) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		-- @Incomplete: Proper error messages here:

		if SIMPLE_TYPES[typeInfo.tag] then
			assert(not typeNode.arguments) -- This should have been caught during parsing, e.g. int(a,b).

		elseif typeInfo.tag == !(TYPE_STRUCT) then
			local structInfo = typeInfo
			if structInfo.arguments[1] then
				errorInternal("@Incomplete: Struct arguments.")
			elseif typeNode.arguments then
				typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeNode.arguments[1]), "Parameters for structs are not supported yet.")
			end

		elseif typeInfo.tag == !(TYPE_ENUM) then
			assert(not typeNode.arguments)

		elseif typeInfo.tag == !(TYPE_FUNCTION) then
			assert(not typeNode.arguments) -- This should not be possible I think. The node should have been parsed as an AstCall - not an AstType without functionHeader... right? I may be wrong.

		else
			errorInternal("Incomplete: Handle type group '%s'.", TYPE_NAMES[typeInfo.tag])
		end
	end

	typeNode.representedType = typeInfoRepresented or errorInternal()
	typeNode.inferredType    = typeInfo            or errorInternal()
	typeNode.declaration     = decl

	moveToNextRelevantPipe(state, typeNode)
end

local function getArgumentNodeForError(callOrReturnNode, valueIndex, valueExpr)
	return
		callOrReturnNode.nodeType == !(AST_CALL) and callOrReturnNode.isMethod and valueIndex == 1
		and valueExpr
		or  astGetExpressionVisuallyFurthestToTheLeft(valueExpr)
end

-- doesMatch, compatibilityScore = checkIfValuesMatchArgumentTypes(
--     state, callOrReturnNode, values, valueTypes, typeInfos,
--     softCheck, calleeDeclarationForCurrentOverload=nil, argumentsNamed=nil
-- )
local function checkIfValuesMatchArgumentTypes(state, callOrReturnNode, values, valueTypes, typeInfos, softCheck, calleeDecl, argsNamed)
	--[[
		Situations:

		two :: (x:int,   y:int) -> (x:int    y:int) -- accept in/out 2
		var :: (x:int, ...:int) -> (x:int, ...:int) -- accept in/out 1+vararg
		return  x, (two())  --- request 2
		func(   x, (two())  )-- request 2
		return  x, (var())  --- request 2
		func(   x, (var())  )-- request 2
		return  x, (...)    --- request 2  (Note: The vararg can result in nil.)
		func(   x, (...)    )-- request 2  (Note: The vararg can result in nil.)
		return  x, two()    --- request 1+list(2)
		func(   x, two()    )-- request 1+list(2)
		return  x, ...      --- request 1+vararg
		func(   x, ...      )-- request 1+vararg
		return  x, var()    --- request 1+list(1+vararg)
		func(   x, var()    )-- request 1+list(1+vararg)
	]]

	local isCallingName         = callOrReturnNode.nodeType == !(AST_CALL) and callOrReturnNode.callee.nodeType == !(AST_IDENTIFIER)
	local isCallingConstantName = false
	local constLambda           = nil

	if isCallingName then
		calleeDecl            = calleeDecl or callOrReturnNode.callee.declaration
		isCallingConstantName = isDeclarationConstant(calleeDecl)

		if isCallingConstantName then
			constLambda = followIdentifiersToConstantValue(calleeDecl.value)
			!ASSERT("constLambda.nodeType == "..AST_LAMBDA)
			!ASSERT("constLambda.inferredType")
		end
	end

	-- Get accepted count.
	local typeInfoCount   = #typeInfos
	local acceptingVararg = typeInfoCount > 0 and typeInfos[typeInfoCount].tag == !(TYPE_VARARG)
	local acceptedMin     = acceptingVararg and typeInfoCount-1 or typeInfoCount
	local acceptedMax     = acceptingVararg and math.huge       or typeInfoCount

	-- Consider optional arguments for calls.
	-- @Robustness: Disallow this in PIPE_INFER:  local take2::(req:int,opt=0){} ; local get2::()->int,int{} ; take2(get2())  -- :DisallowListAsLastValueToFunctionWithOptionalArguments
	if constLambda then
		if not areArraysEqual(typeInfos, constLambda.inferredType.argumentTypesIn) then
			-- We should only get here if checking overloads.
			if softCheck then  return false, 0  end
			errorInternal()
		end

		for i = acceptedMin, 1, -1 do
			local arg = constLambda.argumentsIn.arguments[i]
			if arg.isRequired then
				break
			else
				acceptedMin = acceptedMin-1
			end
		end
	end

	-- Get requested count.
	local valueExprLast = getLast(values)
	local valueCount    = #values
	local requestedMin  = valueCount
	local requestedMax  = valueCount
	local slotsToCheck  = valueCount -- Assuming the requested count is accepted.

	if not valueExprLast then
		-- void

	elseif valueExprLast.nodeType == !(AST_CALL) then
		local valueCall = valueExprLast

		if not valueCall.surroundedByParentheses then
			local calleeTypeInfo = valueCall.callee.inferredType

			if calleeTypeInfo.tag == !(TYPE_LIST) then
				local listSig  = calleeTypeInfo
				calleeTypeInfo = listSig[1] or errorInternal() -- The error should have happened when inferring AstCall.
			end

			assert(calleeTypeInfo.tag == !(TYPE_FUNCTION))

			local argTypesOut = calleeTypeInfo.argumentTypesOut
			local argCount    = #argTypesOut

			if argCount == 0 then
				if softCheck then  return false, 0  end
				typeError(state, valueCall, "Function call returns nothing. (Expected at least one value.)")
			end

			local returnsVararg = argCount > 0 and argTypesOut[argCount].tag == !(TYPE_VARARG)
			local returnsMin    = returnsVararg and argCount-1 or argCount
			local returnsMax    = returnsVararg and math.huge  or argCount

			requestedMin = valueCount-1+returnsMin
			requestedMax = valueCount-1+returnsMax
			slotsToCheck = valueCount-1+argCount
		end

	elseif valueExprLast.nodeType == !(AST_VARARG) then
		local valueVararg = valueExprLast

		if not valueVararg.surroundedByParentheses then
			requestedMin = valueCount - 1
			requestedMax = math.huge
			slotsToCheck = valueCount
		end
	end

	-- Increase requestedMin according to named arguments. (Also do some validation of the named arguments.)
	if argsNamed and argsNamed[1] then
		!ASSERT("constLambda") -- We should only get here when calling a constant name to a function.

		local argsIn = constLambda.argumentsIn.arguments

		if argsNamed[1].argumentIndex > 0 then
			for argIndex = valueCount+1, acceptedMin do -- Is acceptedMin good?
				local arg = argsIn[argIndex]
				if not arg.isRequired then  break  end

				local argNamed = itemWith1(argsNamed, "argumentIndex", argIndex)

				-- @Cleanup: Duplicate named argument check. (Maybe keep these and remove the one in the other function?)
				if not argNamed then
					!local NAMED_ARG_ERROR = trimTemplate`
						if softCheck then  return false, 0  end
						local call = callOrReturnNode
						typeError2(state,
							call, F("Missing value for required argument #%d (%s).", argIndex, arg.declaration.name.name),
							arg,  F("...here is the argument in the called function.")
						)
					`
					!!(NAMED_ARG_ERROR)
				end

				requestedMin = requestedMin+1
			end
		else
			for argIndex = 1, acceptedMin do -- Is acceptedMin good?
				local arg = argsIn[argIndex]
				if not arg.isRequired then  break  end

				local name     = arg.declaration.name.name
				local argNamed = nil

				for _, _argNamed in ipairs(argsNamed) do
					if _argNamed.key.name == name then
						argNamed = _argNamed
						break
					end
				end

				-- @Cleanup: Duplicate named argument check. (Maybe keep these and remove the one in the other function?)
				if not (argNamed or values[argIndex]) then
					!!(NAMED_ARG_ERROR)
				end

				if argIndex > valueCount then
					requestedMin = requestedMin+1
				end
			end
		end
	end

	-- ifDEBUG `io.write(F("requested %.0f-%.0f, accepted %.0f-%.0f  ", requestedMin, requestedMax, acceptedMin, acceptedMax)) ; astPrint(callOrReturnNode)`

	-- Too few values.
	-- @UX: Better error message if the last value is a call (without parentheses).
	if requestedMin < acceptedMin then
		if softCheck then  return false, 0  end

		local exprForError = valueExprLast and getArgumentNodeForError(callOrReturnNode, 1, values[1]) or callOrReturnNode
		local prefix       = requestedMax+acceptedMax == math.huge and "Incorrect number of" or "Missing"
		local thingsStr    = callOrReturnNode.nodeType == !(AST_CALL) and "arguments" or "values to return"
		local gotStr       = (requestedMax ~= math.huge and F("%d", requestedMin)) or (requestedMin == 0 and "variable amount") or F("%d + variable amount", requestedMin)

		local errorFunc
			=   not valueExprLast and callOrReturnNode.nodeType == !(AST_RETURN)
			and typeErrorAfter
			or  typeError

		errorFunc(state, exprForError, "%s %s. (Wanted %d, got %s)", prefix, thingsStr, acceptedMin, gotStr)

	-- Too many values.
	-- @UX: Better error message if the last value is a call (without parentheses).
	elseif requestedMax > acceptedMax then
		!ASSERT `not acceptingVararg`

		if softCheck then  return false, 0  end

		local valueIndex          = math.min(acceptedMax+1, valueCount)
		local firstExtraValueExpr = values[valueIndex]
		local exprForError        = getArgumentNodeForError(callOrReturnNode, valueIndex, firstExtraValueExpr)
		local prefix              = requestedMax+acceptedMax == math.huge and "Incorrect number of" or "Too many"
		local thingsStr           = callOrReturnNode.nodeType == !(AST_CALL) and "arguments" or "values to return"
		local gotStr              = (requestedMax ~= math.huge and F("%d", requestedMin)) or (requestedMin == 0 and "variable amount") or F("%d + variable amount", requestedMin)

		typeError(state, exprForError, "%s %s. (Wanted %d, got %s)", prefix, thingsStr, acceptedMax, gotStr) -- Note: acceptedMax is never infinite here.
	end

	local compatibilityScoreSum = 0

	!(
	local function SET_STRICT_TYPE_MATCH_FLAG(argIndexCode)
		__LUA(templateToLua(
			trimTemplate`
				if constLambda and constLambda.polymorphSourceLambda then
					local argsIn    = constLambda.polymorphSourceLambda.argumentsIn
					local arg       = argsIn.arguments and (argsIn.arguments[$argIndex] or getLast(argsIn.arguments)) or errorInternal(state, valueExpr)
					strictTypeMatch = (arg.hasPlaceholders or arg.autobake ~= $AUTOBAKE_DISABLED)
				end
			`,
			{AUTOBAKE_DISABLED=AUTOBAKE_DISABLED, argIndex=argIndexCode}
		))
	end
	)

	for slot = 1, slotsToCheck do
		local valueIndex      = math.min(slot, valueCount)
		local valueExpr       = values[valueIndex]
		local valueTypeInfo   = valueTypes[valueIndex]

		local typeInfoIndex   = math.min(slot, typeInfoCount)
		local typeInfoToMatch = typeInfos[typeInfoIndex]

		local isCompatible, compatibilityScore

		-- Function call (0..inf values).
		if valueTypeInfo.tag == !(TYPE_LIST) then
			local listSig         = valueTypeInfo
			local callOutArgIndex = slot-valueIndex+1
			valueTypeInfo         = listSig[callOutArgIndex]

			if not valueTypeInfo then
				if softCheck then  return false, 0  end
				typeError(state, valueExpr, "Function call returns nothing. (Expected at least one value.)") -- Note: "Nothing" is not the same as vararg of zero length.
			end

			local adjustVarargToIncludeNil = not (valueTypeInfo.tag == !(TYPE_VARARG) and typeInfoToMatch.tag == !(TYPE_VARARG))
			local valueTypeInfoAdjusted    = adjustTypeToOne(state, valueExpr,        valueTypeInfo, adjustVarargToIncludeNil) -- We have a value with a type.
			local typeInfoToMatchAdjusted  = adjustTypeToOne(state, callOrReturnNode, typeInfoToMatch)                         -- We want a specific type.

			local strictTypeMatch = false
			!SET_STRICT_TYPE_MATCH_FLAG(`typeInfoIndex`)

			isCompatible, compatibilityScore = isTypeCompatibleWith(valueTypeInfoAdjusted, typeInfoToMatchAdjusted, strictTypeMatch)

			if not isCompatible then
				if softCheck then  return false, 0  end
				-- @UX: Tell the name of the call/return argument. (For calls, probably only possible for constants, and maybe not all. Not sure! Returns just depend on the output arguments being named.)
				-- @UX: Tell the name of the value call's argument. (Probably only possible for constants, and maybe not all. Not sure!)
				typeError(
					state, valueExpr,
					"Type mismatch for %s #%d (return value #%d from call). (Wanted %s, got %s)",
					callOrReturnNode.nodeType == !(AST_CALL) and "argument" or "return value",
					slot,
					callOutArgIndex,
					getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
					getFriendlyTypeInfoName(valueTypeInfoAdjusted)
				)
			end

		-- Vararg (0..inf values) OR other (1 value).
		else
			local adjustVarargToIncludeNil = not (valueTypeInfo.tag == !(TYPE_VARARG) and typeInfoToMatch.tag == !(TYPE_VARARG))
			local valueTypeInfoAdjusted    = adjustTypeToOne(state, valueExpr,        valueTypeInfo, adjustVarargToIncludeNil) -- We have a value with a type.
			local typeInfoToMatchAdjusted  = adjustTypeToOne(state, callOrReturnNode, typeInfoToMatch)                         -- We want a specific type.

			local strictTypeMatch = false
			!SET_STRICT_TYPE_MATCH_FLAG(`typeInfoIndex`)

			isCompatible, compatibilityScore = isTypeCompatibleWith(valueTypeInfoAdjusted, typeInfoToMatchAdjusted, strictTypeMatch)

			if not isCompatible then
				if softCheck then  return false, 0  end
				!ifDEBUG `astPrintTree(callOrReturnNode)`
				typeError(
					state, getArgumentNodeForError(callOrReturnNode, valueIndex, valueExpr),
					"Type mismatch for %s #%d. (Wanted %s, got %s)",
					callOrReturnNode.nodeType == !(AST_CALL) and "argument" or "return value",
					slot,
					getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
					getFriendlyTypeInfoName(valueTypeInfoAdjusted)
				)
			end
		end

		compatibilityScoreSum = compatibilityScoreSum + compatibilityScore
	end

	for _, argNamed in ipairs(argsNamed or EMPTY_TABLE) do
		local argIndex = argNamed.argumentIndex

		if argIndex == 0 then
			local name = argNamed.key.name

			for _argIndex, arg in ipairs(constLambda.argumentsIn and constLambda.argumentsIn.arguments or EMPTY_TABLE) do
				if arg.declaration.name.name == name then
					argIndex = _argIndex
					break
				end
			end

			if argIndex == 0 then
				-- We should only get here if checking overloads.
				if softCheck then  return false, 0  end
				errorInternal()
			end
		end

		local valueExpr       = argNamed.value
		local valueTypeInfo   = valueExpr.inferredType

		local typeInfoToMatch = typeInfos[argIndex]

		-- @Incomplete: Vararg is not yet supported for named arguments. 2020-04-09
		local valueTypeInfoAdjusted   = adjustTypeToOne(state, valueExpr,        valueTypeInfo,   true)
		local typeInfoToMatchAdjusted = adjustTypeToOne(state, callOrReturnNode, typeInfoToMatch, true)

		local strictTypeMatch = false
		!SET_STRICT_TYPE_MATCH_FLAG(`argIndex`)

		local isCompatible, compatibilityScore = isTypeCompatibleWith(valueTypeInfoAdjusted, typeInfoToMatchAdjusted, strictTypeMatch)

		if not isCompatible then
			if softCheck then  return false, 0  end
			!ifDEBUG `astPrintTree(callOrReturnNode)`
			typeError(
				state, valueExpr,
				"Type mismatch for argument #%d (%s). (Wanted %s, got %s)",
				argIndex,
				argNamed.key.name,
				getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
				getFriendlyTypeInfoName(valueTypeInfoAdjusted)
			)
		end

		compatibilityScoreSum = compatibilityScoreSum + compatibilityScore
	end

	-- @Incomplete: Decrease compatibilityScoreSum as optional arguments are left out?

	return true, compatibilityScoreSum
end

local function ensureNamedArgumentsHaveAssignedIndicies(state, call, lambdaOrStruct, sequentialArguments)
	if not call.argumentsNamed[1]               then  return  end
	if call.argumentsNamed[1].argumentIndex > 0 then  return  end

	!ASSERT("lambdaOrStruct")
	local isLambda = (lambdaOrStruct.nodeType == !(AST_LAMBDA))

	-- Assign indicies.
	for _, argNamed in ipairs(call.argumentsNamed) do
		local name     = argNamed.key.name
		local argIndex = nil

		if isLambda then
			for _argIndex, arg in ipairs(lambdaOrStruct.argumentsIn and lambdaOrStruct.argumentsIn.arguments or EMPTY_TABLE) do
				if arg.declaration.name.name == name then
					argIndex = _argIndex
					break
				end
			end
		else
			for _argIndex, declBaked in ipairs(lambdaOrStruct.bakeDeclarations) do
				if declBaked.name.name == name then
					argIndex = _argIndex
					break
				end
			end
		end

		if not argIndex then
			typeError2(state,
				argNamed.key,   F("No argument '%s'.", name),
				lambdaOrStruct, F("...here is the %s.", (isLambda and "called function" or "struct"))
			)

		elseif sequentialArguments[argIndex] then
			local early, late = getEarlyAndLateExpression(argNamed.key, sequentialArguments[argIndex])
			typeError3(state,
				late,           F("Overlapping values for argument #%d (%s).", argIndex, name),
				early,          F("...here is the previous value."),
				lambdaOrStruct, F("...here is the %s.", (isLambda and "called function" or "struct"))
			)
		end

		argNamed.argumentIndex = argIndex
	end

	local argCount
		=   isLambda
		and (lambdaOrStruct.argumentsIn and #lambdaOrStruct.argumentsIn.arguments or 0)
		or  #lambdaOrStruct.bakeDeclarations

	-- Check for missing required arguments.  @Cleanup: Move this to checkIfValuesMatchArgumentTypes(). (Need to handle structs!)
	for argIndex = #sequentialArguments+1, argCount do
		local decl

		if isLambda then
			local arg = lambdaOrStruct.argumentsIn.arguments[argIndex]
			if not arg.isRequired then  break  end
			decl = arg.declaration
		else
			decl = lambdaOrStruct.bakeDeclarations[argIndex]
		end

		local argNamed = itemWith1(call.argumentsNamed, "argumentIndex", argIndex)
		if not argNamed then
			typeError2(state,
				call, F("Missing value for required argument #%d (%s).", argIndex, decl.name.name),
				decl, F("...here is the argument in the %s.", (isLambda and "called function" or "struct"))
			)
		end
	end
end

local function getMatchingFunctions(state, call, realArguments, realArgumentTypes, declarations)
	local matches = nil

	for _, decl in ipairs(declarations) do
		local funcSig = decl.name.inferredType
		!ASSERT("funcSig.tag == "..TYPE_FUNCTION)

		local doesMatch, compatibilityScore = checkIfValuesMatchArgumentTypes(
			state, call, realArguments, realArgumentTypes, funcSig.argumentTypesIn,
			true, decl, call.argumentsNamed
		)
		if doesMatch then
			matches = matches or {}
			table.insert(matches, {declaration=decl, score=compatibilityScore})
		end
	end

	return matches
end

local function getBestMatchOrTriggerError(state, call, matches, matchTerm, errorTextOnDraw)
	table.sort(matches, function(a, b)
		return a.score > b.score
	end)

	local highscore = matches[1].score

	if not matches[2] or matches[2].score < highscore then
		return matches[1].declaration
	end

	!TRACE()
	printerr()
	typeMessage(io.stderr, state, call.callee, "Error", errorTextOnDraw)
	for i, matchData in ipairs(matches) do
		if matchData.score < highscore then  break  end
		typeMessage(io.stderr, state, matchData.declaration.name, "Info", "...%s #%d: %s", matchTerm, i, getFriendlyTypeInfoName(matchData.declaration.name.inferredType))
	end
	exitFailure()
end

local function getPathToNode(state, topNode, node, nodeContainers, nodeKeys)
	!ASSERT `topNode`
	local locations = {}

	-- while true do
	while node ~= topNode do
		local loc = {
			containerNode = node.parent,
			container     = nodeContainers[node] or errorInternal(state, node),
			key           = nodeKeys[node]       or errorInternal(state, node),
		}
		table.insert(locations, loc)
		-- if node == topNode then  break  end
		node = node.parent or errorInternal(state, topNode)
	end

	return reverseArray(locations)
end

local function handlePolymorphicCall(state, call, calleeTypeInfo, realArguments, realArgumentTypes)
	local ident = call.callee
	if ident.nodeType ~= !(AST_IDENTIFIER) then
		errorInternal(state, ident, "Expected an identifier. Referring to unknown polymorphic function.")
	end

	local decl = ident.declaration
	if not isDeclarationConstant(decl) then
		errorInternal(state, ident, "Identifier is not a constant.")
	end

	local lambda = decl.value or errorInternal(state, decl)
	assert(lambda.nodeType == !(AST_LAMBDA))

	for _, statement in ipairs(lambda.statementsStatic) do
		if statement.queued and statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	for _, statement in ipairs(lambda.statementsDynamic) do
		if statement.queued and statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	for _, morphDecl in ipairs(lambda.polymorphs) do
		if not morphDecl.name.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `morphDecl.name`)
		end
	end

	checkIfValuesMatchArgumentTypes( -- Basically checks everything but placeholders.
		state, call, realArguments, realArgumentTypes, calleeTypeInfo.argumentTypesIn,
		false, nil, call.argumentsNamed
	)

	-- Prepare for auto-bake stuff.
	local autobaking               = false
	local autobakeIndex            = 0
	local nonAutobakeArguments     = realArguments
	local nonAutobakeArgumentTypes = realArgumentTypes
	local relevantPolymorphs       = lambda.polymorphs

	for argIndex, arg in ipairs(lambda.argumentsIn.arguments) do
		if arg.autobake == !(AUTOBAKE_REQUIRED) then
			autobaking    = true
			autobakeIndex = autobakeIndex+1

			if autobakeIndex == 1 then
				nonAutobakeArguments     = {unpack(nonAutobakeArguments)}
				nonAutobakeArgumentTypes = {unpack(nonAutobakeArgumentTypes)}
				relevantPolymorphs       = {unpack(relevantPolymorphs)}
			end

			if call.isMethod then
				errorInternal(state, arg, "@Incomplete: Handle method calls when auto-baking.")
			end

			local valueExpr     = realArguments    [argIndex] or errorInternal(state, call)
			local valueTypeInfo = realArgumentTypes[argIndex] or errorInternal(state, valueExpr)

			if not isExpressionConstant(state, valueExpr, false) then
				-- @UX: Better message for foreign values.
				typeError(state, valueExpr, "Argument must be constant for baking.")
			end

			for i, morphDecl in ipairsr(relevantPolymorphs) do
				local morphLambda    = morphDecl.value
				local autobakedValue = morphLambda.bakeValues[autobakeIndex] or errorInternal()

				-- @Robustness: I'm not sure areConstantTreesEqual() works properly for enums. It might.
				if not areConstantTreesEqual(state, valueExpr, autobakedValue) then
					table.remove(relevantPolymorphs, i)
				end
			end

		elseif arg.autobake == !(AUTOBAKE_ENABLED) then
			errorInternal(state, arg, "@Incomplete: Optional auto-baking.")
		end
	end

	if autobaking then
		for argIndex, arg in ipairsr(lambda.argumentsIn.arguments) do
			if arg.autobake == !(AUTOBAKE_REQUIRED) then
				table.remove(nonAutobakeArguments,     argIndex)
				table.remove(nonAutobakeArgumentTypes, argIndex)
			end
		end
	end

	-- Check for previous matching polymorph(s).
	local matchingMorphs = getMatchingFunctions(state, call, nonAutobakeArguments, nonAutobakeArgumentTypes, relevantPolymorphs)

	if matchingMorphs then
		local morphDecl = getBestMatchOrTriggerError(
			state, call, matchingMorphs, "polymorph",
			"Internal compiler error: There are several matching polymorphs."
		)

		if autobaking then
			for argIndex, arg in ipairsr(lambda.argumentsIn.arguments) do
				if arg.autobake == !(AUTOBAKE_REQUIRED) then
					local valueExpr = call.arguments[argIndex]
					unqueueChildrenRecursively(state, valueExpr)
					unqueue(valueExpr)
					table.remove(call.arguments, argIndex)
				end
			end

			for argIndexNew, valueExpr in ipairs(call.arguments) do
				valueExpr.queued.key = argIndexNew
			end
		end

		-- Update the callee to represent the correct polymorph.
		ident.declaration  = morphDecl
		ident.inferredType = nil

		queueForReinfer(state, ident) -- Re-infer callee.

		local dependency = getExistingDependency(state, call, !(DEPEND_NODE_INFERRED), ident)
		if dependency then
			call.queued.waitingOn = dependency
			return
		else
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `ident`)
		end
	end

	-- Create declaration for the morphed lambda.
	local morphDecl            = astNewNode(AstDeclaration, lambda.token, lambda)
	morphDecl.kind             = !(DECL_KIND_LOCAL_CONST)
	morphDecl.addedByPolymorph = true

	local morphIdent       = astNewNode(AstIdentifier, morphDecl.token, morphDecl)
	morphIdent.name        = ident.name.."_POLY"..(#lambda.polymorphs+1)
	morphIdent.declaration = morphDecl
	morphDecl.name         = morphIdent

	local morphLambda                 = astCopy(lambda, nil, morphDecl)
	morphLambda.polymorphSourceLambda = lambda
	morphDecl.value                   = morphLambda

	-- Don't keep copies of previous polymorphs we've made - that would quickly create a mess!
	-- (@Speed: Don't even copy them in the first place.)
	do
		morphLambda.isPolymorphic = false
		morphLambda.polymorphs    = {}

		for i, statement in ipairsr(morphLambda.statementsStatic) do
			if statement.nodeType == !(AST_DECLARATION) and statement.addedByPolymorph then
				table.remove(morphLambda.statementsStatic, i) -- Should be fast enough. There shouldn't be that many statements in lambdas.
			end
		end

		for _, declBaked in ipairs(morphLambda.bakeDeclarations) do
			declBaked.checkedRedeclaration = true -- @Hack to prevent redeclaration errors between polymorphed lambda and base lambda.
		end
	end

	table.insert(lambda.polymorphs, morphDecl)

	astVisitAllNodes(morphLambda, function(node, container, key)
		if node == morphLambda.body then  return !(VISIT_IGNORE_CHILDREN)  end

		-- @Robustness @Robustness @Robustness: So much @Hack!
		node.inferredType    = nil
		node.valueTypeInfo   = nil
		node.representedType = nil

		-- AstBake nodes are only used before baking.
		if node.nodeType == !(AST_BAKE) then
			local bake       = node
			container[key]   = bake.name
			bake.name.parent = bake.parent
			return !(VISIT_IGNORE_CHILDREN)
		end
	end)

	-- Fill in baked values in morphed lambda.
	!ASSERT `lambda.argumentsIn`
	local bakeIndex = 0

	for argIndex, arg in ipairs(lambda.argumentsIn.arguments) do
		local declTypeExpr = arg.declaration.type -- This is probably an AstType, if anything.

		if declTypeExpr then
			local nodeContainers = {}
			local nodeKeys       = {}

			astVisitAllNodes(declTypeExpr, function(node, container, key)
				nodeContainers[node] = container or arg.declaration
				nodeKeys      [node] = key       or "type"

				if node.nodeType ~= !(AST_BAKE) then  return  end

				local bake = node
				bakeIndex  = bakeIndex+1

				if arg.autobake ~= !(AUTOBAKE_DISABLED) then
					typeError(state, bake, "Combinations of auto-baking and placeholder types are not supported yet.")
				end

				-- @Incomplete: Handle optional arguments.
				local valueExpr     = realArguments[argIndex]
				local bakeValueExpr = nil
				local bakeValueType = nil

				if valueExpr then
					bakeValueType  = realArgumentTypes[argIndex] or errorInternal(state, valueExpr)
				else
					local argNamed = itemWith1(call.argumentsNamed, "argumentIndex", argIndex) or errorInternal(state, call)
					valueExpr      = argNamed.value
					bakeValueType  = valueExpr.inferredType or errorInternal(state, valueExpr)
				end
				bakeValueType = adjustTypeToOne(state, valueExpr, bakeValueType)

				!(
				local function BAKE_ERROR(messageAndParamsCode)
					TRACE()
					__LUA(templateToLua(
						trimTemplate`
							printerr()
							typeMessage(io.stderr, state, valueExpr, "Error", $message)
							if bakeValueExpr then
								typeMessage(
									io.stderr, state, bakeValueExpr, "Info",
									"...here is the current value being looked at. (Type is '%s')",
									getFriendlyTypeInfoName(bakeValueExpr.inferredType))
							end
							exitFailure()
						`,
						{message=messageAndParamsCode}
					))
				end
				)

				for _, patternLoc in ipairs(getPathToNode(state, declTypeExpr, bake, nodeContainers, nodeKeys)) do
					if patternLoc.containerNode.nodeType == !(AST_TYPE) then
						local patternTypeNode = patternLoc.containerNode

						if patternTypeNode.kind == !(TYPE_KIND_ARRAY) then
							if bakeValueType.tag == !(TYPE_ARRAY) then
								local arraySig = bakeValueType
								bakeValueExpr  = nil
								bakeValueType  = arraySig.itemType or errorInternal(state, valueExpr)

							elseif bakeValueType.tag == !(TYPE_STRUCT) and bakeValueType.kind == !(STRUCT_KIND_ARRAY) then
								local structInfo = bakeValueType
								bakeValueExpr    = nil
								bakeValueType    = structInfo.valueType or errorInternal(state, valueExpr)

							else
								!BAKE_ERROR`"Polymorphic call: Unexpected type. (Wanted an array, got %s)", getFriendlyTypeInfoName(bakeValueType)`
							end

						else
							errorUnhandledNodeType(state, patternTypeNode)
						end

					elseif patternLoc.containerNode.nodeType == !(AST_CALL) then
						local patternCall = patternLoc.containerNode

						if bakeValueType.tag == !(TYPE_STRUCT) then
							-- void
						elseif bakeValueType.tag == !(TYPE_TYPE) then
							-- Note sure if this is bullet proof or sane in any way...
							assert(bakeValueExpr)
							bakeValueType = requireTypeRepresentedByExpression(state, bakeValueExpr)
						else
							!BAKE_ERROR`"Polymorphic call: Expected a type to be a (polymorphic) struct. (Got %s)", getFriendlyTypeInfoName(bakeValueType)`
						end

						local structInfo = bakeValueType
						if structInfo.tag ~= !(TYPE_STRUCT) then
							!BAKE_ERROR`"Polymorphic call: Expected a type to be a (polymorphic) struct. (Got %s)", getFriendlyTypeInfoName(structInfo)`
						elseif not structInfo.astNode.polymorphSourceStruct then
							bakeValueExpr = structInfo.astNode
							!BAKE_ERROR`"Polymorphic call: Expected a type to be a polymorphic struct. (%s is not polymorphic)", getFriendlyTypeInfoName(structInfo)`
						end

						-- @Incomplete: Handle optional arguments.
						if #patternCall.arguments ~= #structInfo.astNode.bakeDeclarations then
							bakeValueExpr = structInfo.astNode
							!BAKE_ERROR`
								"Polymorphic call: Expected an argument value type to be a polymorphic struct that takes %d argument%s. (%s takes %d)  (Note: Optional arguments are not handled properly yet.)",
								#patternCall.arguments,
								patternCall.arguments[2] and "s" or "",
								getFriendlyTypeInfoName(structInfo),
								#structInfo.astNode.bakeDeclarations
							`
						end

						local declBakedOther = structInfo.astNode.bakeDeclarations[patternLoc.key] or errorInternal(state, valueExpr)

						bakeValueExpr = declBakedOther.value or errorInternal(state, declBakedOther)
						bakeValueType = bakeValueExpr.inferredType -- Note: declBakedOther.name may not be inferred yet.

						if not bakeValueType then
							!BAKE_ERROR`"Internal compiler error: Polymorphic call: Expected this to be inferred."` -- 'this' is referring to bakeValueExpr. (See BAKE_ERROR)
						end

					else
						errorUnhandledNodeType(state, patternLoc.containerNode)
					end
				end--for getPathToNode

				local declBaked = morphLambda.bakeDeclarations[bakeIndex] or errorInternal(state, bake)
				if bakeValueExpr then
					declBaked.value = astCopy(bakeValueExpr, declBaked.token, declBaked)
				else
					declBaked.value = createTypeNodeFromInfo(state, bakeValueType, declBaked.token, declBaked)
				end

				return !(VISIT_IGNORE_CHILDREN) -- There should only be an identifier inside AstBake.
			end)
		end
	end
	!ASSERT `bakeIndex == #lambda.bakeDeclarations`

	if autobaking then
		for argIndex, arg in ipairsr(morphLambda.argumentsIn.arguments) do
			if arg.autobake == !(AUTOBAKE_REQUIRED) then
				--
				-- Here we convert auto-baked arguments to hidden declarations
				-- in the lambda and update the calling site accordingly.
				--
				local declBaked  = arg.declaration
				declBaked.parent = morphLambda
				declBaked.checkedRedeclaration = true -- @Hack to prevent redeclaration errors between polymorphed lambda and base lambda.
				table.insert(morphLambda.statementsStatic, declBaked)
				table.insert(morphLambda.declarations,     declBaked)
				-- table.insert(morphLambda.bakeDeclarations, declBaked) -- Should we do this? It may be useless.

				-- Reuse valueExpr instead of making a copy. Note that this is the
				-- only thing in the morphed lambda that will already be inferred.
				local valueExpr            = realArguments[argIndex]
				declBaked.value            = valueExpr
				valueExpr.parent           = declBaked
				valueExpr.queued.container = declBaked
				valueExpr.queued.key       = "value"
				table.insert(morphLambda.bakeValues, 1, valueExpr)

				table.remove(morphLambda.argumentsIn.arguments, argIndex)
				table.remove(call.arguments,                    argIndex)

			elseif arg.autobake == !(AUTOBAKE_ENABLED) then
				errorInternal(state, arg, "@Incomplete: Optional auto-baking.")
			end
		end

		if not morphLambda.argumentsIn.arguments[1] then
			removeItem(morphLambda.statementsStatic, morphLambda.argumentsIn)
			morphLambda.argumentsIn = nil
		end

		-- !ifDEBUG `astPrintTree(call)`
		-- !ifDEBUG `astPrintTree(morphLambda)`
	end

	-- Update the source lambda, add queueds etc.
	local i                    = #lambda.statementsStatic+1
	lambda.statementsStatic[i] = morphDecl

	addUnqueuedChildrenToQueueRecursively(state, morphDecl, !(PIPE_INFER))
	addToQueue(state, morphDecl, lambda.statementsStatic, i, !(PIPE_INFER))

	for _, declBaked in ipairs(morphLambda.bakeDeclarations) do
		local valueExpr         = declBaked.value
		declBaked.valueTypeInfo = getTypeRepresentedByExpression(valueExpr)
		moveToNextRelevantPipe(state, valueExpr)
	end

	-- Update the callee to represent the correct polymorph.
	ident.declaration  = morphDecl
	ident.inferredType = nil

	queueForReinfer(state, ident) -- Re-infer callee.

	local dependency = getExistingDependency(state, call, !(DEPEND_NODE_INFERRED), ident)
	if dependency then
		call.queued.waitingOn = dependency
		return
	else
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `ident`)
	end
end

local function handleOverloadedCall(state, call, realArguments, realArgumentTypes)
	local ident    = call.callee
	local declBase = getOverloadBase(ident.declaration)

	local matchingOverloads = getMatchingFunctions(state, call, realArguments, realArgumentTypes, declBase.overloads)

	if not matchingOverloads then
		!TRACE()
		printerr()
		typeMessage(io.stderr, state, ident, "Error", "Did not find any matching overload to call.") -- @UX: Show expected signature.
		for i, declOverload in ipairs(declBase.overloads) do
			typeMessage(io.stderr, state, declOverload.name, "Info", "...overload #%d: %s", i, getFriendlyTypeInfoName(declOverload.name.inferredType))
		end
		exitFailure()
	end

	local decl = getBestMatchOrTriggerError(
		state, call, matchingOverloads, "overload",
		"There are several matching overloads."
	)
	local calleeTypeInfo = decl.name.inferredType

	-- Update the callee to represent the correct overload.
	-- @Robustness: Is this safe? I don't think anything except the calls itself depends directly on, and uses values from, any callee.
	ident.declaration  = decl
	ident.inferredType = calleeTypeInfo

	return calleeTypeInfo
end

local function handlePolymorphicStruct(state, call)
	local typeNode = call.callee
	assert(typeNode.nodeType == !(AST_TYPE))

	local structInfo = typeNode.representedType
	assert(structInfo.tag == !(TYPE_STRUCT))
	assert(structInfo.isPolymorphic)

	if call.isMethod then
		local exprForError = astGetOriginal(typeNode)
		if exprForError.nodeType == !(AST_ACCESS) then
			exprForError = exprForError.member
		end
		typeError(state, exprForError, "This is not a method. (It is struct '%s')", getFriendlyTypeInfoName(structInfo))
	end

	local struct = structInfo.astNode

	for _, morphDecl in ipairs(struct.polymorphs) do
		if not morphDecl.name.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `morphDecl`)
		end
	end

	ensureNamedArgumentsHaveAssignedIndicies(state, call, struct, call.arguments)

	-- Check arguments.  @UX: Better error message for foreign values.
	for argIndex, argExpr in ipairs(call.arguments) do
		if not isExpressionConstant(state, argExpr, false) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(argExpr), "Struct argument #%d is not constant.", argIndex)
		end
	end
	for _, argNamed in ipairs(call.argumentsNamed) do
		if not isExpressionConstant(state, argNamed.value, false) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(argNamed.value), "Struct argument #%d is not constant.", argNamed.argumentIndex)
		end
	end

	local requested   = #call.arguments + #call.argumentsNamed
	local acceptedMax = #struct.bakeDeclarations
	local acceptedMin = acceptedMax

	for argIndex = acceptedMax, 1, -1 do
		if not struct.bakeDeclarations[argIndex].value then  break  end
		acceptedMin = acceptedMin-1
	end

	if requested < acceptedMin then
		typeError(state, call, "Too few struct arguments. (Expected %d, got %d)", acceptedMin, requested)

	elseif requested > acceptedMax then
		local valueExpr = call.arguments[acceptedMax+1]
		typeError(
			state, (valueExpr and astGetExpressionVisuallyFurthestToTheLeft(valueExpr) or call),
			"Too many struct arguments. (Expected %d, got %d)",
			acceptedMax, requested
		)
	end

	-- Check for previous matching polymorph.
	for _, morphDecl in ipairs(struct.polymorphs) do
		local morphStruct = morphDecl.value
		local isMatch     = true

		for argIndex, declBaked in ipairs(morphStruct.bakeDeclarations) do
			local valueBaked = declBaked.value
			local valueExpr  = call.arguments[argIndex]

			if not valueExpr then
				local argNamed = itemWith1(call.argumentsNamed, "argumentIndex", argIndex)
				valueExpr      = argNamed and argNamed.value or struct.bakeDeclarations[argIndex].value
			end

			if valueExpr.nodeType ~= valueBaked.nodeType then
				isMatch = false ; break
			elseif valueExpr.nodeType == !(AST_LITERAL) then
				if valueExpr.value ~= valueBaked.value then -- Note: We don't need to check the literalType.
					isMatch = false ; break
				end
			elseif valueExpr.nodeType == !(AST_TYPE) then
				if valueExpr.representedType ~= valueBaked.representedType then
					isMatch = false ; break
				end
			else
				errorUnhandledNodeType(state, valueExpr)
			end
		end

		if isMatch then
			-- Change the call into a type node.
			local morphTypeNode       = astNewNode(AstType, typeNode.token, call.parent)
			morphTypeNode.kind        = !(TYPE_KIND_SIMPLE_USER)
			morphTypeNode.typeName    = morphDecl.name.name
			morphTypeNode.declaration = morphDecl

			replaceQueuedNodeAndUnqueueOldTree(state, call, morphTypeNode)

			-- Stay in PIPE_INFER. Also, the next line is needed.
			!DEPEND_AND_RETURN(`morphTypeNode`, DEPEND_NODE_INFERRED, `morphDecl`)
		end
	end

	-- Create declaration for the morphed struct.
	local morphDecl            = astNewNode(AstDeclaration, struct.token, struct)
	morphDecl.kind             = !(DECL_KIND_LOCAL_CONST)
	morphDecl.addedByPolymorph = true

	local morphIdent       = astNewNode(AstIdentifier, morphDecl.token, morphDecl)
	morphIdent.name        = typeNode.typeName.."_POLY"..(#struct.polymorphs+1)
	morphIdent.declaration = morphDecl
	morphDecl.name         = morphIdent

	local morphStruct                 = astCopy(struct, nil, morphDecl)
	morphStruct.inferredType          = nil
	morphStruct.representedType       = nil
	morphStruct.polymorphSourceStruct = struct
	morphDecl.value                   = morphStruct

	-- Don't keep copies of previous polymorphs we've made - that would quickly create a mess!
	-- (@Speed: Don't even copy them in the first place.)
	do
		morphStruct.isPolymorphic = false
		morphStruct.polymorphs    = {}

		for i, statement in ipairsr(morphStruct.statementsStatic) do
			if statement.nodeType == !(AST_DECLARATION) and statement.addedByPolymorph then
				table.remove(morphStruct.statementsStatic, i) -- This line should only trigger at most twice per polymorph.
			end
		end
	end

	table.insert(struct.polymorphs, morphDecl)

	-- Bake values into morphed struct.
	for argIndex, declBaked in ipairs(morphStruct.bakeDeclarations) do
		local valueExpr = call.arguments[argIndex]

		if not valueExpr then
			local argNamed = itemWith1(call.argumentsNamed, "argumentIndex", argIndex)
			valueExpr      = argNamed and argNamed.value
		end

		if valueExpr then -- valueExpr is nil for optional arguments.
			declBaked.value = astCopy(valueExpr, nil, declBaked) -- Overwrite any old value expression.
		end
		declBaked.checkedRedeclaration = true -- @Hack to prevent redeclaration errors between polymorphed struct and base struct.
	end

	-- Update the source struct, add queueds etc.
	local i                    = #struct.statementsStatic+1
	struct.statementsStatic[i] = morphDecl
	addToQueueRecursively(state, morphDecl, struct.statementsStatic, i, !(PIPE_INFER))

	-- Change the call into a type node.
	local morphTypeNode       = astNewNode(AstType, typeNode.token, call.parent)
	morphTypeNode.kind        = !(TYPE_KIND_SIMPLE_USER)
	morphTypeNode.typeName    = morphDecl.name.name
	morphTypeNode.declaration = morphDecl

	replaceQueuedNodeAndUnqueueOldTree(state, call, morphTypeNode)

	-- Stay in PIPE_INFER. Also, the next line is needed.
	!DEPEND_AND_RETURN(`morphTypeNode`, DEPEND_NODE_INFERRED, `morphDecl`)
end

local function doesExpressionRepresentPolymorphicStructType(expr)
	if expr.inferredType.tag ~= !(TYPE_TYPE) then  return false  end

	local typeRepresented = getTypeRepresentedByExpression(expr)
	return
		typeRepresented ~= nil
		and typeRepresented.tag == !(TYPE_STRUCT)
		and typeRepresented.isPolymorphic
end
local function doesExpressionRepresentStructType(expr)
	if expr.inferredType.tag ~= !(TYPE_TYPE) then  return false  end

	local typeRepresented = getTypeRepresentedByExpression(expr)
	return typeRepresented ~= nil and typeRepresented.tag == !(TYPE_STRUCT)
end

!NODE_INFERRER `function nodeInferrers.AstCall(state, call)`
	local callee     = call.callee
	local calleeType = callee.inferredType

	-- Wait for callee.
	if not calleeType then
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `callee`)
	end

	local isCallingConstantNameOrDeclaredType = (
		(
			callee.nodeType == !(AST_IDENTIFIER)
			or (callee.nodeType == !(AST_TYPE) and callee.declaration ~= nil)
		)
		and isDeclarationConstant(callee.declaration)
	)

	-- Wait for overloads.
	if isCallingConstantNameOrDeclaredType and callee.declaration.overloadOf then
		local ident = callee
		!ASSERT("callee.nodeType == "..AST_IDENTIFIER) -- Only functions can be overloaded in which case 'callee' should not be a type here.
		local declBase = getOverloadBase(ident.declaration)

		calleeType = declBase.name.inferredType
		if not calleeType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `declBase`) -- If the base is overloaded then all others should be too.
		end
	end

	-- Wait for arguments.
	for _, argExpr in ipairs(call.arguments) do
		if not argExpr.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `argExpr`)
		end
	end
	for _, argNamed in ipairs(call.argumentsNamed) do
		-- Only wait for the values.
		if not argNamed.value.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `argNamed.value`)
		end
	end

	calleeType = adjustTypeToOne(state, callee, calleeType, true)

	!local NOT_CALLABLE = templateToLua(
		trimTemplate`
			if callee.nodeType == $nodeTypeIdent then
				local ident = callee
				typeError(state, ident, "'%s' is not a function. (It is %s)", ident.name, getFriendlyTypeInfoName(ident.inferredType))
			else
				typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeType))
			end
		`,
		{nodeTypeIdent=AST_IDENTIFIER}
	)

	if call.argumentsNamed[1] then
		if not isCallingConstantNameOrDeclaredType then
			typeError(state, call.argumentsNamed[1].key, "The called object must be a constant identifier for named arguments to work.")
		end
		if not (calleeType.tag == !(TYPE_FUNCTION) or calleeType.tag == !(TYPE_TYPE)) then
			errorInternal(state, call.argumentsNamed[1].key, "@Incomplete: Handle named arguments for non-function calls.")
		end
	end

	if calleeType.tag == !(TYPE_FUNCTION) then
		-- void

	elseif doesExpressionRepresentPolymorphicStructType(callee) then -- @Cleanup: We can/should probably just check callee.declaration.valueTypeInfo here.
		if isScope(call.parent) then
			errorParsing(
				state, astGetExpressionVisuallyFurthestToTheLeft(call).token,
				"Invalid statement. This not a function call - it is struct type '%s'.",
				getFriendlyTypeInfoName(getTypeRepresentedByExpression(callee))
			)
		end

		handlePolymorphicStruct(state, call)
		return

	elseif doesExpressionRepresentStructType(callee) then -- @Cleanup: We can/should probably just check callee.declaration.valueTypeInfo here.
		local structInfo = getTypeRepresentedByExpression(callee)

		-- We have to wait for the members for inherited declarations to be available.
		if not structInfo.hasMembers then
			!DEPEND_AND_RETURN(`call`, DEPEND_STRUCT_MEMBERS_READY, `structInfo`)
		end

		local decl = findMemberDeclaration(state, structInfo.astNode, "!call")
		if not decl then
			typeError(state, call, "%s has no !call declaration and thus cannot be called.", getFriendlyTypeInfoName(structInfo))
		end

		local ident = astCopy(decl.name, callee.token, call)
		replaceQueuedNodeAndUnqueueOldTree(state, callee, ident)

		return inferNode(state, call)

	else
		!!(NOT_CALLABLE)
	end

	local funcSig = calleeType
	!ASSERT("funcSig.tag == "..TYPE_FUNCTION)

	!if DEBUG then
		if call.isMethod and callee.nodeType ~= !(AST_ACCESS) then
			astPrint(callee)
			errorInternal(state, call)
		end
	!end

	local realArguments     = (call.isMethod and {callee, unpack(call.arguments)} or call.arguments)
	local realArgumentTypes = {}

	if call.isMethod then
		local typeInfo       = callee.object.inferredType
		realArgumentTypes[1] = adjustTypeToOne(state, callee.object, typeInfo, true) -- Is adjustTypeToOne necessary? @Cleanup
	end
	for _, argExpr in ipairs(call.arguments) do
		local typeInfo = argExpr.inferredType
		if !!(CONST_SET{ AST_VARARG, AST_CALL })[argExpr.nodeType] and argExpr.surroundedByParentheses then
			typeInfo = adjustTypeToOne(state, argExpr, typeInfo, true)
		end
		table.insert(realArgumentTypes, typeInfo)
	end

	-- Overloaded call.
	if isCallingConstantNameOrDeclaredType and callee.declaration.overloadOf then
		funcSig = handleOverloadedCall(state, call, realArguments, realArgumentTypes) or errorInternal(state, call)
	end

	local constLambda = nil
	if isCallingConstantNameOrDeclaredType then
		constLambda = followIdentifiersToConstantValue(callee.declaration.value)
		!ASSERT("constLambda.nodeType == "..AST_LAMBDA)
	end

	ensureNamedArgumentsHaveAssignedIndicies(state, call, constLambda, realArguments)

	-- Polymorphic call.
	if funcSig.isPolymorphic then
		handlePolymorphicCall(state, call, funcSig, realArguments, realArgumentTypes)
		return -- Wait for the polymorphed function to infer.
	end

	-- Plain call.
	checkIfValuesMatchArgumentTypes(
		state, call, realArguments, realArgumentTypes, funcSig.argumentTypesIn,
		false, nil, call.argumentsNamed
	)

	-- Make sure foreign function calls don't have gaps among the arguments as
	-- that may have unexpected consequences (since we don't "put" the default
	-- value in empty slots for foreign functions).
	if call.argumentsNamed[1] and constLambda.bodyIsForeign then
		local argsIn        = constLambda.argumentsIn.arguments
		local argInCount    = #argsIn
		local isVararg      = funcSig.argumentTypesIn[argInCount].tag == !(TYPE_VARARG)
		local maxNamedCount = isVararg and argInCount-1 or argInCount
		local requiredCount = maxNamedCount

		for argIndex = requiredCount, 1, -1 do
			local arg = argsIn[argIndex]
			if arg.isRequired then  break  end
			requiredCount = requiredCount-1
		end

		local firstGapAtIndex = nil

		for argIndex = requiredCount+1, maxNamedCount do
			local valueExpr = realArguments[argIndex]
			local nodeForError

			if not valueExpr then
				local argNamed = itemWith1(call.argumentsNamed, "argumentIndex", argIndex)
				valueExpr      = argNamed and argNamed.value
				nodeForError   = argNamed and argNamed.key
			end

			if not valueExpr then
				firstGapAtIndex = firstGapAtIndex or argIndex

			elseif firstGapAtIndex then
				local arg = argsIn[firstGapAtIndex]
				typeError(
					state, nodeForError,
					"Foreign function calls must not have gaps before the last specified optional argument. Missing value for argument #%d (%s).",
					firstGapAtIndex, arg.declaration.name.name
				)
			end
		end
	end

	local listSig  = getTypeInfoForList(state, funcSig.argumentTypesOut)
	local typeInfo = listSig

	if listSig[1] and (call.surroundedByParentheses or not areMultipleValuesEnabledAtPosition(state, call)) then
		call.surroundedByParentheses = true
		typeInfo                     = adjustTypeToOne(state, call, listSig, true)
	end

	-- Handle !must.
	if
		constLambda
		and constLambda.argumentsOut
		and constLambda.argumentsOut.arguments[1].isRequired
		and not !!(CONST_SET{ AST_VARIANT_OF, AST_TYPE_OF, AST_TYPE_INFO, AST_DEBUG })[call.parent.nodeType]
	then
		local lastRequiredIndex = lastIndexWith1(constLambda.argumentsOut.arguments, "isRequired", true)
		local assignment        = call.parent

		if assignment.nodeType ~= !(AST_ASSIGNMENT) then
			local name = constLambda.argumentsOut.arguments[lastRequiredIndex].declaration.name.name
			typeError(
				state, call,
				"Function requires return value #%d%s to be explicitly received in an assigment.",
				lastRequiredIndex, (name ~= "" and F(" (%s)", name) or "")
			)
		end

		local valueIndex  = indexOf(assignment.values, call) or errorInternal(state, call) -- The call shouldn't be one of the targets. That would've been a parsing error!
		local targetIndex = valueIndex+lastRequiredIndex-1

		if not assignment.targets[targetIndex] or (call.surroundedByParentheses and lastRequiredIndex > 1) then
			local name = constLambda.argumentsOut.arguments[lastRequiredIndex].declaration.name.name
			typeError(
				state, call,
				"Missing assignment target for return value #%d%s which is required to be explicitly received.",
				lastRequiredIndex, (name ~= "" and F(" (%s)", name) or "")
			)
		end
	end

	if constLambda then
		call.wantLocation = constLambda.wantCallerLocation
	end

	call.inferredType = typeInfo
	moveToNextRelevantPipe(state, call)
end

!NODE_INFERRER `function nodeInferrers.AstReturn(state, returnNode)`
	for _, valueExpr in ipairs(returnNode.values) do
		if not valueExpr.inferredType then
			!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `valueExpr`)
		end
	end

	local scope = astFindParentScope(returnNode) or errorInternal()

	while scope.nodeType ~= !(AST_LAMBDA) do
		if not isScopeImperative(scope) then -- This may eventually be AstFileScope, at most.
			-- I think this is an internal compiler error, actually. Parsing must have goofed up or something.
			typeError(state, scope, "Return statement is not in a function.")
		end

		scope = astFindParentScope(scope) or errorInternal()
	end

	local lambda = scope

	if not lambda.inferredType then
		!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `lambda`)
	end

	local typeInfos = {}
	for i, valueExpr in ipairs(returnNode.values) do
		typeInfos[i] = valueExpr.inferredType
	end

	checkIfValuesMatchArgumentTypes(
		state, returnNode, returnNode.values, typeInfos, lambda.inferredType.argumentTypesOut,
		false, nil, nil
	)
	moveToNextRelevantPipe(state, returnNode)
end

!NODE_INFERRER `function nodeInferrers.AstDeclaration(state, decl)`
	local valueExpr = getDeclarationValue(decl, true)
	local isConst   = isDeclarationConstant(decl)

	if valueExpr then
		if not valueExpr.inferredType then
			if valueExpr.nodeType == !(AST_TABLE) then
				!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED_FULLY, `valueExpr`)
			else
				!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `valueExpr`)
			end
		end

		if isConst and valueExpr.nodeType == !(AST_STRUCT) or valueExpr.nodeType == !(AST_ENUM) then
			valueExpr.representedType.name = decl.name.name
		end
	end

	local identOrVararg = decl.name
	local typeInfo      = identOrVararg.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `identOrVararg`)
	end

	for _, note in ipairs(decl.notes) do
		if not note.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `note`)
		end
	end

	local scope    = astFindParentScope(decl)
	local typeExpr = decl.type

	local isForeignVariableMember = (not isConst and decl.parent == scope and scope.nodeType == !(AST_STRUCT) and scope.isForeign)

	if typeExpr then
		if not typeExpr.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `typeExpr`)
		end

		local typeInfoRepresented = requireTypeRepresentedByExpression(state, typeExpr)

		if decl.parent.nodeType == !(AST_ARGUMENT) then
			-- void  Ignore function arguments.
		elseif typeInfoRepresented.tag ~= !(TYPE_COMPOUND) then
			-- void  Only compound types have a higher requirement on the value at the moment.
		elseif isConst then
			typeError(
				state, decl.name,
				"Constants cannot be compound types. (Type is %s)",
				getFriendlyTypeInfoName(typeInfoRepresented)
			)
		elseif isForeignVariableMember then
			-- void  These never need a value.
		elseif not valueExpr then
			typeError(
				state, decl.name,
				"An initial value is required for compound types. (Type is %s)",
				getFriendlyTypeInfoName(typeInfoRepresented)
			)
		end
	end

	-- @Incomplete: decl.notes (if we make them structured, which we should!)

	if valueExpr then
		if valueExpr.inferredType.tag == !(TYPE_NAMESPACE) and not isConst then
			typeError(state, valueExpr, "References to namespaces must be constant.")
		end

		-- Validate that the assigned value is the same type as the declared name.
		--
		-- (Not needed for vararg as those only exist as arguments and don't have default values.
		-- Also, this doesn't run for enum members as those declarations never have any specified types.)
		--
		if typeExpr and identOrVararg.nodeType ~= !(AST_VARARG) then
			local ident = identOrVararg

			if decl.assignment then
				getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, ident.inferredType, nil, nil)

			elseif not isTypeCompatibleWith(decl.value.inferredType, ident.inferredType) then -- Note: No need to call adjustTypeToOne() for decl.value.
				-- @UX: Use the same error message as getAssignmentValue().
				typeError(
					state, valueExpr, "Value type mismatch for assignment target #%d. (Wanted %s, got %s)",
					decl.assignmentIndex,
					getFriendlyTypeInfoName(ident.inferredType),
					getFriendlyTypeInfoName(decl.value.inferredType)
				)
			end
		end

		if shouldDeclarationValueDefinitivelyBeConstant(decl) or isScopeDeclarative(scope) then
			if isExpressionConstant(state, valueExpr, false) then
				-- void

			elseif valueExpr.nodeType == !(AST_FOREIGN) then
				-- void
				-- We usually treat foreign values as runtime values. The only exception is when
				-- it's placed directly on a declaration. (Can this be solved in a better way?)
				-- :SpecialForeignValueRules

			elseif astFindInTree(valueExpr, !(AST_FOREIGN)) then
				local foreign = astFindInTree(valueExpr, !(AST_FOREIGN))
				typeError(state, foreign, "Cannot evaluate foreign values during compile time.")

			else
				-- @UX: If the expression is/contains a table with a non-constant field, point out which field key or value!
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
					"Value for declared %s '%s' is not a constant expression.%s",
					(isConst and "constant" or "variable"),
					identOrVararg.name,
					(
						(valueExpr.nodeType == !(AST_LAMBDA) and valueExpr.captures[1] and " (Functions with captures are not constant.)") or
						(not isConst and isScopeDeclarative(scope) and " (All values in declarative scopes must be constant.)") or
						""
					)
				)
			end
		end

	elseif not (
		doesTypeHaveAnyDefaultValue(typeInfo)
		-- Ignore missing values for arguments (which are then required arguments).
		or decl.parent.nodeType == !(AST_ARGUMENT)
		-- Variables in foreign structs do not need initial values since those structs never get constructed locally anyway.
		or isForeignVariableMember
	) then
		!ASSERT `not isConst` -- This should have been detected in inferIdentifierOrVararg() (I think).
		typeError(state, identOrVararg, "Variables in type group '%s' must have a specified initial value.", TYPE_NAMES[typeInfo.tag])
	end

	for _, note in ipairs(decl.notes) do
		local typeRepresented = requireTypeRepresentedByExpression(state, note)
		if typeRepresented.tag ~= !(TYPE_STRUCT) then
			typeError(state, note, "Expected a struct type. (This is %s)", getFriendlyTypeInfoName(typeRepresented))
		end
	end

	moveToNextRelevantPipe(state, decl)

	if scope.nodeType == !(AST_FILE_SCOPE) and state.sendMessages then
		local message = newMessage(!(MESSAGE_CODE_TYPECHECKED))
		table.insert(state.messages, message)

		local typeInfoForPublic
			=   isTypePublic(typeInfo)
			and typeInfo
			or  getTypeInfoForBuiltinType(state, "void")

		local codeDecl          = CodeDeclaration()
		codeDecl.serial         = decl.s
		codeDecl.typeInfo       = getPublicType(state, typeInfoForPublic)
		codeDecl.filepath       = state.tokens.file[decl.token]
		codeDecl.lineNumber     = state.tokens.line1[decl.token]
		codeDecl.filePosition   = state.tokens.position1[decl.token]
		codeDecl.name           = identOrVararg.name
		codeDecl.expressions[1] = nil -- @Incomplete: Generate child CodeNodes.
		codeDecl.rootExpression = nil -- @Incomplete: Generate child CodeNodes.
		codeDecl.isConstant     = isConst

		for i, note in ipairs(decl.notes) do
			local typeRepresented = getTypeRepresentedByExpression(note)
			codeDecl.notes[i]     = typeRepresented.id
		end

		message.declaration = codeDecl
	end
end

!!local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = {
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "none",
	[LITERAL_FLOAT]   = "float",
	[LITERAL_STRING]  = "string",
}
_G.!(local )!!BUILTIN_TYPE_TAG_TO_LITERAL_TYPE = {
	[TYPE_BOOL]   = LITERAL_BOOLEAN,
	[TYPE_INT]    = LITERAL_INTEGER,
	[TYPE_NONE]   = LITERAL_NIL,
	[TYPE_FLOAT]  = LITERAL_FLOAT,
	[TYPE_STRING] = LITERAL_STRING,
}

!NODE_INFERRER `function nodeInferrers.AstLiteral(state, literal)`
	local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType] or errorUnhandledNodeType(state, literal)

	literal.inferredType = getTypeInfoForBuiltinType(state, typeName)

	moveToNextRelevantPipe(state, literal)
end

!NODE_INFERRER `function nodeInferrers.AstUnary(state, unary)`
	local typeInfo = unary.expression.inferredType
	if not typeInfo then
		!DEPEND_AND_RETURN(`unary`, DEPEND_NODE_INFERRED, `unary.expression`)
	end

	if typeInfo.tag == !(TYPE_LIST) then
		typeInfo = adjustTypeToOne(state, unary.expression, typeInfo, true)
	end

	if unary.operation == "+" or unary.operation == "-" then
		-- @Incomplete: Allow int|float compound type here (or disallow declarations of that specific compound type).
		if not isTypeNumeric(typeInfo) then
			typeError(
				state, unary.expression,
				"Unary numeric operation (%s): Expected a float or int. (Got %s)",
				unary.operation,
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "not" then
		if typeInfo.tag ~= !(TYPE_BOOL) then
			wrapInImplicitCast(state, unary.expression, getTypeInfoForBuiltinType(state, "bool"), true)
			return
		end

	elseif unary.operation == "#" then
		if not (
			(typeInfo.tag == !(TYPE_STRUCT) and typeInfo.valueType and not typeInfo.keyType) -- Should we allow keyType to be int?
			or !!(CONST_SET{ TYPE_ARRAY, TYPE_TABLE, TYPE_STRING, TYPE_VARARG })[typeInfo.tag]
		) then
			typeError(
				state, unary.expression,
				"Unary length operation (#): Expected an array, a table or a string. (Got %s)",
				getFriendlyTypeInfoName(typeInfo)
			)
		end

		typeInfo = getTypeInfoForBuiltinType(state, "int")

	else
		errorUnhandledNodeType(state, unary)
	end

	unary.inferredType = typeInfo

	moveToNextRelevantPipe(state, unary)
	simplifyExpressionIfConstant(state, unary)
end

local function isCompoundCompare(state, binary, typeInfoL, typeInfoR)
	-- Detect situations like these: local v:int|string = 0 ; if v == ""

	local compound    = typeInfoL
	local otherType   = typeInfoR

	local lIsCompound = (compound.tag  == !(TYPE_COMPOUND))
	local rIsCompound = (otherType.tag == !(TYPE_COMPOUND))

	if lIsCompound and rIsCompound then
		-- The compound types must be the same for a theoretical test here to pass
		-- since both compounds must contain all of the other one's types, but we
		-- should already have checked for that and thus shouldn't be here. So, we
		-- simply say they are incompatible right away.
		return false
	elseif lIsCompound then
		-- void
	elseif rIsCompound then
		compound, otherType = otherType, compound
	else
		return false
	end

	return indexOf(compound, otherType) ~= nil -- We don't use isTypeCompatibleWith() here - the compound must contain exactly otherType!
end

local function isValidEqualityCheck(state, binary, typeInfoL, typeInfoR)
	if typeInfoL == typeInfoR or typeInfoL.tag == !(TYPE_ANY) or typeInfoR.tag == !(TYPE_ANY) then  return true  end

	-- We allow comparing namespaces even though technically each namespace has it's own unique type.
	-- Functions can also be compared freely despite having different signatures.
	if typeInfoL.tag == typeInfoR.tag and (typeInfoL.tag == !(TYPE_NAMESPACE) or typeInfoL.tag == !(TYPE_FUNCTION)) then  return true  end

	if isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR)  then  return true  end
	if isCompoundCompare(state, binary, typeInfoL, typeInfoR) then  return true  end

	return false
end

-- resultingTypeInfo = checkBinaryOperation( state, expressionForError, mainExpression, leftExpression, rightExpression, binaryOperation, typeInfoL, typeInfoR, inAssignment )
-- Resurns nil if a cast was added and we're now waiting for it to infer.
function _G.checkBinaryOperation(state, exprForError, exprMain,exprL,exprR, binOp, typeInfoL,typeInfoR, inAssignment)
	!local TYPE_MISMATCH = `typeError(
		state, exprForError,
		"Binary operation (%s): Type mismatch for operands. (Left is %s, right is %s)",
		binOp,
		getFriendlyTypeInfoName(typeInfoL),
		getFriendlyTypeInfoName(typeInfoR)
	)`

	-- String repetition.
	if binOp == "*" and (
		(typeInfoL.tag == !(TYPE_STRING) and typeInfoR.tag == !(TYPE_INT)) or
		(typeInfoL.tag == !(TYPE_INT)    and typeInfoR.tag == !(TYPE_STRING))
	) then
		local intExpr = (typeInfoL.tag == !(TYPE_INT) and exprL or exprR)
		if intExpr.nodeType == !(AST_LITERAL) and intExpr.value < 0 then
			typeError(state, intExpr, "String repetition: Integer is negative. (%d)", intExpr.value)
		end
		return getTypeInfoForBuiltinType(state, "string")

	-- Numeric operation.
	elseif !!(CONST_SET{"+","-","*","^","%","/","//"})[binOp] then
		if not (isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR)) then
			typeError(
				state, exprMain,
				"Binary numeric operation (%s): Expected operands to be numeric. (Got %s and %s)",
				binOp,
				getFriendlyTypeInfoName(typeInfoL),
				getFriendlyTypeInfoName(typeInfoR)
			)
		end

		if binOp == "/" then
			return getTypeInfoForBuiltinType(state, "float")
		elseif binOp == "//" then
			return getTypeInfoForBuiltinType(state, "int")
		elseif typeInfoL.tag == !(TYPE_FLOAT) or typeInfoR.tag == !(TYPE_FLOAT) then
			return getTypeInfoForBuiltinType(state, "float")
		else
			return getTypeInfoForBuiltinType(state, "int")
		end

	-- Comparison.
	elseif !!(CONST_SET{"<",">","<=",">="})[binOp] then
		if not (typeInfoL == typeInfoR or (isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR))) then
			!!(TYPE_MISMATCH)
		elseif not !!(CONST_SET{ TYPE_INT, TYPE_FLOAT, TYPE_STRING })[typeInfoL.tag] then
			typeError(
				state, exprMain,
				"Binary comparison (%s): Expected a float, int or string. (Got %s)",
				binOp,
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		return getTypeInfoForBuiltinType(state, "bool")

	-- Equality.
	elseif !!(CONST_SET{"==","~="})[binOp] then
		if not isValidEqualityCheck(state, exprForError, typeInfoL, typeInfoR) then
			!!(TYPE_MISMATCH)
		end
		return getTypeInfoForBuiltinType(state, "bool")

	-- Boolean operation.
	elseif !!(CONST_SET{"and","or"})[binOp] then
		local bothAreBool = true
		local typeInfo    = getTypeInfoForBuiltinType(state, "bool")

		if typeInfoL.tag ~= !(TYPE_BOOL) then
			!ASSERT `not inAssignment`
			bothAreBool = false
			wrapInImplicitCast(state, exprL, typeInfo, true)
		end
		if typeInfoR.tag ~= !(TYPE_BOOL) then
			bothAreBool = false
			wrapInImplicitCast(state, exprR, typeInfo, true)
		end

		if not bothAreBool then  return nil  end
		return typeInfo

	-- String concatenation.
	elseif binOp == ".." then
		if typeInfoL.tag ~= !(TYPE_STRING) then
			typeError(state, exprL, "String concatenation expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoL))
		elseif typeInfoR.tag ~= !(TYPE_STRING) then
			typeError(state, exprR, "String concatenation expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoR))
		end
		return getTypeInfoForBuiltinType(state, "string")

	else
		errorUnhandledNodeType(state, exprForError)
	end
end

!NODE_INFERRER `function nodeInferrers.AstBinary(state, binary)`
	local typeInfoL = binary.left.inferredType
	local typeInfoR = binary.right.inferredType

	if not typeInfoL then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.left`)
	end
	if not typeInfoR then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.right`)
	end

	typeInfoL = adjustTypeToOne(state, binary.left,  typeInfoL, true)
	typeInfoR = adjustTypeToOne(state, binary.right, typeInfoR, true)

	local typeInfo = checkBinaryOperation(state, binary, binary.left,binary.left,binary.right, binary.operation, typeInfoL,typeInfoR, false)
	if not typeInfo then  return  end

	binary.inferredType = typeInfo

	moveToNextRelevantPipe(state, binary)
	simplifyExpressionIfConstant(state, binary)
end

function _G.getConstantNameOrTriggerError(state, node)
	if not (node.nodeType == !(AST_LITERAL) and node.literalType == !(LITERAL_STRING)) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(node), "Expected a name constant as the member.")
	end

	local literal = node
	local name    = literal.value

	if not name:find"^[%a_\128-\255][%w_\128-\255]*$" then
		typeError(state, literal, "Bad format or invalid characters in name '%s'.", name)
	end

	return name
end

-- memberName, memberValueType, constDecl = validateStructKey( state, dependent, keyExpr, structInfo, isLvalue )
-- Returns nil on failure and the dependent is now waiting.
function _G.validateStructKey(state, dependent, keyExpr, structInfo, isLvalue)
	local keyExprType = keyExpr.inferredType
	local memberName  = ""
	local memberValueType, constDecl

	if structInfo.kind ~= !(STRUCT_KIND_NORMAL) and not structInfo.hasMembers then
		!DEPEND_AND_RETURN(`dependent`, DEPEND_STRUCT_MEMBERS_READY, `structInfo`, nil, `nil`)
	end

	if structInfo.kind == !(STRUCT_KIND_TABLE) and (keyExprType.tag ~= !(TYPE_STRING) or structInfo.keyType.tag == !(TYPE_STRING)) then
		if not isTypeCompatibleWith(keyExprType, structInfo.keyType) then
			typeError(state, keyExpr, "Expected struct member name or %s. (Got %s)", getFriendlyTypeInfoName(structInfo.keyType), getFriendlyTypeInfoName(keyExprType))
		end
		memberValueType = structInfo.valueType

	elseif structInfo.kind == !(STRUCT_KIND_ARRAY) and keyExprType.tag ~= !(TYPE_STRING) then
		if keyExprType.tag ~= !(TYPE_INT) then
			typeError(state, keyExpr, "Expected struct member name or array index. (Got %s)", getFriendlyTypeInfoName(keyExprType))
		end
		memberValueType = structInfo.valueType

	else
		if keyExprType.tag ~= !(TYPE_STRING) then
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(keyExpr),
				"Member names in struct constructors must be strings. (This is %s)",
				getFriendlyTypeInfoName(keyExprType)
			)
		elseif keyExpr.nodeType ~= !(AST_LITERAL) then
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(keyExpr),
				"Member names in struct constructors must be constant. (Type is string)"
			)
		end

		local memberLiteral = keyExpr
		memberName          = memberLiteral.value

		local decl = findMemberDeclaration(state, structInfo.astNode, memberName)
		if not decl then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_MEMBER_DECLARATION, `memberName`, `structInfo.astNode`, `nil`)
		elseif isLvalue and isDeclarationConstant(decl) then
			typeError(state, memberLiteral, "Cannot assign value to constant member %s.%s", getFriendlyTypeInfoName(structInfo), memberName)
		end

		memberValueType = decl.name.inferredType
		if not memberValueType then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_INFERRED, `decl.name`, nil, `nil`)
		end

		if isDeclarationConstant(decl) then  constDecl = decl  end
	end

	return memberName, memberValueType, constDecl
end

local function checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode(state, topNodeToCheck, staticObjectNode)
	astVisitAllNodes(topNodeToCheck, function(node)
		if
			node.nodeType == !(AST_ACCESS)
			or (
				node.nodeType == !(AST_IDENTIFIER)
				and node.parent.nodeType == !(AST_ACCESS)
				and node == node.parent.object
			)
			or (
				node.nodeType == !(AST_LITERAL)
				and node.parent.nodeType == !(AST_ACCESS)
				and node == node.parent.member
			)
		then
			-- void

		else
			typeError2(state,
				staticObjectNode, F("Trying to access a static object using code that looks like it's supposed to do something at runtime. Ambigous intension."),
				node,             F("...this looks like a runtime expression.")
			)
		end
	end)
end

!NODE_INFERRER `function nodeInferrers.AstAccess(state, access)`
	local typeObject = access.object.inferredType
	local typeMember = access.member.inferredType

	if not typeObject then
		!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `access.object`)
	end
	if not typeMember then
		!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `access.member`)
	end

	if typeObject.tag == !(TYPE_LIST) then
		typeObject = adjustTypeToOne(state, access.object, typeObject, true)
	end
	typeMember = adjustTypeToOne(state, access.member, typeMember, true)

	local isDirectObject  = access.object.inferredType == typeObject
	local isDirectMember  = access.member.inferredType == typeMember

	local isLvalue        = access.parent.nodeType == !(AST_ASSIGNMENT) and access.queued.container == access.parent.targets
	local typeRepresented = getTypeRepresentedByExpression(access.object)

	if typeObject.tag == !(TYPE_TABLE) then
		if typeMember.tag == !(TYPE_NONE) then
			typeError(state, access.member, "Table keys cannot be nil.")

		elseif typeMember.tag == !(TYPE_COMPOUND) and indexOf(typeMember, getTypeInfoForBuiltinType(state, "none")) then
			typeError(state, access.member, "Table keys cannot be nil. (Type is %s)", getFriendlyTypeInfoName(typeMember))

		--[[ This warning message may be too noisy in some programs.
		elseif typeMember.tag == !(TYPE_ANY) then
			-- @Incomplete: Add a setting to suppress warnings.
			typeMessage(
				io.stderr, state, astGetExpressionVisuallyFurthestToTheLeft(access.member),
				"Warning", "Table key is 'any' and thus possibly nil."
			)
		--]]
		end

		access.inferredType = getTypeInfoForBuiltinType(state, "any")
		moveToNextRelevantPipe(state, access)

	elseif typeObject.tag == !(TYPE_ARRAY) then
		local arraySig = typeObject

		if typeMember.tag == !(TYPE_INT) then
			-- @Incomplete: Check for isLvalue and constantness.

			if access.member.nodeType == !(AST_LITERAL) and access.member.value < 1 then
				local indexLiteral = access.member
				typeError(state, indexLiteral, "Array index is %d.", indexLiteral.value)
			end

			access.inferredType = arraySig.itemType

			if not (isExpressionConstant(state, access.object, false) and isExpressionConstant(state, access.member, false)) then
				moveToNextRelevantPipe(state, access)
				return
			end

			-- Check that the item in the constant array exists.
			local indexLiteral = access.member
			assert(indexLiteral.nodeType == !(AST_LITERAL))
			local i = indexLiteral.value

			local tableNode = followIdentifiersToConstantValue(access.object)
			assert(tableNode.nodeType == !(AST_TABLE))

			local itemExpr = nil

			for _, tableField in ipairs(tableNode.fields) do
				assert(tableField.key.nodeType == !(AST_LITERAL))
				if tableField.key.value == i then
					itemExpr = tableField.value
				end
			end

			if not itemExpr then
				typeError(state, indexLiteral, "No item at index %d in constant array. (Length is %d)", i, #tableNode.fields)
			end

			moveToNextRelevantPipe(state, access)

		-- elseif not isLvalue and typeMember.tag == !(TYPE_STRING) then
		-- 	local abstractMemberLiteral = access.member
		-- 	local abstractMemberName    = getConstantNameOrTriggerError(state, abstractMemberLiteral)
		-- 	if abstractMemberName == ? then ... end

		else
			typeError(state, access.member, "Expected an array index of type int. (Got %s)", getFriendlyTypeInfoName(typeMember))
		end

	elseif typeObject.tag == !(TYPE_STRUCT) or (typeRepresented and typeRepresented.tag == !(TYPE_STRUCT)) then
		local structInfo                             = typeRepresented or typeObject
		local memberName, memberValueType, constDecl = validateStructKey(state, access, access.member, structInfo, isLvalue)

		if not memberName      then  return  end
		if not memberValueType then  errorInternal(state, access.member)  end

		if not constDecl then
			if typeRepresented then
				-- We don't allow StructType.dynamicMember except in certain contexts.
				local foundNode = astFindParent(access, !!(CONST_SET{
					AST_TYPE_OF, AST_TYPE_INFO, AST_LOCATION,
					unpack(scopeNodeTypes)
				}))

				if not !!(CONST_SET{
					AST_TYPE_OF, AST_TYPE_INFO, AST_LOCATION,
				})[foundNode.nodeType] then
					typeError(state, access.member, "Dynamic member '%s' is not accessible in static context.", memberName)
				end
			end

			access.inferredType = memberValueType
			moveToNextRelevantPipe(state, access)
			return
		end

		if not (
			isExpressionConstant(state, access.object, false)
			or (access.parent.nodeType == !(AST_CALL) and access.parent.isMethod) -- It's ok to do e.g. getObject().staticMethod!()
		) then
			checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode(state, access.object, access.member)
		end

		local valueExpr = constDecl.value
		local nodeType  = valueExpr.nodeType
		local replacement

		if !!(CONST_SET{ AST_LITERAL, AST_FOREIGN })[nodeType] then
			replacement = astCopy(valueExpr, access.member.token)

		elseif nodeType == !(AST_TYPE) then
			replacement = astCopy(valueExpr, access.member.token)
			addUnqueuedChildrenToQueueRecursively(state, replacement, !(PIPE_DONE))

		elseif nodeType == !(AST_IDENTIFIER) and valueExpr.inferredType.tag == !(TYPE_ENUM) then
			replacement = astCopy(valueExpr, access.member.token)

		elseif !!(CONST_SET{ AST_ENUM, AST_STRUCT })[nodeType] then
			replacement = createTypeNodeFromInfo(state, valueExpr.representedType, access.member.token, access.parent) -- Parent is temp and will change in a moment.

		elseif nodeType == !(AST_LAMBDA) then
			if access.parent.nodeType == !(AST_CALL) and access == access.parent.callee and access.parent.isMethod then
				--
				-- Change obj.staticMethod!(...) into staticMethod(obj, ...)
				--
				-- AstCall (method)
				--   CALLEE AstAccess
				--     AstIdentifier (object)
				--     AstLiteral (string)
				--   ARG1...
				--
				-- AstCall (normal)
				--   CALLEE AstIdentifier (static function)
				--   ARG1 AstIdentifier (object)
				--   ARG2...
				--
				local call = access.parent

				-- Move object from access to call arguments.
				local obj = access.object
				table.insert(call.arguments, 1, obj)
				obj.parent = call

				-- Update all argument queueds.
				for i, argExpr in ipairs(call.arguments) do
					argExpr.queued.container = call.arguments
					argExpr.queued.key       = i
				end

				-- Update callee using access. (Note: access==callee)
				local ident        = astNewNode(AstIdentifier, access.member.token, call)
				ident.name         = constDecl.name.name
				ident.declaration  = constDecl
				ident.inferredType = constDecl.name.inferredType
				replaceQueuedNode(state, access, ident)
				moveToNextRelevantPipe(state, ident)

				-- Update call.
				call.isMethod = false

				-- Unqueue now unused nodes.
				unqueue(access.member)

				return
			end

			local ident        = astNewNode(AstIdentifier, access.member.token, access.parent)
			ident.name         = constDecl.name.name
			ident.declaration  = constDecl
			ident.inferredType = constDecl.name.inferredType
			replacement        = ident

		else
			!ifDEBUG `where(state, access)`
			errorUnhandledNodeType(state, valueExpr)
		end

		assert(replacement) -- Constants must be simplified!

		replaceQueuedNodeAndUnqueueOldTree(state, access, replacement)
		moveToNextRelevantPipe(state, replacement, !(PIPE_INFER))

	elseif typeObject.tag == !(TYPE_ENUM) or (typeRepresented and typeRepresented.tag == !(TYPE_ENUM)) then
		local memberLiteral = access.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)

		local enumInfo      = typeRepresented or typeObject
		local decl          = findMemberDeclaration(state, enumInfo.astNode, memberName)

		if not decl then
			typeError(state, memberLiteral, "'%s' is not a member of %s.", memberName, getFriendlyTypeInfoName(enumInfo))
		elseif isLvalue then
			typeError(state, memberLiteral, "Cannot assign values to enum members. (Enum is %s)", getFriendlyTypeInfoName(enumInfo))
		end

		!ASSERT `isDeclarationConstant(decl)`

		local ident = astCopy(decl.name, access.token, access.parent)
		replaceQueuedNodeAndUnqueueOldTree(state, access, ident)

		-- Stay in the current pipe so we get simplified. (Needed? Or maybe we can @Speed things up here?)
		inferNode(state, ident)

	elseif typeObject.tag == !(TYPE_NAMESPACE) then
		assert(isDirectObject)

		local memberLiteral = access.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)

		local namespaceInfo = typeObject
		local decl          = findPublicDeclarationInScope(state, namespaceInfo.scope, memberName)

		if not decl then
			!DEPEND_AND_RETURN(`access`, DEPEND_DECLARATION, `memberName`, `namespaceInfo.scope`)
		elseif not decl.name.inferredType then
			!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `decl.name`)
		end

		local ident = astCopy(decl.name, access.token, access.parent)
		replaceQueuedNodeAndUnqueueOldTree(state, access, ident)

		-- Stay in the current pipe so we get simplified. (Needed? Or maybe we can @Speed things up here?)
		inferNode(state, ident)

	elseif typeObject.tag == !(TYPE_STRING) then
		local strExpr   = access.object
		local indexExpr = access.member

		if typeMember.tag ~= !(TYPE_INT) then
			typeError(state, indexExpr, "Expected a byte position of type int. (Got %s)", getFriendlyTypeInfoName(typeMember))
		elseif indexExpr.nodeType == !(AST_LITERAL) and indexExpr.value <= 0 then
			typeError(state, indexExpr, "Byte position is not positive. (It is %d)", indexExpr.value)
		end

		access.inferredType = typeMember

		if not (isExpressionConstant(state, strExpr, false) and isExpressionConstant(state, indexExpr, false)) then
			moveToNextRelevantPipe(state, access)
			return
		end

		assert(strExpr.nodeType   == !(AST_LITERAL))
		assert(indexExpr.nodeType == !(AST_LITERAL))

		local s = strExpr.value
		local i = indexExpr.value

		if i > #s then
			typeError(state, indexExpr, "Byte position is greater than the length of the string. (Index is %d, length is %d)", i, #s)
		end

		local literal = newLiteral(access.parent, access.token, !(LITERAL_INTEGER), s:byte(i), typeMember)
		replaceQueuedNodeAndUnqueueOldTree(state, access, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	elseif typeObject.tag == !(TYPE_VARARG) then
		local indexExpr = access.member

		if typeMember.tag ~= !(TYPE_INT) then
			typeError(state, indexExpr, "Expected an index of type int. (Got %s)", getFriendlyTypeInfoName(typeMember))
		elseif indexExpr.nodeType == !(AST_LITERAL) and indexExpr.value <= 0 then
			typeError(state, indexExpr, "Index is not positive. (It is %d)", indexExpr.value)
		end

		local varargSig     = typeObject
		access.inferredType = varargSig.itemType -- Treat varargs like arrays (i.e. we don't use adjustTypeToOne() when accessing them).
		moveToNextRelevantPipe(state, access)

	else
		typeError(state, access, "Values of type '%s' do not have members.", getFriendlyTypeInfoName(typeObject))
	end
end

local function inferTableArray(state, tableNode, arraySig)
	for _, tableField in ipairs(tableNode.fields) do
		local indexLiteral = tableField.key

		if not indexLiteral.inferredType then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `indexLiteral`)
		elseif indexLiteral.inferredType.tag ~= !(TYPE_INT) then
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(indexLiteral),
				"Array indices must be integers. (This is %s)",
				getFriendlyTypeInfoName(indexLiteral.inferredType)
			)
		elseif indexLiteral.nodeType ~= !(AST_LITERAL) then
			-- @Incomplete: Allow indices to be variable? :VariableArrayIndices
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(indexLiteral),
				"Indices must be constant in array constructors."
			)
		end

		local itemExpr     = tableField.value
		local itemTypeInfo = itemExpr.inferredType

		if itemTypeInfo then
			if not isTypeCompatibleWith(adjustTypeToOne(state, itemExpr, itemTypeInfo, true), arraySig.itemType) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
					"Array item type mismatch. (Wanted %s, got %s)",
					getFriendlyTypeInfoName(arraySig.itemType),
					getFriendlyTypeInfoName(adjustTypeToOne(state, itemExpr, itemTypeInfo, true))
				)
			end
		elseif itemExpr.nodeType == !(AST_TABLE) then
			if isTypeTableLike(arraySig.itemType) then
				-- void  (Wait with validation.)
			else
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
					"Expected array item to be %s.",
					getFriendlyTypeInfoName(arraySig.itemType)
				)
			end
		else
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `itemExpr`)
		end
	end

	tableNode.inferredType = arraySig

	local trailingExpr = tableNode.trailingExpression
	if trailingExpr then
		adjustTypeToOne(state, trailingExpr, trailingExpr.inferredType) -- Ensure this is not a call that returns nothing.
	end

	-- Validate indices and sequence. :ConstructorTrailingCall
	local indexLiterals       = {}
	local highestLiteralIndex = 0

	for _, tableField in ipairs(tableNode.fields) do
		local literal    = tableField.key
		local arrayIndex = literal.value

		if indexLiterals[arrayIndex] then
			typeError2(state,
				literal,                   F("Duplicate index %d.", arrayIndex),
				indexLiterals[arrayIndex], F("...first occurance is here.")
			)
		elseif arrayIndex <= 0 then
			typeError(state, literal, "Array index is not positive. (It is %d)", arrayIndex)
		end

		indexLiterals[arrayIndex] = literal
		highestLiteralIndex       = math.max(highestLiteralIndex, arrayIndex)
	end

	if trailingExpr and highestLiteralIndex > tableNode.highestGeneratedIndex then
		-- We get here if explicit indices are combined with a trailing expression.
		for i = tableNode.highestGeneratedIndex+1, highestLiteralIndex do
			local overlap = indexLiterals[i]
			if overlap then
				typeError2(state,
					trailingExpr, F("Potentially overlapping value(s) at or after array index %d because of this expression.", tableNode.highestGeneratedIndex+1),
					overlap,      F("...first overlap would be here.")
				)
			end
		end
		errorInternal() -- highestLiteralIndex would be incorrect if we're here.
	end

	for arrayIndex = 1, highestLiteralIndex do
		if not indexLiterals[arrayIndex] then
			typeError(state, tableNode, "Array is not a sequence. Missing item at index %d.", arrayIndex)
		end
	end

	-- Validate trailing expression.
	if not trailingExpr then
		-- void

	elseif trailingExpr.nodeType == !(AST_VARARG) then
		if not isTypeCompatibleWith(trailingExpr.inferredType.itemType, arraySig.itemType) then
			typeError(
				state, trailingExpr,
				"Array item type mismatch for vararg. (Wanted %s, got %s)",
				getFriendlyTypeInfoName(arraySig.itemType),
				getFriendlyTypeInfoName(trailingExpr.inferredType.itemType)
			)
		end

	elseif trailingExpr.nodeType == !(AST_CALL) then
		local call        = trailingExpr
		local argTypesOut = call.callee.inferredType.argumentTypesOut

		for i, argTypeInfo in ipairs(argTypesOut) do
			argTypeInfo = adjustTypeToOne(state, call, argTypeInfo)

			if not isTypeCompatibleWith(argTypeInfo, arraySig.itemType) then
				typeError(
					state, call,
					"Array item type mismatch for return value #%d from call. (Wanted %s, got %s)",
					i,
					getFriendlyTypeInfoName(arraySig.itemType),
					getFriendlyTypeInfoName(argTypeInfo)
				)
			end
		end

	else
		errorUnhandledNodeType(state, trailingExpr)
	end
end

local function inferTableStruct(state, tableNode, structInfo)
	if structInfo.astNode.isForeign then
		!TRACE()
		printerr()
		nodeMessage(io.stderr, state, tableNode, "Error", "Typer", "Cannot instantiate foreign struct '%s'.", getFriendlyTypeInfoName(structInfo))
		-- if structInfo.astNode.foreignThroughNode then
		-- 	nodeMessage(io.stderr, state, structInfo.astNode.foreignThroughNode, "Info", "Typer", "...the struct got its foreign state through this.")
		-- end
		exitFailure()
	end

	for _, tableField in ipairs(tableNode.fields) do
		local fieldKey     = tableField.key
		local fieldKeyType = fieldKey.inferredType

		if not fieldKeyType then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `fieldKey`)
		end

		local memberName, memberValueType = validateStructKey(state, tableNode, fieldKey, structInfo, true)
		if not memberName      then  return  end
		if not memberValueType then  errorInternal(state, fieldKey)  end

		!local TARGET_NAME   = `memberName ~= "" and F("value for struct field '%s'", memberName) or "value"`
		local fieldValue     = tableField.value
		local fieldValueType = fieldValue.inferredType

		if fieldValueType then
			if not isTypeCompatibleWith(adjustTypeToOne(state, fieldValue, fieldValueType, true), memberValueType) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(fieldValue),
					"Type mismatch for %s. (Wanted %s, got %s)",
					!!(TARGET_NAME),
					getFriendlyTypeInfoName(memberValueType),
					getFriendlyTypeInfoName(fieldValueType)
				)
			end
		elseif fieldValue.nodeType == !(AST_TABLE) then
			if isTypeTableLike(memberValueType) then
				-- void  (Wait with validation.)
			else
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
					"Expected %s to be %s.",
					!!(TARGET_NAME),
					getFriendlyTypeInfoName(memberValueType)
				)
			end
		else
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `fieldValue`)
		end
	end

	tableNode.inferredType = structInfo

	-- Check for duplicate keys.
	-- @Incomplete: Check non-string keys.
	local keyLiterals = {}

	for _, tableField in ipairs(tableNode.fields) do
		if tableField.key.nodeType == !(AST_LITERAL) and tableField.key.literalType == !(LITERAL_STRING) then
			local memberLiteral = tableField.key
			local memberName    = memberLiteral.value

			if keyLiterals[memberName] then
				typeError2(state,
					memberLiteral,           F("Duplicate field '%s'.", memberName),
					keyLiterals[memberName], F("...first occurance is here.")
				)
			end

			keyLiterals[memberName] = memberLiteral
		end
	end

	if tableNode.trailingExpression then
		errorInternal(state, tableNode.trailingExpression, "@Incomplete: Handle trailing expression in struct constructors.") -- :ConstructorTrailingCall (and vararg)
	end
end

!NODE_INFERRER `function nodeInferrers.AstTable(state, tableNode)`
	-- Note: tableNode.inferredType may get set before all child nodes are inferred.
	local typeExpected = tableNode.inferredType or getExpectedTypeInfo(state, tableNode, false, "constructor", tableNode)
	if not typeExpected then  return  end

	if typeExpected.tag == !(TYPE_ANY) and tableNode.parent.nodeType == !(AST_TABLE) then
		typeExpected = getTypeInfoForBuiltinType(state, "table")
	end

	local trailingExpr   = tableNode.trailingExpression
	local lastTableField = not trailingExpr and getLast(tableNode.fields) or nil

	if lastTableField and lastTableField.keyIsGenerated then
		local valueExpr = lastTableField.value

		-- Note: We don't need to check for vararg as the parser should have
		-- handled that (by setting trailingExpression right away).
		if valueExpr.nodeType == !(AST_CALL) and not valueExpr.surroundedByParentheses then
			if not valueExpr.inferredType then
				!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `valueExpr`)
			end

			trailingExpr                        = valueExpr

			valueExpr.parent                    = tableNode
			valueExpr.queued.container          = tableNode
			valueExpr.queued.key                = "trailingExpression"

			tableNode.trailingExpression        = valueExpr
			tableNode.fields[#tableNode.fields] = nil
			tableNode.highestGeneratedIndex     = tableNode.highestGeneratedIndex-1

			unqueue(lastTableField.key) -- Note: The key should be an int literal as it's generated.
		end
	end

	if trailingExpr and not trailingExpr.inferredType then
		!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `trailingExpr`)
	end

	if typeExpected.tag == !(TYPE_TABLE) then
		-- @Incomplete: Check for duplicate fields (among constant keys).
		-- @Incomplete: Check for nil keys.
		tableNode.inferredType = typeExpected
		-- Note: We don't need to validate any types or anything (including tableNode.trailingExpression) as generic tables accept anything.

	elseif typeExpected.tag == !(TYPE_ARRAY) then
		inferTableArray(state, tableNode, typeExpected)
		if tableNode.queued.waitingOn then  return  end

	elseif typeExpected.tag == !(TYPE_STRUCT) then
		inferTableStruct(state, tableNode, typeExpected)
		if tableNode.queued.waitingOn then  return  end

	else
		typeError(
			state, tableNode,
			"This constructor is trying to get inferred as %s (type group '%s') which is illegal. (The inferred type must be array, struct or table.)",
			getFriendlyTypeInfoName(typeExpected),
			TYPE_NAMES[typeExpected.tag]
		)
	end

	!ASSERT `tableNode.inferredType`

	-- Make sure all children (including table-likes) are fully(!) inferred before we advance to the next pipe.
	for _, tableField in ipairs(tableNode.fields) do
		if tableField.value.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED_FULLY, `tableField.value`)
		end
		if tableField.key.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED_FULLY, `tableField.key`)
		end
	end
	if trailingExpr and trailingExpr.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED_FULLY, `trailingExpr`)
	end

	moveToNextRelevantPipe(state, tableNode)
end

!NODE_INFERRER `function nodeInferrers.AstArgument(state, arg)`
	if arg.declaration.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`arg`, DEPEND_NODE_INFERRED, `arg.declaration`)
	end
	moveToNextRelevantPipe(state, arg)
end

!NODE_INFERRER `function nodeInferrers.AstArguments(state, args)`
	for _, arg in ipairs(args.arguments) do
		if arg.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`args`, DEPEND_NODE_INFERRED, `arg`)
		end
	end
	moveToNextRelevantPipe(state, args)
end

!NODE_INFERRER `function nodeInferrers.AstLambda(state, lambda)`
	if lambda.isPolymorphic then
		lambda.inferredType = getTypeInfoForLambda(state, lambda) or errorInternal(state, lambda)
		moveToNextRelevantPipe(state, lambda)
		return
	end

	local argsIn  = lambda.argumentsIn
	local argsOut = lambda.argumentsOut

	if argsIn and argsIn.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `argsIn`)
	end
	if argsOut and argsOut.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `argsOut`)
	end
	if lambda.bodyTextLambda and lambda.bodyTextLambda.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.bodyTextLambda`)
	end

	if lambda.bodyIsForeign and lambda.foreignSource == "method" then
		-- Validate method.
		local argIn1   = argsIn and argsIn.arguments[1]
		local argType1 = argIn1 and argIn1.declaration.name.inferredType

		if not argIn1 then
			typeError(state, lambda, "Expected a struct as first argument for foreign method.")

		elseif argType1.tag ~= !(TYPE_STRUCT) then
			typeError(
				state, argIn1,
				"Expected the first arguments to be a struct. Foreign methods are only supported on structs. (Type is %s)",
				getFriendlyTypeInfoName(argType1)
			)

		elseif not argType1.astNode.isForeign and not argType1.hasMembers then
			!DEPEND_AND_RETURN(`lambda`, DEPEND_STRUCT_MEMBERS_READY, `argType1`) -- We need this for isForeign to be valid.

		elseif not argType1.astNode.isForeign then
			typeError2(state,
				argIn1.declaration.type, F("%s is not a foreign struct. Foreign methods only work on foreign structs.", getFriendlyTypeInfoName(argType1)),
				argType1.astNode,        F("...here is the struct")
			)

		elseif not argIn1.isRequired then
			typeError(state, argIn1, "The first argument must not be optional for foreign methods.")
		end
	end

	-- Note: We don't require the body to inferred - just the "header".

	local bodyTextFunc = nil

	if lambda.bodyTextLambda then
		bodyTextFunc = prepareToRun(state, lambda, lambda.bodyTextLambda)
		if not bodyTextFunc then  return  end
	end

	--
	-- No more dependencies for this lambda after this point!
	--

	if bodyTextFunc then
		local bodyText
		do
			local body_text = bodyTextFunc -- For better error messages.
			bodyText        = body_text()
		end

		if type(bodyText) ~= "string" then
			typeError(state, lambda.bodyTextLambda, "Function did not return a string. (It returned %s)", type(bodyText))
		end

		local fileScope  = astFindParent1(lambda, !(AST_FILE_SCOPE))
		local tokens     = state.tokens
		local startToken = tokens.count+1

		-- @UX: Output all bodyTexts into a file that's easier to debug.
		local pathDummy
		if tokens.file[lambda.bodyTextLambda.token] == fileScope.path then
			pathDummy = F("<body_text @ %s:%d>", fileScope.path, tokens.line1[lambda.bodyTextLambda.token])
		else
			pathDummy = F("<body_text @ %s>", fileScope.path) -- @UX: Get the line number from the closest parent lambda with the same path as fileScope.
		end

		-- @Incomplete: Include these times in the compilation stats.
		local timeStartLexing, timeEndLexing = readAndTokenizeString(state, pathDummy, true, bodyText, 1)

		insertToken(tokens, !(TOKEN_PUNCTUATION),"}", bodyText,pathDummy) -- So we can parse the block.
		tokens.position1[tokens.count] = #bodyText
		tokens.position2[tokens.count] = #bodyText

		parseBlockStatements(state, lambda.body) -- May trigger a parsing error.

		if peekNextToken(state) then
			errorParsingLast(state, "Expected the end of the body text.") -- This is pointing at an unbalanced '}'.
		end

		--
		-- WARNING: The body will be able to see everything a normal body would even though
		-- it was generated from a string which could have come from literally anywhere!
		--

		addUnqueuedChildrenToQueueRecursively(state, lambda.body)
		queueForReinfer(state, lambda.body) -- This was empty and probably got inferred right away.
	end

	if argsIn and not lambda.bodyIsForeign then
		for _, arg in ipairs(argsIn.arguments) do
			if arg.declaration.value and not isExpressionConstant(state, arg.declaration.value, true) then
				typeError(state,
					astGetExpressionVisuallyFurthestToTheLeft(arg.declaration.value),
					"Non-constant default values for arguments are not supported yet."
				)
			end
		end
	end

	local funcSig       = getTypeInfoForLambda(state, lambda) or errorInternal(state, lambda)
	lambda.inferredType = funcSig

	if lambda.bodyIsForeign then
		if not lambda.foreignSourceName then
			errorInternal(state, lambda, "@Incomplete: Infer lambda.foreignSourceName")
		end

		validateForeignSource(state, lambda.foreignSource, lambda.foreignSourceName.value, lambda.foreignSourceName)
		lambda.foreignSourceId = lambda.foreignSource.." "..lambda.foreignSourceName.value
	end

	moveToNextRelevantPipe(state, lambda)
end

!NODE_INFERRER `function nodeInferrers.AstTypeOf(state, typeOf)`
	-- @Robustness: Check that the expression doesn't have code that looks like it's going to be executed, because it's not!

	local exprTypeInfo = typeOf.expression.inferredType

	if not exprTypeInfo then
		!DEPEND_AND_RETURN(`typeOf`, DEPEND_NODE_INFERRED, `typeOf.expression`)
	elseif exprTypeInfo.tag == !(TYPE_NAMESPACE) then
		typeError(state, typeOf.expression, "Namespaces don't have a type.")
	end
	if typeOf.expression.nodeType == !(AST_CALL) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeOf.expression), "Cannot get the type of function calls.")
	end

	typeOf.inferredType    = getTypeInfoForBuiltinType(state, "Type")
	typeOf.representedType = exprTypeInfo

	if typeOf.representedType.tag == !(TYPE_VARARG) then
		local varargSig        = typeOf.representedType
		typeOf.representedType = varargSig.itemType
	end

	moveToNextRelevantPipe(state, typeOf)
	simplifyTypeExpression(state, typeOf, typeOf.representedType)
end

!NODE_INFERRER `function nodeInferrers.AstVariantOf(state, variant)`
	if not variant.call.inferredType then
		!DEPEND_AND_RETURN(`variant`, DEPEND_NODE_INFERRED, `variant.call`)
	end

	local call = variant.call
	if call.nodeType == !(AST_TYPE) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(call), "Expected a function call. (This is a type)")
	elseif call.nodeType ~= !(AST_CALL) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(call), "Expected a function call.")
	end

	local ident = call.callee
	if ident.nodeType ~= !(AST_IDENTIFIER) then
		typeError(state, call, "Expected the reference to the called function to be a constant name.")
	end

	local decl = ident.declaration
	if not isDeclarationConstant(decl) then
		typeError2(state,
			ident, F("'%s' is not constant.", ident.name),
			decl,  F("...here is the declaration.")
		)
	end

	local lambda = decl.value or errorInternal(state, decl)
	lambda       = followIdentifiersToConstantValue(lambda)

	!ASSERT("lambda.nodeType == "..AST_LAMBDA)

	if not (
		decl.overloadOf
		or (
			lambda.parent.parent.nodeType == !(AST_LAMBDA)
			and indexOf(lambda.parent.parent.polymorphs, lambda.parent)
		)
	) then
		typeError2(state,
			ident, F("'%s' is neither overloaded nor a polymorphic function.", ident.name),
			decl,  F("...here is the declaration.")
		)
	end

	local replacement = astCopy(ident, variant.token, variant.parent)
	replaceQueuedNodeAndUnqueueOldTree(state, variant, replacement)
	moveToNextRelevantPipe(state, replacement)
end

!NODE_INFERRER `function nodeInferrers.AstTypeInfo(state, typeInfoNode)`
	-- @Robustness: Check that the expression doesn't have code that looks like it's going to be executed, because it's not!

	if not typeInfoNode.expression.inferredType then
		!DEPEND_AND_RETURN(`typeInfoNode`, DEPEND_NODE_INFERRED, `typeInfoNode.expression`)
	end

	local typeRepresented = requireTypeRepresentedByExpression(state, typeInfoNode.expression)
	local tag             = typeRepresented.tag
	local typeInfoStructName

	if tag == !(TYPE_ARRAY) then
		typeInfoStructName = "TypeInfoArray"
	elseif tag == !(TYPE_COMPOUND) then
		typeInfoStructName = "TypeInfoCompound"
	elseif tag == !(TYPE_ENUM) then
		typeInfoStructName = "TypeInfoEnum"
	elseif tag == !(TYPE_FUNCTION) then
		typeInfoStructName = "TypeInfoFunction"
	elseif tag == !(TYPE_STRUCT) then
		typeInfoStructName = "TypeInfoStruct"
	elseif tag == !(TYPE_VARARG) then
		typeInfoStructName = "TypeInfoVararg"

	elseif !!(CONST_SET{ -- :SimplePublicTypeInfo
		TYPE_ANY,
		TYPE_BOOL,
		TYPE_FLOAT,
		TYPE_INT,
		TYPE_NONE,
		TYPE_PLACEHOLDER,
		TYPE_STRING,
		TYPE_TABLE,
		TYPE_TYPE,
		TYPE_VOID,
	})[tag] then
		typeInfoStructName = "TypeInfo"

	else
		errorUnhandledType(state, typeInfoNode, typeRepresented)
	end

	!ASSERT `typeInfoStructName`

	local decl = findInferredPreloadDeclaration(state, typeInfoNode, typeInfoStructName, !(TYPE_STRUCT))
	if not decl then  return  end

	typeInfoNode.valueTypeInfo = typeRepresented
	typeInfoNode.inferredType  = decl.valueTypeInfo
	moveToNextRelevantPipe(state, typeInfoNode)
end

!NODE_INFERRER `function nodeInferrers.AstLocation(state, loc)`
	local target = loc.expression
	if target and not target.inferredType then
		!DEPEND_AND_RETURN(`loc`, DEPEND_NODE_INFERRED, `target`)
	end

	local decl = findInferredPreloadDeclaration(state, loc, "SourceCodeLocation", !(TYPE_STRUCT))
	if not decl then  return  end

	if not target then
		target = loc -- Note: If loc is !caller_location then this isn't the actual target.

	else
		local original = astGetOriginal(target)

		if original.nodeType == !(AST_IDENTIFIER) then
			target = original.declaration or errorInternal(state, original, "Missing declaration for identifier.")

		elseif original.nodeType == !(AST_ACCESS) then
			if target.nodeType == !(AST_IDENTIFIER) then
				target = target.declaration -- This is probably a variable or enum constant.
			else
				errorInternal(state, loc, "@Incomplete: Locations of certain kinds of lookup targets.")
			end

		else
			typeError(state, target, "Cannot get the location of this expression.")
		end
	end

	loc.inferredType = decl.valueTypeInfo
	loc.target       = target
	moveToNextRelevantPipe(state, loc)
end

!NODE_INFERRER `function nodeInferrers.AstCast(state, cast)`
	-- Note: For convenience, cast.targetType may be nil here for generated casts. cast.inferredType must be set in those cases.

	local expr = cast.expression

	if cast.targetType and not cast.targetType.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.targetType`)
	end
	if not expr.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `expr`)
	end

	local castType    = cast.inferredType or requireTypeRepresentedByExpression(state, cast.targetType)
	local exprType    = adjustTypeToOne(state, expr, expr.inferredType, true)
	local castTypeTag = castType.tag
	local exprTypeTag = exprType.tag

	!local INVALID_CAST = `
		typeError(
			state, astGetExpressionVisuallyFurthestToTheLeft(expr),
			"Cannot cast from %s to %s.",
			getFriendlyTypeInfoName(exprType),
			getFriendlyTypeInfoName(castType)
		)
	`

	cast.inferredType = castType

	-- Useless cast.
	if castType == exprType then
		if cast.targetType and !!(CONST_SET{ AST_STRUCT, AST_ENUM })[cast.targetType.nodeType] then
			-- @Robustness: We cannot unqueue struct and enum nodes as that
			-- would mess up the types themselves! Can we maybe move these
			-- nodes somewhere safe?
			moveToNextRelevantPipe(state, cast)
		else
			moveToPipe(state, cast, expr.queued.pipe) -- @Cleanup: Maybe cutOutPartOfNodeTree()/replaceQueuedNode() should do this (or maybe we just keep the wrong queued in cutOutPartOfNodeTree()).
			cutOutPartOfNodeTree(state, cast, expr)
		end
		return

	elseif
		-- Comaptible types.
		(exprTypeTag == !(TYPE_ANY) or isTypeCompatibleWith(exprType, castType))
		-- float <-> int
		or (isTypeNumeric(castType) and isTypeNumeric(exprType))
		-- Struct to substruct.
		or (exprTypeTag == !(TYPE_STRUCT) and castTypeTag == !(TYPE_STRUCT) and doesStructInherit(castType, exprType))
		-- Values to bool.
		or (castTypeTag == !(TYPE_BOOL) and !!(CONST_SET{
			TYPE_INT,
			TYPE_FLOAT,
			TYPE_STRING,
			TYPE_ARRAY
		})[exprTypeTag])
		-- Array-like struct to bool (passes as an array).
		or (castTypeTag == !(TYPE_BOOL) and exprTypeTag == !(TYPE_STRUCT) and exprType.kind == !(STRUCT_KIND_ARRAY))
		-- Enum member to real member type.
		or (exprTypeTag == !(TYPE_ENUM) and castType == exprType.memberTypeInfo)
		-- Type to int.
		or (exprTypeTag == !(TYPE_TYPE) and castTypeTag == !(TYPE_INT))
	then
		-- void  Valid cast.

	-- Compound to single.
	elseif castTypeTag ~= !(TYPE_COMPOUND) and exprTypeTag == !(TYPE_COMPOUND) then
		-- We get here for situations like these: local xMaybe:int|nil = 0 ; local x = cast(int) xMaybe
		-- The user better know what they're doing!
		local compound = exprType
		if not indexOf(compound, castType) then
			!!(INVALID_CAST)
		end

	-- Enum to numeric (not real member type).
	elseif exprTypeTag == !(TYPE_ENUM) and isTypeNumeric(castType) and isTypeNumeric(exprType.memberTypeInfo) then
		-- We need two casts to happen in sequence here so we wrap the expression in another cast.
		wrapInImplicitCast(state, cast.expression, exprType.memberTypeInfo, false)
		simplifyExpressionIfConstant(state, cast.expression)

	-- Enum member type to enum.
	elseif castTypeTag == !(TYPE_ENUM) and exprType == castType.memberTypeInfo then
		if isExpressionConstant(state, expr, false) then
			assert(expr.nodeType == !(AST_LITERAL) or expr.nodeType == !(AST_TYPE))

			local enumInfo = castType
			local decl     = findDeclarationInEnumForValue(state, enumInfo.astNode, expr)

			if not decl then
				typeError(state, expr, "This value is not valid for enum '%s'.", getFriendlyTypeInfoName(castType))
			end
		end

	else
		!!(INVALID_CAST)
	end

	moveToNextRelevantPipe(state, cast)
	simplifyExpressionIfConstant(state, cast)
end

!NODE_INFERRER `function nodeInferrers.AstAssignment(state, assignment)`
	for _, targetExpr in ipairs(assignment.targets) do
		if not targetExpr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `targetExpr`)
		end
	end
	for _, expr in ipairs(assignment.values) do
		if not expr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `expr`)
		end
	end

	-- Validate targets.
	for _, targetExpr in ipairs(assignment.targets) do
		if not !!(CONST_SET{ AST_IDENTIFIER, AST_ACCESS, AST_BLANK })[targetExpr.nodeType] then
			!ifDEBUG`astPrint(targetExpr)`
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(targetExpr), "Invalid assignment target. Expected a variable name or object field.")
		end
	end

	-- Validate values.
	-- Note: Enum member values are already validated by the enum itself.
	local declScope        = assignment.forDeclaration and astFindParentScope(assignment) or nil
	local isEnumMemberDecl = declScope ~= nil and declScope.nodeType == !(AST_ENUM)

	if not isEnumMemberDecl then
		for i, targetExpr in ipairs(assignment.targets) do
			getAssignmentValue(state, targetExpr, assignment.values, i, targetExpr.inferredType, assignment.binaryOperation, nil)
		end
	end

	-- @Incomplete: Check that !must args from functions have an assignment target.

	moveToNextRelevantPipe(state, assignment)
end

!NODE_INFERRER `function nodeInferrers.AstBreak(state, breakNode)`
	moveToNextRelevantPipe(state, breakNode)
end
!NODE_INFERRER `function nodeInferrers.AstContinue(state, continue)`
	moveToNextRelevantPipe(state, continue)
end

!NODE_INFERRER `function nodeInferrers.AstDefer(state, defer)`
	if defer.body.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`defer`, DEPEND_NODE_INFERRED, `defer.body`)
	end

	astVisitAllNodesInUnit(defer.body, false, function(node)
		if node.nodeType == !(AST_RETURN) then
			typeError2(state,
				node,  F("Cannot return from within a defer."),
				defer, F("...here is the defer.")
			)
		elseif node.nodeType == !(AST_BREAK) or node.nodeType == !(AST_CONTINUE) then
			local loop = node.loop or astFindParent(node, !!(CONST_SET{ AST_FOR, AST_WHILE }))

			if astHasParent(defer, loop) then
				typeError2(state,
					node,  F("Cannot %s from within a defer to the outside.", (node.nodeType == !(AST_BREAK) and "break" or "continue")),
					defer, F("...here is the defer.")
				)
			end
		end
	end)

	moveToNextRelevantPipe(state, defer)
end

!NODE_INFERRER `function nodeInferrers.AstImport(state, import)`
	if import.fileScope then
		import.inferredType = getTypeInfoForNamespace(state, import.fileScope)
		moveToNextRelevantPipe(state, import)
		return
	end

	local importName = import.importName
	local path

	!(
	local function SET_PATH(pathCode, pathFallbackCode, fileDescription)
		__LUA(templateToLua(
			`
				path = $pathCode

				if not isReadableFile(path) then
					local pathFallback = $pathFallbackCode

					if not isReadableFile(pathFallback) then
						typeError(state, import, "Could not read $fileDescription '%s' or '%s'.", path, pathFallback)
					end

					path = pathFallback
				end
			`,
			{pathCode=pathCode, pathFallbackCode=pathFallbackCode, fileDescription=fileDescription}
		))
	end
	)

	if not import.isLoad then
		!SET_PATH(
			`F("%s/modules/%s.gloa",    COMPILER_DIRECTORY, importName)`,
			`F("%s/modules/%s/%s.gloa", COMPILER_DIRECTORY, importName, (importName:gsub("^.*/", "")))`,
			"module file"
		)
	elseif isPathAbsolute(importName) then
		path = importName
	else
		!SET_PATH(
			`F("%s/%s.gloa",    state.projectDirectory, importName)`,
			`F("%s/%s/%s.gloa", state.projectDirectory, importName, (importName:gsub("^.*/", "")))`,
			"file"
		)
	end

	local globalScope = state.globalScope

	if state.fileBuffers[path] then
		import.fileScope = itemWith1(globalScope.fileScopes, "path", path) or errorInternal(path)

	else
		!ifDEBUG `profilerPause()`

		local isPreload = not import.isLoad and importName == "preload"
		local tokens    = state.tokens

		if not isPreload then
			insertToken(tokens, !(TOKEN_DIRECTIVE),"import", "",path)
			insertToken(tokens, !(TOKEN_STRING),"preload",   "",path)
		end

		local startToken = tokens.count+1

		local timeStart          = os.clock()
		readAndTokenizeFile(state, path, (not isPreload))
		!ASSERT(`state.fileBuffers[path]`, `path`)
		local fileScope          = parseFileScope(state, globalScope, path, (not import.isLoad), importName)
		local timeParsing        = os.clock()  - timeStart
		state.timeParsing        = timeParsing + state.timeParsing
		state.timeParsingInPipes = timeParsing + state.timeParsingInPipes

		if peekNextToken(state) then
			errorParsingNext(state, "Expected the end of the file.")
		end

		if isPreload then
			for token = startToken, tokens.count do
				tokens.inserted[token] = true
			end
		end

		!ifDEBUG `profilerUnpause()`

		table.insert(globalScope.statementsStatic, fileScope)
		table.insert(globalScope.fileScopes,       fileScope)

		if import.isLoad then
			astMoveRelevantThingsFromFileScopeToGlobalScope(state, fileScope)
		end

		local i = indexOf(globalScope.fileScopes, fileScope) or errorInternal()
		addToQueueRecursively(state, fileScope, globalScope.fileScopes, i)

		import.fileScope = fileScope
	end

	import.inferredType = getTypeInfoForNamespace(state, import.fileScope)
	moveToNextRelevantPipe(state, import)
end

!NODE_INFERRER `function nodeInferrers.AstUsing(state, using)`
	local expr     = using.expression
	local typeInfo = expr.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`using`, DEPEND_NODE_INFERRED, `expr`)
	end

	local usingScope

	if expr.nodeType == !(AST_IDENTIFIER) then
		local ident = expr
		local decl  = ident.declaration

		if typeInfo.tag == !(TYPE_STRUCT) then
			local structInfo    = typeInfo
			usingScope          = structInfo.astNode
			if not isDeclarationConstant(decl) then  using.variableDeclaration = decl  end
		elseif typeInfo.tag == !(TYPE_ENUM) then
			local enumInfo      = typeInfo
			usingScope          = enumInfo.astNode -- Using an enum value is the same as using the enum type. :UsingEnumValueOrType
		elseif typeInfo.tag == !(TYPE_NAMESPACE) then
			local namespaceInfo = typeInfo
			usingScope          = namespaceInfo.scope
		else
			typeError(state, ident, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_NAMES[typeInfo.tag])
		end

	elseif expr.nodeType == !(AST_TYPE) then
		local typeNode = expr
		typeInfo       = typeNode.representedType

		if typeInfo.tag == !(TYPE_STRUCT) then
			local structInfo = typeInfo
			usingScope       = structInfo.astNode
		elseif typeInfo.tag == !(TYPE_ENUM) then
			local enumInfo   = typeInfo
			usingScope       = enumInfo.astNode -- :UsingEnumValueOrType
		else
			typeError(state, typeNode, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_NAMES[typeInfo.tag])
		end

	elseif expr.nodeType == !(AST_ACCESS) then
		local access = expr
		if typeInfo.tag == !(TYPE_ENUM) then
			local enumInfo = typeInfo
			usingScope     = enumInfo.astNode -- :UsingEnumValueOrType
		else
			-- @Incomplete: Support using struct instance members which themselves are structs: using myObj.otherObj
			typeError(state, access, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_NAMES[typeInfo.tag])
		end

	else
		!ifDEBUG`astPrint(expr)`
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Invalid or unsupported 'using' expression.")
	end

	local scopeOfUsing = astFindParentScope(using)

	local usingExisting =
		itemWith1(scopeOfUsing.usings, "scope", usingScope)
		-- Treat usings among function arguments as if they were in the body.
		or scopeOfUsing.nodeType == !(AST_BLOCK) and scopeOfUsing.parent.nodeType == !(AST_LAMBDA) and itemWith1(scopeOfUsing.parent.usings, "scope", usingScope)

	if usingExisting then
		-- Note: We don't look at .variableDeclaration. Maybe we should?
		local usingEarly = usingExisting
		local usingLate  = using

		if usingLate.token < usingEarly.token then
			usingEarly, usingLate = usingLate, usingEarly
		end

		typeError2(state,
			usingLate,  F("Duplicate using in the same scope."),
			usingEarly, F("...first using is here.")
		)
	end

	using.scope = usingScope

	moveToNextRelevantPipe(state, using)
end

!NODE_INFERRER `function nodeInferrers.AstForeign(state, foreign)`
	-- @Cleanup: Make AstLambda use AstForeign?
	if foreign.source == "method" then
		errorParsing(state, foreign.token+1, "Only function bodies can be marked as foreign methods.")
	end

	-- @Robustness: Further limit places the expected type can be inferred from for foreign values.
	local typeInfoExpected = getExpectedTypeInfo(state, foreign, true, "foreign value", foreign)
	if not typeInfoExpected then  return  end

	foreign.inferredType = typeInfoExpected

	if not foreign.sourceName then
		errorInternal(state, foreign, "@Incomplete: Infer foreign.sourceName")
	end

	validateForeignSource(state, foreign.source, foreign.sourceName.value, foreign.sourceName)
	foreign.sourceId = foreign.source.." "..foreign.sourceName.value

	moveToNextRelevantPipe(state, foreign)
end

!NODE_INFERRER `function nodeInferrers.AstBake(state, bake)`
	local scope, statement = astFindParentScope(bake)
	if not (scope and (
		(scope.nodeType == !(AST_LAMBDA) and statement == scope.argumentsIn)
		-- or (scope.nodeType == !(AST_STRUCT) and indexOf(scope.bakeDeclarations, statement))
	)) then
		astPrintTree(bake)
		astPrintTree(scope)
		errorParsing(state, bake.token, "Unexpected '$'.")
	end

	if not bake.name.inferredType then
		!DEPEND_AND_RETURN(`bake`, DEPEND_NODE_INFERRED, `bake.name`)
	end

	bake.inferredType = bake.name.inferredType
	moveToNextRelevantPipe(state, bake)
end

!NODE_INFERRER `function nodeInferrers.AstDebug(state, debugNode)`
	local expr     = debugNode.expression
	local typeInfo = expr.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`debugNode`, DEPEND_NODE_INFERRED, `expr`)
	end

	if debugNode.action == "assert" then
		if typeInfo.tag ~= !(TYPE_BOOL) then
			wrapInImplicitCast(state, expr, getTypeInfoForBuiltinType(state, "bool"), true)
			return
		end

		if not isExpressionConstant(state, expr, true) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Expression is not constant.")

		elseif not isExpressionConstant(state, expr, false) then
			while expr.nodeType == !(AST_CAST) do
				expr = expr.expression
			end
			typeError(state, expr, "Cannot statically assert foreign values as they are not known at compile-time.")

		elseif not (expr.nodeType == !(AST_LITERAL) and expr.literalType == !(LITERAL_BOOLEAN)) then
			errorInternal(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Constant expression did not result in a boolean literal.")

		elseif expr.value then
			-- void  Assertion passed!

		elseif not expr.replacing then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Assertion failed!")

		elseif expr.replacing.nodeType == !(AST_BINARY) then
			local binary = expr.replacing
			typeError(
				state, binary,
				"Binary assertion failed! (Left is %s, right is %s)",
				getFriendlyTypeInfoName(binary.left.inferredType), getFriendlyTypeInfoName(binary.right.inferredType)
			)

		elseif expr.replacing.nodeType == !(AST_CAST) and expr.replacing.expression.inferredType.tag ~= !(TYPE_BOOL) then
			local cast      = expr.replacing
			local typeInfo  = cast.expression.inferredType
			local tag       = typeInfo.tag
			typeError(
				state, cast, "Assertion failed! '%s' value is %s.",
				getFriendlyTypeInfoName(typeInfo),
				(
					(tag == !(TYPE_INT) or tag == !(TYPE_FLOAT)) and "zero"
					or "empty"
				)
			)

		else
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Assertion failed!")
		end

	elseif debugNode.action == "print" then
		astPrintTree(expr)
		typeMessage(state, expr, "!print", "The expression above is here.")

	else
		errorInternal(state, debugNode)
	end

	moveToNextRelevantPipe(state, debugNode)
end

local function inferIfOrWhile(state, ifOrWhile)
	local cond     = ifOrWhile.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`ifOrWhile`, DEPEND_NODE_INFERRED, `cond`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(TYPE_BOOL) then
		wrapInImplicitCast(state, cond, getTypeInfoForBuiltinType(state, "bool"), true)
		return
	end

	-- @Optimize: Remove/replace the branch if the condition is statically known.

	moveToNextRelevantPipe(state, ifOrWhile)
end

!NODE_INFERRER `function nodeInferrers.AstIf(state, ifBranch)`
	inferIfOrWhile(state, ifBranch)
end
!NODE_INFERRER `function nodeInferrers.AstWhile(state, whileLoop)`
	inferIfOrWhile(state, whileLoop)
end

!NODE_INFERRER `function nodeInferrers.AstStaticIf(state, staticIf)`
	local cond     = staticIf.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`staticIf`, DEPEND_NODE_INFERRED, `cond`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(TYPE_BOOL) then
		wrapInImplicitCast(state, cond, getTypeInfoForBuiltinType(state, "bool"), true)
		return
	end

	if not isExpressionConstant(state, cond, false) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(cond), "Static if: The condition must be a constant expression.")
	elseif not (cond.nodeType == !(AST_LITERAL) and cond.literalType == !(LITERAL_BOOLEAN)) then
		errorInternal(state, astGetExpressionVisuallyFurthestToTheLeft(cond), "Constant condition expression did not result in a boolean literal.")
	end

	local scope = staticIf.parent
	assert(isScope(scope))

	local statementsStatic  = scope.statementsStatic
	local targetContainer   = staticIf.queued.container
	local insertionIndex    = staticIf.queued.key
	local containerIsStatic = targetContainer == statementsStatic

	local statementsNew = {}
	local newlyDeclared = {} -- Keys are declarations and name strings.

	local branchToUse = (cond.value and staticIf.branchTrue or staticIf.branchFalse)

	if branchToUse then
		-- Static ifs in static context should only have static statements,
		-- but in dynamic context there may be both static and dynamic.
		if containerIsStatic and branchToUse.statementsDynamic[1] then
			errorInternal(state, branchToUse.statementsDynamic[1], "Dynamic statement(s) in static context.")
		end

		addUnqueuedChildrenToQueueRecursively(state, branchToUse) -- Note: We update the queueds in a moment.

		local statementsNewContainer = (containerIsStatic and branchToUse.statementsStatic or branchToUse.statementsDynamic)

		for iNew, statement in ipairs(statementsNewContainer) do
			if statement.nodeType == !(AST_DECLARATION) and statement.canShadow then
				typeError(state, statement, "Cannot have shadowing declarations directly inside !if blocks.") -- @Incomplete: Make this work?
			end
			statement.parent    = scope
			statementsNew[iNew] = statement
		end

		if not containerIsStatic then
			for _, statement in ipairs(branchToUse.statementsStatic) do
				if statement.nodeType == !(AST_DECLARATION) and statement.canShadow then
					typeError(state, statement, "Cannot have shadowing declarations directly inside !if blocks.") -- @Incomplete: Make this work?
				end
				local iNew             = #statementsStatic+1
				statement.parent       = scope
				statement.container    = statementsStatic
				statement.key          = iNew
				statementsStatic[iNew] = statement
			end
		end

		for _, decl in ipairs(branchToUse.declarations) do
			table.insert(scope.declarations, decl)
			newlyDeclared[decl]           = true
			newlyDeclared[decl.name.name] = true
		end
		for _, import in ipairs(branchToUse.imports) do
			if import.exported then  errorInternal(state, import, "@Incomplete: Export from static if.")  end
			table.insert(scope.imports, import)
		end
		for _, using in ipairs(branchToUse.usings) do
			table.insert(scope.usings, using)
		end
	end

	for i = insertionIndex+1, #targetContainer do
		table.insert(statementsNew, targetContainer[i])
	end

	local iNew = 0
	for i = insertionIndex, math.max(#targetContainer, insertionIndex + #statementsNew - 1) do
		iNew               = iNew+1
		targetContainer[i] = statementsNew[iNew] -- May be nil at the end if the static if was empty and at the end of the scope.
	end

	for iNew = insertionIndex, #targetContainer do
		local statement            = targetContainer[iNew]
		statement.queued.container = targetContainer
		statement.queued.key       = iNew
	end

	moveToPipe(state, staticIf, !(PIPE_DONE)) -- Not sure if needed. @Cleanup
	unqueue(staticIf) -- @Robustness: Check if the correct thing happens for things waiting on staticIf (i.e. the scope).

	-- Re-check redeclarations for already-inferred things later in the scope.
	if branchToUse and branchToUse.declarations[1] then
		for _, decl in ipairs(scope.declarations) do
			if not newlyDeclared[decl] and newlyDeclared[decl.name.name] and decl.token > staticIf.token and decl.queued.pipe > !(PIPE_INFER) then
				checkRedeclaration(state, decl.name, decl, false, scope)
			end
		end
	end
end

!NODE_INFERRER `function nodeInferrers.AstConditional(state, conditional)`
	local cond     = conditional.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `cond`)
	end
	if conditional.branchTrue and not conditional.branchTrue.inferredType then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `conditional.branchTrue`)
	end
	if not conditional.branchFalse.inferredType then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `conditional.branchFalse`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(TYPE_BOOL) then
		-- Note: This wrap will not affect conditional.conditionAndBranchTrue which is the actual expression we use in the output.
		wrapInImplicitCast(state, cond, getTypeInfoForBuiltinType(state, "bool"), true)
		return
	end

	local branchTrue    = conditional.branchTrue or conditional.conditionAndBranchTrue
	local branchFalse   = conditional.branchFalse

	local typeInfoTrue  = adjustTypeToOne(state, branchTrue,  branchTrue.inferredType,  true)
	local typeInfoFalse = adjustTypeToOne(state, branchFalse, branchFalse.inferredType, true)

	if typeInfoTrue ~= typeInfoFalse then
		typeError(
			state, conditional,
			"Type mismatch in conditional. (Left branch is %s, right branch is %s)",
			getFriendlyTypeInfoName(typeInfoTrue),
			getFriendlyTypeInfoName(typeInfoFalse)
		)
	end

	conditional.inferredType = typeInfoTrue
	moveToNextRelevantPipe(state, conditional)

	-- @Optimize: Remove/replace the branch if the condition is statically known.
end

!NODE_INFERRER `function nodeInferrers.AstSwitch(state, switch)`
	local typeInfo = switch.value.inferredType
	if not typeInfo then
		!DEPEND_AND_RETURN(`switch`, DEPEND_NODE_INFERRED, `switch.value`)
	end
	typeInfo = adjustTypeToOne(state, switch.value, typeInfo, true)

	for i, case in ipairs(switch.cases) do
		if case.body and case.body.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`switch`, DEPEND_NODE_INFERRED, `case.body`)
		elseif case.value and not case.value.inferredType then
			!DEPEND_AND_RETURN(`switch`, DEPEND_NODE_INFERRED, `case.value`)
		end
	end

	for i, case in ipairs(switch.cases) do
		if not case.value then
			-- void
		elseif not isExpressionConstant(state, case.value, true) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(case.value), "Case expression must be constant.")
		elseif not isTypeCompatibleWith(case.value.inferredType, typeInfo) then
			typeError(
				state, case.value,
				"Case type mismatch. (Wanted %s, got %s)",
				getFriendlyTypeInfoName(typeInfo), getFriendlyTypeInfoName(case.value.inferredType)
			)
		end
	end

	if switch.complete then
		local enumInfo = typeInfo

		if enumInfo.tag ~= !(TYPE_ENUM) then
			typeError(
				state, switch.value,
				"!complete requires the value to be an enum. (Got %s)",
				getFriendlyTypeInfoName(enumInfo)
			)
		end

		local coveredEnums = {}

		for _, case in ipairs(switch.cases) do
			if case.value then
				!ASSERT("case.value.nodeType == "..AST_IDENTIFIER)
				coveredEnums[case.value.name] = true
			end
		end

		local missingEnums = {}

		for _, member in ipairs(enumInfo.members) do
			if not coveredEnums[member.name] then
				table.insert(missingEnums, member.name)
			end
		end

		if missingEnums[1] then
			typeError(state, switch, "Missing cases: %s", table.concat(missingEnums, ", "))
		end
	end

	moveToNextRelevantPipe(state, switch)
	-- @Incomplete: Simplify AstSwitch.
end

local function addDeclarationInForLoop(state, forLoop, name, typeInfo)
	-- @Incomplete: Care about name shadowing.

	local decl         = astNewNode(AstDeclaration, forLoop.token, forLoop)
	local ident        = astNewNode(AstIdentifier, decl.token, decl)
	ident.name         = name
	ident.declaration  = decl
	ident.inferredType = typeInfo
	decl.name          = ident

	table.insert(forLoop.statementsDynamic, decl)
	table.insert(forLoop.declarations,      decl)

	addToQueueRecursively(state, decl, forLoop, #forLoop, !(PIPE_DONE))
	moveToNextRelevantPipe(state, decl, !(PIPE_INFER))
end

!NODE_INFERRER `function nodeInferrers.AstFor(state, forLoop)`
	if not forLoop.declarations[1] then
		local names  = forLoop.names
		local values = forLoop.expressions

		-- @Incomplete: Add all declarations now and infer their types later to fix confusing "undeclared identifier" errors.

		for _, expr in ipairs(values) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		----------------------------------------------------------------
		-- for [ i = ] start, end [, step ]
		if forLoop.forType == !(FOR_NUMERIC) then
			!ASSERT `#names <= 1`
			!ASSERT `values[2] and not values[4]`

			for _, valueExpr in ipairs(values) do
				local typeInfo = adjustTypeToOne(state, valueExpr, valueExpr.inferredType, true)

				if typeInfo.tag ~= !(TYPE_INT) then
					typeError(
						state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
						"For loop: Expected an int. (Got %s)",
						getFriendlyTypeInfoName(typeInfo)
					)
				end
			end

			if values[3] and values[3].nodeType == !(AST_LITERAL) and values[3].value == 0 then
				typeError(state, values[3], "For loop: The step value is 0.")
			end

			if
				values[1].nodeType == !(AST_LITERAL) and
				values[2].nodeType == !(AST_LITERAL) and
				(not values[3] or values[3].nodeType == !(AST_LITERAL))
			then
				local i1   = values[1].value
				local i2   = values[2].value
				local step = values[3] and values[3].value or 1

				if step > 0 and i2 < i1 then
					typeError(state, values[2], "For loop: The final value is lower than the starting value in ascending loop.")
				elseif step < 0 and i2 > i1 then
					typeError(state, values[2], "For loop: The final value is higher than the starting value in descending loop.")
				end
			end

			addDeclarationInForLoop(state, forLoop, (names[1] and names[1].name or "it"), values[1].inferredType)

		----------------------------------------------------------------
		-- for [ v1, ... : ] obj
		elseif forLoop.forType == !(FOR_SHORT) then
			!ASSERT `#values == 1`

			-- Note: Built-in short-form for loops have the value first and then the index/key.
			local objExpr = values[1]
			local objType = objExpr.inferredType

			-- We adjust lists to one, but leave vararg as-is.
			if objType.tag == !(TYPE_LIST) then
				objType = adjustTypeToOne(state, objExpr, objExpr.inferredType, true)
			end

			if objType.tag == !(TYPE_ARRAY) then
				local arraySig = objType
				if names[3] then
					typeError(state, names[3], "For loop: Too many names for short-form array loop. (Expected at most a value name and an index name.)")
				end
				local name1 = (names[1] and names[1].name) or "it"
				local name2 = (names[2] and names[2].name) or "itIndex"
				addDeclarationInForLoop(state, forLoop, name2, getTypeInfoForBuiltinType(state, "int"))
				addDeclarationInForLoop(state, forLoop, name1, arraySig.itemType)

			elseif objType.tag == !(TYPE_VARARG) then
				local varargSig = objType
				if names[3] then
					typeError(state, names[3], "For loop: Too many names for short-form vararg loop. (Expected at most a value name and an index name.)")
				end
				local name1 = (names[1] and names[1].name) or "it"
				local name2 = (names[2] and names[2].name) or "itIndex"
				addDeclarationInForLoop(state, forLoop, name2, getTypeInfoForBuiltinType(state, "int"))
				addDeclarationInForLoop(state, forLoop, name1, varargSig.itemType)

			elseif objType.tag == !(TYPE_TABLE) then
				if names[3] then
					typeError(state, names[3], "For loop: Too many names for short-form table loop. (Expected at most a value name and a key name.)")
				end
				local name1    = (names[1] and names[1].name) or "it"
				local name2    = (names[2] and names[2].name) or "itIndex"
				local typeInfo = getTypeInfoForBuiltinType(state, "any")
				addDeclarationInForLoop(state, forLoop, name2, typeInfo)
				addDeclarationInForLoop(state, forLoop, name1, typeInfo)

			elseif objType.tag == !(TYPE_STRUCT) then
				local structInfo = objType

				-- We have to wait for the members for inherited declarations to be available.
				if not structInfo.hasMembers then
					!DEPEND_AND_RETURN(`forLoop`, DEPEND_STRUCT_MEMBERS_READY, `structInfo`)
				end

				local decl = findMemberDeclaration(state, structInfo.astNode, "!iterator")

				if decl then
					if decl.overloadOf then
						typeError(state, decl, "This declaration is overloaded which is currently not supported for default iterators.")
					end

					local iterLambda   = followIdentifiersToConstantValue(decl.value)
					local iterTypeInfo = iterLambda.inferredType

					if iterTypeInfo.tag ~= !(TYPE_FUNCTION) then
						typeError(state, decl.value, "The !iterator value must be a function. (This is %s)", getFriendlyTypeInfoName(iterTypeInfo))
					end

					local intType = getTypeInfoForBuiltinType(state, "int")

					if #iterTypeInfo.argumentTypesIn ~= 2 then
						typeError(
							state, iterLambda.argumentsIn.arguments[1],
							"Default iterators for structs must take exactly two values - the struct instance and a control value. (This returns %d)",
							#iterTypeInfo.argumentTypesOut
						)
					elseif not isTypeCompatibleWith(structInfo, iterTypeInfo.argumentTypesIn[1]) then
						typeError(
							state, iterLambda.argumentsIn.arguments[1],
							"The default iterator must take %s as the first argument. (This is %s)",
							getFriendlyTypeInfoName(structInfo),
							getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[1])
						)
					elseif iterTypeInfo.argumentTypesIn[2] ~= intType then
						typeError(
							state, iterLambda.argumentsIn.arguments[2],
							"The default iterator must take an int as the second argument. (This is %s)",
							getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[2])
						)
					end

					local intOrNoneType = getTypeInfoForCompoundType(state, {intType, getTypeInfoForBuiltinType(state, "none")}, true)

					if #iterTypeInfo.argumentTypesOut ~= 2 then
						typeError(
							state, iterLambda.argumentsOut.arguments[1],
							"Default iterators for structs must return exactly two values - a control value and the current value. (This returns %d)",
							#iterTypeInfo.argumentTypesOut
						)
					elseif iterTypeInfo.argumentTypesOut[1] ~= intOrNoneType then
						typeError(
							state, iterLambda.argumentsOut.arguments[1],
							"The default iterator must return int|none as the first argument. (This is %s)",
							getFriendlyTypeInfoName(iterTypeInfo.argumentTypesOut[1])
						)
					end
					-- Note: We don't care what type the second returned value is.

					if names[3] then
						typeError(state, names[3], "For loop: Too many names for short-form struct loop. (Expected at most a value name and a control value name.)")
					end
					names[1] = names[1] or newIdentifier(forLoop, forLoop.token, "itIndex")
					names[2] = names[2] or newIdentifier(forLoop, forLoop.token, "it")

					-- Convert FOR_SHORT into FOR_ITERATOR.
					values[1] = astCopy(decl.name, nil, forLoop)
					values[2] = objExpr
					values[3] = newLiteral(forLoop, forLoop.token, !(LITERAL_INTEGER), 0, intType)
					objExpr.queued.key = 2
					addToQueue(state, values[1], values,1, !(PIPE_INFER))
					addToQueue(state, values[3], values,3, !(PIPE_INFER))

					forLoop.forType = !(FOR_ITERATOR)
					-- Continue to after the reverse check below.

				elseif structInfo.kind == !(STRUCT_KIND_ARRAY) then
					if names[3] then
						typeError(state, names[3], "For loop: Too many names for short-form array loop. (Expected at most a value name and an index name.)")
					end
					local name1 = (names[1] and names[1].name) or "it"
					local name2 = (names[2] and names[2].name) or "itIndex"
					addDeclarationInForLoop(state, forLoop, name2, getTypeInfoForBuiltinType(state, "int"))
					addDeclarationInForLoop(state, forLoop, name1, structInfo.valueType)

				else
					typeError(state, objExpr, "For loop: %s has no default iterator and is not array-like.", getFriendlyTypeInfoName(structInfo))
				end
			else
				typeError(
					state, objExpr,
					"For loop: Cannot iterate over values in type group '%s'. (Type is %s)",
					TYPE_NAMES[objType.tag],
					getFriendlyTypeInfoName(objType)
				)
			end

			if forLoop.reverse and not (
				objType.tag == !(TYPE_ARRAY)
				or objType.tag == !(TYPE_VARARG)
				or (objType.tag == !(TYPE_STRUCT) and objType.kind == !(STRUCT_KIND_ARRAY) and forLoop.forType == !(FOR_SHORT))
			) then
				typeError(
					state, objExpr,
					"For loop: Only arrays can be iterated in reverse. (This is %s)",
					getFriendlyTypeInfoName(objType)
				)
			end

			if forLoop.forType == !(FOR_ITERATOR) then  return  end

		----------------------------------------------------------------
		-- for v1, ... in iter [, state [, init ] ]
		elseif forLoop.forType == !(FOR_ITERATOR) then
			!ASSERT `#names >= 1`
			!ASSERT `values[1]`

			local iterExpr, iterTypeInfo = getAssignmentValue(state, forLoop, values, 1, nil, nil, "loop value")

			if iterTypeInfo.tag ~= !(TYPE_FUNCTION) then
				typeError(state, iterExpr, "For loop: Expected a function. (Got %s)", getFriendlyTypeInfoName(iterTypeInfo))

			elseif #iterTypeInfo.argumentTypesIn ~= 2 then
				-- @Incomplete: Consider optional arguments.
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(iterExpr),
					"For loop: Iterators must take two arguments - an invariant state object and a control value. (The signature of this function is %s)",
					getFriendlyTypeInfoName(iterTypeInfo)
				)

			elseif not iterTypeInfo.argumentTypesOut[1] then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(iterExpr),
					"For loop: Iterator does not return anything."
				)

			elseif iterTypeInfo.argumentTypesOut[1].tag == !(TYPE_NONE) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(iterExpr),
					"For loop: The type of the first returned value from iterators cannot be simply nil. It must be a compound type where nil is included."
				)

			elseif not (
				iterTypeInfo.argumentTypesOut[1].tag == !(TYPE_ANY)
				or (
					iterTypeInfo.argumentTypesOut[1].tag == !(TYPE_COMPOUND)
					and itemWith1(iterTypeInfo.argumentTypesOut[1], "tag", !(TYPE_NONE))
				)
			) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(iterExpr),
					"For loop: The type of the first returned value from iterators must be a compound type where nil is included. (This function returns %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesOut[1])
				)

			elseif #iterTypeInfo.argumentTypesOut ~= #names then
				-- @Incomplete: Consider !must and make everything else optional.
				typeError(
					state, names[math.min(#iterTypeInfo.argumentTypesOut+1, #names)],
					"For loop: Incorrect number of names specified for iterator. (Expected %d, got %d)",
					#iterTypeInfo.argumentTypesOut,
					#names
				)
			end

			--
			-- @Incomplete: Support 'for' loops/iterators that don't require an iterator value or
			-- even a state (e.g. if values are read from somewhere else, like an event queue).
			--
			-- @Incomplete: Complain if getAssignmentValue() can return a fourth value.
			--
			local stateExpr, stateTypeInfo = getAssignmentValue(state, forLoop, values, 2, nil, nil, "loop value")
			local initExpr,  initTypeInfo  = getAssignmentValue(state, forLoop, values, 3, nil, nil, "loop value")

			if not isTypeCompatibleWith(adjustTypeToOne(state, stateExpr, stateTypeInfo, true), iterTypeInfo.argumentTypesIn[1]) then
				typeError(
					state, stateExpr,
					"For loop: Type mismatch for iterator state (value #2). (Wanted %s, got %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[1]),
					getFriendlyTypeInfoName(adjustTypeToOne(state, stateExpr, stateTypeInfo, true))
				)
			end
			if not isTypeCompatibleWith(adjustTypeToOne(state, initExpr, initTypeInfo, true), iterTypeInfo.argumentTypesIn[2]) then
				typeError(
					state, initExpr,
					"For loop: Type mismatch for initial control value (value #3). (Wanted %s, got %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[2]),
					getFriendlyTypeInfoName(adjustTypeToOne(state, initExpr, initTypeInfo, true))
				)
			end

			for i, ident in ipairs(names) do
				local typeInfo = iterTypeInfo.argumentTypesOut[i]

				if i > 1 or typeInfo.tag == !(TYPE_ANY) then
					-- void

				-- Strip nil from the compound type for the first value (unless it's 'any').
				elseif #typeInfo > 2 then
					local typeInfos = {unpack(typeInfo)}
					removeItem(typeInfos, getTypeInfoForBuiltinType(state, "none"))
					typeInfo = getTypeInfoForCompoundType(state, typeInfos, false)
				else
					typeInfo = typeInfo[2].tag == !(TYPE_NONE) and typeInfo[1] or typeInfo[2] or errorInternal()
				end

				addDeclarationInForLoop(state, forLoop, ident.name, typeInfo)
			end

		----------------------------------------------------------------
		else
			errorInternal(state, forLoop, "%d", forLoop.forType)
		end
	end

	for _, statement in ipairs(forLoop) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, forLoop)
end

local function checkForRecursiveStruct(state, declThatWeAreChecking, memberPath,memberName,memberType, structInfo, parentStructInfo)
	local structInfoInner

	if memberType.tag == !(TYPE_STRUCT) then
		structInfoInner = memberType

		if structInfoInner == structInfo then
			local decl
				=  findMemberDeclaration(state, parentStructInfo.astNode, memberName)
				or errorInternal(state, declThatWeAreChecking, "%s", table.concat(memberPath, "."))

			local valueExpr = decl.value
			if valueExpr and !!(CONST_SET{ AST_FOREIGN, AST_NULL })[valueExpr.nodeType] then
				return
			end

			local niceTypeName = getFriendlyTypeInfoName(structInfo)

			typeError2(state,
				declThatWeAreChecking.name, F(
					"%s.%s is of type %s. This creates an infinite recursive loop. (Note: Compound types containing the struct are ok (unless the default value is the struct type), e.g. %s|nil)",
					niceTypeName, table.concat(memberPath, "."), niceTypeName, niceTypeName
				),
				decl, "...here is the other member declaration."
			)
		end

	else
		local decl
			=  findMemberDeclaration(state, parentStructInfo.astNode, memberName)
			or errorInternal(state, declThatWeAreChecking, "%s", table.concat(memberPath, "."))

		local valueExpr = decl.value
		if not valueExpr or !!(CONST_SET{ AST_FOREIGN, AST_NULL })[valueExpr.nodeType] then
			return
		end

		structInfoInner = valueExpr.inferredType
		if structInfoInner.tag ~= !(TYPE_STRUCT) then  return  end

		if structInfoInner == structInfo then
			local nodeForError = declThatWeAreChecking.value
			nodeForError       = nodeForError and astGetExpressionVisuallyFurthestToTheLeft(nodeForError) or declThatWeAreChecking

			local niceTypeName = getFriendlyTypeInfoName(structInfo)

			typeError2(state,
				nodeForError, F(
					"The default value for %s.%s is of type %s. This creates an infinite recursive loop.",
					niceTypeName, table.concat(memberPath, "."), niceTypeName
				),
				astGetExpressionVisuallyFurthestToTheLeft(valueExpr), F("...here is the default value.")
			)
		end
	end

	if not structInfoInner.hasMembers then  return  end

	local memberPathIndex = #memberPath+1

	for _, member in ipairs(structInfoInner.members) do
		memberPath[memberPathIndex] = member.name
		checkForRecursiveStruct(state, declThatWeAreChecking, memberPath,member.name,member.typeInfo, structInfo, structInfoInner)
	end

	memberPath[memberPathIndex] = nil
end

function _G.getEarlyAndLateExpression(expr1, expr2)
	if expr1.token < expr2.token then  return expr1, expr2  end
	return expr2, expr1
end

!NODE_INFERRER `function nodeInferrers.AstStruct(state, struct)`
	if struct.isPolymorphic then
		local structInfo         = newTypeInfo(state, TypeInfoStruct)
		structInfo.astNode       = struct
		-- structInfo.kind          = ?
		structInfo.isPolymorphic = true
		structInfo.hasMembers    = true -- Probably doesn't matter.

		table.insert(state.allTypeInfos,                      structInfo)
		table.insert(state.allTypeInfosByTag[!(TYPE_STRUCT)], structInfo)
		markTypeAsReady(state, structInfo)

		struct.representedType = structInfo
		struct.inferredType    = getTypeInfoForBuiltinType(state, "Type")

		moveToNextRelevantPipe(state, struct)
		return
	end

	-- Start by creating a TypeInfoStruct that others can grab a reference to right away (before any members are ready).
	local structInfo = struct.representedType

	if not structInfo then
		structInfo         = newTypeInfo(state, TypeInfoStruct)
		structInfo.astNode = struct

		if struct.valueType then
			structInfo.kind = struct.keyType and !(STRUCT_KIND_TABLE) or !(STRUCT_KIND_ARRAY)
		elseif struct.keyType then
			typeError(state, struct.keyType, "Missing a corresponding !value type for structured table.")
		end

		-- Note: We don't populate structInfo.members just yet. (Is this gonna a problem?)

		table.insert(state.allTypeInfos,                      structInfo)
		table.insert(state.allTypeInfosByTag[!(TYPE_STRUCT)], structInfo)

		struct.representedType = structInfo
		struct.inferredType    = getTypeInfoForBuiltinType(state, "Type")
	end

	-- Wait for explicit contents to infer.
	for _, statement in ipairs(struct.statementsStatic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	if struct.keyType and not struct.keyType.inferredType then
		!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `struct.keyType`)
	end
	if struct.valueType and not struct.valueType.inferredType then
		!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `struct.valueType`)
	end

	-- Wait for and validate inherits.
	for i, typeExpr in ipairs(struct.inherits) do
		typeExpr           = astGetReplacement(typeExpr)
		struct.inherits[i] = typeExpr

		local structInfoToInherit = requireTypeRepresentedByExpression(state, typeExpr)
		if structInfoToInherit.tag ~= !(TYPE_STRUCT) then
			typeError(state, typeExpr, "Expected the type of a struct to inherit members from.")
		end
		if not structInfoToInherit.hasMembers then
			!DEPEND_AND_RETURN(`struct`, DEPEND_STRUCT_MEMBERS_READY, `structInfoToInherit`)
		end
		if doesStructInherit(structInfoToInherit, structInfo) then
			typeError(state, typeExpr, "Struct is trying to inherit members from itself.")
		end
	end

	--
	-- No more dependencies for this struct after this point!
	--

	local typeSourceNodeK = struct.keyType
	local typeSourceNodeV = struct.valueType

	if typeSourceNodeK then  structInfo.keyType   = requireTypeRepresentedByExpression(state, typeSourceNodeK)  end
	if typeSourceNodeV then  structInfo.valueType = requireTypeRepresentedByExpression(state, typeSourceNodeV)  end

	-- Inherit members from other structs.
	if struct.inherits[1] then
		local declarationsWithNew = {} -- Declarations will be sorted as expected.
		local inheritIndices      = {}

		for i, typeExpr in ipairs(struct.inherits) do
			inheritIndices[typeExpr] = i
		end

		for _, statement in ipairs(struct.statementsStatic) do
			if statement.nodeType == !(AST_DECLARATION) then
				local decl = statement
				table.insert(declarationsWithNew, decl)

			elseif inheritIndices[statement] then
				local typeExpr            = statement
				local structInfoToInherit = requireTypeRepresentedByExpression(state, typeExpr)

				for j = 1, inheritIndices[statement]-1 do
					local typeExprPrevious   = struct.inherits[j]
					local structInfoPrevious = requireTypeRepresentedByExpression(state, typeExprPrevious)
					if
						structInfoToInherit == structInfoPrevious
						-- @Speed?
						or doesStructInherit(structInfoToInherit, structInfoPrevious)
						or doesStructInherit(structInfoPrevious, structInfoToInherit)
					then
						typeError2(state,
							typeExpr,         F("Two inherited structs are the same or share a base struct."),
							typeExprPrevious, F("...here is the other inheritance.")
						)
					end
				end

				local structToInherit = structInfoToInherit.astNode

				for j, declToInherit in ipairs(structToInherit.declarations) do
					local decl = findMemberDeclaration(state, struct, declToInherit.name.name)
					if not decl or decl.parent ~= struct then
						table.insert(struct.declarations,      declToInherit)
						table.insert(declarationsWithNew, declToInherit)
					elseif isDeclarationConstant(decl) and isDeclarationConstant(declToInherit) then
						-- void  Shadowing/overriding static declarations is permitted. (@Design: Should we limit this to only functions, methods, or even foreign methods?)
					else
						typeError3(state,
							typeExpr,      F("Trying to inherit a member called '%s' but the struct already has a member with that name.", decl.name.name),
							decl,          F("...one declaration."), -- This may be an inherited member too.
							declToInherit, F("...the other declaration.")
						)
					end
				end

				if structToInherit.isForeign and not struct.isForeign then
					typeError(
						state, typeExpr,
						"Trying to inherit foreign struct '%s' into non-foreign struct. Both structs must be foreign for inheritance to work.",
						getFriendlyTypeInfoName(structInfoToInherit)
					)
					-- struct.isForeign          = true
					-- struct.foreignThroughNode = typeExpr
				end

				if structInfoToInherit.keyType then
					if structInfo.keyType then
						local early, late = getEarlyAndLateExpression(typeExpr, typeSourceNodeK)
						typeError2(state, late, "Key type is already defined.", early, "...key type was defined here.")
					end
					typeSourceNodeK    = typeExpr
					structInfo.keyType = structInfoToInherit.keyType
				end
				if structInfoToInherit.valueType then
					if structInfo.valueType then
						local early, late = getEarlyAndLateExpression(typeExpr, typeSourceNodeV)
						typeError2(state, late, "Value type is already defined.", early, "...value type was defined here.")
					end
					typeSourceNodeV      = typeExpr
					structInfo.valueType = structInfoToInherit.valueType
				end
				-- @Incomplete: Handle structInfo.kind==STRUCT_KIND_ARRAY and structInfoToInherit.kind==STRUCT_KIND_TABLE, and vice versa.
				if structInfoToInherit.kind ~= !(STRUCT_KIND_NORMAL) then
					assert(structInfo.kind == !(STRUCT_KIND_NORMAL))
					structInfo.kind = structInfoToInherit.kind
				end
			end
		end

		struct.declarations = declarationsWithNew
	end

	-- Check invalid recursiveness.
	for _, decl in ipairs(struct.statementsStatic) do
		if decl.nodeType == !(AST_DECLARATION) then
			local memberName = decl.name.name
			local memberType = decl.name.inferredType or errorInternal()
			checkForRecursiveStruct(state, decl, {memberName},memberName,memberType, structInfo, structInfo)
		end
	end

	-- Add members to structInfo.
	for _, decl in ipairs(struct.declarations) do
		if not isDeclarationConstant(decl) then
			local memberName = decl.name.name
			local memberType = decl.name.inferredType or errorInternal()

			local member    = TypeInfoStructMember()
			member.name     = memberName
			member.typeInfo = memberType
			table.insert(structInfo.members, member)

			-- Make sure we never attempt to construct foreign values for members natively.
			-- (There's also a check for this in ProgramWriter.)

			if struct.isForeign then
				-- void

			elseif decl.value and !!(CONST_SET{ AST_FOREIGN, AST_NULL })[decl.value.nodeType] then
				-- void  Already foreign values and nil are always fine.

			elseif member.typeInfo.tag == !(TYPE_STRUCT) then
				if member.typeInfo.astNode.isForeign then
					typeError(state, (decl.value or decl), "Struct member value is foreign but the struct itself isn't. Mark the struct as !foreign or use NULL as initial value for this member to be valid.")
					-- struct.isForeign          = true
					-- struct.foreignThroughNode = decl
				end

			elseif member.typeInfo.tag == !(TYPE_COMPOUND) then
				!ASSERT("decl.value.inferredType.tag ~= "..TYPE_COMPOUND)

				if decl.value.inferredType.tag == !(TYPE_STRUCT) and decl.value.inferredType.astNode.isForeign then
					typeError(state, decl.value, "Struct member value is foreign but the struct itself isn't. Mark the struct as !foreign or use NULL as initial value for this member to be valid.")
					-- struct.isForeign          = true
					-- struct.foreignThroughNode = decl
				end
			end
		end
	end

	structInfo.hasMembers = true
	markTypeAsReady(state, structInfo)

	fulfillDependencies(state, struct, !(DEPEND_STRUCT_MEMBERS_READY))

	if structInfo.keyType and (structInfo.members[1] or struct.declarations[1]) and structInfo.keyType.tag == !(TYPE_STRING) then
		-- Note: We trigger this error for static members too, not just dynamic, as some lookups would otherwise be ambigous.
		typeError(state, typeSourceNodeK, "Strongly typed tables with string keys cannot also have members.")
	end

	moveToNextRelevantPipe(state, struct)
end

!NODE_INFERRER `function nodeInferrers.AstEnum(state, enum)`
	for _, statement in ipairs(enum.statementsStatic) do
		if statement.nodeType == !(AST_DECLARATION) then
			local decl = statement
			!ASSERT `decl.value`
			if not decl.value.inferredType then
				!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `decl.value`)
			end

		elseif statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	assert(enum.declarations[1]) -- This should have been caught during parsing.

	local enumMemberInfo

	if enum.memberType then
		!ASSERT `enum.memberType.typeName`
		enumMemberInfo = getTypeInfoForBuiltinType(state, enum.memberType.typeName)
	else
		-- Just use the type of the first member as the wanted type for the enum.
		enumMemberInfo = enum.declarations[1].value.inferredType
		if not !!(CONST_SET{ TYPE_INT, TYPE_STRING, TYPE_TYPE, TYPE_BOOL, TYPE_FLOAT })[enumMemberInfo.tag] then
			typeError(state, enum, "Supported enum member types are: int, string, Type, bool, float")
		end
	end

	local enumInfo          = newTypeInfo(state, TypeInfoEnum)
	enumInfo.astNode        = enum
	enumInfo.memberTypeInfo = enumMemberInfo or errorInternal()

	for i, decl in ipairs(enum.declarations) do
		local valueExpr = decl.value

		if valueExpr.nodeType == !(AST_FOREIGN) then
			-- @UX @Bug: This should be possible but something swaps the enum type with the member type somewhere.
			typeError(state, valueExpr, "Enum values cannot be foreign.")
		elseif not isExpressionConstant(state, valueExpr, false) then
			typeError(state, valueExpr, "Enum value is not constant.")
		elseif not isTypeCompatibleWith(valueExpr.inferredType, enumMemberInfo) then
			typeError(state, valueExpr,
				"Value type mismatch for '%s'. (Wanted %s, got %s)",
				decl.name.name,
				getFriendlyTypeInfoName(enumMemberInfo),
				getFriendlyTypeInfoName(valueExpr.inferredType)
			)
		end

		-- Note: valueExpr may not be a constant expression, but the
		-- declaration will check that after this enum gets inferred.

		local member        = TypeInfoEnumMember()
		member.name         = decl.name.name
		enumInfo.members[i] = member
	end

	table.insert(state.allTypeInfos,                    enumInfo)
	table.insert(state.allTypeInfosByTag[!(TYPE_ENUM)], enumInfo)
	markTypeAsReady(state, enumInfo)

	enum.representedType = enumInfo
	enum.inferredType    = getTypeInfoForBuiltinType(state, "Type")

	moveToNextRelevantPipe(state, enum)
end

!NODE_INFERRER `function nodeInferrers.AstFileScope(state, fileScope)`
	local valueExpr = fileScope.valueToExport

	if not valueExpr then
		-- void
	elseif valueExpr.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`fileScope`, DEPEND_NODE_INFERRED_FULLY, `valueExpr`)
	elseif valueExpr.inferredType.tag == !(TYPE_NAMESPACE) then
		typeError(state, valueExpr, "Cannot export namespaces.")
	elseif valueExpr.inferredType.tag == !(TYPE_FUNCTION) and valueExpr.inferredType.isPolymorphic then
		typeError(state, valueExpr, "Cannot export references to raw polymorphic functions.")
	end

	for _, statement in ipairs(fileScope.statementsStatic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`fileScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, fileScope)
end

!NODE_INFERRER `function nodeInferrers.AstGlobalScope(state, globalScope)`
	for _, statement in ipairs(globalScope.statementsStatic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`globalScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, globalScope)
end

!NODE_INFERRER `function nodeInferrers.AstBlock(state, block)`
	for _, statement in ipairs(block.statementsStatic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`block`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	for _, statement in ipairs(block.statementsDynamic) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`block`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, block)
end

-- @Robustness @Cleanup: Join visitNodesForRunning() and crawl().
local function visitNodesForRunning(state, dependent, unit, visited, deepTopScopeDeclarations)
	astVisitAllNodes(unit, function(node)
		visited[node] = true

		if not node.queued then
			return !(VISIT_IGNORE_CHILDREN)

		elseif node.queued.pipe <= !(PIPE_EMIT) then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_EMITTED, `node`, nil, toLua(VISIT_BREAK))

		elseif node.nodeType == !(AST_IDENTIFIER) then
			local ident = node
			local decl  = ident.declaration or errorInternal(state, ident)

			if visited[decl] then  return  end

			visitNodesForRunning(state, dependent, decl, visited, deepTopScopeDeclarations)
			if dependent.queued.waitingOn then  return !(VISIT_BREAK)  end

			if decl.value then  return  end

			local valueExpr = getDeclarationValue(decl)
			if valueExpr then
				visitNodesForRunning(state, dependent, valueExpr, visited, deepTopScopeDeclarations)
				if dependent.queued.waitingOn then  return !(VISIT_BREAK)  end
			end

		elseif node.nodeType == !(AST_DECLARATION) then
			local decl = node
			if decl.kind == !(DECL_KIND_STATIC) or decl.parent.nodeType == !(AST_NAMESPACE) then
				table.insert(deepTopScopeDeclarations, decl)
			end

		elseif node.nodeType == !(AST_LOCATION) then
			return !(VISIT_IGNORE_CHILDREN)

		elseif !!(CONST_SET{ AST_LITERAL, AST_FOREIGN, AST_TYPE_INFO })[node.nodeType] then
			return !(VISIT_IGNORE_CHILDREN)
		end
	end)
end

function _G.crawl(state, unit, crawled, forMeta, cb)
	astVisitAllNodes(unit, function(node)
		!(
		local function MARK_CRAWLED(objCode, crawlObjKind)
			__LUA(templateToLua(
				trimTemplate`
					crawled[$obj] = true
					if cb then  cb($obj, $crawlObjKind)  end
				`,
				{obj=objCode, crawlObjKind=toLua(crawlObjKind)}
			))
		end
		local function MARK_CRAWLED_IF_NEW(objCode, crawlObjKind)
			__LUA(templateToLua(
				trimTemplate`
					if not crawled[$obj] then
						crawled[$obj] = true
						if cb then  cb($obj, $crawlObjKind)  end
					end
				`,
				{obj=objCode, crawlObjKind=toLua(crawlObjKind)}
			))
		end
		)

		-- Also see visitNodesForRunning():

		if not node.queued then
			!MARK_CRAWLED(`node`, CRAWL_NODE)
			return !(VISIT_IGNORE_CHILDREN)

		elseif node.nodeType == !(AST_IDENTIFIER) then
			local ident = node
			!MARK_CRAWLED(`ident`, CRAWL_NODE)

			local decl = ident.declaration-- or errorInternal(state, ident)
			if not decl then  return  end -- @Robustness @Cleanup: This currently only happens for names in calls with named arguments. 2020-04-09

			if crawled[decl] then  return  end

			crawl(state, decl, crawled, forMeta, cb)

			if decl.value then  return  end

			local valueExpr = getDeclarationValue(decl)
			if valueExpr then
				crawl(state, valueExpr, crawled, forMeta, cb)
			end

		elseif node.nodeType == !(AST_DECLARATION) then
			local decl = node

			if not decl.valueConstant then
				!MARK_CRAWLED(`decl`, CRAWL_NODE)
				return
			end

			-- This check seem a bit out of place maybe. @Cleanup
			if decl.name.inferredType.tag == !(TYPE_NAMESPACE) then
				!MARK_CRAWLED(`decl`, CRAWL_NODE)
				return
			end

			if decl ~= unit then -- decl is unit if we followed an identifier.
				-- Don't mark as crawled!
				return !(VISIT_IGNORE_CHILDREN)
			end

			!MARK_CRAWLED(`decl`, CRAWL_NODE)
			!MARK_CRAWLED_IF_NEW(`decl.valueConstant`, CRAWL_CONSTANT)

		elseif node.nodeType == !(AST_LOCATION) then
			local loc = node
			!MARK_CRAWLED(`loc`, CRAWL_NODE)

			if not loc.ofCaller then
				!MARK_CRAWLED_IF_NEW(`loc.valueConstant`, CRAWL_CONSTANT)
			end

			return !(VISIT_IGNORE_CHILDREN)

		elseif !!(CONST_SET{ AST_LITERAL, AST_FOREIGN, AST_TYPE_INFO })[node.nodeType] then
			!MARK_CRAWLED(`node`, CRAWL_NODE)
			!MARK_CRAWLED_IF_NEW(`node.valueConstant`, CRAWL_CONSTANT)
			return !(VISIT_IGNORE_CHILDREN)

		--

		elseif node.nodeType == !(AST_LAMBDA) then
			local lambda = node
			!MARK_CRAWLED(`lambda`, CRAWL_NODE)

			if lambda.metaOnly and not forMeta then
				return !(VISIT_IGNORE_CHILDREN)
			end

			if lambda.valueConstant then -- @Robustness: When is this not set? Be more clear!
				!MARK_CRAWLED_IF_NEW(`lambda.valueConstant`, CRAWL_CONSTANT)
			end

		elseif node.nodeType == !(AST_CALL) then
			local call = node
			!MARK_CRAWLED(`call`, CRAWL_NODE)

			if call.wantLocation then
				!MARK_CRAWLED_IF_NEW(`call.locationConstant`, CRAWL_CONSTANT)
			end

		else
			!MARK_CRAWLED(`node`, CRAWL_NODE)
		end
	end)
end

local function createRunReplacementFromTypeAndLuaValue(state, runNode, parent, typeInfo, v)
	local tag = typeInfo.tag

	if tag == !(TYPE_INT) or (tag == !(TYPE_ANY) and type(v) == "number" and v == math.floor(v)) then
		local n = v
		assert(type(n) == "number" and n == math.floor(n))
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = n
		literal.inferredType = getTypeInfoForBuiltinType(state, "int")
		return literal

	elseif tag == !(TYPE_FLOAT) or (tag == !(TYPE_ANY) and type(v) == "number") then
		local n = v
		assert(type(n) == "number")
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = n
		literal.inferredType = getTypeInfoForBuiltinType(state, "float")
		return literal

	elseif tag == !(TYPE_STRING) or (tag == !(TYPE_ANY) and type(v) == "string") then
		local s = v
		assert(type(s) == "string")
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_STRING)
		literal.value        = s
		literal.inferredType = getTypeInfoForBuiltinType(state, "string")
		return literal

	elseif tag == !(TYPE_BOOL) or (tag == !(TYPE_ANY) and type(v) == "boolean") then
		local flag = v
		assert(type(flag) == "boolean")
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = flag
		literal.inferredType = getTypeInfoForBuiltinType(state, "bool")
		return literal

	elseif tag == !(TYPE_NONE) or (tag == !(TYPE_ANY) and v == nil) then
		assert(v == nil)
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_NIL)
		literal.value        = nil
		literal.inferredType = getTypeInfoForBuiltinType(state, "none")
		return literal

	elseif tag == !(TYPE_TABLE) or (tag == !(TYPE_ANY) and type(v) == "table") then
		local t = v
		assert(type(t) == "table")
		local tableNode = astNewNode(AstTable, runNode.token, parent)
		local anyType   = getTypeInfoForBuiltinType(state, "any")

		for k, v in pairsSorted(t, naturalCompare) do
			local tableField    = TableField()
			tableField.key      = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, anyType, k)
			tableField.value    = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, anyType, v)
			table.insert(tableNode.fields, tableField)
		end

		tableNode.inferredType = getTypeInfoForBuiltinType(state, "table")
		return tableNode

	elseif tag == !(TYPE_ARRAY) then
		local t = v
		assert(type(t) == "table")
		local arraySig  = typeInfo
		local tableNode = astNewNode(AstTable, runNode.token, parent)
		local intType   = getTypeInfoForBuiltinType(state, "int")

		-- @Robustness: Check that all keys in 't' are valid.
		for i, v in ipairs(t) do
			local tableField          = TableField()

			local indexLiteral        = astNewNode(AstLiteral, runNode.token, tableNode)
			indexLiteral.literalType  = !(LITERAL_INTEGER)
			indexLiteral.value        = i
			indexLiteral.inferredType = intType
			tableField.key            = indexLiteral

			tableField.value          = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, arraySig.itemType, v)

			tableNode.fields[i]       = tableField
		end

		tableNode.inferredType = arraySig
		return tableNode

	elseif tag == !(TYPE_STRUCT) then
		local t = v
		assert(type(t) == "table")
		local structInfo = typeInfo
		local tableNode  = astNewNode(AstTable, runNode.token, parent)
		local stringType = getTypeInfoForBuiltinType(state, "string")
		assert(structInfo.hasMembers)

		-- @Incomplete @Incomplete @Incomplete!!!!!!!!!
		if structInfo.keyType or structInfo.valueType then
			errorInternal(state, runNode, "@Incomplete: Handle !run expression results containing instances of structs with !key and !value types.")
		end

		-- @Robustness: Check that all keys in 't' are valid.
		for _, member in ipairs(structInfo.members) do
			local tableField           = TableField()

			local memberLiteral        = astNewNode(AstLiteral, runNode.token, tableNode)
			memberLiteral.literalType  = !(LITERAL_STRING)
			memberLiteral.value        = member.name
			memberLiteral.inferredType = stringType
			tableField.key             = memberLiteral

			tableField.value           = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, member.typeInfo, t[member.name])

			table.insert(tableNode.fields, tableField)
		end

		tableNode.inferredType = structInfo
		return tableNode

	elseif tag == !(TYPE_ENUM) then
		local enumInfo     = typeInfo
		local ident        = astNewNode(AstIdentifier, runNode.token, parent)
		ident.inferredType = enumInfo

		if !!(CONST_SET{ TYPE_INT, TYPE_STRING, TYPE_BOOL, TYPE_FLOAT })[enumInfo.memberTypeInfo.tag] then
			for _, decl in ipairs(enumInfo.astNode.declarations) do
				local literal = decl.value
				assert(literal.nodeType == !(AST_LITERAL))
				if literal.value == v then
					ident.name        = decl.name.name
					ident.declaration = decl
					break
				end
			end

		elseif enumInfo.memberTypeInfo.tag == !(TYPE_TYPE) then
			for _, decl in ipairs(enumInfo.astNode.declarations) do
				if requireTypeRepresentedByExpression(state, decl.value).id == v then
					ident.name        = decl.name.name
					ident.declaration = decl
					break
				end
			end

		else
			errorUnhandledType(state, runNode, enumInfo.memberTypeInfo)
		end

		if not ident.declaration then
			typeError(state, runNode, "Got an invalid enum value. (Enum '%s', value: %s)", getFriendlyTypeInfoName(enumInfo), tostring(v))
		end

		return ident

	elseif tag == !(TYPE_FUNCTION) then
		local func = v
		assert(type(func) == "function")

		local theConst = nil

		for _, const in ipairs(state.constants) do
			if const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION) and state.runnerEnvironment[const.name] == func then
				theConst = const
				break
			end
		end

		if not theConst then
			errorInternal(state, runNode, "The resulting function is no an existing constant for some reason.")
		end

		local lambda = theConst.value

		if lambda.parent.nodeType == !(AST_DECLARATION) then
			local decl  = lambda.parent
			local ident = astCopy(decl.name, runNode.token, parent)
			return ident
		else
			local copy = astCopy(lambda, nil, parent)
			copy.token = runNode.token
			return copy
		end

	elseif tag == !(TYPE_TYPE) then
		local typeId = v
		assert(type(typeId) == "number" and typeId == math.floor(typeId))

		local typeRepresented = state.allTypeInfos[typeId]
		if not typeRepresented then
			typeError(state, runNode, "Got the ID of a type that doesn't exist. (Type ID %d)", typeId)
		end

		local typeNode = createTypeNodeFromInfo(state, typeRepresented, runNode.token, parent)
		return typeNode

	elseif tag == !(TYPE_COMPOUND) then
		typeError(state, runNode, "!run expression is, or contains something, of a compound type which is illegal. (Type is %s)", getFriendlyTypeInfoName(typeInfo))
	elseif tag == !(TYPE_NAMESPACE) then
		typeError(state, runNode, "!run expression is a namespace which is illegal here.")
	else
		errorUnhandledType(state, runNode, typeInfo)
	end
end

-- luaFunction = prepareToRun( state, dependent, lambdaToRun )
-- Returns nil if waiting.
function _G.prepareToRun(state, dependent, lambda)
	if lambda.queued.pipe <= !(PIPE_EMIT) then
		!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_EMITTED, `lambda`, nil, `nil`)
	end
	--[[ This is currently not needed as only functions may be waiting. 2020-02-26
	for _, const in ipairs(state.constants) do
		if not const.isReady and not (const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION)) then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_CONSTANT_READY, `const`, nil, `nil`)
		end
	end
	--]]

	local deepTopScopeDeclarations = {}

	visitNodesForRunning(state, dependent, lambda, {}, deepTopScopeDeclarations)
	if dependent.queued.waitingOn then  return nil  end

	local relevantObjects = {}
	crawl(state, lambda, relevantObjects, true, nil)

	for _, const in ipairs(state.constants) do
		if relevantObjects[const] and not const.isReady and (const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION)) then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_CONSTANT_READY, `const`, nil, `nil`)
		end
	end

	!ifDEBUG `profilerPause()`
	runnerSetup(state)

	local newConstants            = {}
	local newTopScopeDeclarations = {}

	for _, const in ipairs(state.constants) do
		if relevantObjects[const] and not state.runnerWrittenObjects[const] then
			assert(const.isReady)
			state.runnerWrittenObjects[const] = true
			table.insert(newConstants, const)
			const.nameLocked = true -- @UX: Update constant names as they are allocated (and not when declarations pass PIPE_EMIT).
		end
	end

	for _, decl in ipairs(state.globalScope.declarations) do
		if relevantObjects[decl] and not state.runnerWrittenObjects[decl] then
			state.runnerWrittenObjects[decl] = true
			table.insert(newTopScopeDeclarations, decl)
		end
	end
	for _, fileScope in ipairs(state.globalScope.fileScopes) do
		for __, decl in ipairs(fileScope.declarations) do
			if relevantObjects[decl] and not state.runnerWrittenObjects[decl] then
				state.runnerWrittenObjects[decl] = true
				table.insert(newTopScopeDeclarations, decl)
			end
		end
	end
	for __, decl in ipairs(deepTopScopeDeclarations) do
		if relevantObjects[decl] and not state.runnerWrittenObjects[decl] then
			state.runnerWrittenObjects[decl] = true
			table.insert(newTopScopeDeclarations, decl)
		end
	end

	local writer = state.runnerWriter

	writeLuaPreloads(state, writer, state.luaPreloads, state.runnerWrittenPreloads+1)
	state.runnerWrittenPreloads = #state.luaPreloads

	writeForeignImports                (state, writer, newConstants, true)
	writeConstantObjectsExceptFunctions(state, writer, newConstants, true)
	writeFunctionObjects               (state, writer, newConstants)
	writeTopScopeDeclarations          (state, writer, newTopScopeDeclarations)

	-- !ifDEBUG `print(writer.file:getBuffer())`
	runnerRunBufferAsChunk(state)
	!ifDEBUG `profilerUnpause()`

	local constName = lambda.valueConstant.name
	local func      = state.runnerEnvironment[constName]

	if type(func) ~= "function" then
		errorInternal(state, dependent, "Missing the compiled object to run for some reason. (Constant '%s')", constName)
	end

	return func
end

!NODE_INFERRER `function nodeInferrers.AstRun(state, runNode)`
	local func = prepareToRun(state, runNode, runNode.lambda)
	if not func then  return  end

	local v
	do
		local run = func -- For better error messages.
		v         = run()
	end

	if not isAnExpressionExpected(state, runNode) then
		runNode.inferredType = getTypeInfoForBuiltinType(state, "void")
		moveToNextRelevantPipe(state, runNode)
		return
	end

	-- Replace the directive with a constant value.

	local returnNode = getLast(runNode.lambda.body.statementsDynamic)
	assert(returnNode.nodeType == !(AST_RETURN))

	local typeInfo = returnNode.values[1].inferredType
	typeInfo       = adjustTypeToOne(state, runNode, typeInfo, true)

	local replacement = createRunReplacementFromTypeAndLuaValue(state, runNode, runNode.parent, typeInfo, v)
	addUnqueuedChildrenToQueueRecursively(state, replacement, !(PIPE_INFER))

	replaceQueuedNodeAndUnqueueOldTree(state, runNode, replacement)
	if typeInfo.tag == !(TYPE_ANY) and replacement.inferredType.tag ~= !(TYPE_ANY) then
		replacement = wrapInImplicitCast(state, replacement, typeInfo, true)
	end

	moveChildrenToNextRelevantPipe(state, replacement)
	moveToNextRelevantPipe(state, replacement)
end

!NODE_INFERRER `function nodeInferrers.AstNull(state, null)`
	local typeInfoExpected = getExpectedTypeInfo(state, null, false, "NULL value", null)
	if not typeInfoExpected then  return  end

	null.inferredType = typeInfoExpected
	moveToNextRelevantPipe(state, null)
end

!NODE_INFERRER `function nodeInferrers.AstNamespace(state, namespace)`
	namespace.inferredType = getTypeInfoForNamespace(state, namespace)
	moveToNextRelevantPipe(state, namespace)
end

!if DEBUG then
	!for nodeType, nodeName in ipairs(AST_NAMES) do
		!local inferrerName    = "nodeInferrer_"..nodeName
		local !!(inferrerName) = nodeInferrers[!(nodeType)]

		nodeInferrers[!(nodeType)] = function(state, node)
			!!(inferrerName)(state, node) -- Better traceback in DEBUG mode.
		end
	!end
!end

function _G.inferNode(state, node)
	!if DEBUG then
		local nodeInferrer = nodeInferrers[node.nodeType] or errorInternal(state, node)
		nodeInferrer(state, node)
	!else
		return nodeInferrers[node.nodeType](state, node)
	!end
end

function _G.queueForReinfer(state, node)
	!ASSERT `node.queued`
	moveToPipe(state, node, !(PIPE_INFER))
	table.insert(state.queueActive, node.queued)
end



-- Note: It's assumed that the expression tree has all types figured out.
local ALWAYS_CONST = !(Set{
	AST_BAKE,
	AST_IMPORT, -- Imports refer to namespaces which are always constant.
	AST_LITERAL,
	AST_NAMESPACE,
	AST_NULL,
	AST_VARIANT_OF, -- The resulting reference will always be constant.
	AST_STRUCT, AST_ENUM,   -- Structs and enums are types (which are constant).
	AST_TYPE,   AST_TYPE_OF, -- All types are constant, just like literals.
})
local NEVER_CONST = !(Set{
	AST_CALL,
	AST_TYPE_INFO, -- @Incomplete: Make type_info() a constant expression.
	AST_VARARG,
})
function _G.isExpressionConstant(state, expr, foreignIsConst)
	local nodeType = expr.nodeType

	if ALWAYS_CONST[nodeType] then
		return true
	elseif NEVER_CONST[nodeType] then
		return false

	elseif nodeType == !(AST_IDENTIFIER) then
		local ident = expr
		local decl  = ident.declaration or errorInternal(state, ident)
		return isDeclarationConstant(decl) and isExpressionConstant(state, decl.value, foreignIsConst)

	elseif nodeType == !(AST_CAST) then
		local cast = expr
		return isExpressionConstant(state, cast.expression, foreignIsConst)

	elseif nodeType == !(AST_UNARY) then
		local unary = expr
		return isExpressionConstant(state, unary.expression, foreignIsConst)
	elseif nodeType == !(AST_BINARY) then
		local binary = expr
		return isExpressionConstant(state, binary.left, foreignIsConst) and isExpressionConstant(state, binary.right, foreignIsConst)

	elseif nodeType == !(AST_LAMBDA) then -- Note: We should not get here for AstType nodes.
		local lambda = expr
		return not lambda.captures[1]

	elseif nodeType == !(AST_CONDITIONAL) then
		local conditional = expr
		return (
			isExpressionConstant(state, conditional.condition, foreignIsConst)
			and (conditional.branchTrue == nil or isExpressionConstant(state, conditional.branchTrue, foreignIsConst))
			and isExpressionConstant(state, conditional.branchFalse, foreignIsConst)
		)

	elseif nodeType == !(AST_ACCESS) then
		local access = expr
		return isExpressionConstant(state, access.object, foreignIsConst) and isExpressionConstant(state, access.member, foreignIsConst)

	elseif nodeType == !(AST_TABLE) then
		local tableNode = expr
		if tableNode.trailingExpression then  return false  end

		for _, tableField in ipairs(tableNode.fields) do
			if not isExpressionConstant(state, tableField.key,   foreignIsConst) then  return false  end
			if not isExpressionConstant(state, tableField.value, foreignIsConst) then  return false  end
		end

		return true

	elseif nodeType == !(AST_FOREIGN) then
		-- Technically foreign values are seen as constant at runtime, but since we don't
		-- know what they are at compile-time we (usually) treat them as runtime values.
		return foreignIsConst

	elseif nodeType == !(AST_LOCATION) then
		local loc = expr
		return loc.ofCaller -- @Incomplete: Make !location() a constant expression (that can be simplified).

	else
		errorUnhandledNodeType(state, expr)
	end
end

-- function _G.isExpressionExactlyOneValue(expr)
-- 	return not (expr.nodeType == !(AST_VARARG) or expr.nodeType == !(AST_CALL)) or expr.surroundedByParentheses
-- end



-- expression, typeInfo = getAssignmentValue( state, assignmentTarget, values, valueIndex, expectedTypeInfo=any, extraBinaryOperation="", targetTerm="assignment target" )
-- Note: Vararg node/type may be returned.
function _G.getAssignmentValue(state, targetExpr, values, i, typeInfoExpected, binOp, targetTerm)
	!(
	local TEMPLATE_TARGET_NAME = trimTemplate`
		targetExpr.nodeType == $nodeTypeIdent  and " ('"..targetExpr.name.."')" or
		targetExpr.nodeType == $nodeTypeAccess and targetExpr.member.nodeType == $nodeTypeLiteral and targetExpr.member.literalType == $literalTypeString and " ('"..targetExpr.member.value.."')" or
		""
	`
	local TARGET_NAME = templateToLua(TEMPLATE_TARGET_NAME, {
		nodeTypeIdent     = AST_IDENTIFIER,
		nodeTypeAccess    = AST_ACCESS,
		nodeTypeLiteral   = AST_LITERAL,
		literalTypeString = LITERAL_STRING,
	})

	local TEMPLATE_CALL_RETURNS_NOTHING = trimTemplate`
		typeError(state, call, "Called function returns nothing for %s #%d%s (return value #%d).", targetTerm, i, $targetName, argIndex)
	`
	local CALL_RETURNS_NOTHING = templateToLua(TEMPLATE_CALL_RETURNS_NOTHING, {
		targetName = TARGET_NAME,
	})

	local TEMPLATE_CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN = `
		if binOp == "" then
			if isTypeCompatibleWith($valueTypeInfoAdjusted, typeInfoExpected) then  return $valueExpr, $valueTypeInfo  end

		else
			$valueTypeInfoAdjusted = checkBinaryOperation(
				state,
				targetExpr,
				$valueExpr, targetExpr, $valueExpr,
				binOp,
				typeInfoExpected, $valueTypeInfoAdjusted,
				true
			) or errorInternal()

			if not isTypeCompatibleWith($valueTypeInfoAdjusted, typeInfoExpected) then
				typeError(
					state, targetExpr,
					"Type mismatch between %s #%d%s (%s) and result of binary operation (%s) (%s).",
					targetTerm, i, $targetName, getFriendlyTypeInfoName(typeInfoExpected),
					binOp, getFriendlyTypeInfoName($valueTypeInfoAdjusted))
			end

			return $valueExpr, $valueTypeInfo
		end
	`
	local function CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(valueExprVar, typeInfoVar, typeInfoAdjustedVar)
		local lua = templateToLua(TEMPLATE_CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN, {
			valueExpr             = valueExprVar,
			valueTypeInfo         = typeInfoVar,
			valueTypeInfoAdjusted = typeInfoAdjustedVar,
			targetName            = TARGET_NAME,
		})
		__LUA(lua)
	end
	)

	binOp      = binOp      or ""
	targetTerm = targetTerm or "assignment target"

	local valueExpr = values[i]

	if valueExpr then
		local valueTypeInfo = valueExpr.inferredType

		if valueTypeInfo.tag == !(TYPE_LIST) then
			valueTypeInfo = valueTypeInfo[1]

			if not valueTypeInfo then
				local call     = valueExpr
				local argIndex = 1
				!!(CALL_RETURNS_NOTHING)
			end
		end

		if not typeInfoExpected then  return valueExpr, valueTypeInfo  end

		local valueTypeInfoAdjusted = adjustTypeToOne(state, valueExpr, valueTypeInfo, true)
		!CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(`valueExpr`, `valueTypeInfo`, `valueTypeInfoAdjusted`)

		local messageFormat
			=   valueTypeInfoAdjusted.tag == !(TYPE_FUNCTION) and typeInfoExpected.tag == !(TYPE_FUNCTION)
			and "Function signature is different from %s #%d%s. (Wanted %s, got %s)"
			or  "Value type mismatch for %s #%d%s. (Wanted %s, got %s)"

		typeError(
			state, valueExpr, messageFormat,
			targetTerm, i, !!(TARGET_NAME),
			getFriendlyTypeInfoName(typeInfoExpected),
			getFriendlyTypeInfoName(valueTypeInfoAdjusted)
		)
	end

	valueExpr = values[#values]

	if not valueExpr then
		typeError(state, targetExpr, "Missing a value for %s #%d%s.", targetTerm, i, !!(TARGET_NAME))

	elseif valueExpr.nodeType == !(AST_CALL) and not valueExpr.surroundedByParentheses then
		local call      = valueExpr
		local lastIndex = #values
		local argIndex  = i-lastIndex+1

		local typeInfoForCall = call.inferredType
		local listSig

		if typeInfoForCall.tag == !(TYPE_LIST) then
			listSig = typeInfoForCall
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfoForCall))
		end

		local typeInfoForOutArg = listSig[argIndex]

		if typeInfoForOutArg then
			-- void
		elseif listSig[1] and listSig[#listSig].tag == !(TYPE_VARARG) then
			typeInfoForOutArg = listSig[#listSig]
		else
			!!(CALL_RETURNS_NOTHING)
		end

		if not typeInfoExpected then  return call, typeInfoForOutArg  end

		local typeInfoForOutArgAdjusted = adjustTypeToOne(state, call, typeInfoForOutArg, true)
		!CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(`call`, `typeInfoForOutArg`, `typeInfoForOutArgAdjusted`)

		local calleeName = (call.callee.nodeType == !(AST_IDENTIFIER) and " of '"..call.callee.name.."'" or "")

		typeError(
			state, call,
			"The type of return value #%d%s (%s) does not match the type of %s #%d%s (%s).",
			argIndex, calleeName, getFriendlyTypeInfoName(typeInfoForOutArgAdjusted),
			targetTerm, i, !!(TARGET_NAME), getFriendlyTypeInfoName(typeInfoExpected)
		)

	elseif valueExpr.nodeType == !(AST_VARARG) and not valueExpr.surroundedByParentheses then
		local vararg = valueExpr
		return vararg, vararg.inferredType

	else
		typeError(state, targetExpr, "Missing a value for %s #%d%s.", targetTerm, i, !!(TARGET_NAME))
	end
end



-- inferredTypeNode = createTypeNodeFromInfo( state, typeRepresented, token, parent )
function _G.createTypeNodeFromInfo(state, typeRepresented, token, parent)
	local typeNode            = astNewNode(AstType, token, parent)
	local isBuiltin, typeName = isTypeBuiltin(typeRepresented)

	typeNode.inferredType    = getTypeInfoForBuiltinType(state, "Type")
	typeNode.representedType = typeRepresented

	if isBuiltin then
		typeNode.kind              = !(TYPE_KIND_SIMPLE_BUILTIN)
		typeNode.typeName          = typeName

	elseif typeRepresented.tag == !(TYPE_STRUCT) then
		local structInfo           = typeRepresented
		typeNode.kind              = structInfo.isPolymorphic and !(TYPE_KIND_POLY_STRUCT) or !(TYPE_KIND_SIMPLE_USER)
		typeNode.typeName          = structInfo.name

	elseif typeRepresented.tag == !(TYPE_ENUM) then
		local enumInfo             = typeRepresented
		typeNode.kind              = !(TYPE_KIND_SIMPLE_USER)
		typeNode.typeName          = enumInfo.name

	elseif typeRepresented.tag == !(TYPE_FUNCTION) then
		local funcSig              = typeRepresented
		typeNode.kind              = !(TYPE_KIND_FUNCTION)
		-- typeNode.functionHeader = ? -- This is not needed.

	elseif typeRepresented.tag == !(TYPE_COMPOUND) then
		typeNode.kind              = !(TYPE_KIND_COMPOUND)

	elseif typeRepresented.tag == !(TYPE_ARRAY) then
		local arraySig             = typeRepresented
		typeNode.kind              = !(TYPE_KIND_ARRAY)
		typeNode.arrayItemType     = createTypeNodeFromInfo(state, arraySig.itemType, token, typeNode)

	elseif typeRepresented.tag == !(TYPE_VARARG) then
		errorInternal(state, typeNode) -- When do we get here?
	else
		!ifDEBUG `print(getFriendlyTypeInfoName(typeRepresented))`
		errorInternal("Incomplete: Handle type group '%s'.", TYPE_NAMES[typeRepresented.tag])
	end

	return typeNode
end

local function isTypeOrDoesTypeContainPlaceholder(typeInfo)
	if typeInfo.tag == !(TYPE_PLACEHOLDER) then
		return true

	elseif typeInfo.tag == !(TYPE_COMPOUND) then
		local compound = typeInfo
		return itemWith1(compound, "tag", !(TYPE_PLACEHOLDER)) ~= nil

	elseif typeInfo.tag == !(TYPE_FUNCTION) then
		local funcSig = typeInfo
		for _, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			if isTypeOrDoesTypeContainPlaceholder(argTypeInfo) then  return true  end
		end
		for _, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			if isTypeOrDoesTypeContainPlaceholder(argTypeInfo) then  return true  end
		end
		return false

	else
		return false
	end
end

function _G.simplifyTypeExpression(state, expr, typeRepresented)
	!ASSERT("expr.nodeType ~= "..AST_TYPE)
	!ASSERT("typeRepresented")

	if isTypeOrDoesTypeContainPlaceholder(typeRepresented) then  return nil  end

	local typeNode = createTypeNodeFromInfo(state, typeRepresented, expr.token, expr.parent)

	if expr.nodeType == !(AST_IDENTIFIER) then
		local ident          = expr
		typeNode.declaration = ident.declaration
	end

	addUnqueuedChildrenToQueueRecursively(state, typeNode, !(PIPE_INFER))
	moveChildrenToNextRelevantPipe(state, typeNode)

	replaceQueuedNodeAndUnqueueOldTree(state, expr, typeNode)
end

local function simplifyCast(state, cast)
	if cast.expression.nodeType == !(AST_ACCESS) then  return  end -- Cannot simplify views.

	local exprTypeInfo = cast.expression.inferredType
	local castTypeInfo = cast.inferredType

	local parent = cast.parent
	if
		parent.nodeType == !(AST_CONDITIONAL)
		and parent.conditionAndBranchTrue
		and parent.conditionAndBranchTrue ~= parent.condition
		and cast == parent.condition
	then
		-- Simplifying this cast would mess up the output. Example situation:
		-- local x = if myString "a" else "b"
		return
	end

	if exprTypeInfo == castTypeInfo then
		errorInternal(state, cast) -- This should have been simplified away already.

	-- int -> float
	elseif exprTypeInfo.tag == !(TYPE_INT) and castTypeInfo.tag == !(TYPE_FLOAT) then
		!ASSERT("cast.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(cast.expression.value) == 'number'")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = cast.expression.value
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- float -> int
	elseif exprTypeInfo.tag == !(TYPE_FLOAT) and castTypeInfo.tag == !(TYPE_INT) then
		!ASSERT("cast.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(cast.expression.value) == 'number'")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = math.modf(cast.expression.value)
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- (numeric) -> bool
	elseif isTypeNumeric(exprTypeInfo) and castTypeInfo.tag == !(TYPE_BOOL) then
		!ASSERT("cast.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(cast.expression.value) == 'number'")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = cast.expression.value ~= 0
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- string -> bool
	elseif exprTypeInfo.tag == !(TYPE_STRING) and castTypeInfo.tag == !(TYPE_BOOL) then
		!ASSERT("cast.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(cast.expression.value) == 'string'")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = cast.expression.value ~= ""
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- array -> bool
	elseif exprTypeInfo.tag == !(TYPE_ARRAY) and castTypeInfo.tag == !(TYPE_BOOL) then
		local tableNode = followIdentifiersToConstantValue(cast.expression)
		assert(tableNode.nodeType == !(AST_TABLE))

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = tableNode.fields[1] ~= nil -- (Assume the array constructor is valid.)
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- enum -> enumMemberType (int, float, string, bool or Type)
	elseif exprTypeInfo.tag == !(TYPE_ENUM) and isTypeCompatibleWith(exprTypeInfo.memberTypeInfo, castTypeInfo) then
		local castIsDirect = (castTypeInfo == exprTypeInfo.memberTypeInfo)

		local enumInfo = exprTypeInfo
		local ident    = cast.expression

		assert(ident.nodeType == !(AST_IDENTIFIER)) -- All enums should have been simplified to identifiers.

		!ASSERT `isDeclarationConstant(ident.declaration)`
		local valueExpr = ident.declaration.value

		if BUILTIN_TYPE_TAG_TO_LITERAL_TYPE[castTypeInfo.tag] then
			local literal = valueExpr
			assert(literal.nodeType == !(AST_LITERAL))

			local literalCopy = astCopy(literal, cast.token)

			if castIsDirect then
				assert(literalCopy.inferredType == castTypeInfo)

			elseif exprTypeInfo.memberTypeInfo.tag == !(TYPE_INT) and castTypeInfo.tag == !(TYPE_FLOAT) then
				literalCopy.literalType  = !(LITERAL_FLOAT)
				literalCopy.inferredType = castTypeInfo

			else
				errorInternal(
					state, cast,
					"Incomplete: Implicitly cast enum from %s to %s.",
					getFriendlyTypeInfoName(exprTypeInfo.memberTypeInfo),
					getFriendlyTypeInfoName(castTypeInfo)
				)
			end

			replaceQueuedNodeAndUnqueueOldTree(state, cast, literalCopy)
			moveToNextRelevantPipe(state, literalCopy, !(PIPE_INFER))

		elseif castTypeInfo.tag == !(TYPE_TYPE) then
			assert(castIsDirect)

			local typeNode = valueExpr
			assert(typeNode.nodeType == !(AST_TYPE))

			local typeNodeCopy = astCopy(typeNode, cast.token)

			addUnqueuedChildrenToQueueRecursively(state, typeNodeCopy, !(PIPE_DONE)) -- Only does something if the type has parameters.
			replaceQueuedNodeAndUnqueueOldTree(state, cast, typeNodeCopy)
			moveToNextRelevantPipe(state, typeNodeCopy, !(PIPE_INFER))

		else
			errorInternal(state, cast, "Incomplete: Handle casting enum to %s.", getFriendlyTypeInfoName(castTypeInfo))
		end

	-- enumMemberType -> enum
	elseif castTypeInfo.tag == !(TYPE_ENUM) and exprTypeInfo == castTypeInfo.memberTypeInfo then
		local enumInfo = castTypeInfo
		local decl     = findDeclarationInEnumForValue(state, enumInfo.astNode, cast.expression) or errorInternal(state, cast.expression)
		local ident    = astCopy(decl.name, cast.token, cast.parent)

		replaceQueuedNodeAndUnqueueOldTree(state, cast, ident)
		moveToNextRelevantPipe(state, ident, !(PIPE_INFER))

	-- Type -> int
	elseif exprTypeInfo.tag == !(TYPE_TYPE) and castTypeInfo.tag == !(TYPE_INT) then
		local typeRepresented = getTypeRepresentedByExpression(cast.expression) or errorInternal(state, cast)
		local literal         = newLiteral(cast.parent, cast.token, !(LITERAL_INTEGER), typeRepresented.id, castTypeInfo)

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- (whatever) -> compound
	elseif castTypeInfo.tag == !(TYPE_COMPOUND) then
		typeError(state, cast, "Cannot cast constants to compound types. (Target type is %s)", getFriendlyTypeInfoName(castTypeInfo))

	-- (whatever) -> any
	-- any -> (whatever)
	elseif exprTypeInfo.tag == !(TYPE_ANY) or castTypeInfo.tag == !(TYPE_ANY) then -- Handle this last!
		-- void

	else
		errorInternal(
			state, cast,
			"Incomplete: Handle casting constant from %s to %s.",
			getFriendlyTypeInfoName(exprTypeInfo),
			getFriendlyTypeInfoName(castTypeInfo)
		)
	end
end

local function simplifyUnary(state, unary)
	-- @Incomplete: Simplify these kinds of expressions (including implicit casts): not (str ~= "") => str == ""

	if unary.expression.nodeType == !(AST_ACCESS) then  return  end -- Cannot simplify views.

	local typeInfo = unary.inferredType

	if nil then

	!for _, opArithmetic in ipairs{"+","-"} do
	elseif unary.operation == !(opArithmetic) then
		!ASSERT("unary.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(unary.expression.value) == 'number'")

		local literal = astNewNode(AstLiteral, unary.token, unary.parent)

		literal.literalType
			=  typeInfo.tag == !(TYPE_INT)   and !(LITERAL_INTEGER)
			or typeInfo.tag == !(TYPE_FLOAT) and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = !!(opArithmetic ~= "+" and opArithmetic or "") unary.expression.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	elseif unary.operation == "not" then
		!ASSERT("unary.expression.nodeType == "..AST_LITERAL)
		!ASSERT("type(unary.expression.value) == 'boolean'")

		local literal        = astNewNode(AstLiteral, unary.token, unary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = not unary.expression.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	elseif unary.operation == "#" then
		local valueExpr = followIdentifiersToConstantValue(unary.expression)
		local length    = 0

		if valueExpr.nodeType == !(AST_TABLE) then
			local tableNode = valueExpr

			if tableNode.inferredType.tag == !(TYPE_ARRAY) then
				for _, tableField in ipairs(tableNode.fields) do
					length = math.max(length, tableField.key.value)
				end

			elseif tableNode.inferredType.tag == !(TYPE_TABLE) then
				errorUnhandledNodeType(state, unary)

			else
				errorInternal(state, tableNode)
			end

		elseif valueExpr.nodeType == !(AST_LITERAL) then
			local literal = valueExpr
			!ASSERT("literal.literalType == "..LITERAL_STRING)

			length = #literal.value

		else
			errorUnhandledNodeType(state, valueExpr)
		end

		local literal        = astNewNode(AstLiteral, unary.token, unary.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = length
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	else
		errorUnhandledNodeType(state, unary)
	end
end

local function simplifyBinary(state, binary)
	local l  = binary.left
	local r  = binary.right
	local op = binary.operation

	if l.nodeType == !(AST_ACCESS) or r.nodeType == !(AST_ACCESS) then  return  end -- Cannot simplify views.

	!local ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS = templateToLua(
		`
			if l.nodeType    ~= $nodeTypeLiteral then  errorInternal()  end
			if r.nodeType    ~= $nodeTypeLiteral then  errorInternal()  end
			if type(l.value) ~= "number"         then  errorInternal()  end
			if type(r.value) ~= "number"         then  errorInternal()  end
		`, {
			nodeTypeLiteral = toLua(AST_LITERAL),
		}
	)

	-- @Incomplete: Simplify these kinds of expressions: (1+x)+2 => (1+2)+x => 3+x
	-- @Incomplete: Simplify these kinds of expressions: 1 + -x => 1 - x
	local typeInfo = binary.inferredType

	if op == "*" and typeInfo.tag == !(TYPE_STRING) then
		local s     = l.value
		local count = r.value

		if l.inferredType.tag == !(TYPE_INT) then
			s, count = count, s
		end

		local literal = newLiteral(binary.parent, binary.token, !(LITERAL_STRING), s:rep(count), typeInfo)
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	!for _, opArithmeticKeepType in ipairs{"+","-","*","^","%"} do
	elseif op == !(opArithmeticKeepType) then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		local literalType
			=  typeInfo.tag == !(TYPE_INT)   and !(LITERAL_INTEGER)
			or typeInfo.tag == !(TYPE_FLOAT) and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		local n = l.value !!(opArithmeticKeepType) r.value -- This should produce the correct result for any combination of int and float.

		local literal = newLiteral(binary.parent, binary.token, literalType, n, typeInfo)
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	elseif op == "/" then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		local literal = newLiteral(binary.parent, binary.token, !(LITERAL_FLOAT), l.value/r.value, typeInfo)
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	elseif op == "//" then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		local literal = newLiteral(binary.parent, binary.token, !(LITERAL_INTEGER), math.floor(l.value/r.value), typeInfo)
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	!for _, opComparison in ipairs{"<",">","<=",">="} do
	elseif op == !(opComparison) then
		!ASSERT("l.nodeType == "..AST_LITERAL)
		!ASSERT("r.nodeType == "..AST_LITERAL)

		!if DEBUG then
			local lType = type(l.value)
			!ASSERT("lType == type(r.value)")
			!ASSERT("lType == 'number' or lType == 'string'")
		!end

		local literal = newLiteral(binary.parent, binary.token, !(LITERAL_BOOLEAN), (l.value !!(opComparison) r.value), typeInfo)
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	!for _, opEquality in ipairs{"==","~="} do
	elseif op == !(opEquality) then
		local valueL, valueR

		if l.inferredType.tag == !(TYPE_TYPE) then
			!ASSERT("r.inferredType.tag == "..TYPE_TYPE)
			valueL = getTypeRepresentedByExpression(l) or errorInternal(state, l)
			valueR = getTypeRepresentedByExpression(r) or errorInternal(state, r)

		elseif l.nodeType == !(AST_LITERAL) then
			!ASSERT("r.nodeType == "..AST_LITERAL)
			!ASSERT("type(l.value) == type(r.value)")
			valueL = l.value
			valueR = r.value

		else
			valueL = followIdentifiersToConstantValue(l)
			valueR = followIdentifiersToConstantValue(r)
			!ASSERT("valueL.nodeType == valueR.nodeType")
		end

		local literal = newLiteral(binary.parent, binary.token, !(LITERAL_BOOLEAN), (valueL !!(opEquality) valueR), typeInfo)
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	!for _, opLogical in ipairs{"and","or"} do
	elseif op == !(opLogical) then
		!ASSERT("l.nodeType == "..AST_LITERAL)
		!ASSERT("r.nodeType == "..AST_LITERAL)
		!ASSERT("type(l.value) == 'boolean'")
		!ASSERT("type(r.value) == 'boolean'")

		local literal = newLiteral(binary.parent, binary.token, !(LITERAL_BOOLEAN), (l.value !!(opLogical) r.value), typeInfo)
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	elseif op == ".." then
		!ASSERT("l.nodeType == "..AST_LITERAL)
		!ASSERT("r.nodeType == "..AST_LITERAL)
		!ASSERT("type(l.value) == 'string'")
		!ASSERT("type(r.value) == 'string'")

		-- @Speed: Concatinate more than two values at a time. (Maybe the parsing stage need an update.)
		local literal = newLiteral(binary.parent, binary.token, !(LITERAL_STRING), l.value..r.value, typeInfo)
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	else
		errorUnhandledNodeType(state, binary)
	end
end

function _G.simplifyExpressionIfConstant(state, expr)
	if not isExpressionConstant(state, expr, false) then
		if
			-- :SpecialForeignValueRules
			expr.nodeType == !(AST_IDENTIFIER)
			and isDeclarationConstant(expr.declaration)
			and expr.declaration.value.nodeType == !(AST_FOREIGN)
		then
			local ident       = expr
			local foreign     = ident.declaration.value
			local foreignCopy = astCopy(foreign, ident.token, ident.parent)

			replaceQueuedNodeAndUnqueueOldTree(state, ident, foreignCopy)
			moveToNextRelevantPipe(state, foreignCopy, !(PIPE_INFER))
		end

	elseif expr.nodeType == !(AST_IDENTIFIER) then
		local ident = expr
		local decl  = ident.declaration or errorInternal(state, ident)
		if not isDeclarationConstant(decl) then  return  end

		local typeInfo = ident.inferredType

		if typeInfo.tag == !(TYPE_ENUM) then
			if ident.name ~= decl.name.name then
				-- @Cleanup: Is this necessary? Can't we just do ident.name=decl.name.name?
				local copy = astCopy(decl.name, ident.token, ident.parent)
				replaceQueuedNodeAndUnqueueOldTree(state, ident, copy)
				moveToNextRelevantPipe(state, copy, !(PIPE_INFER))
			end
			return
		end

		local typeInfoRepresented = decl.valueTypeInfo

		if typeInfoRepresented then
			simplifyTypeExpression(state, ident, typeInfoRepresented)
			return
		end

		!ASSERT("typeInfo.tag ~= "..TYPE_TYPE)
		if not isTypeSimple(typeInfo) then  return  end

		if decl.value.nodeType == !(AST_ACCESS) then  return  end -- This will create a constant lookup (AKA view).

		-- At this point we should have a literal to copy. Hopefully the expression we copy
		-- has been simplified into a literal if it wasn't a literal to begin with.
		local literal = decl.value
		if literal.nodeType ~= !(AST_LITERAL) then
			errorInternal(state, literal)
		end

		local copy = astCopy(literal, ident.token, ident.parent)
		replaceQueuedNodeAndUnqueueOldTree(state, ident, copy)
		moveToNextRelevantPipe(state, copy, !(PIPE_INFER))

	elseif expr.nodeType == !(AST_CAST) then
		simplifyCast(state, expr)
	elseif expr.nodeType == !(AST_UNARY) then
		simplifyUnary(state, expr)
	elseif expr.nodeType == !(AST_BINARY) then
		simplifyBinary(state, expr)

	else
		-- void
	end
end



-- Values of simple types are non-objects (e.g. ints) in the outputted Lua code.
-- Note: Glóa types are represented as ints in Lua and thus are 'simple'.
function _G.isTypeSimple(typeInfo)
	local tag = typeInfo.tag
	return !!(CONST_SET{
		TYPE_BOOL,
		TYPE_INT,
		TYPE_NONE,
		TYPE_FLOAT,
		TYPE_STRING,
		TYPE_TYPE,
		TYPE_ENUM -- All enum member types are simple.
	})[tag] or false
end

function _G.isTypeNumeric(typeInfo)
	return !!(CONST_SET{ TYPE_INT, TYPE_FLOAT })[typeInfo.tag] or false
end

function _G.isTypeTableLike(typeInfo)
	return !!(CONST_SET{ TYPE_TABLE, TYPE_STRUCT, TYPE_ARRAY })[typeInfo.tag] or false
end

function _G.isTypePublic(typeInfo)
	local tag = typeInfo.tag
	if !!(CONST_SET{ TYPE_LIST, TYPE_NAMESPACE, TYPE_PLACEHOLDER, TYPE_VARARG })[tag] then  return false  end
	if !!(CONST_SET{ TYPE_FUNCTION, TYPE_STRUCT })[tag] and typeInfo.isPolymorphic    then  return false  end
	return true
end

-- isCompatible, compatibilityScore = isTypeCompatibleWith( typeToCheck, otherType [, strictTypeMatch=false ] )
--
-- strictTypeMatch ought to be set for arguments of morphed polymorphic functions that were baked or came from a placeholder argument.
-- (Not sure if the baked state matter - maybe just the placeholder state.)
--
function _G.isTypeCompatibleWith(typeToCheck, otherType, strictTypeMatch)
	!local SCORE = 0x10000
	if typeToCheck == otherType then  return true, !(SCORE)  end

	-- Namespaces are never compatible with anything but themselves as they're not allowed in most places.
	if typeToCheck.tag == !(TYPE_NAMESPACE) or otherType.tag == !(TYPE_NAMESPACE) then  return false, 0  end

	-- Placeholders cannot actually be checked - we just say they are compatible with
	-- everything (except namespaces) until the situation is handled elsewhere.
	!local SCORE = .1
	if typeToCheck.tag == !(TYPE_PLACEHOLDER) or otherType.tag == !(TYPE_PLACEHOLDER) then  return true, !(SCORE)  end

	if not strictTypeMatch then
		-- Everything is compatible with the 'any' type. The user better know what they're doing!
		!local SCORE = 0x1
		if otherType.tag == !(TYPE_ANY) then  return true, !(SCORE)  end

		-- Ints are always compatible with floats (but the opposite is false).
		-- This should be safe as all numbers are 64-bit floats in Lua 5.1 (I think).
		!local SCORE = 0x1000
		if typeToCheck.tag == !(TYPE_INT) and otherType.tag == !(TYPE_FLOAT) then  return true, !(SCORE)  end

		-- Substructs are compatible with base structs.
		!local SCORE = 0x1000
		if typeToCheck.tag == !(TYPE_STRUCT) and otherType.tag == !(TYPE_STRUCT) then
			if doesStructInherit(typeToCheck, otherType) then  return true, !(SCORE)  end
			return false, 0
		end

		-- Structs and arrays are outputted as tables in Lua, so they are always compatible with tables in Glóa.
		!local SCORE = 0x10
		if otherType.tag == !(TYPE_TABLE) and !!(CONST_SET{ TYPE_STRUCT, TYPE_ARRAY })[typeToCheck.tag] then
			return true, !(SCORE)
		end

		!local SCORE = 0x100
		if typeToCheck.tag == !(TYPE_COMPOUND) then
			-- All compound items has to match the target. (If only one item matches, an explicit cast is needed.)
			local compoundToCheck = typeToCheck
			for _, compoundItemToCheck in ipairs(compoundToCheck) do
				if not isTypeCompatibleWith(compoundItemToCheck, otherType, false) then  return false, 0  end
			end
			return true, !(SCORE)
		end

		!local SCORE = 0x100
		if otherType.tag == !(TYPE_COMPOUND) then
			-- typeToCheck has to match at least one compound item.
			local otherCompound = otherType
			for _, otherCompoundItem in ipairs(otherCompound) do
				if isTypeCompatibleWith(typeToCheck, otherCompoundItem, false) then  return true, !(SCORE)  end
			end
			return false, 0
		end
	end

	-- Array compatability completely depends on the item type.
	if otherType.tag == !(TYPE_ARRAY) then
		if typeToCheck.tag == !(TYPE_ARRAY) then
			return isTypeCompatibleWith(typeToCheck.itemType, otherType.itemType, strictTypeMatch)
		elseif typeToCheck.tag == !(TYPE_STRUCT) and typeToCheck.kind == !(STRUCT_KIND_ARRAY) then -- We allow array-like structs even if strictTypeMatch is set.
			return isTypeCompatibleWith(typeToCheck.valueType, otherType.itemType, strictTypeMatch)
		end
		return false, 0
	end

	return false, 0
end

function _G.doesStructInherit(structInfoToCheck, otherStructInfo)
	!ASSERT `otherStructInfo`

	for _, typeExpr in ipairs(structInfoToCheck.astNode.inherits) do
		local structInfoInherited = getTypeRepresentedByExpression(typeExpr)

		if structInfoInherited == otherStructInfo or doesStructInherit(structInfoInherited, otherStructInfo) then
			return true
		end
	end

	return false
end

function _G.compareIdsOfTypes(a, b)
	return a.id < b.id
end

-- singleTypeInfo = adjustTypeToOne( state, expressionForError, typeInfo [, adjustVarargToIncludeNil=false ] )
-- Types that aren't single: TypeInfoVararg and TypeInfoList.
do
	local function adjustVarargItemTypeToOneAndToIncludeNil(state, itemType)
		if !!(CONST_SET{ TYPE_NONE, TYPE_ANY })[itemType.tag] then
			return itemType
		end

		local nilTypeInfo = getTypeInfoForBuiltinType(state, "none")

		if itemType.tag ~= !(TYPE_COMPOUND) then
			return getTypeInfoForCompoundType(state, {itemType, nilTypeInfo}, true)
		end

		local compound = itemType
		if indexOf(compound, nilTypeInfo) then  return compound  end

		return getTypeInfoForCompoundType(state, {nilTypeInfo, unpack(compound)}, true)
	end

	function _G.adjustTypeToOne(state, exprForError, typeInfo, adjustVarargToIncludeNil)
		if typeInfo.tag == !(TYPE_LIST) then
			typeInfo = typeInfo[1]
			if not typeInfo then
				typeError(state, exprForError, "Function call returns nothing. (Expected at least one value.)") -- Note: "Nothing" is not the same as vararg of zero length.
			end
		end

		if typeInfo.tag == !(TYPE_VARARG) then
			typeInfo = typeInfo.itemType
			if adjustVarargToIncludeNil then
				typeInfo = adjustVarargItemTypeToOneAndToIncludeNil(state, typeInfo)
			end
		end

		return typeInfo
	end
end



local function getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError)
	!(
	local NO_EXPECTATION = 'typeError(state, nodeForError, "Could not determine the type of this %s.", expectantTerm)'
	if DEBUG then
		NO_EXPECTATION = 'astPrintTree(node) ; '..NO_EXPECTATION
	end
	)

	if node.nodeType == !(AST_TABLE) then
		-- Detect constructors that look like arrays.
		local tableNode   = node
		local tableField1 = tableNode.fields[1]
		if not tableField1 then  !!(NO_EXPECTATION)  end

		local fieldKey = tableField1.key

		if fieldKey.nodeType == !(AST_LITERAL) and fieldKey.literalType == !(LITERAL_INTEGER) then
			local fieldValue = tableField1.value
			if fieldValue.nodeType == !(AST_TABLE) then  !!(NO_EXPECTATION)  end

			if not fieldValue.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `fieldValue`, nil, `nil`)
			end

			local typeInfo = adjustTypeToOne(state, fieldValue, fieldValue.inferredType)
			return getTypeInfoForArray(state, typeInfo)

		elseif not fieldKey.inferredType then
			if fieldKey.nodeType ~= !(AST_TABLE) then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `fieldKey`, nil, `nil`)
			end
		end
	end

	!!(NO_EXPECTATION)
end

-- Returns nil if we're now waiting for something. Errors on failure.
function _G.getExpectedTypeInfo(state, node, strict, expectantTerm, nodeForError)
	local parentNodeType = node.parent.nodeType

	if parentNodeType == !(AST_ASSIGNMENT) then
		local assignment = node.parent
		local i          = indexOf(assignment.values, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		local decl = (assignment.forDeclaration and assignment.declarations[i] or nil)

		if decl then
			if decl.name.inferredType then
				return decl.name.inferredType
			elseif not decl.type then
				return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			elseif not decl.type.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
			else
				return getTypeRepresentedByExpression(decl.type) or errorInternal()
			end

		else
			if not assignment.targets[i].inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `assignment.targets[i]`, nil, `nil`)
			end
			return assignment.targets[i].inferredType
		end

	--[[ Is this older than the above? What's going on? @Cleanup!
	elseif parentNodeType == !(AST_ASSIGNMENT) then
		local assignment = node.parent
		local i          = indexOf(assignment.values, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		local decl = (assignment.forDeclaration and assignment.declarations[i] or nil)

		if decl then
			if decl.name.inferredType then
				return decl.name.inferredType

			elseif decl.parent.nodeType == !(AST_ENUM) then
				local enum     = decl.parent
				local enumInfo = enum.representedType
				if enumInfo then
					return enumInfo
				elseif enum.memberType or decl ~= enum.declarations[1] then
					-- @Incomplete: This doesn't work right now as enums wait for their members. Enums need to be more like structs!
					!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `enum`, nil, `nil`)
				else
					return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
				end

			elseif decl.type then
				if not decl.type.inferredType then
					!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
				else
					return getTypeRepresentedByExpression(decl.type) or errorInternal(state, decl.type)
				end

			else
				return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			end

		else
			-- @Incomplete: Get type from assignment target.
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end
	]]

	elseif parentNodeType == !(AST_DECLARATION) then
		local decl = node.parent
		if node ~= decl.value then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		if decl.name.inferredType then
			return decl.name.inferredType

		elseif decl.parent.nodeType == !(AST_ENUM) then
			local enum     = decl.parent
			local enumInfo = enum.representedType
			if enumInfo then
				return enumInfo
			elseif enum.memberType or decl ~= enum.declarations[1] then
				-- @Incomplete: This doesn't work right now as enums wait for their members. Enums need to be more like structs!
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `enum`, nil, `nil`)
			else
				return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			end

		elseif decl.type then
			if not decl.type.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
			else
				return getTypeRepresentedByExpression(decl.type) or errorInternal(state, decl.type)
			end

		elseif node.nodeType == !(AST_TABLE) then
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))

		else
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
		end

	elseif parentNodeType == !(AST_CAST) then
		local cast = node.parent
		if node ~= cast.expression then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		if not cast.targetType.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `cast.targetType`, nil, `nil`)
		end

		return getTypeRepresentedByExpression(cast.targetType) or errorInternal(state, cast.targetType)

	elseif parentNodeType == !(AST_BINARY) then
		local binary = node.parent
		local other  = node == binary.left and binary.right or binary.left

		if not other.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `other`, nil, `nil`)
		end

		return other.inferredType

	elseif parentNodeType == !(AST_TABLE) then
		local tableNode = node.parent
		if not tableNode.inferredType then
			-- Note: Tables will always get inferred before child tables.
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `tableNode`, nil, `nil`)
		end

		local tableField = nil
		local isKey      = false

		for _, _tableField in ipairs(tableNode.fields) do
			if node == _tableField.key then
				isKey      = true
				tableField = _tableField
				break
			elseif node == _tableField.value then
				tableField = _tableField
				break
			end
		end

		!ASSERT `tableField`

		if tableNode.inferredType.tag == !(TYPE_TABLE) then
			return getTypeInfoForBuiltinType(state, "any")

		elseif tableNode.inferredType.tag == !(TYPE_ARRAY) then
			if isKey then  return getTypeInfoForBuiltinType(state, "int")  end

			local arraySig = tableNode.inferredType
			return arraySig.itemType

		elseif tableNode.inferredType.tag == !(TYPE_STRUCT) then
			if isKey then  return getTypeInfoForBuiltinType(state, "string")  end

			local structInfo = tableNode.inferredType
			if not structInfo.hasMembers then
				!DEPEND_AND_RETURN(`node`, DEPEND_STRUCT_MEMBERS_READY, `structInfo`)
			end

			local memberLiteral = tableField.key
			if not memberLiteral.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `memberLiteral`)
			end

			local memberName = memberLiteral.value
			local member     = itemWith1(structInfo.members, "name", memberName) or errorInternal(state, memberLiteral, memberName)

			return member.typeInfo

		else
			errorInternal(getFriendlyTypeInfoName(tableNode.inferredType))
		end

	elseif parentNodeType == !(AST_RETURN) then
		local returnNode = node.parent

		if returnNode.runDirective then
			return getExpectedTypeInfo(state, returnNode.runDirective, strict, expectantTerm, nodeForError)
		end

		local i = indexOf(returnNode.values, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		local lambda  = getLambda(returnNode)
		local funcSig = lambda.inferredType

		if not funcSig then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `lambda`, nil, `nil`)
		end

		local argTypesOut = funcSig.argumentTypesOut
		local argTypeInfo = argTypesOut[i]

		if
			(not argTypeInfo and argTypesOut[1] and argTypesOut[#argTypesOut].tag == !(TYPE_VARARG))
			or (argTypeInfo.tag == !(TYPE_VARARG))
		then
			local varargSig = argTypeInfo or argTypesOut[#argTypesOut]
			argTypeInfo     = varargSig.itemType
		end

		-- Note: We don't need to get too fancy with validation here as the return is validated later.
		if not argTypeInfo then
			typeError(state, returnNode, "Too many values specified for return.")
		end

		return argTypeInfo

	elseif strict then
		return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))

	elseif parentNodeType == !(AST_CALL) then
		local call = node.parent
		local i    = indexOf(call.arguments, node)
		if not i then  return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))  end

		local calleeTypeInfo = call.callee.inferredType

		if not calleeTypeInfo then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `call.callee`, nil, `nil`)
		end

		if not call.inferredType and call.callee.nodeType == !(AST_IDENTIFIER) and call.callee.declaration.overloadOf then
			-- Circular dependency:
			-- Overloaded and polymorphic calls must have all args inferred before being valid,
			-- and table constructors etc. must know the exact function being called.
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			--[[
			typeError(
				state, node, !(
					"Circular dependency: Call to overloaded function '%s' is waiting for this argument, but the argument is also waiting for the call to finish."
					.." Use a cast to specify what type this value is to solve the situation."
				),
				call.callee.name
			)
			--]]
		end

		local argTypesIn  = calleeTypeInfo.argumentTypesIn
		local argTypeInfo = argTypesIn[i]

		if
			(argTypeInfo and argTypeInfo.tag == !(TYPE_VARARG))
			or (not argTypeInfo and argTypesIn[1] and argTypesIn[#argTypesIn].tag == !(TYPE_VARARG))
		then
			local varargSig = argTypeInfo or argTypesIn[#argTypesIn]
			argTypeInfo     = varargSig.itemType
		end

		-- Note: We don't need to get too fancy with validation here as the call is validated later.
		if not argTypeInfo then
			!ifDEBUG `astPrintTree(call)`
			typeError(state, call, "Too many arguments specified for call.")
		end

		if argTypeInfo.tag == !(TYPE_PLACEHOLDER) then
			-- (See above circular dependency note.)
			return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
			--[[
			typeError(
				state, node, !(
					"Circular dependency: Call to polymorphic function%s is waiting for this argument, but the argument is also waiting for the call to finish."
					.." Use a cast to specify what type this value is to solve the situation."
				),
				(call.callee.nodeType == !(AST_IDENTIFIER) and F(" '%s'", call.callee.name) or "")
			)
			--]]
		end

		return argTypeInfo

	else
		return (getExpectedTypeInfoUsingContents(state, node, strict, expectantTerm, nodeForError))
	end
	errorInternal()
end



-- Note: The expression must be constant!
function _G.followIdentifiersToConstantValue(constExpr)
	while constExpr.nodeType == !(AST_IDENTIFIER) do
		local decl = constExpr.declaration
		constExpr  = decl.value or errorInternal()
	end
	return constExpr
end



function _G.wrapInImplicitCast(state, nodeToWrap, resultingTypeInfo, addToInferPipe)
	local cast        = astNewNode(AstCast, nodeToWrap.token, nodeToWrap.parent)
	cast.isImplicit   = true
	cast.inferredType = resultingTypeInfo
	pokeAndQueueUnqueuedNodeIntoTree(state, nodeToWrap, cast, cast,"expression", (addToInferPipe and !(PIPE_INFER) or !(PIPE_DONE)))
	return cast
end



local EXPRESSION_EXPECTED = !(Set{
	AST_ACCESS,
	AST_ASSIGNMENT,
	AST_BAKE,
	AST_BINARY,
	AST_CALL,
	AST_CAST,
	AST_CONDITIONAL,
	AST_DEBUG,
	AST_VARIANT_OF,
	AST_RETURN,
	AST_RUN, -- Good?
	AST_TABLE,
	AST_TYPE,
	AST_TYPE_OF,
	AST_UNARY,
	AST_USING,
})
local EXPRESSION_NOT_EXPECTED = !(Set{
	AST_ARGUMENT,
	AST_ARGUMENTS,
	AST_BLOCK,
	AST_DEFER,
	AST_ENUM,
	AST_FILE_SCOPE,
	AST_GLOBAL_SCOPE,
	AST_LAMBDA,
	AST_NAMESPACE,
	AST_STRUCT,
})

function _G.isAnExpressionExpected(state, node)
	local parent         = node.parent
	local parentNodeType = parent.nodeType

	if EXPRESSION_EXPECTED[parentNodeType] then
		return true
	elseif EXPRESSION_NOT_EXPECTED[parentNodeType] then
		return false
	elseif parentNodeType == !(AST_DECLARATION) then
		return node == parent.name or node == parent.type or node == parent.value or indexOf(parent.notes, node) ~= nil
	elseif parentNodeType == !(AST_FOR) then
		return node ~= parent.body
	elseif !!(CONST_SET{ AST_IF, AST_STATIC_IF, AST_WHILE })[parentNodeType] then
		return node == parent.condition
	else
		errorUnhandledNodeType(state, node.parent)
	end
end



-- Note: The expressions must already be inferred!
function _G.areConstantTreesEqual(state, expr1, expr2)
	expr1 = followIdentifiersToConstantValue(expr1)
	expr2 = followIdentifiersToConstantValue(expr2)

	if expr1 == expr2 then
		return true
	elseif expr1.nodeType ~= expr2.nodeType then
		return false
	elseif expr1.nodeType == !(AST_LITERAL) then
		return expr1.literalType == expr2.literalType and expr1.value == expr2.value
	elseif expr1.nodeType == !(AST_TYPE) then
		return expr1.representedType.id == expr2.representedType.id
	else
		errorUnhandledNodeType(state, expr1)
	end
end



-- valueExpression = getDeclarationValue( declaration [, fallBackToLastAssignmentValue=false ] )
function _G.getDeclarationValue(decl, fallBackToLastAssignmentValue)
	return decl.value or decl.assignment and (
		decl.assignment.values[decl.assignmentIndex]
		or (fallBackToLastAssignmentValue and getLast(decl.assignment.values) or nil)
	)
end

function _G.isDeclarationGlobal(decl)
	return decl.kind == !(DECL_KIND_EXPORT_CONST) and decl.parent.nodeType == !(AST_FILE_SCOPE) and not decl.parent.isModule
end

function _G.isDeclarationConstant(decl)
	return decl.kind == !(DECL_KIND_LOCAL_CONST) or decl.kind == !(DECL_KIND_EXPORT_CONST)
end
function _G.isDeclarationImperative(decl)
	return not isDeclarationConstant(decl)
end
function _G.isDeclarationStatic(decl)
	return decl.kind == !(DECL_KIND_LOCAL_CONST) or decl.kind == !(DECL_KIND_EXPORT_CONST) or decl.kind == !(DECL_KIND_STATIC)
end
function _G.isDeclarationWritable(decl)
	return decl.kind == !(DECL_KIND_LOCAL_VAR) or decl.kind == !(DECL_KIND_EXPORT_VAR) or decl.kind == !(DECL_KIND_STATIC)
end
function _G.isDeclarationExported(decl)
	return decl.kind == !(DECL_KIND_EXPORT_VAR) or decl.kind == !(DECL_KIND_EXPORT_CONST)
end

-- Note: This function does not check what scope the declaration is in!
-- The scope may require the value to be constant even if this function returns false.
function _G.shouldDeclarationValueDefinitivelyBeConstant(decl)
	return not isDeclarationWritable(decl)
end



function _G.getOverloadBase(decl)
	decl = decl.overloadOf
	if not decl then  return nil  end

	while decl.overloadOf and decl.overloadOf ~= decl do
		decl = decl.overloadOf
	end

	return decl
end



-- Determine whether calls or varargs should adjust to one.
function _G.areMultipleValuesEnabledAtPosition(state, node)
	local parentNodeType = node.parent.nodeType

	if parentNodeType == !(AST_DECLARATION) then
		local decl = node.parent
		return node == decl.name

	elseif parentNodeType == !(AST_ASSIGNMENT) then
		local assignment = node.parent
		return node.queued.container == assignment.values and not assignment.values[node.queued.key+1]

	elseif parentNodeType == !(AST_CALL) then
		local call = node.parent
		return node.queued.container == call.arguments and not call.arguments[node.queued.key+1]

	elseif parentNodeType == !(AST_RETURN) then
		local returnNode = node.parent
		return node.queued.container == returnNode.values and not returnNode.values[node.queued.key+1]

	elseif parentNodeType == !(AST_TABLE) then
		local tableNode = node.parent
		if tableNode.trailingExpression then  return node == tableNode.trailingExpression  end

		-- Predict what tableNode.trailingExpression may be when the table infers (if anything).
		local lastTableField = getLast(tableNode.fields)
		return lastTableField ~= nil and lastTableField.keyIsGenerated and node == lastTableField.value

	elseif parentNodeType == !(AST_FOR) then
		local forLoop = node.parent
		return node.queued.container == forLoop.expressions

	elseif parentNodeType == !(AST_ACCESS) then
		local access = node.parent
		return node == access.object

	elseif parentNodeType == !(AST_UNARY) then
		local unary = node.parent
		return node.nodeType == !(AST_VARARG) and unary.operation == "#"

	elseif !!(CONST_SET{ AST_TYPE, AST_VARIANT_OF, AST_TYPE_OF, AST_TYPE_INFO, AST_DEBUG })[parentNodeType] then
		return true -- These are static expressions. They don't care about resulting values of any subexpressions - only about the subexpressions themselves.

	elseif isScope(node.parent) then
		return true -- We don't really care about statement-level nodes.

	else
		return false
	end
end


