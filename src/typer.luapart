--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	getAssignmentValue
	getClosestScope, isScope, isScopeDeclarative, isScopeImperative
	getLiteralValueFromExpressionIfConstant
	getTypeInfo*
	inferNode
	isTypeSimple
	typeError, typeMessage

--============================================================]]



!(
_G.typeTags        = {}
local lastTypeTag  = 0
local typeTagNames = {}

local function structTypeInfo(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			lastTypeTag           = lastTypeTag+1
			fields._overrides     = fields._overrides or {}
			fields._overrides.tag = lastTypeTag

			local typeTagName = name:gsub("^TypeInfo", ""):lower()
			if typeTagName == "any" then  typeTagName = "*any*"  end

			typeTags[name]            = lastTypeTag
			typeTagNames[lastTypeTag] = typeTagName
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_TypeInfo"{
	tag         = 0,    -- This is like a "type of type info". The word "type" is used in so many places so we call it "tag" here to make it less confusing...
	id          = 0,
	declaration = NIL, -- AstTypeDeclaration
}

local !structTypeInfo"TypeInfoAny:_TypeInfo"{}
local !structTypeInfo"TypeInfoBool:_TypeInfo"{}
local !structTypeInfo"TypeInfoInt:_TypeInfo"{}
local !structTypeInfo"TypeInfoNil:_TypeInfo"{}
local !structTypeInfo"TypeInfoFloat:_TypeInfo"{}
local !structTypeInfo"TypeInfoString:_TypeInfo"{}
local !structTypeInfo"TypeInfoTable:_TypeInfo"{}
local !structTypeInfo"TypeInfoType:_TypeInfo"{}
local !structTypeInfo"TypeInfoNamespace:_TypeInfo"{}
local !structTypeInfo"TypeInfoVoid:_TypeInfo"{}

_G.!(local )!!SIMPLE_TYPE_TAG = {
	-- These small type infos don't have any extra information.
	[typeTags.TypeInfoAny]       = true,
	[typeTags.TypeInfoBool]      = true,
	[typeTags.TypeInfoInt]       = true,
	[typeTags.TypeInfoNil]       = true,
	[typeTags.TypeInfoFloat]     = true,
	[typeTags.TypeInfoString]    = true,
	[typeTags.TypeInfoTable]     = true,
	[typeTags.TypeInfoType]      = true,
	[typeTags.TypeInfoNamespace] = true,
}

local !structTypeInfo"TypeInfoArray:_TypeInfo"{
	itemType = NIL, -- TypeInfo
}

local !structTypeInfo"TypeInfoVararg:_TypeInfo"{
	itemType = NIL, -- TypeInfo
}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{ -- AKA function signature.
	argumentTypesIn  = {}, -- []TypeInfo  @Cleanup: Use TypeInfoList here.
	argumentTypesOut = {}, -- []TypeInfo  @Cleanup: Use TypeInfoList here.
	polymorphic      = false,
	inline           = false,
}

local !struct"TypeInfoStructMember"{
	name     = "",
	typeInfo = NIL,
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	name                  = "",  -- Filled in during definition.
	arguments             = {},  -- []TypeInfo  @Incomplete: Polymorphism.  @Cleanup: Use TypeInfoList here.
	members               = {},  -- []TypeInfoStructMember
	polymorphSourceStruct = NIL, -- TypeInfoStruct  @Incomplete: Polymorphism.
}

local !struct"TypeInfoEnumMember"{
	name = "",
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	name     = "",
	typeInfo = NIL, -- Must be one of these primitive types: int, string, type, bool or float.
	members  = {},  -- []TypeInfoEnumMember
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	-- [1]=typeInfo1, ...
}

local !structTypeInfo"TypeInfoList:_TypeInfo"{ -- Special type used for returns from calls (both when sending and receiving).
	-- [1]=typeInfo1, ...
}

_G.TYPE_TAG_NAMES = !(typeTagNames)



-- typeInfo = newTypeInfo( TypeInfoCreator [, declaration=internal ] )
-- typeInfo = newTypeInfo( TypeInfoCreator [, definition=internal ] )  @Depricated
do
	local lastTypeId = 0

	function _G.newTypeInfo(TypeInfoCreator, decl)
		if not TypeInfoCreator then  errorInternal(2, "No TypeInfoCreator specified.")  end

		lastTypeId = lastTypeId+1

		local typeInfo       = TypeInfoCreator()
		typeInfo.id          = lastTypeId
		typeInfo.declaration = decl

		--[[
		if lastTypeId == 22 then
			errorInternal("DEBUG")
		end
		--]]

		return typeInfo
	end
end

do
	local builtinTypeInfos = {}

	local BUILTIN_TYPE_STRUCTS = {
		["*"]         = TypeInfoAny,
		["bool"]      = TypeInfoBool,
		["int"]       = TypeInfoInt,
		["nil"]       = TypeInfoNil,
		["float"]     = TypeInfoFloat,
		["string"]    = TypeInfoString,
		["table"]     = TypeInfoTable,
		["type"]      = TypeInfoType,      -- The result of e.g. type_of(int) or type_of(type_of(myVariable)).
		["namespace"] = TypeInfoNamespace, -- Imports/loads.
		["void"]      = TypeInfoVoid,      -- Barely used, if at all.
	}

	function _G.getTypeInfoForBuiltinType(state, typeName)
		local typeInfo = builtinTypeInfos[typeName]

		if not typeInfo then
			local TypeInfoCreator      = BUILTIN_TYPE_STRUCTS[typeName] or errorInternal(tostring(typeName))
			typeInfo                   = newTypeInfo(TypeInfoCreator)
			builtinTypeInfos[typeName] = typeInfo

			table.insert(state.allTypeInfos, typeInfo)
		end

		return typeInfo
	end

	-- bool, typeName = isTypeBuiltin( typeInfo )
	function _G.isTypeBuiltin(typeInfo)
		!ASSERT `typeInfo`
		if typeInfo == builtinTypeInfos["*"]         then  return true, "*"          end
		if typeInfo == builtinTypeInfos["bool"]      then  return true, "bool"       end
		if typeInfo == builtinTypeInfos["int"]       then  return true, "int"        end
		if typeInfo == builtinTypeInfos["nil"]       then  return true, "nil"        end
		if typeInfo == builtinTypeInfos["float"]     then  return true, "float"      end
		if typeInfo == builtinTypeInfos["string"]    then  return true, "string"     end
		if typeInfo == builtinTypeInfos["table"]     then  return true, "table"      end
		if typeInfo == builtinTypeInfos["type"]      then  return true, "type"       end
		if typeInfo == builtinTypeInfos["namespace"] then  return true, "namespace"  end
		if typeInfo == builtinTypeInfos["void"]      then  return true, "void"       end
		return false, ""
	end
end

function _G.getTypeInfoForLambda(state, lambda)
	for _, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if not arg.declaration.name.inferredType then  return nil  end
	end
	for _, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if not arg.declaration.name.inferredType then  return nil  end
	end

	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoFunction) and doesLambdaHaveSignature(lambda, typeInfoCached) then
			return typeInfoCached
		end
	end

	local funcSig = newTypeInfo(TypeInfoFunction)

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		funcSig.argumentTypesIn[i] = arg.declaration.name.inferredType
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		funcSig.argumentTypesOut[i] = arg.declaration.name.inferredType
	end

	table.insert(state.allTypeInfos, funcSig)
	return funcSig
end

do
	local function getTypeInfoForListOrCompoundType(state, typeInfos, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfos) do
			if typeInfoCached.tag == tag and areArraysEqual(typeInfos, typeInfoCached) then
				return typeInfoCached
			end
		end

		local typeInfo = newTypeInfo(schematicForTypeInfo)
		copyToArray(typeInfos, typeInfo)
		table.insert(state.allTypeInfos, typeInfo)

		return typeInfo
	end

	function _G.getTypeInfoForList(state, typeInfos)
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(typeTags.TypeInfoList), TypeInfoList)
	end

	-- Note: typeInfos is expected to be sorted by type ID.
	function _G.getTypeInfoForCompoundType(state, typeInfos)
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(typeTags.TypeInfoCompound), TypeInfoCompound)
	end
end

do
	local function getTypeInfoForArrayOrVararg(state, itemType, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfos) do
			if typeInfoCached.tag == tag and itemType == typeInfoCached.itemType then
				return typeInfoCached
			end
		end

		local typeInfo    = newTypeInfo(schematicForTypeInfo)
		typeInfo.itemType = itemType
		table.insert(state.allTypeInfos, typeInfo)

		return typeInfo
	end

	function _G.getTypeInfoForArray(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(typeTags.TypeInfoArray), TypeInfoArray)
	end

	function _G.getTypeInfoForVararg(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(typeTags.TypeInfoVararg), TypeInfoVararg)
	end
end



-- Note: The expression must already be inferred!
function _G.getTypeRepresentedByExpression(expr)
	if expr.inferredType.tag ~= !(typeTags.TypeInfoType) then
		return nil

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		return typeNode.representedType
	elseif expr.nodeType == !(nodeTypes.AstStruct) then
		local struct = expr
		return struct.representedType
	elseif expr.nodeType == !(nodeTypes.AstEnum) then
		local enum = expr
		return enum.representedType

	elseif expr.nodeType == !(nodeTypes.AstTypeOf) then
		local typeOf = expr
		return typeOf.expression.inferredType
	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		return cast.expression.inferredType

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local identOther = expr
		assert(identOther.inferredType)
		return identOther.declaration.valueTypeInfo -- May be nil.

	else
		errorUnhandledNodeType(expr)
	end
end



function _G.doesLambdaHaveSignature(lambda, funcSig)
	if #(lambda.argumentsIn  or EMPTY_TABLE) ~= #funcSig.argumentTypesIn  then  return false  end
	if #(lambda.argumentsOut or EMPTY_TABLE) ~= #funcSig.argumentTypesOut then  return false  end

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if arg.declaration.name.inferredType ~= funcSig.argumentTypesIn[i]  then  return false  end
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if arg.declaration.name.inferredType ~= funcSig.argumentTypesOut[i] then  return false  end
	end

	-- @Incomplete: Check arg.isRequired for input args.

	return true
end



-- scope, childClosestToScope = getClosestScope( node )
function _G.getClosestScope(node)
	return astFindParent(node,
		!outputCommaSeparatedValues(unpack(scopeNodeTypes))
	)
end

function _G.isScope           (node)   return SCOPE_SET            [node .nodeType] or false  end
function _G.isScopeDeclarative(scope)  return SCOPE_SET_DECLARATIVE[scope.nodeType] or false  end
function _G.isScopeImperative (scope)  return SCOPE_SET_IMPERATIVE [scope.nodeType] or false  end



-- declaration = findDeclaration( state, startNode, name [, declarationToIgnore ] )
function _G.findDeclaration(state, startNode, name, declToIgnore)
	local scope = startNode

	while true do
		scope = getClosestScope(scope)
		if not scope then  break  end

		for _, decl in ipairs(scope.declarations) do
			if decl ~= declToIgnore and decl.name.name == name and isDeclarationVisibleToNode(decl, startNode) then
				return decl
			end
		end

		-- @Speed: Don't re-check already checked declarations. (Any potential speed-up may be neglectable though. Need to test with a bigger program.)
		for _, decl in ipairs(scope.declarationsInTree[name] or EMPTY_TABLE) do
			if decl ~= declToIgnore and isDeclarationVisibleToNode(decl, startNode) then
				return decl
			end
		end

		--[[ @Incomplete: Look through the scope's imports.
		for _, import in ipairs(scope.imports) do
			if import.fileScope then
				for _, decl in ipairs(import.fileScope.declarations) do
					if decl ~= declToIgnore and decl.name.name == name and decl.isGlobalOrExported then
						return decl
					end
				end
			end
		end
		--]]

		-- @Incomplete: Look through the scope's usings.
	end

	return nil
end

function _G.isDeclarationVisibleToNode(decl, node)
	if decl.isGlobalOrExported then  return true  end

	local nodeScope, nodeScopeChild = getClosestScope(node)
	local canSeeImperativeVariables = not decl.isConstant -- It doesn't matter if this is true and we're in a declarative scope because we check that in the loop below.

	while true do
		if not indexOf(nodeScope.declarations, decl) then
			-- void  (Keep looking through parent scopes and update canSeeImperativeVariables as we go.)

		elseif decl.isConstant or isScopeDeclarative(nodeScope) then
			return true

		elseif not canSeeImperativeVariables then
			return false

		elseif isAny(nodeScope.nodeType, !(nodeTypes.AstFor),!(nodeTypes.AstLambda)) then -- These are really a combination of declarative and imperative scopes.
			return true

		elseif nodeScope.nodeType == !(nodeTypes.AstBlock) then
			local block = nodeScope

			local declScope, declScopeChild = getClosestScope(decl)
			!ASSERT `declScope == block`

			local imperativeIndexForDecl = indexOf(block, declScopeChild) or errorInternal()
			local imperativeIndexForNode = indexOf(block, nodeScopeChild) or errorInternal()

			return (imperativeIndexForDecl < imperativeIndexForNode)

		else
			errorUnhandledNodeType(nodeScope)
		end

		if canSeeImperativeVariables and nodeScope.nodeType == !(nodeTypes.AstLambda) then
			-- Lambdas act as the only boundary between imperative and declarative
			-- scopes right now. Maybe this will change in the future? 2019-12-07
			canSeeImperativeVariables = false
		end

		nodeScope, nodeScopeChild = getClosestScope(nodeScope)
		if not nodeScope then  return false  end -- This shouldn't happen I don't think, unless decl and node is not part of the same tree.
	end
end

-- printDeclarationChain( [ file=io.stdout, ] state, declaration, typeName )
function _G.printDeclarationChain(file, state, decl, typeName)
	if type(file) ~= "userdata" then  return printDeclarationChain(io.stdout, file, state, decl)  end

	!local MAX_CHAIN_LENGTH = 10

	for _ = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(file, state, decl.name, "Info", "...here is '%s' declared.", typeName)

		local placeDeclared = decl.name.placeDeclared
		if not placeDeclared then  break  end

		decl = nil

		if placeDeclared.nodeType == !(nodeTypes.AstDeclaration) then
			local declCurrent = placeDeclared
			local valueNode   = declCurrent.assignment and declCurrent.assignment.values[declCurrent.assignmentIndex]

			if valueNode then
				while valueNode.replacing do
					valueNode = valueNode.replacing -- Caused by simplifications of constants.
				end

				if valueNode.nodeType == !(nodeTypes.AstIdentifier) then
					local ident = valueNode
					typeName    = ident.name
					decl        = ident.declaration or findDeclaration(state, ident, typeName, declCurrent)
				end
			end
		end

		if not decl then  break  end
	end
end



function _G.typeError(state, node, s, ...)
	return nodeError(state, node, "Typer", s, ...)
end

-- typeMessage( [ outputFile=io.stdout, ] compilationState, node, label, formatString, ... )
function _G.typeMessage(file, state, node, label, s, ...)
	return nodeMessage(file, state, node, label, "Typer", s, ...)
end



function _G.getFriendlyTypeInfoName(typeInfo)
	local name = ""

	if typeInfo.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		name             = structInfo.name -- @Incomplete: Include parameters for parameterized structs.

	elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo = typeInfo
		name           = enumInfo.name

	elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
		local funcSig      = typeInfo
		local typeTextsIn  = {}
		local typeTextsOut = {}

		for i, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			typeTextsIn[i] = getFriendlyTypeInfoName(argTypeInfo)
		end
		for i, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			typeTextsOut[i] = getFriendlyTypeInfoName(argTypeInfo)
		end

		name = typeTextsOut[1]
			and F("function(%s)->(%s)", table.concat(typeTextsIn, ","), table.concat(typeTextsOut, ","))
			or  F("function(%s)->void", table.concat(typeTextsIn, ","))

	elseif typeInfo.tag == !(typeTags.TypeInfoCompound) then
		local compound  = typeInfo
		local typeTexts = {}

		for i, compoundItem in ipairs(compound) do
			typeTexts[i] = getFriendlyTypeInfoName(compoundItem)
		end

		name = table.concat(typeTexts, "|")

	elseif typeInfo.tag == !(typeTags.TypeInfoArray) then
		local arraySig = typeInfo
		name           = "[]"..getFriendlyTypeInfoName(arraySig.itemType)

	elseif typeInfo.tag == !(typeTags.TypeInfoVararg) then
		local vararg = typeInfo
		name         = "...vararg("..getFriendlyTypeInfoName(vararg.itemType)..")"
	end

	if name == "" then
		name = TYPE_TAG_NAMES[typeInfo.tag]
	end

	-- !(if DEBUG then)  name = name.."@"..typeInfo.id  !(end)

	return name
end



local nodeInferrers = {}

!(
local function DEPEND_AND_RETURN(dependentCode, dependType, dependOnCode)
	__LUA("addDependency(state, ",dependentCode,", ",toLua(dependType),", ",dependOnCode,") ; return")
end

local function NODE_INFERRER(funcHeaderCode)
	local replacements

	funcHeaderCode, replacements = funcHeaderCode:gsub("function +nodeInferrers%.(Ast%w+)", function(nodeName)
		local nodeType = nodeTypes[nodeName] or error(nodeName)
		return "nodeInferrers[--[["..nodeName.."]]"..nodeType.."] = function"
	end)

	assert(replacements == 1, funcHeaderCode)

	__LUA(funcHeaderCode)
end
)

local function isPartOfAnyDeclaration(identOrVararg)
	local parent = identOrVararg.parent

	if parent.nodeType == !(nodeTypes.AstDeclaration) then
		local decl = parent
		return identOrVararg == decl.name

	elseif parent.nodeType == !(nodeTypes.AstAssignment) then
		local assignment = parent
		return assignment.forDeclaration and indexOf(assignment.targets, identOrVararg) ~= nil

	else
		return false
	end
end

local function inferIdentifierOrVararg(state, identOrVararg)
	local vararg = identOrVararg.nodeType == !(nodeTypes.AstVararg) and identOrVararg or nil
	local ident  = not vararg                                       and identOrVararg or nil
	local decl   = identOrVararg.declaration

	-- Loose identifier.
	if not isPartOfAnyDeclaration(identOrVararg) then
		if not decl then
			decl = findDeclaration(state, identOrVararg, identOrVararg.name)
			if not decl then
				!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_DECLARATION, `identOrVararg.name`)
			end
			identOrVararg.declaration = decl
		end

		local identInDecl = decl.name
		if not identInDecl.inferredType then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `identInDecl`)
		end
		identOrVararg.inferredType = identInDecl.inferredType

		moveToPipe(state, identOrVararg, !(PIPE_DONE))
		if ident then
			simplifyExpressionIfConstant(state, ident) -- @Check: Are we in the right pipe after simplification?
		end
		return
	end

	!ASSERT `decl`
	!ASSERT `isAny(identOrVararg.parent.nodeType, !(nodeTypes.AstDeclaration),!(nodeTypes.AstAssignment)`

	-- Assignment target in declaration (which is a copy of the identifier in the declaration).
	if identOrVararg.parent.nodeType == !(nodeTypes.AstAssignment) then
		local identInDecl = decl.name
		if not identInDecl.inferredType then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `identInDecl`)
		end
		identOrVararg.inferredType = identInDecl.inferredType

		moveToPipe(state, identOrVararg, !(PIPE_DONE))
		return
	end

	-- At this point we're defining a declared identifier.

	for _, typeNode in ipairs(decl.types) do
		if not typeNode.inferredType then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `typeNode`)
		end
	end

	local assignment = decl.assignment

	if assignment then
		for _, valueExpr in ipairs(assignment.values) do
			if not valueExpr.inferredType then
				!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `valueExpr`)
			end
		end
	end

	-- No more dependencies after this point!

	local scope = getClosestScope(decl)
	if not scope then
		typeError(state, identOrVararg, "Internal compiler error: Could not find what scope '%s' is in.", identOrVararg.name)
	end

	local isMember = isAny(scope.nodeType, !(nodeTypes.AstStruct),!(nodeTypes.AstEnum))

	local isLambdaArgOut = (
		not isMember
		and scope.nodeType == !(nodeTypes.AstLambda)
		and scope.argumentsOut ~= nil
		and indexOf(scope.argumentsOut, astFindParent(decl, !(nodeTypes.AstArgument))) ~= nil
	)

	if not (isLambdaArgOut or vararg) then
		local declExisting = findDeclaration(state, ident, ident.name, decl)
		!ASSERT `declExisting ~= decl`

		if not declExisting then
			-- void

		elseif isMember and scope ~= getClosestScope(declExisting) then
			-- void  (Members never shadow anything.)

		elseif not decl.canShadow then
			local identEarly        = declExisting.name
			local identLate         = ident
			local extraMessageEarly = ""
			local extraMessageLate  = ""

			-- Globals before locals.
			if identEarly.declaration.isGlobalOrExported ~= identLate.declaration.isGlobalOrExported then
				if identLate.declaration.isGlobalOrExported then
					identEarly, identLate = identLate, identEarly
				end

			-- Constants before variables.
			elseif identEarly.declaration.isConstant ~= identLate.declaration.isConstant then
				if identLate.declaration.isConstant then
					identEarly, identLate = identLate, identEarly
				end

				if isScopeImperative(getClosestScope(identLate.declaration)) then
					extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope, unlike variables.)"
				end

			-- Low depth before high depth.
			-- Early in file before late in file.
			else
				local depthEarly = astGetDepth(identEarly)
				local depthLate  = astGetDepth(identLate)

				if depthLate < depthEarly or (depthLate == depthEarly and identLate.token < identEarly.token) then
					-- @Incomplete: Explicitly handle the identifiers being declared in different files. (May be unnecessary.)
					identEarly, identLate = identLate, identEarly
				end

				if identEarly.declaration.isConstant and isScopeImperative(getClosestScope(identEarly.declaration)) then
					extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope.)"
				end
			end

			printerr()
			typeMessage(io.stderr, state, identLate,  "Error", "'%s' has already been declared.%s", ident.name, extraMessageLate)
			typeMessage(io.stderr, state, identEarly, "Info",  "...it was declared here.%s", extraMessageEarly)
			exitFailure()

		elseif
			scope == getClosestScope(declExisting)
			or (
				-- We do not allow declarations on lambda bodies to shadow the lambda's arguments.
				scope.nodeType == !(nodeTypes.AstBlock)
				and getClosestScope(scope).nodeType == !(nodeTypes.AstLambda)
				and getClosestScope(scope) == getClosestScope(declExisting)
			)
		then
			printerr()
			typeMessage(io.stderr, state, ident,             "Error", "'%s' has already been declared in the same scope (which means name shadowing does not work).", ident.name)
			typeMessage(io.stderr, state, declExisting.name, "Info",  "...it was declared here.")
			exitFailure()

		else
			-- void  (We're validly shadowing something in an outer scope.)
		end
	end

	if not (isLambdaArgOut or decl.canShadow or vararg) then -- Should vararg do this? I think it's not needed.
		local parentScope = scope
		repeat
			local declarationsInTree = parentScope.declarationsInTree[ident.name]

			if not declarationsInTree then
				declarationsInTree = {}
				parentScope.declarationsInTree[ident.name] = declarationsInTree
			end

			table.insert(declarationsInTree, decl)

			parentScope = getClosestScope(parentScope)
		until not parentScope
	end

	local typeInfo
	local typeInfoForDecl = nil

	-- Compound type.
	if decl.types[2] then
		-- Note: It's ok that these share the same table!
		local typeInfos    = {}        -- Keys are numbers.
		local typeInfosIds = typeInfos -- Keys are AstNode.
		local duplicates   = typeInfos -- Keys are TypeInfo.

		for _, typeExpr in ipairs(decl.types) do
			local typeInfoRepresented = getTypeRepresentedByExpression(typeExpr) or errorInternal()

			if duplicates[typeInfoRepresented] then
				printerr()
				typeMessage(io.stderr, state, typeExpr,                        "Error", "Duplicate type specified in compound type.")
				typeMessage(io.stderr, state, duplicates[typeInfoRepresented], "Info",  "...this is the same type. (%s)", getFriendlyTypeInfoName(typeInfoRepresented))
				exitFailure()
			end

			table.insert(typeInfos, typeInfoRepresented)
			typeInfosIds[typeExpr]          = typeInfoRepresented.id
			duplicates[typeInfoRepresented] = typeExpr
		end

		table.sort(decl.types, function(a, b)  return typeInfosIds[a] < typeInfosIds[b]  end) -- @Cleanup: This is probably unnecessary.
		table.sort(typeInfos,  function(a, b)  return a.id            < b.id             end)

		typeInfo = getTypeInfoForCompoundType(state, typeInfos)

	-- Single type.
	elseif decl.types[1] then
		local typeExpr = decl.types[1]
		typeInfo       = getTypeRepresentedByExpression(typeExpr)

	-- Infer type from value.
	else
		assert(not vararg)

		local valueExpr, valueTypeInfo = getAssignmentValue(state, ident, assignment.values, decl.assignmentIndex)
		typeInfo        = valueTypeInfo
		typeInfoForDecl = getTypeRepresentedByExpression(valueExpr)
	end

	-- Validate that the assigned value is the same type as the declared name.
	-- (Not needed for vararg as those only exist as arguments and don't have default values.)
	if assignment and decl.types[1] and ident then
		getAssignmentValue(state, ident, assignment.values, decl.assignmentIndex, typeInfo)
	end

	assert(typeInfo)
	if vararg then  assert(not typeInfoForDecl)  end

	-- print(typeInfoForDecl and getFriendlyTypeInfoName(typeInfoForDecl))
	if not typeInfoForDecl then
		-- void

	elseif typeInfoForDecl.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfoForDecl
		structInfo.name  = ident.name

	elseif typeInfoForDecl.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo = typeInfoForDecl
		enumInfo.name  = ident.name
	end

	if vararg then
		typeInfo = getTypeInfoForVararg(state, typeInfo)
	end

	decl.valueTypeInfo         = typeInfoForDecl -- May be nil.  @Cleanup: Move this code to AstDeclaration?
	identOrVararg.inferredType = typeInfo

	!if DEBUG then
		if debug_onlyInferTypes then
			io.stdout:write("DEFINE ", identOrVararg.name ,":", getFriendlyTypeInfoName(typeInfo))
			if decl.isConstant then  io.stdout:write(" (CONST)")  end
			if typeInfoForDecl then  io.stdout:write(" (VALUE ", getFriendlyTypeInfoName(typeInfoForDecl), ")")  end
			io.stdout:write(" IN ")
			if decl.name.placeDeclared ~= getClosestScope(decl) then
				io.stdout:write(AST_NODE_TYPE_NAMES[decl.name.placeDeclared.nodeType], " > ")
			end
			astPrint(getClosestScope(decl))
		end
	!end

	moveToPipe(state, identOrVararg, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstIdentifier(state, ident)`
	inferIdentifierOrVararg(state, ident)
end
!NODE_INFERRER `function nodeInferrers.AstVararg(state, vararg)`
	inferIdentifierOrVararg(state, vararg)
end

!NODE_INFERRER `function nodeInferrers.AstType(state, typeNode)`
	local decl = nil
	local typeInfo, typeInfoRepresented

	if not typeNode.isUserType then
		typeInfoRepresented = getTypeInfoForBuiltinType(state, typeNode.typeName)
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.functionSignature then
		local lambda = typeNode.functionSignature

		if not lambda.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `lambda`)
		end
		assert(lambda.inferredType.tag == !(typeTags.TypeInfoFunction))

		local funcSig       = getTypeInfoForLambda(state, lambda)
		typeInfoRepresented = funcSig
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.arrayItemType then
		local itemTypeInfo = typeNode.arrayItemType

		if not itemTypeInfo.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `itemTypeInfo`)
		end
		assert(itemTypeInfo.inferredType == getTypeInfoForBuiltinType(state, "type"))

		typeInfoRepresented = itemTypeInfo
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	else
		assert(typeNode.typeName ~= "")

		decl = findDeclaration(state, typeNode, typeNode.typeName)
		if not decl then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_DECLARATION, `typeNode.typeName`)
		end
		if not decl.name.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `decl.name`)
		end

		typeInfoRepresented = decl.valueTypeInfo -- May be nil.
		typeInfo            = decl.name.inferredType
		assert(typeInfo)

		if typeInfo ~= getTypeInfoForBuiltinType(state, "type") then
			printerr()
			typeMessage(io.stderr, state, typeNode, "Error", "'%s' is not a type. (It is %s)", typeNode.typeName, getFriendlyTypeInfoName(typeInfo))
			printDeclarationChain(io.stderr, state, decl, typeNode.typeName)
			exitFailure()
		end

		for _, expr in ipairs(typeNode.arguments or EMPTY_TABLE) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		-- @Incomplete: Proper error messages here:

		if SIMPLE_TYPE_TAG[typeInfo.tag] then
			assert(not typeNode.arguments) -- This should have been caught during parsing, e.g. int(a,b).

		elseif typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			if structInfo.arguments[1] then
				errorInternal("@Incomplete: Struct arguments.")
			elseif typeNode.arguments then
				typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeNode.arguments[1]), "Parameters for structs are not supported yet.")
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			assert(not typeNode.arguments)

		elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
			assert(not typeNode.arguments) -- This should not be possible I think. The node should have been parsed as an AstCall - not an AstType without functionSignature... right? I may be wrong.

		else
			errorInternal("Incomplete: Handle type tag '%s'.", TYPE_TAG_NAMES[typeInfo.tag])
		end
	end

	assert(typeInfoRepresented)
	assert(typeInfo)

	typeNode.representedType = typeInfoRepresented
	typeNode.inferredType    = typeInfo
	typeNode.declaration     = decl

	moveToPipe(state, typeNode, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstCall(state, call)`
	if not call.callee.inferredType then
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `call.callee`)
	end
	for _, arg in ipairs(call.arguments) do
		if not arg.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `arg`)
		end
	end

	local calleeTypeInfo = call.callee.inferredType

	if calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then -- @Incomplete: Parameterized structs.
		-- void

	elseif calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig  = calleeTypeInfo
		calleeTypeInfo = listSig[1]

		if not calleeTypeInfo then
			typeError(state, call, "Trying to call void.")
		elseif calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then
			-- void
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
		end

	else
		if call.callee.nodeType == !(nodeTypes.AstIdentifier) then
			local ident = call.callee
			typeError(state, ident, "'%s' is not a function. (It is %s)", ident.name, getFriendlyTypeInfoName(ident.inferredType))
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
		end
	end

	assert(calleeTypeInfo.tag == !(typeTags.TypeInfoFunction)) -- @Incomplete: Handle parameterized structs.

	-- @Cleanup: This code is similar to the code for AstReturn. (In fact, it's the exact same thing,
	-- except AstCall is for input arguments and AstReturn is for output arguments.) :MatchingValueListToArguments

	local argTypesIn  = calleeTypeInfo.argumentTypesIn
	local argCount    = #argTypesIn
	local hasVararg   = argCount > 0 and argTypesIn[argCount].tag == !(typeTags.TypeInfoVararg)
	local argCountMin = hasVararg and argCount-1 or argCount -- Note: Varargs can have zero length.
	local argCountMax = hasVararg and math.huge  or argCount

	-- @Incomplete: Check for optional arguments.
	if #call.arguments < argCountMin then
		typeError(state, call, "Missing arguments.")
	elseif #call.arguments > argCountMax then
		!ASSERT `not hasVararg`
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(call.arguments[argCount+1]), "Too many arguments.")
	end

	local function checkArgument(argIndex, argTypeInfo, argExpr, callOutArgIndex)
		local typeInfoWanted = argTypesIn[math.min(argIndex, argCount)] -- Note: Varargs are always the last argument.
		if typeInfoWanted.tag == !(typeTags.TypeInfoVararg) then
			typeInfoWanted = typeInfoWanted.itemType
		end

		if not isTypeCompatibleWith(argTypeInfo, typeInfoWanted) then
			-- @UX: Tell the name of the argument. (Probably only possible for constants, and maybe not all. Not sure!)
			if callOutArgIndex then
				local argCall = argExpr
				typeError(
					state, argCall,
					"Type mismatch for argument #%d (return value #%d from call). (Wanted %s, got %s)",
					argIndex,
					callOutArgIndex,
					getFriendlyTypeInfoName(typeInfoWanted),
					getFriendlyTypeInfoName(argTypeInfo)
				)
			else
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(argExpr),
					"Type mismatch for argument #%d. (Wanted %s, got %s)",
					argIndex,
					getFriendlyTypeInfoName(typeInfoWanted),
					getFriendlyTypeInfoName(argTypeInfo)
				)
			end
		elseif argTypeInfo ~= typeInfoWanted then
			-- @Incomplete: Add cast.
		end
	end

	-- Check additional values returned by the last value if it's call.
	local argExprLast = getLast(call.arguments)

	if argExprLast and argExprLast.nodeType == !(nodeTypes.AstCall) and not argExprLast.surroundedByParenthesis then
		local argCall   = argExprLast
		local argOffset = #call.arguments-1

		for callOutArgIndex, argTypeInfo in ipairs(argCall.callee.inferredType.argumentTypesOut) do
			local argIndex = callOutArgIndex+argOffset
			checkArgument(argIndex, argTypeInfo, argCall, callOutArgIndex)
		end
	end

	-- Check apparent arguments.
	for argIndex, argExpr in ipairs(call.arguments) do
		local argTypeInfo = argExpr.inferredType

		if argExpr.nodeType == !(nodeTypes.AstCall) then
			local listSig = argTypeInfo
			argTypeInfo   = listSig[1]

			if not argTypeInfo then
				local argCall = argExpr
				typeError(state, argCall, "Function call returns nothing. (Expected at least one value.)")
			end
		end

		checkArgument(argIndex, argTypeInfo, argExpr, nil)
	end

	call.inferredType = getTypeInfoForList(state, calleeTypeInfo.argumentTypesOut)

	moveToPipe(state, call, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstReturn(state, returnNode)`
	for _, valueExpr in ipairs(returnNode.values) do
		if not valueExpr.inferredType then
			!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `valueExpr`)
		end
	end

	local scope = getClosestScope(returnNode) or errorInternal()

	while scope.nodeType ~= !(nodeTypes.AstLambda) do
		if not isScopeImperative(scope) then -- This may eventually be AstFileScope, at most.
			-- I think this is an internal compiler error, actually. Parsing must have goofed up or something.
			typeError(state, scope, "Return statement is not in a function.")
		end

		scope = getClosestScope(scope) or errorInternal()
	end

	local lambda = scope

	if not lambda.inferredType then
		!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `lambda`)
	end

	--
	-- From now on we check that the correct stuff is returned.
	--
	-- @Incomplete: Support varargs.
	--
	-- @Cleanup: Use getAssignmentValue() or something here?
	-- Also see :MatchingValueListToArguments.
	--

	local argTypesOut      = lambda.inferredType.argumentTypesOut
	local lastValueExpr    = getLast(returnNode.values)
	local returnValueCount = #returnNode.values

	local lastValueIsListToUnpack
		=   lastValueExpr ~= nil
		and lastValueExpr.nodeType == !(nodeTypes.AstCall)
		and not lastValueExpr.surroundedByParenthesis
		and lastValueExpr.inferredType.tag == !(typeTags.TypeInfoList)

	if lastValueIsListToUnpack then
		local listSig    = lastValueExpr.inferredType
		returnValueCount = returnValueCount - 1 + #listSig
	end

	if returnValueCount == #argTypesOut then
		-- void

	-- Too few values.
	elseif returnValueCount < #argTypesOut then
		-- @UX: Show a better message if lastValueExpr is a function call (not wrapped in parenthesis).
		typeError(state, returnNode, "Too few values to return. (Expected %d, got %d)", #argTypesOut, returnValueCount)

	-- Too many values.
	elseif not lastValueIsListToUnpack then
		local expr = astGetExpressionVisuallyFurthestToTheLeft(returnNode.values[#argTypesOut+1])
		typeError(state, expr, "Too many values to return. (Expected %d, got %d)", #argTypesOut, returnValueCount)
	else
		local callOutArgCount = #returnNode.values-1
		local listSig         = lastValueExpr.inferredType
		typeError(state, lastValueExpr, "Too many values returned from call. (Expected %d, got %d)", #argTypesOut-callOutArgCount, #listSig)
	end

	if lastValueIsListToUnpack then
		local listSig = lastValueExpr.inferredType

		for i = #returnNode.values, returnValueCount do
			local callOutArgIndex = i-#returnNode.values+1
			local typeInfo        = listSig[callOutArgIndex]

			if not isTypeCompatibleWith(typeInfo, argTypesOut[i]) then
				typeError(state, lastValueExpr,
					"Type mismatch for return value #%d from call. (Wanted %s, got %s)",
					callOutArgIndex,
					getFriendlyTypeInfoName(argTypesOut[i]),
					getFriendlyTypeInfoName(typeInfo)
				)
			elseif typeInfo ~= argTypesOut[i] then
				-- @Incomplete: Add cast.
			end
		end
	end

	for i = 1, #returnNode.values - (lastValueIsListToUnpack and 1 or 0) do
		local expr     = returnNode.values[i]
		local typeInfo = expr.inferredType

		if expr.nodeType == !(nodeTypes.AstCall) then
			local listSig = typeInfo
			typeInfo      = listSig[1]

			if not typeInfo then
				local call = expr
				typeError(state, call, "Function call returns nothing. (Expected at least one value.)")
			end
		end

		if not isTypeCompatibleWith(typeInfo, argTypesOut[i]) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr),
				"Type mismatch for return value #%d. (Wanted %s, got %s)",
				i,
				getFriendlyTypeInfoName(argTypesOut[i]),
				getFriendlyTypeInfoName(typeInfo)
			)
		elseif typeInfo ~= argTypesOut[i] then
			-- @Incomplete: Add cast.
		end
	end

	moveToPipe(state, returnNode, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstDeclaration(state, decl)`
	if decl.assignment and decl.assignment.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `decl.assignment`)
	end

	local ident = decl.name
	if not ident.inferredType then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `ident`)
	end

	for _, typeNode in ipairs(decl.types) do
		if not typeNode.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `typeNode`)
		end
	end

	-- @Incomplete: decl.notes (if we make them structured)

	if decl.assignment then
		local scope              = getClosestScope(decl) or errorInternal()
		local scopeIsDeclarative = isScopeDeclarative(scope)

		if scopeIsDeclarative or decl.isConstant then
			local valueExpr = getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex)
			local isConst   = getLiteralValueFromExpressionIfConstant(state, valueExpr)

			if not isConst then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
					"Value for declared %s '%s' is not a constant expression.%s",
					(decl.isConstant and "constant" or "variable"),
					ident.name,
					(scopeIsDeclarative and not decl.isConstant and " (All values in declarative scopes must be constant.)" or "")
				)
			end
		end
	end

	moveToPipe(state, decl, !(PIPE_BYTECODE))
end

!!local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = {
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "nil",
	[LITERAL_FLOAT]   = "float",
	[LITERAL_STRING]  = "string",
}
_G.!(local )!!BUILTIN_TYPE_TAG_TO_LITERAL_TYPE = {
	[typeTags.TypeInfoBool]   = LITERAL_BOOLEAN,
	[typeTags.TypeInfoInt]    = LITERAL_INTEGER,
	[typeTags.TypeInfoNil]    = LITERAL_NIL,
	[typeTags.TypeInfoFloat]  = LITERAL_FLOAT,
	[typeTags.TypeInfoString] = LITERAL_STRING,
}

!NODE_INFERRER `function nodeInferrers.AstLiteral(state, literal)`
	local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType] or errorUnhandledNodeType(literal)

	literal.inferredType = getTypeInfoForBuiltinType(state, typeName)

	moveToNextPipe(state, literal, !(PIPE_BYTECODE))
end

!NODE_INFERRER `function nodeInferrers.AstUnary(state, unary)`
	if not unary.expression.inferredType then
		!DEPEND_AND_RETURN(`unary`, DEPEND_NODE_INFERRED, `unary.expression`)
	end

	local typeInfo = unary.expression.inferredType

	if isAny(unary.operation, "+","-") then
		if not isAny(typeInfo,
			getTypeInfoForBuiltinType(state, "int"),
			getTypeInfoForBuiltinType(state, "float")
		) then
			typeError(state, unary.expression,
				"Unary numeric operation (%s): Expected a float or int. (Got %s)",
				unary.operation,
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "not" then
		if typeInfo ~= getTypeInfoForBuiltinType(state, "bool") then
			typeError(state, unary.expression,
				"Unary boolean operation (%s): Expected a bool. (Got %s)",
				unary.operation,
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "#" then
		errorInternal("@Incomplete: Length operator.")

	else
		errorUnhandledNodeType(unary)
	end

	unary.inferredType = typeInfo

	--
	-- Inferring complete! Now fold the expression if it's constant.
	--

	local isConst, literalValue = getLiteralValueFromExpressionIfConstant(state, unary.expression)
	if not isConst then
		moveToPipe(state, unary, !(PIPE_DONE))

	!for _, opArithmetic in ipairs{"+","-"} do
	elseif unary.operation == !(opArithmetic) then
		local literal = astNewNode(AstLiteral, unary.token, unary.parent)

		literal.literalType
			=  typeInfo == getTypeInfoForBuiltinType(state, "int")   and !(LITERAL_INTEGER)
			or typeInfo == getTypeInfoForBuiltinType(state, "float") and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = !!(opArithmetic ~= "+" and opArithmetic or "") literalValue
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))
	!end

	elseif unary.operation == "not" then
		local literal        = astNewNode(AstLiteral, unary.token, unary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = not literalValue
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))

	elseif unary.operation == "#" then
		errorUnhandledNodeType(unary)

	else
		errorUnhandledNodeType(unary)
	end

	-- astPrintTree(unary.parent)
end

!NODE_INFERRER `function nodeInferrers.AstBinary(state, binary)`
	local typeInfoL = binary.left.inferredType
	local typeInfoR = binary.right.inferredType

	if not typeInfoL then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.left`)
	end
	if not typeInfoR then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.right`)
	end

	-- @Incomplete: Use isTypeCompatibleWith(). For now, both sides need to be
	-- the same exact type. (Or maybe we shouldn't for binary operations?)
	if typeInfoL ~= typeInfoR then
		typeError(
			state, binary,
			"Binary operation (%s): Type mismatch for operands. (Left is %s, right is %s)",
			binary.operation,
			getFriendlyTypeInfoName(typeInfoL),
			getFriendlyTypeInfoName(typeInfoR)
		)
	end

	-- Numeric operation.
	if isAny(binary.operation, "+","-","*","^","%","/","//") then
		if not isAny(typeInfoL,
			getTypeInfoForBuiltinType(state, "int"),
			getTypeInfoForBuiltinType(state, "float")
		) then
			typeError(
				state, binary.left,
				"Binary numeric operation (%s): Expected a float or int. (Got %s)",
				binary.operation,
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		if     binary.operation == "/"  then  typeInfo = getTypeInfoForBuiltinType(state, "float") -- Cast to float.
		elseif binary.operation == "//" then  typeInfo = getTypeInfoForBuiltinType(state, "int")   -- Cast to int.
		else                                  typeInfo = typeInfoL  end                            -- Keep type.

	-- Comparison.
	elseif isAny(binary.operation, "<",">","<=",">=") then
		if not isAny(typeInfoL,
			getTypeInfoForBuiltinType(state, "int"),
			getTypeInfoForBuiltinType(state, "float"),
			getTypeInfoForBuiltinType(state, "string")
		) then
			typeError(
				state, binary.left,
				"Binary comparison (%s): Expected a float, int or string. (Got %s)",
				binary.operation,
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		typeInfo = getTypeInfoForBuiltinType(state, "bool")

	-- Equality.
	elseif isAny(binary.operation, "==","~=") then
		typeInfo = getTypeInfoForBuiltinType(state, "bool")

	-- Boolean operation.
	elseif isAny(binary.operation, "and","or") then
		if typeInfoL ~= getTypeInfoForBuiltinType(state, "bool") then
			typeError(state, binary.left, "Binary boolean operation (%s): Expected a bool. (Got %s)", binary.operation, getFriendlyTypeInfoName(typeInfoL))
		end
		typeInfo = getTypeInfoForBuiltinType(state, "bool")

	-- String concatination.
	elseif isAny(binary.operation, "..") then
		if typeInfoL ~= getTypeInfoForBuiltinType(state, "string") then
			typeError(state, binary.left, "String concatination expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoL))
		end
		typeInfo = getTypeInfoForBuiltinType(state, "string")

	-- Lookup, or similar.
	elseif isAny(binary.operation, ".") then
		errorInternal("@Incomplete: Handle '.' operator.")

	else
		errorUnhandledNodeType(binary)
	end

	assert(typeInfo)
	binary.inferredType = typeInfo

	--
	-- Inferring complete! Now fold the expression if it's constant.
	-- @Incomplete: Fold these kinds of expressions: (1+x)+2 => (1+2)+x => 3+x
	-- @Incomplete: Fold these kinds of expressions: 1 + -x => 1 - x
	--

	local isConstL, valueL = getLiteralValueFromExpressionIfConstant(state, binary.left)
	local isConstR, valueR = getLiteralValueFromExpressionIfConstant(state, binary.right)
	if not (isConstL and isConstR) then
		moveToPipe(state, binary, !(PIPE_DONE))

	!for _, opArithmeticKeepType in ipairs{"+","-","*","^","%"} do
	elseif binary.operation == !(opArithmeticKeepType) then
		local literal = astNewNode(AstLiteral, binary.token, binary.parent)

		literal.literalType
			=  typeInfo == getTypeInfoForBuiltinType(state, "int")   and !(LITERAL_INTEGER)
			or typeInfo == getTypeInfoForBuiltinType(state, "float") and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = valueL !!(opArithmeticKeepType) valueR
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))
	!end

	elseif binary.operation == "/" then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = valueL/valueR
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))

	elseif binary.operation == "//" then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = math.floor(valueL/valueR) -- Do we need to floor valueL and valueR before the division too?
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))

	!for _, opComparison in ipairs{"<",">","<=",">=","==","~=","and","or"} do
	elseif binary.operation == !(opComparison) then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = valueL !!(opComparison) valueR
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))
	!end

	elseif binary.operation == ".." then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = valueL..valueR -- @Speed: Concatinate more than two values at a time. (Probably need to update parsing stage.)
		literal.inferredType = typeInfo
		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToPipe(state, literal, !(PIPE_BYTECODE))

	elseif binary.operation == "." then
		errorUnhandledNodeType(binary)

	else
		errorUnhandledNodeType(binary)
	end

	-- astPrintTree(binary.parent)
end

-- !NODE_INFERRER `function nodeInferrers.AstTable(state, tableNode)`
-- 	for _, tableField in ipairs(tableNode) do
-- 		tableField.key
-- 		tableField.value
-- 	end
-- end

!NODE_INFERRER `function nodeInferrers.AstArgument(state, arg)`
	if arg.declaration.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`arg`, DEPEND_NODE_INFERRED, `arg.declaration`)
	end
	moveToPipe(state, arg, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstArguments(state, args)`
	for _, arg in ipairs(args) do
		if arg.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`args`, DEPEND_NODE_INFERRED, `arg`)
		end
	end
	moveToPipe(state, args, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstLambda(state, lambda)`
	if lambda.argumentsIn and lambda.argumentsIn.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.argumentsIn`)
	end
	if lambda.argumentsOut and lambda.argumentsOut.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.argumentsOut`)
	end

	-- Note: We don't require the body to inferred.

	lambda.inferredType = getTypeInfoForLambda(state, lambda) or errorInternal()

	if lambda.body then
		moveToNextPipe(state, lambda, !(PIPE_BYTECODE))
	else
		moveToPipe(state, lambda, !(PIPE_DONE))
	end
end

!NODE_INFERRER `function nodeInferrers.AstTypeOf(state, typeOf)`
	if not typeOf.expression.inferredType then
		!DEPEND_AND_RETURN(`typeOf`, DEPEND_NODE_INFERRED, `typeOf.expression`)

	elseif typeOf.expression.inferredType == getTypeInfoForBuiltinType(state, "namespace") then
		typeError(state, typeOf.expression, "Namespaces don't have a type.")
	end

	typeOf.inferredType = getTypeInfoForBuiltinType(state, "type")

	moveToPipe(state, typeOf, !(PIPE_DONE))
	simplifyTypeExpression(state, typeOf, typeOf.expression.inferredType) -- @Check: Are we in the right pipe after simplification?
end

!NODE_INFERRER `function nodeInferrers.AstCast(state, cast)`
	if not cast.targetType.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.targetType`)
	end
	if not cast.expression.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.expression`)
	end

	local castTypeInfo = getTypeRepresentedByExpression(cast.targetType) or errorInternal()

	if castTypeInfo == cast.expression.inferredType then
		-- @Incomplete: Remove unnecessary cast.

	elseif
		isAny(castTypeInfo,                 getTypeInfoForBuiltinType(state, "float"),getTypeInfoForBuiltinType(state, "int")) and
		isAny(cast.expression.inferredType, getTypeInfoForBuiltinType(state, "float"),getTypeInfoForBuiltinType(state, "int"))
	then
		-- void

	elseif isTypeBuiltin(castTypeInfo) or isTypeBuiltin(cast.expression.inferredType) then
		typeError(
			state, cast.expression,
			"Cannot cast from %s to %s.",
			getFriendlyTypeInfoName(cast.expression.inferredType),
			getFriendlyTypeInfoName(castTypeInfo)
		)

	else
		errorUnhandledNodeType(cast)
	end

	cast.inferredType = castTypeInfo

	moveToPipe(state, cast, !(PIPE_DONE))
	-- @Incomplete: Simplify casted constants.
end

!NODE_INFERRER `function nodeInferrers.AstStatement(state, statement)`
	if statement.what.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`statement`, DEPEND_NODE_INFERRED, `statement.what`)
	end
	moveToPipe(state, statement, !(PIPE_DONE))
end

!NODE_INFERRER `function nodeInferrers.AstAssignment(state, assignment)`
	for _, ident in ipairs(assignment.targets) do
		if not ident.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `ident`)
		end
	end

	for _, expr in ipairs(assignment.values) do
		if not expr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `expr`)
		end
	end

	for i, ident in ipairs(assignment.targets) do
		getAssignmentValue(state, ident, assignment.values, i, ident.inferredType)
	end

	-- @Incomplete: Check that !must args from functions have an assignment target.

	moveToPipe(state, assignment, !(PIPE_DONE))
end

-- !NODE_INFERRER `function nodeInferrers.AstBreak(state, breakNode)`
-- 	breakNode.loopName
-- end

-- !NODE_INFERRER `function nodeInferrers.AstContinue(state, continue)`
-- 	continue.loopName
-- end

-- !NODE_INFERRER `function nodeInferrers.AstDefer(state, defer)`
-- 	defer.body
-- end

!NODE_INFERRER `function nodeInferrers.AstImport(state, import)`
	local path
	if import.isLoad then
		path = import.importName
	else
		typeError(state, import, "@Incomplete: !import")
	end

	local globalScope = state.globalScope

	if not state.fileBuffers[path] then
		-- @Incomplete: Include times in compilation stats.
		local timeStartLexing, timeEndLexing = readAndTokenizeFile(state, path)
		assert(state.fileBuffers[path], path)

		local timeStartParsing = os.clock()
		local fileScope        = parseFileScope(state, globalScope, path)
		local timeEndParsing   = os.clock()

		if peekNextToken(state) then
			errorParsingNext(state, "Expected the end of the file.")
		end

		astMoveGlobalDeclarationsToGlobalScope(state, fileScope)
		addToQueueRecursively(state, fileScope)
	end

	import.fileScope    = itemWith1(globalScope.fileScopes, "path", path) or errorInternal(path)
	import.inferredType = getTypeInfoForBuiltinType(state, "namespace")

	moveToPipe(state, import, !(PIPE_DONE))
end

-- !NODE_INFERRER `function nodeInferrers.AstIf(state, ifBranch)`
-- 	ifBranch.condition
-- 	ifBranch.branchTrue
-- 	ifBranch.branchFalse
-- end

-- !NODE_INFERRER `function nodeInferrers.AstWhile(state, whileLoop)`
--  whileLoop.condition
--  whileLoop.body
-- end

-- !NODE_INFERRER `function nodeInferrers.AstFor(state, forLoop)`
-- 	forLoop.names[]
-- 	forLoop.expressions[]
-- 	forLoop.body
-- end

!NODE_INFERRER `function nodeInferrers.AstStruct(state, struct)`
	for _, statement in ipairs(struct) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	local structInfo = newTypeInfo(TypeInfoStruct)

	for i, decl in ipairs(struct.declarations) do
		local member          = TypeInfoStructMember()
		member.name           = decl.name.name
		member.typeInfo       = decl.name.inferredType or errorInternal()
		structInfo.members[i] = member
	end

	-- @Incomplete: struct.arguments

	table.insert(state.allTypeInfos, structInfo)

	struct.representedType = structInfo
	struct.inferredType    = getTypeInfoForBuiltinType(state, "type")

	moveToPipe(state, struct, !(PIPE_DONE)) -- @Temp until struct bodies are decoupled from the "header".
	-- moveToNextPipe(state, struct, !(PIPE_BYTECODE))
end

!NODE_INFERRER `function nodeInferrers.AstEnum(state, enum)`
	for _, statement in ipairs(enum) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	assert(enum.declarations[1], "Enums must have members.") -- This should have been caught during parsing.

	local enumMemberInfo

	if enum.memberType then
		enumMemberInfo = getTypeInfoForBuiltinType(state, enum.memberType.typeName)
	else
		-- Just use the type of the first member as the wanted type for the enum.
		-- Note: Struct member declarations only have one name.
		enumMemberInfo = enum.declarations[1].name.inferredType
		if not isAny(enumMemberInfo,
			getTypeInfoForBuiltinType(state, "int"),
			getTypeInfoForBuiltinType(state, "string"),
			getTypeInfoForBuiltinType(state, "type"),
			getTypeInfoForBuiltinType(state, "bool"),
			getTypeInfoForBuiltinType(state, "float")
		) then
			typeError(state, enum, "Supported enum member types are: int, string, type, bool, float")
		end
	end

	local enumInfo = newTypeInfo(TypeInfoEnum)

	for i, decl in ipairs(enum.declarations) do
		local valueExpr = decl.assignment.values[1]

		if not isTypeCompatibleWith(valueExpr.inferredType, enumMemberInfo) then
			typeError(state, valueExpr,
				"Value type mismatch for '%s'. (Wanted %s, got %s)",
				decl.name.name,
				getFriendlyTypeInfoName(enumMemberInfo),
				getFriendlyTypeInfoName(valueExpr.inferredType)
			)
		elseif valueExpr.inferredType ~= enumMemberInfo then
			-- @Incomplete: Add cast.
		end

		local member        = TypeInfoEnumMember()
		member.name         = decl.name.name
		enumInfo.members[i] = member
	end

	table.insert(state.allTypeInfos, enumInfo)

	enum.representedType = enumInfo
	enum.inferredType    = getTypeInfoForBuiltinType(state, "type")

	moveToPipe(state, enum, !(PIPE_DONE)) -- @Temp until enum bodies are decoupled from the "header" (right?).
	-- moveToNextPipe(state, enum, !(PIPE_BYTECODE))
end

!NODE_INFERRER `function nodeInferrers.AstFileScope(state, fileScope)`
	for _, statement in ipairs(fileScope) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`fileScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	-- @Incomplete: fileScope.imports[]

	moveToPipe(state, fileScope, !(PIPE_DONE))
	-- moveToNextPipe(state, fileScope, !(PIPE_BYTECODE))
end

!NODE_INFERRER `function nodeInferrers.AstGlobalScope(state, globalScope)`
	for _, statement in ipairs(globalScope) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`globalScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	-- @Incomplete: globalScope.imports[] (if we're going to allow global imports)

	moveToPipe(state, globalScope, !(PIPE_DONE))
	-- moveToNextPipe(state, globalScope, !(PIPE_BYTECODE))
end

!NODE_INFERRER `function nodeInferrers.AstBlock(state, block)`
	for _, statement in ipairs(block) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`block`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	moveToPipe(state, block, !(PIPE_DONE))
end

function _G.inferNode(state, node)
	local nodeInferrer = nodeInferrers[node.nodeType] or errorUnhandledNodeType(node)
	return nodeInferrer(state, node)
end



-- expressionIsConstant, literalValue = getLiteralValueFromExpressionIfConstant( compilationState, expression )
-- Note: It's assumed that the expression tree has all types figured out.
function _G.getLiteralValueFromExpressionIfConstant(state, expr)
	-- @Incomplete: Return an AstNode?

	if expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		return true, literal.value

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration or errorInternal()

		if not decl.isConstant then  return false, nil  end

		assert(decl.assignment) -- Constant declarations must have a value.

		local valueExpr = getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex)
		return getLiteralValueFromExpressionIfConstant(state, valueExpr)

	elseif isAny(expr.nodeType, !(nodeTypes.AstType),!(nodeTypes.AstTypeOf)) then
		return true, nil -- All types are constant, just like literals.

	elseif isAny(expr.nodeType, !(nodeTypes.AstLambda),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum)) then
		return true, nil -- Lambdas (which are function signatures), structs and enums are types (which are constant, just like literals).

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast       = expr
		local isConst, v = getLiteralValueFromExpressionIfConstant(state, cast.expression)
		if not isConst then  return false, nil  end

		if cast.inferredType == getTypeInfoForBuiltinType(state, "int") then
			return true, math.floor(v)
		elseif cast.inferredType == getTypeInfoForBuiltinType(state, "float") then
			return true, v
		elseif cast.inferredType == getTypeInfoForBuiltinType(state, "type") then
			return true, nil -- Should we return the type ID?
		else
			errorInternal("Unhandled cast type: %s", getFriendlyTypeInfoName(cast.inferredType))
		end

	elseif isAny(expr.nodeType, !(nodeTypes.AstBinary),!(nodeTypes.AstBinary)) then
		return false, nil -- We don't check child nodes as those should have been folded into 'expr' where this function is called.

	elseif expr.nodeType == !(nodeTypes.AstCall) then
		return false, nil -- Calls are always a runtime operation.

	elseif expr.nodeType == !(nodeTypes.AstImport) then
		return true, nil -- Namespaces, just like types, are always constant.

	else
		errorUnhandledNodeType(expr)
	end
end



-- expression, typeInfo = getAssignmentValue( state, identifier, values, i [, expectedTypeInfo=any ] )
function _G.getAssignmentValue(state, ident, values, i, typeInfoExpected)
	local valueExpr = values[i]

	-- Non-call value or value not last in list.
	if valueExpr and not (valueExpr.nodeType == !(nodeTypes.AstCall) and not valueExpr.surroundedByParenthesis) then
		if typeInfoExpected and not isTypeCompatibleWith(valueExpr.inferredType, typeInfoExpected) then
			if valueExpr.inferredType.tag ~= typeInfoExpected.tag then
				typeError(
					state, valueExpr,
					"Type and value type mismatch. ('%s' is %s, value is %s)",
					ident.name,
					getFriendlyTypeInfoName(typeInfoExpected),
					getFriendlyTypeInfoName(valueExpr.inferredType)
				)

			elseif typeInfoExpected.tag == !(typeTags.TypeInfoFunction) then
				typeError(
					state, valueExpr,
					"Function signature is different from the type of '%s'. (Wanted %s, got %s)",
					ident.name,
					getFriendlyTypeInfoName(typeInfoExpected),
					getFriendlyTypeInfoName(valueExpr.inferredType)
				)

			elseif typeInfoExpected.tag == !(typeTags.TypeInfoStruct) then
				typeError(
					state, valueExpr,
					"Type and value type mismatch. Expected a struct initializer for %s.",
					getFriendlyTypeInfoName(typeInfoExpected)
				)

			else
				typeError(state, valueExpr, "Type and value type mismatch.")
			end
		end

		return valueExpr, valueExpr.inferredType
	end

	-- Value list ending in a call (hopefully).
	local call      = valueExpr
	local lastIndex = #values

	if not call then
		-- We're past the end of the list - get the last specified value.
		call = values[lastIndex]

		if call.nodeType ~= !(nodeTypes.AstCall) then
			typeError(state, call, "Expected a potential function call as the last expression in the list. Missing a value for '%s' (name #%d).", ident.name, i)
		elseif call.surroundedByParenthesis then
			typeError(state, ident, "Missing a value for '%s' (name #%d).", ident.name, i)
		end
	end

	local argIndex = i-lastIndex+1

	local typeInfoForCall = call.inferredType
	local listSig

	if typeInfoForCall.tag == !(typeTags.TypeInfoList) then
		listSig = typeInfoForCall
	elseif typeInfoForCall.tag == !(typeTags.TypeInfoVoid) then
		typeError(state, call, "Called function does not return anything.") -- Only function calls can be void at the moment. 2019-12-04
	else
		typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfoForCall))
	end

	local typeInfoForOutArg = listSig[argIndex]
	if not typeInfoForOutArg then
		typeError(state, call, "Function does not return anything for '%s' (return value #%d).", ident.name, argIndex)
	end

	if typeInfoExpected and typeInfoForOutArg ~= typeInfoExpected then
		local calleeName = (call.callee.nodeType == !(nodeTypes.AstIdentifier) and call.callee.name or "?")
		typeError(
			state, call,
			"The type of return value #%d of '%s' (%s) does not match the type of '%s' (%s).",
			argIndex,
			calleeName,
			getFriendlyTypeInfoName(typeInfoForOutArg),
			ident.name,
			getFriendlyTypeInfoName(typeInfoExpected)
		)
	end

	return call, typeInfoForOutArg
end



local function createLambdaArgumentsFromTypes(state, typeInfos, lambda)
	local args = astNewNode(AstArguments, lambda.token, lambda)

	for i, argTypeInfo in ipairs(typeInfos) do
		local arg           = astNewNode(AstArgument,    lambda.token, args)
		local decl          = astNewNode(AstDeclaration, lambda.token, arg)
		local ident         = astNewNode(AstIdentifier,  lambda.token, decl)

		ident.name          = "_"..i
		ident.placeDeclared = lambda
		ident.declaration   = declaration
		ident.inferredType  = argTypeInfo

		decl.name           = ident

		arg.declaration     = decl
		arg.group           = i

		-- @Incomplete: Handle default values for input arguments. (Needed?)

		args[i] = arg
	end

	return args
end

local function createLambdaFromSignature(state, funcSig, parent)
	local lambda = astNewNode(AstLambda, parent.token, parent)

	if funcSig.argumentTypesIn[1] then
		lambda.argumentsIn = createLambdaArgumentsFromTypes(state, funcSig.argumentTypesIn, lambda)
	end
	if funcSig.argumentTypesOut[1] then
		lambda.argumentsOut = createLambdaArgumentsFromTypes(state, funcSig.argumentTypesOut, lambda)
	end

	return lambda
end

function _G.simplifyTypeExpression(state, expr, typeInfoRepresented)
	local typeInfo            = expr.inferredType
	local typeNode            = astNewNode(AstType, expr.token, expr.parent)
	local isBuiltin, typeName = isTypeBuiltin(typeInfoRepresented)

	typeNode.isUserType      = not isBuiltin
	typeNode.inferredType    = typeInfo
	typeNode.representedType = typeInfoRepresented

	if isBuiltin then
		typeNode.typeName = typeName

	elseif typeInfoRepresented.tag == !(typeTags.TypeInfoFunction) then
		local decl = typeInfo.declaration

		if decl then
			local lambda = getAssignmentValue(state, decl.name, decl.assignment.values, decl.assignmentIndex)
			assert(lambda.nodeType == !(nodeTypes.AstLambda))
			assert(not lambda.body)
			typeNode.functionSignature = astCopy(lambda) -- Do we need to update the location info of the lambda to where typeNode/expr is?
		else
			local funcSig              = typeInfoRepresented
			typeNode.functionSignature = createLambdaFromSignature(state, funcSig, typeNode)
		end

		addUnqueuedChildrenToQueueRecursively(state, typeNode, !(PIPE_BYTECODE))

		astVisitAllNodes(typeNode.functionSignature, function(node)
			if node ~= typeNode and node.nodeType ~= !(nodeTypes.AstDeclaration) then
				moveToPipe(state, node, !(PIPE_DONE))
			end
		end)

	elseif typeInfoRepresented.tag == !(typeTags.TypeInfoStruct) then
		local structInfo  = typeInfoRepresented
		typeNode.typeName = structInfo.name

	elseif typeInfoRepresented.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo    = typeInfoRepresented
		typeNode.typeName = enumInfo.name

	else
		errorInternal("Incomplete: Handle type tag '%s'.", TYPE_TAG_NAMES[typeInfoRepresented.tag])
	end

	replaceQueuedNodeAndUnqueueOldTree(state, expr, typeNode)
end

function _G.simplifyExpressionIfConstant(state, expr)
	local typeInfo = expr.inferredType

	local decl
	if expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		decl = ident.declaration or errorInternal()
	else
		decl = typeInfo.declaration -- Nil for built-in types (and function signatures?).
		if not decl then  return  end
	end
	if not decl.isConstant then  return  end

	local typeInfoRepresented = decl.valueTypeInfo
	if typeInfoRepresented then
		return simplifyTypeExpression(state, expr, typeInfoRepresented)
	end
	!ASSERT `typeInfo ~= getTypeInfoForBuiltinType(state, "type")`

	if not isTypeSimple(typeInfo) then  return  end

	-- At this point we should have a literal to copy. Hopefully the expression we copy
	-- has been simplified into a literal if it wasn't a literal to begin with.
	local valueExpr = getAssignmentValue(state, decl.name, decl.assignment.values, decl.assignmentIndex)
	assert(valueExpr.nodeType == !(nodeTypes.AstLiteral))

	local copy = astCopy(valueExpr)
	copy.token = expr.token

	replaceQueuedNodeAndUnqueueOldTree(state, expr, copy)
	moveToPipe(state, copy, !(PIPE_BYTECODE))
end



-- Values of simple types are non-objects (e.g. ints) in the outputted Lua code.
-- Note: Glóa types are represented as ints in Lua.
function _G.isTypeSimple(typeInfo)
	return isAny(typeInfo.tag, !(typeTags.TypeInfoBool),!(typeTags.TypeInfoInt),!(typeTags.TypeInfoNil),!(typeTags.TypeInfoFloat),!(typeTags.TypeInfoString),!(typeTags.TypeInfoType))
end



function _G.isTypeCompatibleWith(typeToCheck, otherType)
	if typeToCheck == otherType then  return true  end

	-- Everything is compatible with the *any* type. The user better know what they're doing!
	if otherType.tag == !(typeTags.TypeInfoAny) then  return true  end

	-- Ints are always compatible with floats (but the opposite is false).
	-- This should be safe as all numbers are 64-bit floats in Lua 5.1 (I think).
	-- @Robustness: Keep this rule?
	if typeToCheck.tag == !(typeTags.TypeInfoInt) and otherType.tag == !(typeTags.TypeInfoFloat) then  return true  end

	if otherType.tag == !(typeTags.TypeInfoCompound) then
		local compound = otherType
		for _, compoundItem in ipairs(compound) do
			if isTypeCompatibleWith(typeToCheck, compoundItem) then  return true  end
		end
	end

	-- @Incomplete: Handle typeToCheck being a compound type.

	return false
end


