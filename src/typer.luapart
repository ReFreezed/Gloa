--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	typeError, typeMessage, errorUnhandledNodeType
	inferType*
	getTypeInfo*

--============================================================]]

!(
local function WAITING_OR_ERROR(errCode)
	__LUA("if state.mustInfer then ")
		__LUA("state.errorStep = state.errorStep-1 ")
		__LUA("if state.errorStep <= 0 then ")
			__LUA(errCode," ")
		__LUA("end ")
	__LUA("end ")
	__LUA("state.waiting = state.waiting+1 ")
end
)



_G.!struct"TyperState"{
	fileBuffers  = {},
	tokens       = {},

	progress     = 0,
	waiting      = 0,

	mustInfer    = false,
	errorStep    = 0,

	allTypeInfos = {},
}



!(
_G.typeTags        = {}
local lastTypeTag  = 0
local typeTagNames = {}

local function structTypeInfo(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			lastTypeTag           = lastTypeTag+1
			fields._overrides     = fields._overrides or {}
			fields._overrides.tag = lastTypeTag

			typeTags[name]            = lastTypeTag
			typeTagNames[lastTypeTag] = name:gsub("^TypeInfo", ""):lower()
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_TypeInfo"{
	tag        = 0, -- This is like a "type of type info". The word "type" is used in so many places so we call it "tag" here to make it less confusing...
	id         = 0,
	definition = NIL, -- AstTypeDefinition (This node has the scope.) (Should typeInfos even have this field? Possibly.)
}

local !structTypeInfo"TypeInfoAny:_TypeInfo"{}
local !structTypeInfo"TypeInfoBool:_TypeInfo"{}
local !structTypeInfo"TypeInfoInt:_TypeInfo"{}
local !structTypeInfo"TypeInfoNil:_TypeInfo"{}
local !structTypeInfo"TypeInfoNumber:_TypeInfo"{}
local !structTypeInfo"TypeInfoString:_TypeInfo"{}
local !structTypeInfo"TypeInfoTable:_TypeInfo"{}
local !structTypeInfo"TypeInfoType:_TypeInfo"{}

!!local SIMPLE_TYPE_TAG = {
	-- These small type infos don't have any extra information.
	[typeTags.TypeInfoAny]    = true,
	[typeTags.TypeInfoBool]   = true,
	[typeTags.TypeInfoInt]    = true,
	[typeTags.TypeInfoNil]    = true,
	[typeTags.TypeInfoNumber] = true,
	[typeTags.TypeInfoString] = true,
	[typeTags.TypeInfoTable]  = true,
	[typeTags.TypeInfoType]   = true,
}

local !structTypeInfo"TypeInfoArray:_TypeInfo"{
	itemType = NIL, -- TypeInfo
}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{ -- AKA function signature.
	argumentTypesIn  = {}, -- []TypeInfo
	argumentTypesOut = {}, -- []TypeInfo
	polymorphic      = false,
	inline           = false,
}

local !struct"TypeInfoStructMember"{
	name     = "",
	typeInfo = NIL,
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	name                  = "",  -- Filled in during definition.
	arguments             = {},  -- @Incomplete: Polymorphism.
	members               = {},  -- []TypeInfoStructMember
	polymorphSourceStruct = NIL, -- TypeInfoStruct  @Incomplete: Polymorphism.
}

local !struct"TypeInfoEnumMember"{
	name = "",
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	name    = "",
	members = {}, -- []TypeInfoEnumMember
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	-- [1]=typeInfo1, ...
}

local TYPE_TAG_NAMES = !(typeTagNames)



-- typeInfo = newTypeInfo( TypeInfoCreator [, definition=internal ] )
do
	local lastTypeId = 0

	function _G.newTypeInfo(TypeInfoCreator, defn)
		if not TypeInfoCreator then  errorInternal(2, "No TypeInfoCreator specified.")  end

		lastTypeId = lastTypeId+1

		local typeInfo      = TypeInfoCreator()
		typeInfo.id         = lastTypeId
		typeInfo.definition = defn

		--[[
		if lastTypeId == 22 then
			errorInternal("DEBUG")
		end
		--]]

		return typeInfo
	end
end

do
	local builtinTypeInfos = {}

	local BUILTIN_TYPE_STRUCTS = {
		["*"]      = TypeInfoAny,
		["bool"]   = TypeInfoBool,
		["int"]    = TypeInfoInt,
		["nil"]    = TypeInfoNil,
		["number"] = TypeInfoNumber,
		["string"] = TypeInfoString,
		["table"]  = TypeInfoTable,
		["type"]   = TypeInfoType, -- The result of e.g. typeOf(int) or typeOf(typeOf(myVariable)).
	}

	function _G.getTypeInfoForBuiltinType(state, typeName)
		local typeInfo = builtinTypeInfos[typeName]

		if not typeInfo then
			local TypeInfoCreator      = BUILTIN_TYPE_STRUCTS[typeName] or errorInternal(tostring(typeName))
			typeInfo                   = newTypeInfo(TypeInfoCreator)
			builtinTypeInfos[typeName] = typeInfo
		end

		return typeInfo
	end
end

function _G.getTypeInfoForLambda(state, lambda)
	for _, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if not arg.declaration.inferredTypes[1] then  return nil  end
	end
	for _, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if not arg.declaration.inferredTypes[1] then  return nil  end
	end

	-- Have we encountered an equal signature before?
	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoFunction) then
			if doesLambdaHaveSignature(lambda, typeInfoCached) then
				return typeInfoCached
			end
		end
	end

	local funcSig = newTypeInfo(TypeInfoFunction)

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		funcSig.argumentTypesIn[i] = arg.declaration.inferredTypes[1]
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		funcSig.argumentTypesOut[i] = arg.declaration.inferredTypes[1]
	end

	table.insert(state.allTypeInfos, funcSig)
	return funcSig
end

-- typeInfo, definition = getTypeInfoFromTypeNode( state, typeNode )
-- Can return nil. The definition is always nil for built-in types and things without names.
-- Note: We're not inferring the type here! We're returning the type that the type node represets (i.e. the *value* of the type node).
function _G.getTypeInfoFromTypeNode(state, typeNode)
	-- print(">>>>>>>>>") astPrint(typeNode) print("<<<<<<<<<")

	if not typeNode.isUserType then
		return getTypeInfoForBuiltinType(state, typeNode.typeName), nil

	elseif typeNode.functionSignature then
		local lambda  = typeNode.functionSignature
		local funcSig = getTypeInfoForLambda(state, lambda)
		return funcSig, nil

	elseif typeNode.arrayType then
		errorInternal("@Incomplete: Array types.")

	else
		assert(typeNode.typeName ~= "")

		local defn = findDefinition(state, typeNode, typeNode.typeName)
		if not defn then  return nil, nil  end

		local typeInfo = defn.typeInfo
		assert(typeInfo)

		-- @Incomplete: Proper error messages here:

		if SIMPLE_TYPE_TAG[typeInfo.tag] then
			assert(not typeNode.arguments) -- This should have been caught during parsing, e.g. int(a,b).

		elseif typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			if structInfo.arguments[1] then
				error("@Incomplete")
			else
				if typeNode.arguments then
					typeError(state, typeNode.arguments[1], "Parameters for structs are not supported yet.")
				end
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			assert(not typeNode.arguments)

		elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
			assert(not typeNode.arguments) -- This should not be possible I think. The node should have been parsed as an AstCall - not an AstType without functionSignature... right? I may be wrong.

		else
			errorInternal("Incomplete: Unhandled type tag '%s'.", TYPE_TAG_NAMES[typeInfo.tag])
		end

		return typeInfo, defn
	end
end



function _G.doesLambdaHaveSignature(lambda, funcSig)
	if #(lambda.argumentsIn  or EMPTY_TABLE) ~= #funcSig.argumentTypesIn  then  return false  end
	if #(lambda.argumentsOut or EMPTY_TABLE) ~= #funcSig.argumentTypesOut then  return false  end

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if arg.declaration.inferredTypes[1] ~= funcSig.argumentTypesIn[i]  then  return false  end
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if arg.declaration.inferredTypes[1] ~= funcSig.argumentTypesOut[i] then  return false  end
	end

	-- @Incomplete: Check arg.isRequired for input args.

	return true
end



function _G.getClosestScope(node)
	return astFindParent(node, !(nodeTypes.AstFileScope),!(nodeTypes.AstBlock),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum),!(nodeTypes.AstFor),!(nodeTypes.AstLambda))
end



function _G.findDefinition(state, startNode, name)
	-- @Incomplete: Check that the defined value is constant everywhere a type is expected.
	local scope = startNode

	while true do
		scope = getClosestScope(scope)
		if not scope then  return nil  end

		assert(scope.definitions, scope.nodeType)

		for _, defn in ipairs(scope.definitions) do
			if defn.name.name == name then  return defn  end
		end
	end
end

-- defineInClosestScope( state, ident, typeInfo [, typeInfoForDeclaration ] )
function _G.defineInClosestScope(state, ident, typeInfo, typeInfoForDecl)
	-- @Incomplete: (Sometimes) add hints in all parent scopes about this definition so we can detect name shadowing.

	local defnExisting = findDefinition(state, ident, ident.name)

	if defnExisting then
		-- @Incomplete: We're not following imperative scope rules for name shadowing (if that's what happening here).
		typeMessage(state, ident,             "Error", "'%s' has already been defined.", ident.name)
		typeMessage(state, defnExisting.name, "Info",  "...it was defined here.")
		exitFailure()
	end

	local scope = getClosestScope(ident)
	if not scope then
		typeError(state, ident, "Could not find what scope '%s' is in.", ident.name)
	end

	local defn    = astNewNode(AstTypeDefinition, ident.token, scope)
	defn.name     = ident
	defn.scope    = scope
	defn.typeInfo = typeInfo
	defn.typeInfoForDeclaration = typeInfoForDecl -- May be nil.

	if typeInfoForDecl and typeInfoForDecl.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfoForDecl
		structInfo.name  = ident.name
	end

	table.insert(scope.definitions, defn)
end

function _G.printDefinitionChain(state, defn, typeName)
	!local MAX_CHAIN_LENGTH = 10

	for i = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(state, defn.name, "Info", "...here is '%s' defined.", typeName)

		local placeDeclared = defn.name.placeDeclared
		if not placeDeclared then  break  end

		defn = nil

		if placeDeclared.nodeType == !(nodeTypes.AstDeclaration) then
			local decl      = placeDeclared
			local i         = indexWith1(decl.names, "name", typeName)
			local valueNode = decl.assignment and decl.assignment.values[i]

			if valueNode and valueNode.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = valueNode
				typeName    = ident.name
				defn        = findDefinition(state, ident, typeName)
			end
		end

		if not defn then  break  end
	end
end



local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = !({
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "nil",
	[LITERAL_NUMBER]  = "number",
	[LITERAL_STRING]  = "string",
})

function _G.inferExpression(state, expr)
	local typeInfo

	if expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr

		if typeNode.functionSignature and not typeNode.functionSignature.inferredType then
			inferExpression(state, typeNode.functionSignature)
			if not typeNode.functionSignature then  return  end
		end

		local typeInfoForTypeNode, defn = getTypeInfoFromTypeNode(state, typeNode)
		if not typeInfoForTypeNode then  return  end

		-- We successfully got information about what type the type node represents,
		-- so we can now say that the type of the expression itself is indeed a real type.
		typeInfo = getTypeInfoForBuiltinType(state, "type")

	elseif expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal  = expr
		local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType]

		if typeName then
			typeInfo = getTypeInfoForBuiltinType(state, typeName)
		else
			errorUnhandledNodeType(expr)
		end

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local defn  = findDefinition(state, ident, ident.name)

		if defn then
			typeInfo = defn.typeInfo
		else
			!WAITING_OR_ERROR `typeError(state, ident, "Undefined identifier '%s'.", ident.name)`
			return
		end

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda          = expr
		local argsAreInferred = true

		-- Infer arguments.
		!for argsVarI, argsVar in ipairs{`lambda.argumentsIn`,`lambda.argumentsOut`} do
			local args = !!(argsVar)

			for i, arg in ipairs(args or EMPTY_TABLE) do
				local decl = arg.declaration

				if not decl.inferredTypes[1] then
					inferDeclaration(state, decl, !(argsVarI == 2))

					local typeInfoForArg = decl.inferredTypes[1]

					if typeInfoForArg then
						-- Arguments in the same group have the same type, so we copy the type from the first argument in the group to the rest. Some speed boost.
						for i = i+1, #args do
							local argOther = args[i]
							if argOther.group == arg.group then
								argOther.declaration.inferredTypes[1] = typeInfoForArg
							else
								break
							end
						end
					else
						argsAreInferred = false
					end
				end
			end
		!end

		if not argsAreInferred then  return  end

		local funcSig = getTypeInfoForLambda(state, lambda) -- Should succeed because everything's inferred.
		assert(funcSig)

		-- @Incomplete: funcSig.polymorphic
		-- @Incomplete: funcSig.inline

		typeInfo = funcSig

	elseif expr.nodeType == !(nodeTypes.AstCall) then
		-- @Incomplete: Check that the callee can take the args we give it.
		local call          = expr
		local allIsInferred = true

		if not call.callee.inferredType then
			inferExpression(state, call.callee)

			if not call.callee.inferredType then
				allIsInferred = false
			elseif call.callee.inferredType.tag ~= !(typeTags.TypeInfoFunction) then -- @Incomplete: Allow parameterized structs.
				typeError(state, call.callee, "This is not a function.")
			end
		end

		for _, argExpr in ipairs(call.arguments) do
			if not argExpr.inferredType then
				inferExpression(state, argExpr)
				allIsInferred = (allIsInferred and argExpr.inferredType ~= nil)
			end
		end

		if not allIsInferred then  return  end

		typeInfo = call.callee.inferredType -- Note: We've already assured we're calling a function.  @Incomplete: Handle parameterized structs.

	elseif expr.nodeType == !(nodeTypes.AstStruct) then
		local struct        = expr
		local allIsInferred = true

		for _, decl in ipairs(struct.declarations) do
			if not decl.inferredTypes[1] then
				inferDeclaration(state, decl)
				-- Note: Struct member declarations only have one name.
				allIsInferred = (allIsInferred and decl.inferredTypes[1] ~= nil)
			end
		end

		if not allIsInferred then  return  end

		local structInfo = newTypeInfo(TypeInfoStruct)

		for i, decl in ipairs(struct.declarations) do
			local member          = TypeInfoStructMember()
			member.name           = decl.names[1].name
			member.typeInfo       = decl.inferredTypes[1]
			structInfo.members[i] = member
		end

		-- @Incomplete: Fill in structInfo.name (if needed?).
		-- @Incomplete: Struct arguments.

		table.insert(state.allTypeInfos, structInfo)
		typeInfo = structInfo

	else
		errorUnhandledNodeType(expr)
	end

	assert(typeInfo)
	expr.inferredType = typeInfo
end

-- typeInfo, typeInfoForDeclaration = inferDeclarationAssignmentValue( state, assignment, identifier, assignmentTargetIndex [, expectedTypeInfo=any ] )
local function inferDeclarationAssignmentValue(state, assignment, ident, i, typeInfoExpected)
	local expr      = assignment.values[i]
	local lastIndex = #assignment.values

	-- Value list ending in a call (hopefully).
	-- @Incomplete: Check that !must args from functions have an assignment target.
	if not expr or expr.nodeType == !(nodeTypes.AstCall) then
		local call = expr

		if not call then
			-- We're past the end of the list - get the last specified value.
			call = assignment.values[lastIndex]

			if call.nodeType ~= !(nodeTypes.AstCall) then
				typeError(state, call, "Expected a function call. Missing a value for '%s'.", ident.name)
			elseif call.surroundedByParenthesis then
				typeError(state, ident, "Missing a value for '%s'.", ident.name)
			end
		end

		local argIndex = i-lastIndex+1

		if not call.inferredType then
			inferExpression(state, call)

			if not call.inferredType then  return nil, nil  end

			-- :OncePerValue
		end

		-- @Speed: Only do the following once per name. (Moving this to :OncePerValue doesn't
		-- work if argIndex > 1 because call.inferredType is already set at that point.)
		local typeInfoForCall = call.inferredType
		assert(typeInfoForCall.tag == !(typeTags.TypeInfoFunction))

		local typeInfoForOutArg = typeInfoForCall.argumentTypesOut[argIndex]
		if not typeInfoForOutArg then
			typeError(state, call, "Call does not return anything for '%s' (output argument #%d).", ident.name, argIndex)
		end

		if typeInfoExpected and typeInfoForOutArg ~= typeInfoExpected then
			-- @UX: Mention the declaration type in the message (maybe with getFriendlyTypeInfoName()).
			local calleeName = (call.callee.nodeType == !(nodeTypes.AstIdentifier) and call.callee.name or "?")
			typeError(
				state, assignment.values[math.min(i, lastIndex)],
				"Type of return value #%d of '%s' does not match specified type in declaration.",
				argIndex, calleeName
			)
		end

		return typeInfoForOutArg, nil

	-- Non-call value or value not last in list.
	else
		if not expr.inferredType then
			inferExpression(state, expr)

			if typeInfoExpected and expr.inferredType ~= typeInfoExpected then
				-- @Incomplete: Define isTypeCompatibleWith(typeToCheck, otherType) or something, if necessary.
				if expr.inferredType.tag ~= typeInfoExpected.tag then
					typeError(
						state, assignment.values[math.min(i, lastIndex)],
						!if DEBUG then
							"Value and type mismatch in declaration. (Type is %s [%d], value is %s [%d])",
							getFriendlyTypeInfoName(typeInfoExpected),
							typeInfoExpected.id,
							expr.inferredType and getFriendlyTypeInfoName(expr.inferredType) or "?",
							expr.inferredType and expr.inferredType.id or 0
						!else
							"Value and type mismatch in declaration. (Type is %s, value is %s)",
							getFriendlyTypeInfoName(typeInfoExpected),
							expr.inferredType and getFriendlyTypeInfoName(expr.inferredType) or "?"
						!end
					)

				elseif typeInfoExpected.tag == !(typeTags.TypeInfoFunction) then
					-- @Incomplete: Print the type signature.
					typeError(state, assignment.values[math.min(i, lastIndex)], "Function signature is different from the type in declaration.")

				elseif typeInfoExpected.tag == !(typeTags.TypeInfoStruct) then
					typeError(
						state, assignment.values[math.min(i, lastIndex)],
						"Value and type mismatch in declaration. Expected a struct initializer.",
						-- "Value and type mismatch in declaration. Expected a struct initializer for '%s'.", -- @Incomplete: Fill in TypeInfoStruct.name somewhere.
						typeInfoExpected.name
					)

				else
					typeError(state, assignment.values[math.min(i, lastIndex)], "Value and type mismatch in declaration.")
				end
			end

			if not expr.inferredType then  return nil, nil  end
		end

		local typeInfo        = expr.inferredType
		local typeInfoForDecl = nil

		if expr.nodeType == !(nodeTypes.AstType) then
			local typeNode = expr

			-- @Cleanup: I feel like all these cases can be handled the same, but I'm not sure...

			if not typeNode.isUserType then
				typeInfoForDecl = getTypeInfoFromTypeNode(state, typeNode)
				-- typeInfoForDecl = getTypeInfoForBuiltinType(state, typeNode.typeName) -- This is the same as the above line but more direct, right? @Cleanup

			elseif typeNode.functionSignature then
				typeInfoForDecl = getTypeInfoFromTypeNode(state, typeNode)
				assert(typeInfoForDecl)

			else
				-- Do we ever get here? @Revise
				local defn
				typeInfoForDecl, defn = getTypeInfoFromTypeNode(state, typeNode)
				assert(defn)

				typeInfoForDecl = defn.typeInfoForDeclaration
				assert(typeInfoForDecl)
			end

		elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
			local ident = expr
			local defn  = findDefinition(state, ident, ident.name)
			assert(defn)

			typeInfoForDecl = defn.typeInfoForDeclaration -- Can be nil.

		elseif expr.nodeType == !(nodeTypes.AstCall) then
			local call = expr
			-- Should we do the same as for AstIdentifier here above? I think so. @Incomplete

		elseif expr.nodeType == !(nodeTypes.AstStruct) or expr.nodeType == !(nodeTypes.AstEnum) then
			typeInfoForDecl = typeInfo
			typeInfo        = getTypeInfoForBuiltinType(state, "type")

		-- else
		-- 	print(AST_NODE_TYPE_NAMES[expr.nodeType])
		end

		return typeInfo, typeInfoForDecl
	end
end

-- inferDeclaration( state, declaration [, isOutArg=false ] )
function _G.inferDeclaration(state, decl, isOutArg)
	-- Infer names and declare them.
	for i, ident in ipairs(decl.names) do
		local typeInfo = decl.inferredTypes[i]

		if not typeInfo then
			local valueTypeInfo = nil

			-- Specified compound type.
			-- local x:int|string
			if decl.types[2] then
				errorInternal("@Incomplete: Compound types.")

			-- Single specified type.
			-- local x:int
			elseif decl.types[1] then
				local typeNodeOrTypeOf = decl.types[1]

				-- local x:int
				if typeNodeOrTypeOf.nodeType == !(nodeTypes.AstType) then
					local typeNode = typeNodeOrTypeOf
					local typeName = typeNode.typeName

					if not typeNode.inferredType then
						inferExpression(state, typeNode) -- The inferred type of the type node should be TypeInfoType, or else we messed up.
						if typeNode.inferredType then
							assert(typeNode.inferredType.tag == !(typeTags.TypeInfoType))
						end
					end

					if typeNode.inferredType then
						local defn
						typeInfo, defn = getTypeInfoFromTypeNode(state, typeNode--[[, true]])
						assert(typeInfo)

						if defn then
							typeInfo = defn.typeInfoForDeclaration

							if not typeInfo then
								typeMessage(state, typeNode, "Error", "'%s' is not a type. (It is '%s')", typeName, getFriendlyTypeInfoName(defn.typeInfo))
								printDefinitionChain(state, defn, typeName)
								exitFailure()
							end

						else
							-- Do we need something to happen here?
						end

					else
						!WAITING_OR_ERROR `typeError(state, typeNode, "Undefined type '%s'.", typeName)`
					end

				-- local x:typeOf(y)
				elseif typeNodeOrTypeOf.nodeType == !(nodeTypes.AstTypeOf) then
					local typeOf = typeNodeOrTypeOf
					local expr   = typeOf.expression

					if not typeOf.inferredType then
						inferExpression(state, expr)
						typeOf.inferredType = expr.inferredType
					end

					typeInfo = typeOf.inferredType

				else
					errorUnhandledNodeType(typeNodeOrTypeOf)
				end

			-- No type specified - infer from initial values. (Also infers the values.)
			else
				assert(decl.assignment) -- This should have been caught during parsing.
				typeInfo, valueTypeInfo = inferDeclarationAssignmentValue(state, decl.assignment, ident, i, nil)
			end

			if typeInfo then
				state.progress        = state.progress+1
				decl.inferredTypes[i] = typeInfo

				if not isOutArg then
					defineInClosestScope(state, ident, typeInfo, valueTypeInfo)
				end
			end

			-- [[ DEBUG
			!if DEBUG then
				if typeInfo then
					printf("DECLARE %s:%s%s%s%s",
						ident.name,
						getFriendlyTypeInfoName(typeInfo),
						ident.placeDeclared and " IN "..AST_NODE_TYPE_NAMES[ident.placeDeclared.nodeType] or "",
						isOutArg            and " (isOutArg)"                                             or "",
						valueTypeInfo       and " (value:"..getFriendlyTypeInfoName(valueTypeInfo)..")"   or ""
					)
				else
					printf("(failed declaring %s)", ident.name)
				end
			!end
			--]]
		end--if not typeInfo

		-- Infer values (if types are specified). This will make sure types and value types are matching.
		if typeInfo and decl.types[1] and decl.assignment --[[and decl.assignment.values[1] ]]then
			typeInfo = (typeInfo.definition and typeInfo.definition.typeInfoForDeclaration or typeInfo) -- Necessary, or even correct?
			inferDeclarationAssignmentValue(state, decl.assignment, ident, i, typeInfo)
		end--if specified value and type
	end--for decl.names
end

function _G.inferFileScope(state, fileScope)
	for _, decl in ipairs(fileScope.declarations) do
		inferDeclaration(state, decl)
	end
end



-- typeError( typerState, node, formatString, ... )
function _G.typeError(state, node, s, ...)
	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	errorInFile(buffer, path, tokens.position1[token], "Typer", s, ...)
end

-- typeMessage( typerState, node, label, formatString, ... )
function _G.typeMessage(state, node, label, s, ...)
	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	reportMessageInFile(buffer, path, tokens.position1[token], label, "Typer", s, ...)
end

function _G.errorUnhandledNodeType(node)
	!if DEBUG then
		astPrint(node)
	!end
	errorInternal(2, "Incomplete: Unhandled node type '%s'.", (AST_NODE_TYPE_NAMES[node.nodeType] or node.nodeType))
end



function _G.getFriendlyTypeInfoName(typeInfo)
	if typeInfo.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		if structInfo.name ~= "" then  return structInfo.name  end

	elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
		-- @Incomplete: Return function signature.
	end

	return TYPE_TAG_NAMES[typeInfo.tag]
end


