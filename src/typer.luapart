--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	getClosestScope, isScope
	getTypeInfo*
	inferType*
	typeError, typeMessage

	v2_*

--============================================================]]

!(
local function WAITING_OR_ERROR(errCode)
	__LUA("if state.mustInfer then ")
		__LUA("state.errorStep = state.errorStep-1 ")
		__LUA("if state.errorStep <= 0 then ")
			__LUA(errCode," ")
		__LUA("end ")
	__LUA("end ")
	__LUA("state.waiting = state.waiting+1")
end

local function WAITING_SILENT()
	__LUA("state.waitingSilent = state.waitingSilent+1")
end
)



_G.!struct"TyperState"{ -- @Cleanup: Rename to PipesState?
	fileBuffers   = {},
	tokens        = {},

	progress      = 0,
	waiting       = 0,
	waitingSilent = 0,

	mustInfer     = false,
	errorStep     = 0,

	allTypeInfos  = {},

	-- v2:
	queue         = {},
	dependencies  = {},
}



!(
_G.typeTags        = {}
local lastTypeTag  = 0
local typeTagNames = {}

local function structTypeInfo(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			lastTypeTag           = lastTypeTag+1
			fields._overrides     = fields._overrides or {}
			fields._overrides.tag = lastTypeTag

			typeTags[name]            = lastTypeTag
			typeTagNames[lastTypeTag] = name:gsub("^TypeInfo", ""):lower()
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_TypeInfo"{
	tag        = 0, -- This is like a "type of type info". The word "type" is used in so many places so we call it "tag" here to make it less confusing...
	id         = 0,
	definition = NIL, -- AstTypeDefinition (This node has the scope.) (Should typeInfos even have this field? Possibly.)
}

local !structTypeInfo"TypeInfoAny:_TypeInfo"{}
local !structTypeInfo"TypeInfoBool:_TypeInfo"{}
local !structTypeInfo"TypeInfoInt:_TypeInfo"{}
local !structTypeInfo"TypeInfoNil:_TypeInfo"{}
local !structTypeInfo"TypeInfoNumber:_TypeInfo"{}
local !structTypeInfo"TypeInfoString:_TypeInfo"{}
local !structTypeInfo"TypeInfoTable:_TypeInfo"{}
local !structTypeInfo"TypeInfoType:_TypeInfo"{}
local !structTypeInfo"TypeInfoVoid:_TypeInfo"{}

!!local SIMPLE_TYPE_TAG = {
	-- These small type infos don't have any extra information.
	[typeTags.TypeInfoAny]    = true,
	[typeTags.TypeInfoBool]   = true,
	[typeTags.TypeInfoInt]    = true,
	[typeTags.TypeInfoNil]    = true,
	[typeTags.TypeInfoNumber] = true,
	[typeTags.TypeInfoString] = true,
	[typeTags.TypeInfoTable]  = true,
	[typeTags.TypeInfoType]   = true,
}

local !structTypeInfo"TypeInfoArray:_TypeInfo"{
	itemType = NIL, -- TypeInfo
}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{ -- AKA function signature.
	argumentTypesIn  = {}, -- []TypeInfo  @Cleanup: Use TypeInfoList here.
	argumentTypesOut = {}, -- []TypeInfo  @Cleanup: Use TypeInfoList here.
	polymorphic      = false,
	inline           = false,
}

local !struct"TypeInfoStructMember"{
	name     = "",
	typeInfo = NIL,
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	name                  = "",  -- Filled in during definition.
	arguments             = {},  -- []TypeInfo  @Incomplete: Polymorphism.  @Cleanup: Use TypeInfoList here.
	members               = {},  -- []TypeInfoStructMember
	polymorphSourceStruct = NIL, -- TypeInfoStruct  @Incomplete: Polymorphism.
}

local !struct"TypeInfoEnumMember"{
	name = "",
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	name     = "",
	typeInfo = NIL, -- Must be one of these primitive types: int, string, type, bool or number.
	members  = {},  -- []TypeInfoEnumMember
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	-- [1]=typeInfo1, ...
}

local !structTypeInfo"TypeInfoList:_TypeInfo"{ -- Special type used for returns from calls (both when sending and receiving).
	-- [1]=typeInfo1, ...
}

_G.TYPE_TAG_NAMES = !(typeTagNames)



-- typeInfo = newTypeInfo( TypeInfoCreator [, definition=internal ] )
do
	local lastTypeId = 0

	function _G.newTypeInfo(TypeInfoCreator, defn)
		if not TypeInfoCreator then  errorInternal(2, "No TypeInfoCreator specified.")  end

		lastTypeId = lastTypeId+1

		local typeInfo      = TypeInfoCreator()
		typeInfo.id         = lastTypeId
		typeInfo.definition = defn

		--[[
		if lastTypeId == 22 then
			errorInternal("DEBUG")
		end
		--]]

		return typeInfo
	end
end

do
	local builtinTypeInfos = {}

	local BUILTIN_TYPE_STRUCTS = {
		["*"]      = TypeInfoAny,
		["bool"]   = TypeInfoBool,
		["int"]    = TypeInfoInt,
		["nil"]    = TypeInfoNil,
		["number"] = TypeInfoNumber,
		["string"] = TypeInfoString,
		["table"]  = TypeInfoTable,
		["type"]   = TypeInfoType, -- The result of e.g. typeOf(int) or typeOf(typeOf(myVariable)).
		["void"]   = TypeInfoVoid, -- Only used for calls that return nothing.
	}

	function _G.getTypeInfoForBuiltinType(typeName)
		local typeInfo = builtinTypeInfos[typeName]

		if not typeInfo then
			local TypeInfoCreator      = BUILTIN_TYPE_STRUCTS[typeName] or errorInternal(tostring(typeName))
			typeInfo                   = newTypeInfo(TypeInfoCreator)
			builtinTypeInfos[typeName] = typeInfo
		end

		return typeInfo
	end
end

function _G.getTypeInfoForLambda(state, lambda)
	for _, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if not arg.declaration.inferredTypes[1] then  return nil  end
	end
	for _, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if not arg.declaration.inferredTypes[1] then  return nil  end
	end

	-- Have we encountered an equal signature before?
	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoFunction) and doesLambdaHaveSignature(lambda, typeInfoCached) then
			return typeInfoCached
		end
	end

	local funcSig = newTypeInfo(TypeInfoFunction)

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		funcSig.argumentTypesIn[i] = arg.declaration.inferredTypes[1]
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		funcSig.argumentTypesOut[i] = arg.declaration.inferredTypes[1]
	end

	table.insert(state.allTypeInfos, funcSig)
	return funcSig
end

function _G.doesTypeListHaveSignature(typeList, listSig)
	if #typeList ~= #listSig then  return false   end

	for i = 1, #typeList do
		if typeList[i] ~= listSig[i] then  return false  end
	end

	return true
end

function _G.getTypeInfoForList(state, typeList)
	-- Have we encountered an equal signature before?
	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoList) and doesTypeListHaveSignature(typeList, typeInfoCached) then
			return typeInfoCached
		end
	end

	local listSig = newTypeInfo(TypeInfoList)
	copyToArray(typeList, listSig)
	table.insert(state.allTypeInfos, listSig)

	return listSig
end

-- typeInfo, definition = getTypeInfoFromTypeNode( state, typeNode )
-- Can return nil. The definition is always nil for built-in types and things without names.
-- Note: We're not inferring the type here! We're returning the type that the type node represets (i.e. the *value* of the type node).
function _G.getTypeInfoFromTypeNode(state, typeNode)
	-- print(">>>>>>>>>") astPrintTree(typeNode) print("<<<<<<<<<")

	if not typeNode.isUserType then
		return getTypeInfoForBuiltinType(typeNode.typeName), nil

	elseif typeNode.functionSignature then
		local lambda  = typeNode.functionSignature
		local funcSig = getTypeInfoForLambda(state, lambda)
		return funcSig, nil

	elseif typeNode.arrayItemType then
		errorInternal("@Incomplete: Array types.")

	else
		assert(typeNode.typeName ~= "")

		local defn = findDefinition(state, typeNode, typeNode.typeName)
		if not defn then  return nil, nil  end

		local typeInfo = defn.typeInfo
		assert(typeInfo)

		-- @Incomplete: Proper error messages here:

		if SIMPLE_TYPE_TAG[typeInfo.tag] then
			assert(not typeNode.arguments) -- This should have been caught during parsing, e.g. int(a,b).

		elseif typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			if structInfo.arguments[1] then
				errorInternal("@Incomplete: Struct arguments.")
			else
				if typeNode.arguments then
					typeError(state, typeNode.arguments[1], "Parameters for structs are not supported yet.")
				end
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			assert(not typeNode.arguments)

		elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
			assert(not typeNode.arguments) -- This should not be possible I think. The node should have been parsed as an AstCall - not an AstType without functionSignature... right? I may be wrong.

		else
			errorInternal("Incomplete: Unhandled type tag '%s'.", TYPE_TAG_NAMES[typeInfo.tag])
		end

		return typeInfo, defn
	end
end



function _G.doesLambdaHaveSignature(lambda, funcSig)
	if #(lambda.argumentsIn  or EMPTY_TABLE) ~= #funcSig.argumentTypesIn  then  return false  end
	if #(lambda.argumentsOut or EMPTY_TABLE) ~= #funcSig.argumentTypesOut then  return false  end

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if arg.declaration.inferredTypes[1] ~= funcSig.argumentTypesIn[i]  then  return false  end
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if arg.declaration.inferredTypes[1] ~= funcSig.argumentTypesOut[i] then  return false  end
	end

	-- @Incomplete: Check arg.isRequired for input args.

	return true
end



-- scope, childClosestToScope = getClosestScope( node )
function _G.getClosestScope(node)
	return astFindParent(node, !(nodeTypes.AstFileScope),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum),!(nodeTypes.AstBlock),!(nodeTypes.AstFor),!(nodeTypes.AstLambda))
end

function _G.isScope(node)
	return isAny(node.nodeType, !(nodeTypes.AstFileScope),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum),!(nodeTypes.AstBlock),!(nodeTypes.AstFor),!(nodeTypes.AstLambda))
end
function _G.isScopeDeclarative(scope)
	return isAny(scope.nodeType, !(nodeTypes.AstFileScope),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum))
end
function _G.isScopeImperative(scope)
	return isAny(scope.nodeType, !(nodeTypes.AstBlock),!(nodeTypes.AstFor),!(nodeTypes.AstLambda))
end



function _G.findDefinition(state, startNode, name)
	-- @Incomplete: Check that the defined value is constant everywhere a type is expected.
	local scope = startNode

	while true do
		scope = getClosestScope(scope)
		if not scope then  return nil  end

		assert(scope.definitions, scope.nodeType)

		for _, defn in ipairs(scope.definitions) do
			if defn.name.name == name and isDefinitionVisibleToNode(defn, startNode) then
				return defn
			end
		end
	end
end

function _G.isDefinitionVisibleToNode(defn, node)
	local nodeScope, nodeScopeChild = getClosestScope(node)
	local canSeeImperativeVariables = not defn.isConst

	while true do
		if isScopeDeclarative(nodeScope) then
			if indexOf(nodeScope.definitions, defn) then  return true  end

		elseif isAny(nodeScope.nodeType, !(nodeTypes.AstFor),!(nodeTypes.AstLambda)) then
			if canSeeImperativeVariables and indexOf(nodeScope.definitions, defn) then  return true  end

		elseif nodeScope.nodeType == !(nodeTypes.AstBlock) then
			local block           = nodeScope
			local imperativeIndex = indexOf(block, nodeScopeChild) or errorInternal()

			for i, statement in ipairs(block) do
				if statement.what.nodeType == !(nodeTypes.AstDeclaration) then
					local decl = statement.what
					if decl.isConstant or (canSeeImperativeVariables and i < imperativeIndex) then
						if astHasParent(defn.name, decl) then  return true  end
					end
				end
			end

		else
			errorUnhandledNodeType(nodeScope)
		end

		if nodeScope.nodeType == !(nodeTypes.AstLambda) then
			-- Lambdas act as the only boundary between imperative and declarative
			-- scopes right now. Maybe this will change in the future? 2019-12-07
			canSeeImperativeVariables = false
		end

		nodeScope, nodeScopeChild = getClosestScope(nodeScope)
		if not nodeScope then  return false  end
	end
end

-- defineInClosestScope( state, ident, isConstant, typeInfo [, typeInfoForDeclaration ] )
function _G.defineInClosestScope(state, ident, isConst, typeInfo, typeInfoForDecl)
	-- @Incomplete: (Sometimes) add hints in all parent scopes about this definition so we (quickly?) can detect name shadowing.

	assert(typeInfo.tag ~= !(typeTags.TypeInfoList))
	if typeInfoForDecl then
		assert(typeInfoForDecl.tag ~= !(typeTags.TypeInfoList))
	end

	local defnExisting = findDefinition(state, ident, ident.name)

	if defnExisting then
		-- @Incomplete: We're not following imperative scope rules for name shadowing (if that's what happening here).
		printerr()
		typeMessage(io.stderr, state, ident,             "Error", "'%s' has already been defined.", ident.name)
		typeMessage(io.stderr, state, defnExisting.name, "Info",  "...it was defined here.")
		exitFailure()
	end

	local scope = getClosestScope(ident)
	if not scope then
		typeError(state, ident, "Could not find what scope '%s' is in.", ident.name)
	end

	local defn      = astNewNode(AstTypeDefinition, ident.token, scope)
	defn.name       = ident
	defn.scope      = scope
	defn.isConstant = isConst
	defn.typeInfo   = typeInfo
	defn.typeInfoForDeclaration = typeInfoForDecl -- May be nil.

	if not typeInfoForDecl then
		-- void

	elseif typeInfoForDecl.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfoForDecl
		structInfo.name  = ident.name

	elseif typeInfoForDecl.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo = typeInfoForDecl
		enumInfo.name  = ident.name
	end

	table.insert(scope.definitions, defn)
end

function _G.printDefinitionChain(file, state, defn, typeName)
	if type(file) ~= "userdata" then  return printDefinitionChain(io.stdout, file, state, defn)  end

	!local MAX_CHAIN_LENGTH = 10

	for i = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(file, state, defn.name, "Info", "...here is '%s' defined.", typeName)

		local placeDeclared = defn.name.placeDeclared
		if not placeDeclared then  break  end

		defn = nil

		if placeDeclared.nodeType == !(nodeTypes.AstDeclaration) then
			local decl      = placeDeclared
			local i         = indexWith1(decl.names, "name", typeName)
			local valueNode = decl.assignment and decl.assignment.values[i]

			if valueNode and valueNode.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = valueNode
				typeName    = ident.name
				defn        = findDefinition(state, ident, typeName)
			end
		end

		if not defn then  break  end
	end
end



local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = !({
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "nil",
	[LITERAL_NUMBER]  = "number",
	[LITERAL_STRING]  = "string",
})

function _G.inferExpressionThatHasNotBeenInferredYet(state, expr)
	assert(not expr.inferredType)

	local typeInfo

	if expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr

		if typeNode.functionSignature and not typeNode.functionSignature.inferredType then
			inferExpressionThatHasNotBeenInferredYet(state, typeNode.functionSignature)
			if not typeNode.functionSignature then  return  end
		end

		local typeInfoForTypeNode, defn = getTypeInfoFromTypeNode(state, typeNode)
		if not typeInfoForTypeNode then  return  end

		-- We successfully got information about what type the type node represents,
		-- so we can now say that the type of the expression itself is indeed a real type.
		typeInfo = getTypeInfoForBuiltinType"type"

	elseif expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal  = expr
		local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType]

		if typeName then
			typeInfo = getTypeInfoForBuiltinType(typeName)
		else
			errorUnhandledNodeType(literal)
		end

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local defn  = findDefinition(state, ident, ident.name)

		if defn then
			typeInfo = defn.typeInfo
		else
			-- @Incomplete: Report about captures/upvalues, which is not supported (yet?).
			!WAITING_OR_ERROR `typeError(state, ident, "Undefined identifier '%s'.", ident.name)`
			return
		end

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda          = expr
		local argsAreInferred = true

		-- Infer arguments.
		!for argsVarI, argsVar in ipairs{`lambda.argumentsIn`,`lambda.argumentsOut`} do
			local args = !!(argsVar)

			for i, arg in ipairs(args or EMPTY_TABLE) do
				local decl = arg.declaration

				if not decl.inferredTypes[1] then
					inferDeclaration(state, decl, !(argsVarI == 2))

					local typeInfoForArg = decl.inferredTypes[1]

					if typeInfoForArg then
						-- Arguments in the same group have the same type, so we copy the type from the first argument in the group to the rest. Some speed boost.
						for i = i+1, #args do
							local argOther = args[i]
							if argOther.group == arg.group then
								argOther.declaration.inferredTypes[1] = typeInfoForArg
							else
								break
							end
						end
					else
						argsAreInferred = false
					end
				end
			end
		!end

		if not argsAreInferred then  return  end

		local funcSig = getTypeInfoForLambda(state, lambda) -- Should succeed because everything's inferred.
		assert(funcSig)

		-- @Incomplete: funcSig.polymorphic
		-- @Incomplete: funcSig.inline

		typeInfo = funcSig

	elseif expr.nodeType == !(nodeTypes.AstCall) then
		local call           = expr
		local allIsInferred  = true
		local calleeTypeInfo = call.callee.inferredType

		if not calleeTypeInfo then
			inferExpressionThatHasNotBeenInferredYet(state, call.callee)
			calleeTypeInfo = call.callee.inferredType

			if not calleeTypeInfo then
				allIsInferred = false

			elseif calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
				local listSig   = calleeTypeInfo
				local typeInfo1 = listSig[1]
				if not typeInfo1 then
					typeError(state, call, "Trying to call void.")
				elseif typeInfo1.tag == !(typeTags.TypeInfoFunction) then
					-- void
				else
					typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfo1))
				end

			elseif calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then
				-- void

			else
				-- @Incomplete: Allow parameterized structs.
				typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
			end
		end

		for _, argExpr in ipairs(call.arguments) do
			if not argExpr.inferredType then
				inferExpressionThatHasNotBeenInferredYet(state, argExpr)
				allIsInferred = (allIsInferred and argExpr.inferredType ~= nil)
			end
		end

		if not allIsInferred then  return  end

		local effectiveCalleeTypeInfo

		if calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
			local listSig           = calleeTypeInfo
			effectiveCalleeTypeInfo = listSig[1]
		else
			effectiveCalleeTypeInfo = calleeTypeInfo
		end
		assert(effectiveCalleeTypeInfo.tag == !(typeTags.TypeInfoFunction)) -- @Incomplete: Handle parameterized structs.

		-- @Incomplete: Check for optional arguments.
		if #call.arguments < #effectiveCalleeTypeInfo.argumentTypesIn then
			typeError(state, call, "Missing arguments.")
		elseif #call.arguments > #effectiveCalleeTypeInfo.argumentTypesIn then
			typeError(state, call.arguments[#effectiveCalleeTypeInfo.argumentTypesIn+1], "Too many arguments.")
		end

		for i, argExpr in ipairs(call.arguments) do
			local typeInfoWanted = effectiveCalleeTypeInfo.argumentTypesIn[i]
			if argExpr.inferredType ~= typeInfoWanted then
				-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
				-- @UX: Tell the name of the argument. (Probably only possible for constants, and maybe not all. Not sure!)
				typeError(
					state, argExpr,
					"Wrong type for argument #%d. (Wanted %s, got %s)",
					i,
					getFriendlyTypeInfoName(typeInfoWanted),
					getFriendlyTypeInfoName(argExpr.inferredType)
				)
			end
		end

		typeInfo = getTypeInfoForList(state, effectiveCalleeTypeInfo.argumentTypesOut)

	elseif expr.nodeType == !(nodeTypes.AstStruct) then
		local struct        = expr
		local allIsInferred = true

		for _, decl in ipairs(struct.declarations) do
			if not decl.inferredTypes[1] then
				inferDeclaration(state, decl)
				-- Note: Struct member declarations only have one name.
				allIsInferred = (allIsInferred and decl.inferredTypes[1] ~= nil)
			end
		end

		if not allIsInferred then  return  end

		local structInfo = newTypeInfo(TypeInfoStruct)

		for i, decl in ipairs(struct.declarations) do
			local member          = TypeInfoStructMember()
			member.name           = decl.names[1].name
			member.typeInfo       = decl.inferredTypes[1]
			structInfo.members[i] = member
		end

		-- @Incomplete: Struct arguments.

		table.insert(state.allTypeInfos, structInfo)
		typeInfo = structInfo

	elseif expr.nodeType == !(nodeTypes.AstEnum) then
		local enum          = expr
		local allIsInferred = true

		for _, decl in ipairs(enum.declarations) do
			if not decl.inferredTypes[1] then
				inferDeclaration(state, decl)
				-- Note: Enum member declarations only have one name.
				allIsInferred = (allIsInferred and decl.inferredTypes[1] ~= nil)
			end
		end

		if not allIsInferred then  return  end

		assert(enum.declarations[1], "Enums must have members.") -- This should have been caught during parsing.

		local enumInfo = newTypeInfo(TypeInfoEnum)

		local enumMemberInfo
		if enum.memberType then
			enumMemberInfo = getTypeInfoForBuiltinType(enum.memberType.typeName)
		else
			enumMemberInfo = enum.declarations[1].inferredTypes[1]
			if not isAny(enumMemberInfo,
				getTypeInfoForBuiltinType"int",
				getTypeInfoForBuiltinType"string",
				getTypeInfoForBuiltinType"type",
				getTypeInfoForBuiltinType"bool",
				getTypeInfoForBuiltinType"number"
			) then
				typeError(state, enum, "Supported enum member types are: int, string, type, bool, number")
			end
		end

		for i, decl in ipairs(enum.declarations) do
			local valExpr = decl.assignment.values[1]

			if valExpr.inferredType ~= enumMemberInfo then
				-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
				typeError(state, valExpr,
					"Incorrect value type for '%s'. (Wanted %s, got %s)",
					decl.names[1].name,
					getFriendlyTypeInfoName(enumMemberInfo),
					getFriendlyTypeInfoName(valExpr.inferredType)
				)
			end

			local member        = TypeInfoEnumMember()
			member.name         = decl.names[1].name
			enumInfo.members[i] = member
		end

		table.insert(state.allTypeInfos, enumInfo)
		typeInfo = enumInfo

	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		local unary = expr

		if not unary.expression.inferredType then
			inferExpressionThatHasNotBeenInferredYet(state, unary.expression)
			if not unary.expression.inferredType then  return  end
		end

		if isAny(unary.operation, "+","-") then
			if not isAny(unary.expression.inferredType,
				getTypeInfoForBuiltinType"int",
				getTypeInfoForBuiltinType"number"
			) then
				typeError(state, unary.expression,
					"Unary operation: Expected a number or int. (Got %s)",
					getFriendlyTypeInfoName(unary.expression.inferredType)
				)
			end

		elseif unary.operation == "#" then
			errorInternal("@Incomplete: Length operator.")

		elseif unary.operation == "not" then
			if unary.expression.inferredType ~= getTypeInfoForBuiltinType"bool" then
				typeError(state, unary.expression,
					"Unary operation: Expected a bool. (Got %s)",
					getFriendlyTypeInfoName(unary.expression.inferredType)
				)
			end

		else
			errorUnhandledNodeType(unary)
		end

		typeInfo = unary.expression.inferredType

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr

		if not binary.left .inferredType then  inferExpressionThatHasNotBeenInferredYet(state, binary.left )  end
		if not binary.right.inferredType then  inferExpressionThatHasNotBeenInferredYet(state, binary.right)  end

		if not (binary.left.inferredType and binary.right.inferredType) then  return  end

		-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
		-- For now, both sides need to be the same exact type.
		if binary.left.inferredType ~= binary.right.inferredType then
			typeError(state, binary,
				"Binary operation: Operands are different types. (Left is %s, right is %s)",
				getFriendlyTypeInfoName(binary.left.inferredType),
				getFriendlyTypeInfoName(binary.right.inferredType)
			)
		end

		-- Numeric operation.
		if isAny(binary.operation, "+","-","*","/","//","^","%") then
			if not isAny(binary.left.inferredType,
				getTypeInfoForBuiltinType"int",
				getTypeInfoForBuiltinType"number"
			) then
				typeError(state, binary.left,
					"Binary operation: Expected a number or int. (Got %s)",
					getFriendlyTypeInfoName(binary.left.inferredType)
				)
			end

			if isAny(binary.operation, "/") then -- Result in number.
				typeInfo = getTypeInfoForBuiltinType"number"
			elseif isAny(binary.operation, "//") then -- Result in int.
				typeInfo = getTypeInfoForBuiltinType"int"
			else -- Keep type.
				typeInfo = binary.left.inferredType
			end

		-- Comparison.
		elseif isAny(binary.operation, "<",">","<=",">=") then
			if not isAny(binary.left.inferredType,
				getTypeInfoForBuiltinType"int",
				getTypeInfoForBuiltinType"number",
				getTypeInfoForBuiltinType"string"
			) then
				typeError(state, binary.left,
					"Binary operation: Expected a number, int or string. (Got %s)",
					getFriendlyTypeInfoName(binary.left.inferredType)
				)
			end

			typeInfo = getTypeInfoForBuiltinType"bool"

		-- Equality.
		elseif isAny(binary.operation, "==","~=") then
			typeInfo = getTypeInfoForBuiltinType"bool"

		-- Boolean operation.
		elseif isAny(binary.operation, "and","or") then
			if binary.left.inferredType ~= getTypeInfoForBuiltinType"bool" then
				typeError(state, binary.left, "Binary operation: Expected a bool. (Got %s)", getFriendlyTypeInfoName(binary.left.inferredType))
			end
			typeInfo = getTypeInfoForBuiltinType"bool"

		-- String concatination.
		elseif isAny(binary.operation, "..") then
			if binary.left.inferredType ~= getTypeInfoForBuiltinType"string" then
				typeError(state, binary.left, "Binary operation: Expected a string. (Got %s)", getFriendlyTypeInfoName(binary.left.inferredType))
			end
			typeInfo = getTypeInfoForBuiltinType"string"

		-- Lookup, or similar.
		elseif isAny(binary.operation, ".") then
			errorInternal("@Incomplete: Handle '.' operator.")

		else
			errorUnhandledNodeType(binary)
		end

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr

		if not cast.targetType.inferredType then  inferExpressionThatHasNotBeenInferredYet(state, cast.targetType)  end
		if not cast.expression.inferredType then  inferExpressionThatHasNotBeenInferredYet(state, cast.expression)  end

		if not (cast.targetType.inferredType and cast.expression.inferredType) then  return  end

		local castTypeInfo = getTypeInfoFromTypeNode(state, cast.targetType)
		assert(castTypeInfo)

		if isAny(castTypeInfo, getTypeInfoForBuiltinType"number",getTypeInfoForBuiltinType"int") then
			if not isAny(cast.expression.inferredType, getTypeInfoForBuiltinType"number",getTypeInfoForBuiltinType"int") then
				typeError(
					state, cast.expression,
					"Cannot cast from %s to %s.",
					getFriendlyTypeInfoName(cast.expression.inferredType),
					getFriendlyTypeInfoName(castTypeInfo)
				)
			end
		else
			errorUnhandledNodeType(cast)
		end

		typeInfo = castTypeInfo

	else
		errorUnhandledNodeType(expr)
	end

	assert(typeInfo)
	expr.inferredType = typeInfo
end

-- typeInfo, typeInfoForDeclaration = inferAssignmentValue( state, assignment, identifier, assignmentTargetIndex, expectedTypeInfo=any, isDeclaration, isConstantDeclaration )
local function inferAssignmentValue(state, assignment, ident, i, typeInfoExpected, isDecl, isConstDecl)
	if not isDecl then  assert(not isConstDecl)  end

	-- @Robustness: If isConstDecl, make sure we're not grabbing a variable from an outer imperative scope.
	local scope              = getClosestScope(assignment)
	local scopeIsDeclarative = isScopeDeclarative(scope)

	local expr      = assignment.values[i]
	local lastIndex = #assignment.values

	-- Value list ending in a call (hopefully).
	-- @Incomplete: Check that !must args from functions have an assignment target.
	if (not expr) or (expr.nodeType == !(nodeTypes.AstCall) and not expr.surroundedByParenthesis) then
		local call = expr

		if isConstDecl or scopeIsDeclarative then
			typeError(state, call, "%s: Value expression #%d is not constant.", (isDecl and "Declaration" or "Assignment"), i)
		end

		if not call then
			-- We're past the end of the list - get the last specified value.
			call = assignment.values[lastIndex]

			if call.nodeType ~= !(nodeTypes.AstCall) then
				typeError(state, call, "Expected a function call. Missing a value for '%s'.", ident.name)
			elseif call.surroundedByParenthesis then
				typeError(state, ident, "Missing a value for '%s'.", ident.name)
			end
		end

		local argIndex = i-lastIndex+1

		if not call.inferredType then
			inferExpressionThatHasNotBeenInferredYet(state, call)
			if not call.inferredType then  return nil, nil  end

			-- :OncePerValue
		end

		-- @Speed: Only do the following once per name. (Moving this to :OncePerValue doesn't
		-- work if argIndex > 1 because call.inferredType is already set at that point.)

		local typeInfoForCall = call.inferredType
		local listSig

		if typeInfoForCall.tag == !(typeTags.TypeInfoList) then
			listSig = typeInfoForCall
		elseif typeInfoForCall.tag == !(typeTags.TypeInfoVoid) then
			typeError(state, call, "Called function does not return anything.") -- Only function calls can be void at the moment. 2019-12-04
		else
			typeError(state, call, "Trying to call %s object.", getFriendlyTypeInfoName(typeInfoForCall))
		end

		local typeInfoForOutArg = listSig[argIndex]
		if not typeInfoForOutArg then
			typeError(state, call, "Function does not return anything for '%s' (output argument #%d).", ident.name, argIndex)
		end

		if typeInfoExpected and typeInfoForOutArg ~= typeInfoExpected then
			local calleeName = (call.callee.nodeType == !(nodeTypes.AstIdentifier) and call.callee.name or "?")
			typeError(
				state, assignment.values[math.min(i, lastIndex)],
				"%s: The type of return value #%d of '%s' (%s) does not match the type of '%s' (%s).",
				(isDecl and "Declaration" or "Assignment"),
				argIndex,
				calleeName,
				getFriendlyTypeInfoName(typeInfoForOutArg),
				ident.name,
				getFriendlyTypeInfoName(typeInfoExpected)
			)
		end

		return typeInfoForOutArg, nil

	-- Non-call value or value not last in list.
	else
		if not expr.inferredType then
			inferExpressionThatHasNotBeenInferredYet(state, expr)
			if not expr.inferredType then  return nil, nil  end

			-- @Speed: Don't do this every round.
			astVisitAllNodes(expr, function(node)
				if isScope(node) then
					return !(VISIT_IGNORE_CHILDREN)

				elseif (isConstDecl or scopeIsDeclarative) and node.nodeType == !(nodeTypes.AstCall) then -- (I think this will match parameterized structs. @Incomplete: Polymorphism.)
					local call = node
					typeError(state, call, "%s: Expression is not constant.", (isDecl and "Declaration" or "Assignment"))

				elseif isConstDecl and node.nodeType == !(nodeTypes.AstIdentifier) then
					local ident = node
					local defn  = findDefinition(state, ident, ident.name)
					assert(defn)

					if not defn.isConstant then
						typeError(state, ident, "%s: '%s' is not constant.", (isDecl and "Declaration" or "Assignment"), ident.name)
					end
				end
			end)

			if typeInfoExpected and expr.inferredType ~= typeInfoExpected then
				-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
				local valExpr = assignment.values[math.min(i, lastIndex)]

				if expr.inferredType.tag ~= typeInfoExpected.tag then
					typeError(
						state, valExpr,
						"%s: Value and type mismatch. (%s is %s, value is %s)",
						(isDecl and "Declaration" or "Assignment"),
						(isDecl and "Type" or "'"..ident.name.."'"),
						getFriendlyTypeInfoName(typeInfoExpected),
						getFriendlyTypeInfoName(expr.inferredType)
					)

				elseif typeInfoExpected.tag == !(typeTags.TypeInfoFunction) then
					typeError(
						state, valExpr,
						"%s: Function signature is different from the type. (Wanted %s, got %s)",
						(isDecl and "Declaration" or "Assignment"),
						getFriendlyTypeInfoName(typeInfoExpected),
						getFriendlyTypeInfoName(expr.inferredType)
					)

				elseif typeInfoExpected.tag == !(typeTags.TypeInfoStruct) then
					typeError(
						state, valExpr,
						"%s: Value and type mismatch. Expected a struct initializer for %s.",
						(isDecl and "Declaration" or "Assignment"),
						getFriendlyTypeInfoName(typeInfoExpected)
					)

				else
					typeError(state, valExpr, "%s: Value and type mismatch.", (isDecl and "Declaration" or "Assignment"))
				end
			end
		end

		local typeInfo        = expr.inferredType
		local typeInfoForDecl = nil

		if isDecl then
			if expr.nodeType == !(nodeTypes.AstType) then
				local typeNode = expr

				-- @Cleanup: I feel like all these cases can be handled the same, but I'm not sure...

				if not typeNode.isUserType then
					typeInfoForDecl = getTypeInfoFromTypeNode(state, typeNode)
					-- typeInfoForDecl = getTypeInfoForBuiltinType(typeNode.typeName) -- This is the same as the above line but more direct, right? @Cleanup

				elseif typeNode.functionSignature then
					typeInfoForDecl = getTypeInfoFromTypeNode(state, typeNode)
					assert(typeInfoForDecl)

				else
					-- Do we ever get here? @Revise
					local defn
					typeInfoForDecl, defn = getTypeInfoFromTypeNode(state, typeNode)
					assert(defn)

					typeInfoForDecl = defn.typeInfoForDeclaration
					assert(typeInfoForDecl)
				end

			elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = expr
				local defn  = findDefinition(state, ident, ident.name)
				assert(defn)

				typeInfoForDecl = defn.typeInfoForDeclaration -- Can be nil.

			elseif expr.nodeType == !(nodeTypes.AstCall) then
				local call = expr
				-- Should we do the same as for AstIdentifier here above? I think so. pre-2019-12-07 @Incomplete

			elseif expr.nodeType == !(nodeTypes.AstStruct) then
				typeInfoForDecl = typeInfo
				typeInfo        = getTypeInfoForBuiltinType"type"
			elseif expr.nodeType == !(nodeTypes.AstEnum) then
				typeInfoForDecl = typeInfo
				typeInfo        = getTypeInfoForBuiltinType"type"

			-- else
			-- 	print(AST_NODE_TYPE_NAMES[expr.nodeType])
			end
		end

		return typeInfo, typeInfoForDecl
	end
end

-- inferDeclaration( state, declaration [, isOutArg=false ] )
function _G.inferDeclaration(state, decl, isOutArg)
	-- Infer names and declare them.
	for i, ident in ipairs(decl.names) do
		local typeInfo = decl.inferredTypes[i]

		if not typeInfo then
			local valueTypeInfo = nil

			-- Specified compound type.
			-- local x:int|string
			if decl.types[2] then
				errorInternal("@Incomplete: Compound types.")

			-- Single specified type.
			-- local x:int
			elseif decl.types[1] then
				local typeNodeOrTypeOf = decl.types[1]

				-- local x:int
				if typeNodeOrTypeOf.nodeType == !(nodeTypes.AstType) then
					local typeNode = typeNodeOrTypeOf
					local typeName = typeNode.typeName

					if not typeNode.inferredType then
						inferExpressionThatHasNotBeenInferredYet(state, typeNode) -- The inferred type of the type node should be TypeInfoType, or else we messed up.
						if typeNode.inferredType then
							assert(typeNode.inferredType.tag == !(typeTags.TypeInfoType))
						end
					end

					if typeNode.inferredType then
						local defn
						typeInfo, defn = getTypeInfoFromTypeNode(state, typeNode)
						assert(typeInfo)

						if defn then
							if not defn.isConstant then -- I don't think this ever matches. 2019-12-07 @Cleanup
								printerr()
								typeMessage(io.stderr, state, typeNode, "Error", "'%s' is not a constant. Types must be constant.", typeName)
								typeMessage(io.stderr, state, defn.name, "Info", "...here is '%s' defined.", typeName)
								exitFailure()
							end

							typeInfo = defn.typeInfoForDeclaration

							if not typeInfo then
								printerr()
								typeMessage(io.stderr, state, typeNode, "Error", "'%s' is not a type. (It is %s)", typeName, getFriendlyTypeInfoName(defn.typeInfo))
								printDefinitionChain(io.stderr, state, defn, typeName)
								exitFailure()
							end

						else
							-- Do we need something to happen here?
						end

					else
						!WAITING_OR_ERROR `typeError(state, typeNode, "Undefined type '%s'.", typeName)`
					end

				-- local x:typeOf(y)
				elseif typeNodeOrTypeOf.nodeType == !(nodeTypes.AstTypeOf) then
					local typeOf = typeNodeOrTypeOf
					local expr   = typeOf.expression

					if not typeOf.inferredType then
						inferExpressionThatHasNotBeenInferredYet(state, expr)
						typeOf.inferredType = expr.inferredType
					end

					typeInfo = typeOf.inferredType

				else
					errorUnhandledNodeType(typeNodeOrTypeOf)
				end

			-- No type specified - infer from initial values. (Also infers the values.)
			else
				assert(decl.assignment) -- This should have been caught during parsing.
				typeInfo, valueTypeInfo = inferAssignmentValue(state, decl.assignment, ident, i, nil, true, decl.isConstant)
			end

			if typeInfo then
				state.progress        = state.progress+1
				decl.inferredTypes[i] = typeInfo

				if not isOutArg then
					defineInClosestScope(state, ident, decl.isConstant, typeInfo, valueTypeInfo)
				end
			else
				!WAITING_SILENT()
			end

			-- [[ DEBUG
			!if DEBUG then
				if not debug_onlyInferTypes then
					-- void
				elseif typeInfo then
					printf("DECLARE %s:%s%s%s%s",
						ident.name,
						getFriendlyTypeInfoName(typeInfo),
						ident.placeDeclared and " IN "..AST_NODE_TYPE_NAMES[ident.placeDeclared.nodeType] or "",
						isOutArg            and " (isOutArg)"                                             or "",
						decl.isConstant     and " (CONST)"                                                or "",
						valueTypeInfo       and " (VALUE "..getFriendlyTypeInfoName(valueTypeInfo)..")"   or ""
					)
				else
					printf("(failed declaring %s)", ident.name)
				end
			!end
			--]]
		end--if not typeInfo

		-- Infer values (if types are specified). This will make sure types and value types are matching.
		if typeInfo and decl.types[1] and decl.assignment --[[and decl.assignment.values[1] ]]then
			typeInfo = (typeInfo.definition and typeInfo.definition.typeInfoForDeclaration or typeInfo) -- Necessary, or even correct?
			inferAssignmentValue(state, decl.assignment, ident, i, typeInfo, true, decl.isConstant)
		end--if specified value and type
	end--for decl.names
end

function _G.inferStatement(state, statement)
	local node = statement.what

	if node.nodeType == !(nodeTypes.AstDeclaration) then
		local decl = node
		inferDeclaration(state, decl)

	elseif node.nodeType == !(nodeTypes.AstAssignment) then
		local assignment = node

		for i, ident in ipairs(assignment.targets) do
			if not ident.inferredType then
				inferExpressionThatHasNotBeenInferredYet(state, ident)
				if ident.inferredType then
					state.progress = state.progress+1 -- Needed here?
				else
					!WAITING_SILENT()
				end
			end

			if ident.inferredType then
				-- @Speed: Don't do this every round.
				inferAssignmentValue(state, assignment, ident, i, ident.inferredType, false, false)
			end
		end

	elseif node.nodeType == !(nodeTypes.AstCall) then
		local call = node
		if not call.inferredType then
			inferExpressionThatHasNotBeenInferredYet(state, call)
			if call.inferredType then
				state.progress = state.progress+1 -- Needed here?
			else
				!WAITING_SILENT()
			end
		end

	elseif node.nodeType == !(nodeTypes.AstReturn) then
		local returnNode    = node
		local allIsInferred = true

		for _, expr in ipairs(returnNode.values) do
			if not expr.inferredType then
				inferExpressionThatHasNotBeenInferredYet(state, expr)
				if expr.inferredType then
					state.progress = state.progress+1 -- Needed here?
				else
					allIsInferred = false
					!WAITING_SILENT()
				end
			end
		end

		if not allIsInferred then  return  end

		local lambda = astFindParent(returnNode, !(nodeTypes.AstLambda))
		assert(lambda) -- This should have been caught during parsing.

		if not lambda.inferredType then
			!WAITING_SILENT()
			return
		end

		local argTypesOut      = lambda.inferredType.argumentTypesOut
		local lastValueExpr    = getLast(returnNode.values)
		local returnValueCount = #returnNode.values

		local lastValueIsListToUnpack
			=   lastValueExpr ~= nil
			and lastValueExpr.nodeType == !(nodeTypes.AstCall)
			and not lastValueExpr.surroundedByParenthesis
			and lastValueExpr.inferredType.tag == !(typeTags.TypeInfoList)

		if lastValueIsListToUnpack then
			local listSig    = lastValueExpr.inferredType
			returnValueCount = returnValueCount - 1 + #listSig
		end

		if returnValueCount == #argTypesOut then
			-- void

		-- Too few values.
		elseif returnValueCount < #argTypesOut then
			-- @UX: Show a better message if lastValueExpr is a function call (not wrapped in parenthesis).
			typeError(state, returnNode, "Too few values to return. (Expected %d, got %d)", #argTypesOut, returnValueCount)

		-- Too many values.
		elseif not lastValueIsListToUnpack then
			typeError(state, returnNode.values[#argTypesOut+1], "Too many values to return. (Expected %d, got %d)", #argTypesOut, returnValueCount)
		else
			local callOutArgCount = #returnNode.values-1
			local listSig         = lastValueExpr.inferredType
			typeError(state, lastValueExpr, "Too many values returned from call. (Expected %d, got %d)", #argTypesOut-callOutArgCount, #listSig)
		end

		if lastValueIsListToUnpack then
			local listSig = lastValueExpr.inferredType

			for i = #returnNode.values, returnValueCount do
				local callOutArgIndex = i-#returnNode.values+1
				local typeInfo        = listSig[callOutArgIndex]

				if typeInfo ~= argTypesOut[i] then
					-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
					typeError(state, lastValueExpr,
						"Returned value #%d from call is of incorrect type. (Wanted %s, got %s)",
						callOutArgIndex,
						getFriendlyTypeInfoName(argTypesOut[i]),
						getFriendlyTypeInfoName(typeInfo)
					)
				end
			end
		end

		for i = 1, #returnNode.values - (lastValueIsListToUnpack and 1 or 0) do
			local expr     = returnNode.values[i]
			local typeInfo = expr.inferredType

			if typeInfo.tag == !(typeTags.TypeInfoList) then
				local listSig = typeInfo
				typeInfo      = listSig[1]

				if not typeInfo then
					-- Note: TypeInfoLists are only used when calling functions (at the moment, at least). 2019-12-06
					typeError(state, expr, "Function call returns nothing. (Expected at least one value.)")
				end
			end

			if typeInfo ~= argTypesOut[i] then
				-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
				typeError(state, expr,
					"Returned value #%d is of incorrect type. (Wanted %s, got %s)",
					i,
					getFriendlyTypeInfoName(argTypesOut[i]),
					getFriendlyTypeInfoName(typeInfo)
				)
			end
		end

	else
		errorUnhandledNodeType(node)
	end
end

function _G.inferBlock(state, block)
	for _, statement in ipairs(block) do
		inferStatement(state, statement)
	end
end

function _G.inferFileScope(state, fileScope)
	for _, decl in ipairs(fileScope.declarations) do
		inferDeclaration(state, decl)
	end

	-- @Speed: Visiting all nodes constantly surely isn't necessary...
	-- @Incomplete: Beware of blocks inside polymorphic functions (when we got those implemented)?
	astVisitAllNodes(fileScope, function(node)
		if node.nodeType == !(nodeTypes.AstBlock) then
			local block = node
			inferBlock(state, block)
			-- return !(VISIT_IGNORE_CHILDREN) -- Good? No, we need to visit deeper blocks too! @Speed
		end
	end)
end



-- typeError( typerState, node, formatString, ... )
function _G.typeError(state, node, s, ...)
	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	errorInFile(buffer, path, tokens.position1[token], "Typer", s, ...)
end

-- typeMessage( [ outputFile=io.stdout, ] typerState, node, label, formatString, ... )
function _G.typeMessage(file, state, node, label, s, ...)
	if type(file) ~= "userdata" then  return typeMessage(io.stdout, file, state, node, label, s, ...)  end

	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	reportMessageInFile(file, buffer, path, tokens.position1[token], label, "Typer", s, ...)
end



function _G.getFriendlyTypeInfoName(typeInfo)
	local name = ""

	if typeInfo.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		name             = structInfo.name -- @Incomplete: Include parameters for parameterized structs.

	elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo = typeInfo
		name           = enumInfo.name

	elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
		local funcSig      = typeInfo
		local typeTextsIn  = {}
		local typeTextsOut = {}

		for i, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			typeTextsIn[i] = getFriendlyTypeInfoName(argTypeInfo)
		end
		for i, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			typeTextsOut[i] = getFriendlyTypeInfoName(argTypeInfo)
		end

		name = typeTextsOut[1]
			and F("function(%s)->(%s)", table.concat(typeTextsIn, ","), table.concat(typeTextsOut, ","))
			or  F("function(%s)->void", table.concat(typeTextsIn, ","))
	end

	if name == "" then
		name = TYPE_TAG_NAMES[typeInfo.tag]
	end

	-- !(if DEBUG then)  name = name.."@"..typeInfo.id  !(end)

	return name
end



local !struct"Dependency"{ -- @Cleanup: Rename to something with "wait"?
	dependent  = NIL,
	dependType = 0,   -- DEPEND_DEFINITION|DEPEND_NODE_INFERRED
	dependOn   = NIL, -- The value depends on what dependType is.
}

function _G.v2_addDependency(state, dependent, dependType, dependOn)
	assert(not dependent.queued.waitingOn)
	assert(not itemWith3(state.dependencies, "dependent",dependent, "dependType",dependType, "dependOn",dependOn))

	!if DEBUG then
		if dependType == !(DEPEND_DEFINITION) then
			assert(type(dependOn) == "string")
		elseif dependType == !(DEPEND_NODE_INFERRED) then
			assert(type(dependOn) == "table")
		else
			error(dependType)
		end
	!end

	if dependType == !(DEPEND_NODE_INFERRED) then
		assert(dependent ~= dependOn)
	end

	local dependency      = Dependency()
	dependency.dependent  = dependent
	dependency.dependType = dependType
	dependency.dependOn   = dependOn
	table.insert(state.dependencies, dependency)

	dependent.queued.waitingOn = dependency

	!if DEBUG then
		--[[
		if debug_onlyInferTypes then
			io.stdout:write("DEPEND ")
			astPrint(dependent)

			io.stdout:write("    ON ", DEPEND_TITLES[dependType], " ")
			if dependType == !(DEPEND_DEFINITION) then
				print(dependOn)
			elseif dependType == !(DEPEND_NODE_INFERRED) then
				astPrint(dependOn)
			else
				print("? ("..tostring(dependOn)..")")
			end
		end
		--]]
	!end
end



local !struct"Queued"{
	node      = NIL, -- AstNode
	container = NIL,
	key       = NIL,
	pipe      = 0,
	waitingOn = NIL, -- Dependency
}

function _G.v2_addToQueue(state, node, container, key, pipe)
	local queued     = Queued()
	queued.node      = node
	queued.container = container
	queued.key       = key
	queued.pipe      = pipe

	node.queued = queued
	table.insert(state.queue, queued)

	if node.nodeType == !(nodeTypes.AstIdentifier) and node.declaration and node.parent.nodeType == !(nodeTypes.AstAssignment) then
		local ident       = node
		local assignment  = node.parent
		local decl        = node.declaration
		local i           = indexOf(assignment.targets, ident) or errorInternal()
		local identSource = decl.names[i]
		v2_addDependency(state, ident, !(DEPEND_NODE_INFERRED), identSource)
	end
end

function _G.v2_addToQueueRecursively(state, topNode)
	astVisitAllNodesLeavesFirst(topNode, function(node, container, key)
		-- astPrint(node)
		v2_addToQueue(state, node, container, key, !(PIPE_INFER))
	end)
end

function _G.v2_replaceNode(nodeOld, nodeNew)
	local queued   = nodeOld.queued
	queued.node    = nodeNew
	nodeOld.queued = nil
	nodeNew.queued = queued

	if queued.container then
		queued.container[queued.key] = nodeNew
	end
end


function _G.v2_moveToNextPipe(state, node)
	local queued = node.queued
	queued.pipe  = queued.pipe+1
end



!(
local function DEPEND_AND_RETURN(dependentCode, dependType, dependOnCode)
	__LUA("v2_addDependency(state, ",dependentCode,", ",toLua(dependType),", ",dependOnCode,") ; return")
end

local function NODE_INFERRER(funcHeaderCode)
	local replacements

	funcHeaderCode, replacements = funcHeaderCode:gsub("function +nodeInferrers%.(Ast%w+)", function(nodeName)
		local nodeType = nodeTypes[nodeName] or error(nodeName)
		return "nodeInferrers[--[["..nodeName.."]]"..nodeType.."] = function"
	end)

	assert(replacements == 1, funcHeaderCode)

	__LUA(funcHeaderCode)
end
)

local nodeInferrers = {}

!NODE_INFERRER `function nodeInferrers.AstTypeDefinition(state, defn)`
	if not defn.typeInfo then
		!DEPEND_AND_RETURN(`defn`, DEPEND_NODE_INFERRED, `defn.name`)
	end

	-- @Refactor: Maybe move some logic from AstIdentifier to here?

	v2_moveToNextPipe(state, defn)
end

!NODE_INFERRER `function nodeInferrers.AstIdentifier(state, ident)`
	local decl = ident.declaration

	-- Loose identifier.
	if not decl then
		assert(not ident.placeDeclared)

		local defn = findDefinition(state, ident, ident.name)
		if not defn then
			!DEPEND_AND_RETURN(`ident`, DEPEND_DEFINITION, `ident.name`)
		end
		ident.definition = defn

		if not defn.typeInfo then
			!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `defn`)
		end
		ident.inferredType = defn.typeInfo

		v2_moveToNextPipe(state, ident)
		return

	-- Assignment target in declaration (which is a copy of the identifier in the declaration).
	elseif ident.parent.nodeType == !(nodeTypes.AstAssignment) then
		local identDecl, i = itemWith1(decl.names, "name", ident.name)
		if not identDecl then  errorInternal()  end

		local defn = identDecl.definition
		if not defn then
			!DEPEND_AND_RETURN(`ident`, DEPEND_DEFINITION, `identDecl`)
		end
		ident.definition = defn

		if not defn.typeInfo then
			!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `defn`)
		end
		ident.inferredType = defn.typeInfo

		v2_moveToNextPipe(state, ident)
		return
	end

	-- At this point we're defining a declared identifier.

	local defn = ident.definition

	if not defn then
		local scope = getClosestScope(decl)
		if not scope then
			typeError(state, ident, "Could not find what scope '%s' is in.", ident.name)
		end

		local isLambdaArgOut = (
			scope.nodeType == !(nodeTypes.AstLambda)
			and scope.argumentsOut ~= nil
			and indexOf(scope.argumentsOut, astFindParent(decl, !(nodeTypes.AstArgument))) ~= nil
		)

		if not isLambdaArgOut then
			local defnExisting = findDefinition(state, ident, ident.name)

			if defnExisting then
				-- @Check: Are we following imperative scope rules for name shadowing?
				printerr()
				typeMessage(io.stderr, state, ident,             "Error", "'%s' has already been defined.", ident.name)
				typeMessage(io.stderr, state, defnExisting.name, "Info",  "...it was defined here.")
				exitFailure()
			end
		end

		defn            = astNewNode(AstTypeDefinition, ident.token, scope)
		defn.name       = ident
		defn.scope      = scope
		defn.isConstant = decl.isConstant

		ident.definition = defn

		if isLambdaArgOut then
			v2_addToQueue(state, defn, nil, nil, !(PIPE_INFER))
		else
			local i              = #scope.definitions+1
			scope.definitions[i] = defn
			v2_addToQueue(state, defn, scope.definitions, i, !(PIPE_INFER))
		end
	end

	for _, typeNode in ipairs(decl.types) do
		if not typeNode.inferredType then
			!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `typeNode`)
		end
	end

	local assignment = decl.assignment

	if assignment then
		for _, valueExpr in ipairs(assignment.values) do
			if not valueExpr.inferredType then
				!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `valueExpr`)
			end
		end
	end

	local typeInfo
	local typeInfoForDecl = nil

	-- Compound type.
	if decl.types[2] then
		errorInternal("@Incomplete: Compound types.")

	-- Single type.
	elseif decl.types[1] then
		local typeExpr = decl.types[1]

		if typeExpr.nodeType == !(nodeTypes.AstType) then
			local typeNode = typeExpr
			typeInfo       = typeNode.representedType

		elseif typeExpr.nodeType == !(nodeTypes.AstTypeOf) then
			local typeOf   = typeExpr
			typeInfo       = typeOf.expression.inferredType

		else
			errorUnhandledNodeType(typeExpr)
		end

	-- Infer type from value.
	else
		local i                        = indexWith1(decl.names, "name", ident.name) or errorInternal()
		local valueExpr, valueTypeInfo = v2_getAssignmentValue(state, ident, assignment.values, i)

		typeInfo = valueTypeInfo

		if typeInfo ~= getTypeInfoForBuiltinType"type" then
			-- void

		elseif valueExpr.nodeType == !(nodeTypes.AstType) then
			local typeNode  = valueExpr
			typeInfoForDecl = typeNode.representedType

		elseif valueExpr.nodeType == !(nodeTypes.AstIdentifier) then
			local identOther = valueExpr
			if not identOther.definition.typeInfo then
				!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `identOther.definition`)
			end
			typeInfoForDecl = identOther.definition.typeInfoForDeclaration

		elseif valueExpr.nodeType == !(nodeTypes.AstTypeOf) then
			local typeOf    = valueExpr
			typeInfoForDecl = typeOf.expression.inferredType

		elseif valueExpr.nodeType == !(nodeTypes.AstStruct) then
			local struct    = valueExpr
			typeInfoForDecl = struct.representedType

		elseif valueExpr.nodeType == !(nodeTypes.AstEnum) then
			local enum      = valueExpr
			typeInfoForDecl = enum.representedType

		else
			errorUnhandledNodeType(valueExpr)
		end
	end

	if assignment and decl.types[1] then
		local i = indexWith1(decl.names, "name", ident.name) or errorInternal()
		v2_getAssignmentValue(state, ident, assignment.values, i, typeInfo)
	end

	assert(typeInfo)

	-- print(typeInfoForDecl and getFriendlyTypeInfoName(typeInfoForDecl))
	if not typeInfoForDecl then
		-- void

	elseif typeInfoForDecl.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfoForDecl
		structInfo.name  = ident.name

	elseif typeInfoForDecl.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo = typeInfoForDecl
		enumInfo.name  = ident.name
	end

	defn.typeInfo               = typeInfo
	defn.typeInfoForDeclaration = typeInfoForDecl -- May be nil.
	ident.inferredType          = typeInfo

	table.insert(defn.scope.definitions, defn)

	!if DEBUG then
		if debug_onlyInferTypes then
			io.stdout:write("DEFINE ", ident.name ,":", getFriendlyTypeInfoName(typeInfo), " ")
			if defn.isConstant then  io.stdout:write("(CONST) ")  end
			if typeInfoForDecl then  io.stdout:write("(VALUE ", getFriendlyTypeInfoName(typeInfoForDecl), ") ")  end
			io.stdout:write("IN ") ; astPrint(defn.scope)
		end
	!end

	v2_moveToNextPipe(state, ident)
end

!NODE_INFERRER `function nodeInferrers.AstType(state, typeNode)`
	local defn = nil
	local typeInfo, typeInfoRepresented

	if not typeNode.isUserType then
		typeInfoRepresented = getTypeInfoForBuiltinType(typeNode.typeName)
		typeInfo            = getTypeInfoForBuiltinType"type"

	elseif typeNode.functionSignature then
		local lambda = typeNode.functionSignature

		if not lambda.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `lambda`)
		end
		assert(lambda.inferredType.tag == !(typeTags.TypeInfoFunction))

		local funcSig       = getTypeInfoForLambda(state, lambda)
		typeInfoRepresented = funcSig
		typeInfo            = getTypeInfoForBuiltinType"type"

	elseif typeNode.arrayItemType then
		local itemTypeInfo = typeNode.arrayItemType

		if not itemTypeInfo.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `itemTypeInfo`)
		end
		assert(itemTypeInfo.inferredType == getTypeInfoForBuiltinType"type")

		typeInfoRepresented = itemTypeInfo
		typeInfo            = getTypeInfoForBuiltinType"type"

	else
		assert(typeNode.typeName ~= "")

		defn = findDefinition(state, typeNode, typeNode.typeName)
		if not defn then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_DEFINITION, `typeNode.typeName`)
		end
		if not defn.typeInfo then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `defn`)
		end

		typeInfoRepresented = defn.typeInfoForDeclaration
		typeInfo            = defn.typeInfo
		assert(typeInfo)

		if typeInfo ~= getTypeInfoForBuiltinType"type" then
			printerr()
			typeMessage(io.stderr, state, typeNode, "Error", "'%s' is not a type. (It is %s)", typeNode.typeName, getFriendlyTypeInfoName(typeInfo))
			printDefinitionChain(io.stderr, state, defn, typeNode.typeName)
			exitFailure()
		end

		for _, expr in ipairs(typeNode.arguments or EMPTY_TABLE) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		-- @Incomplete: Proper error messages here:

		if SIMPLE_TYPE_TAG[typeInfo.tag] then
			assert(not typeNode.arguments) -- This should have been caught during parsing, e.g. int(a,b).

		elseif typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			if structInfo.arguments[1] then
				errorInternal("@Incomplete: Struct arguments.")
			elseif typeNode.arguments then
				typeError(state, typeNode.arguments[1], "Parameters for structs are not supported yet.")
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			assert(not typeNode.arguments)

		elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
			assert(not typeNode.arguments) -- This should not be possible I think. The node should have been parsed as an AstCall - not an AstType without functionSignature... right? I may be wrong.

		else
			errorInternal("Incomplete: Unhandled type tag '%s'.", TYPE_TAG_NAMES[typeInfo.tag])
		end
	end

	assert(typeInfoRepresented)
	assert(typeInfo)

	typeNode.representedType = typeInfoRepresented
	typeNode.inferredType    = typeInfo
	typeNode.declaration     = defn and defn.name.declaration
	typeNode.definition      = defn

	v2_moveToNextPipe(state, typeNode)
end

!NODE_INFERRER `function nodeInferrers.AstCall(state, call)`
	if not call.callee.inferredType then
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `call.callee`)
	end
	for _, arg in ipairs(call.arguments) do
		if not arg.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `arg`)
		end
	end

	local calleeTypeInfo = call.callee.inferredType

	if calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then -- @Incomplete: Parameterized structs.
		-- void

	elseif calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig   = calleeTypeInfo
		local typeInfo1 = listSig[1]

		if not typeInfo1 then
			typeError(state, call, "Trying to call void.")
		elseif typeInfo1.tag == !(typeTags.TypeInfoFunction) then
			-- void
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfo1))
		end

	else
		if call.callee.nodeType == !(nodeTypes.AstIdentifier) then
			local ident = call.callee
			typeError(state, ident, "'%s' is not a function. (It is %s)", ident.name, getFriendlyTypeInfoName(ident.inferredType))
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
		end
	end

	local effectiveCalleeTypeInfo

	if calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig           = calleeTypeInfo
		effectiveCalleeTypeInfo = listSig[1]
	else
		effectiveCalleeTypeInfo = calleeTypeInfo
	end
	assert(effectiveCalleeTypeInfo.tag == !(typeTags.TypeInfoFunction)) -- @Incomplete: Handle parameterized structs.

	-- @Incomplete: Check for optional arguments.
	if #call.arguments < #effectiveCalleeTypeInfo.argumentTypesIn then
		typeError(state, call, "Missing arguments.")
	elseif #call.arguments > #effectiveCalleeTypeInfo.argumentTypesIn then
		typeError(state, call.arguments[#effectiveCalleeTypeInfo.argumentTypesIn+1], "Too many arguments.")
	end

	for i, argExpr in ipairs(call.arguments) do
		local typeInfoWanted = effectiveCalleeTypeInfo.argumentTypesIn[i]

		if argExpr.inferredType ~= typeInfoWanted then
			-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
			-- @UX: Tell the name of the argument. (Probably only possible for constants, and maybe not all. Not sure!)
			typeError(
				state, argExpr,
				"Wrong type for argument #%d. (Wanted %s, got %s)",
				i,
				getFriendlyTypeInfoName(typeInfoWanted),
				getFriendlyTypeInfoName(argExpr.inferredType)
			)
		end
	end

	call.inferredType = getTypeInfoForList(state, effectiveCalleeTypeInfo.argumentTypesOut)
	v2_moveToNextPipe(state, call)
end

!NODE_INFERRER `function nodeInferrers.AstDeclaration(state, decl)`
	if decl.assignment and decl.assignment.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `decl.assignment`)
	end

	for _, ident in ipairs(decl.names) do
		if not ident.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `ident`)
		end
	end

	for _, typeNode in ipairs(decl.types) do
		if not typeNode.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `typeNode`)
		end
	end

	-- @Incomplete: decl.notes (if we make them structured)

	for i, ident in ipairs(decl.names) do
		decl.inferredTypes[i] = ident.inferredType or errorInternal()
	end

	v2_moveToNextPipe(state, decl)
end

-- !NODE_INFERRER `function nodeInferrers.AstVararg(state, vararg)`
-- end

!NODE_INFERRER `function nodeInferrers.AstLiteral(state, literal)`
	local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType] or errorUnhandledNodeType(literal)

	literal.inferredType = getTypeInfoForBuiltinType(typeName)

	v2_moveToNextPipe(state, literal)
end

!NODE_INFERRER `function nodeInferrers.AstUnary(state, unary)`
	if not unary.expression.inferredType then
		!DEPEND_AND_RETURN(`unary`, DEPEND_NODE_INFERRED, `unary.expression`)
	end

	local typeInfo = unary.expression.inferredType

	if isAny(unary.operation, "+","-") then
		if not isAny(typeInfo,
			getTypeInfoForBuiltinType"int",
			getTypeInfoForBuiltinType"number"
		) then
			typeError(state, unary.expression,
				"Unary operation: Expected a number or int. (Got %s)",
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "#" then
		errorInternal("@Incomplete: Length operator.")

	elseif unary.operation == "not" then
		if typeInfo ~= getTypeInfoForBuiltinType"bool" then
			typeError(state, unary.expression,
				"Unary operation: Expected a bool. (Got %s)",
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	else
		errorUnhandledNodeType(unary)
	end

	unary.inferredType = typeInfo
	v2_moveToNextPipe(state, unary)
end

!NODE_INFERRER `function nodeInferrers.AstBinary(state, binary)`
	local typeInfoL = binary.left.inferredType
	local typeInfoR = binary.right.inferredType

	if not typeInfoL then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.left`)
	end
	if not typeInfoR then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.right`)
	end

	-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
	-- For now, both sides need to be the same exact type.
	if typeInfoL ~= typeInfoR then
		typeError(
			state, binary,
			"Binary operation: Operands are different types. (Left is %s, right is %s)",
			getFriendlyTypeInfoName(typeInfoL),
			getFriendlyTypeInfoName(typeInfoR)
		)
	end

	-- Numeric operation.
	if isAny(binary.operation, "+","-","*","/","//","^","%") then
		if not isAny(typeInfoL,
			getTypeInfoForBuiltinType"int",
			getTypeInfoForBuiltinType"number"
		) then
			typeError(
				state, binary.left,
				"Binary operation: Expected a number or int. (Got %s)",
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		if isAny(binary.operation, "/") then -- Result in number.
			typeInfo = getTypeInfoForBuiltinType"number"
		elseif isAny(binary.operation, "//") then -- Result in int.
			typeInfo = getTypeInfoForBuiltinType"int"
		else -- Keep type.
			typeInfo = typeInfoL
		end

	-- Comparison.
	elseif isAny(binary.operation, "<",">","<=",">=") then
		if not isAny(typeInfoL,
			getTypeInfoForBuiltinType"int",
			getTypeInfoForBuiltinType"number",
			getTypeInfoForBuiltinType"string"
		) then
			typeError(
				state, binary.left,
				"Binary operation: Expected a number, int or string. (Got %s)",
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		typeInfo = getTypeInfoForBuiltinType"bool"

	-- Equality.
	elseif isAny(binary.operation, "==","~=") then
		typeInfo = getTypeInfoForBuiltinType"bool"

	-- Boolean operation.
	elseif isAny(binary.operation, "and","or") then
		if typeInfoL ~= getTypeInfoForBuiltinType"bool" then
			typeError(state, binary.left, "Binary operation: Expected a bool. (Got %s)", getFriendlyTypeInfoName(typeInfoL))
		end
		typeInfo = getTypeInfoForBuiltinType"bool"

	-- String concatination.
	elseif isAny(binary.operation, "..") then
		if typeInfoL ~= getTypeInfoForBuiltinType"string" then
			typeError(state, binary.left, "Binary operation: Expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoL))
		end
		typeInfo = getTypeInfoForBuiltinType"string"

	-- Lookup, or similar.
	elseif isAny(binary.operation, ".") then
		errorInternal("@Incomplete: Handle '.' operator.")

	else
		errorUnhandledNodeType(binary)
	end

	assert(typeInfo)
	binary.inferredType = typeInfo

	v2_moveToNextPipe(state, binary)
end

-- !NODE_INFERRER `function nodeInferrers.AstTable(state, tableNode)`
-- 	for _, tableField in ipairs(tableNode) do
-- 		tableField.key
-- 		tableField.value
-- 	end
-- end

!NODE_INFERRER `function nodeInferrers.AstArgument(state, arg)`
	if arg.declaration.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`arg`, DEPEND_NODE_INFERRED, `arg.declaration`)
	end
	v2_moveToNextPipe(state, arg)
end

!NODE_INFERRER `function nodeInferrers.AstArguments(state, args)` -- @Cleanup: Make AstArguments obsolete.
	for _, arg in ipairs(args) do
		if arg.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`args`, DEPEND_NODE_INFERRED, `arg`)
		end
	end

	args.inferredType = getTypeInfoForBuiltinType"void" -- AstArguments is an expression, for some reason. @Cleanup

	v2_moveToNextPipe(state, args)
end

!NODE_INFERRER `function nodeInferrers.AstLambda(state, lambda)`
	if lambda.argumentsIn and not lambda.argumentsIn.inferredType then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.argumentsIn`)
	end
	if lambda.argumentsOut and not lambda.argumentsOut.inferredType then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.argumentsOut`)
	end

	-- Note: We don't require the body to inferred.

	lambda.inferredType = getTypeInfoForLambda(state, lambda)
	assert(lambda.inferredType)

	v2_moveToNextPipe(state, lambda)
end

!NODE_INFERRER `function nodeInferrers.AstTypeOf(state, typeOf)`
	if not typeOf.expression.inferredType then
		!DEPEND_AND_RETURN(`typeOf`, DEPEND_NODE_INFERRED, `typeOf.expression`)
	end

	typeOf.inferredType = getTypeInfoForBuiltinType"type"

	v2_moveToNextPipe(state, typeOf)
end

!NODE_INFERRER `function nodeInferrers.AstCast(state, cast)`
	if not cast.targetType.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.targetType`)
	end
	if not cast.expression.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.expression`)
	end

	local castTypeInfo

	if cast.targetType.nodeType == !(nodeTypes.AstType) then
		local typeNode = cast.targetType
		castTypeInfo   = typeNode.representedType
	elseif cast.targetType.nodeType == !(nodeTypes.AstTypeOf) then
		local typeOf   = cast.targetType
		castTypeInfo   = typeOf.expression.inferredType
	else
		errorUnhandledNodeType(cast.targetType)
	end

	if isAny(castTypeInfo, getTypeInfoForBuiltinType"number",getTypeInfoForBuiltinType"int") then
		if not isAny(cast.expression.inferredType, getTypeInfoForBuiltinType"number",getTypeInfoForBuiltinType"int") then
			typeError(
				state, cast.expression,
				"Cannot cast from %s to %s.",
				getFriendlyTypeInfoName(cast.expression.inferredType),
				getFriendlyTypeInfoName(castTypeInfo)
			)
		end
	else
		errorUnhandledNodeType(cast)
	end

	cast.inferredType = castTypeInfo
	v2_moveToNextPipe(state, cast)
end

!NODE_INFERRER `function nodeInferrers.AstStatement(state, statement)`
	if statement.what.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`statement`, DEPEND_NODE_INFERRED, `statement.what`)
	end

	v2_moveToNextPipe(state, statement)
end

-- expression, typeInfo = v2_getAssignmentValue( state, ident, values, i [, expectedTypeInfo=any ] )
function _G.v2_getAssignmentValue(state, ident, values, i, typeInfoExpected)
	local valueExpr = values[i]

	-- Non-call value or value not last in list.
	if valueExpr and not (valueExpr.nodeType == !(nodeTypes.AstCall) and not valueExpr.surroundedByParenthesis) then
		if typeInfoExpected and valueExpr.inferredType ~= typeInfoExpected then
			-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
			if valueExpr.inferredType.tag ~= typeInfoExpected.tag then
				typeError(
					state, valueExpr,
					"Value and type mismatch. ('%s' is %s, value is %s)",
					ident.name,
					getFriendlyTypeInfoName(typeInfoExpected),
					getFriendlyTypeInfoName(valueExpr.inferredType)
				)

			elseif typeInfoExpected.tag == !(typeTags.TypeInfoFunction) then
				typeError(
					state, valueExpr,
					"Function signature is different from the type of '%s'. (Wanted %s, got %s)",
					ident.name,
					getFriendlyTypeInfoName(typeInfoExpected),
					getFriendlyTypeInfoName(valueExpr.inferredType)
				)

			elseif typeInfoExpected.tag == !(typeTags.TypeInfoStruct) then
				typeError(
					state, valueExpr,
					"Value and type mismatch. Expected a struct initializer for %s.",
					getFriendlyTypeInfoName(typeInfoExpected)
				)

			else
				typeError(state, valueExpr, "Value and type mismatch.")
			end
		end

		return valueExpr, valueExpr.inferredType
	end

	-- Value list ending in a call (hopefully).
	local call      = valueExpr
	local lastIndex = #values

	if not call then
		-- We're past the end of the list - get the last specified value.
		call = values[lastIndex]

		if call.nodeType ~= !(nodeTypes.AstCall) then
			typeError(state, call, "Expected a function call. Missing a value for '%s'.", ident.name)
		elseif call.surroundedByParenthesis then
			typeError(state, ident, "Missing a value for '%s'.", ident.name)
		end
	end

	local argIndex = i-lastIndex+1

	local typeInfoForCall = call.inferredType
	local listSig

	if typeInfoForCall.tag == !(typeTags.TypeInfoList) then
		listSig = typeInfoForCall
	elseif typeInfoForCall.tag == !(typeTags.TypeInfoVoid) then
		typeError(state, call, "Called function does not return anything.") -- Only function calls can be void at the moment. 2019-12-04
	else
		typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfoForCall))
	end

	local typeInfoForOutArg = listSig[argIndex]
	if not typeInfoForOutArg then
		typeError(state, call, "Function does not return anything for '%s' (return value #%d).", ident.name, argIndex)
	end

	if typeInfoExpected and typeInfoForOutArg ~= typeInfoExpected then
		local calleeName = (call.callee.nodeType == !(nodeTypes.AstIdentifier) and call.callee.name or "?")
		typeError(
			state, call,
			"The type of return value #%d of '%s' (%s) does not match the type of '%s' (%s).",
			argIndex,
			calleeName,
			getFriendlyTypeInfoName(typeInfoForOutArg),
			ident.name,
			getFriendlyTypeInfoName(typeInfoExpected)
		)
	end

	return call, typeInfoForOutArg
end

!NODE_INFERRER `function nodeInferrers.AstAssignment(state, assignment)`
	for _, ident in ipairs(assignment.targets) do
		if not ident.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `ident`)
		end
	end

	for _, expr in ipairs(assignment.values) do
		if not expr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `expr`)
		end
	end

	for i, ident in ipairs(assignment.targets) do
		v2_getAssignmentValue(state, ident, assignment.values, i, ident.inferredType)
	end

	-- @Incomplete: Check that !must args from functions have an assignment target.

	v2_moveToNextPipe(state, assignment)
end

!NODE_INFERRER `function nodeInferrers.AstReturn(state, returnNode)`
	for _, valueExpr in ipairs(returnNode.values) do
		if not valueExpr.inferredType then
			!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `valueExpr`)
		end
	end

	v2_moveToNextPipe(state, returnNode)
end

-- !NODE_INFERRER `function nodeInferrers.AstBreak(state, breakNode)`
-- 	breakNode.loopName
-- end

-- !NODE_INFERRER `function nodeInferrers.AstContinue(state, continue)`
-- 	continue.loopName
-- end

-- !NODE_INFERRER `function nodeInferrers.AstDefer(state, defer)`
-- 	defer.body
-- end

-- !NODE_INFERRER `function nodeInferrers.AstImport(state, import)`
-- 	import.name
-- end

-- !NODE_INFERRER `function nodeInferrers.AstIf(state, ifBranch)`
-- 	ifBranch.condition
-- 	ifBranch.branchTrue
-- 	ifBranch.branchFalse
-- end

-- !NODE_INFERRER `function nodeInferrers.AstWhile(state, whileLoop)`
--  whileLoop.condition
--  whileLoop.body
-- end

-- !NODE_INFERRER `function nodeInferrers.AstFor(state, forLoop)`
-- 	forLoop.names[]
-- 	forLoop.expressions[]
-- 	forLoop.body
-- end

!NODE_INFERRER `function nodeInferrers.AstStruct(state, struct)`
	for _, decl in ipairs(struct.declarations) do
		if decl.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `decl`)
		end
	end

	local structInfo = newTypeInfo(TypeInfoStruct)

	for i, decl in ipairs(struct.declarations) do
		local member          = TypeInfoStructMember()
		member.name           = decl.names[1].name -- Note: Struct member declarations only have one name.
		member.typeInfo       = decl.inferredTypes[1]
		structInfo.members[i] = member
	end

	-- @Incomplete: struct.includedNamespaces[]
	-- @Incomplete: struct.arguments

	table.insert(state.allTypeInfos, structInfo)

	struct.representedType = structInfo
	struct.inferredType    = getTypeInfoForBuiltinType"type"

	v2_moveToNextPipe(state, struct)
end

!NODE_INFERRER `function nodeInferrers.AstEnum(state, enum)`
	for _, decl in ipairs(enum.declarations) do
		if decl.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `decl`)
		end
	end

	assert(enum.declarations[1], "Enums must have members.") -- This should have been caught during parsing.

	local enumMemberInfo

	if enum.memberType then
		enumMemberInfo = getTypeInfoForBuiltinType(enum.memberType.typeName)
	else
		-- Just use the type of the first member as the wanted type for the enum.
		-- Note: Struct member declarations only have one name.
		enumMemberInfo = enum.declarations[1].inferredTypes[1]
		if not isAny(enumMemberInfo,
			getTypeInfoForBuiltinType"int",
			getTypeInfoForBuiltinType"string",
			getTypeInfoForBuiltinType"type",
			getTypeInfoForBuiltinType"bool",
			getTypeInfoForBuiltinType"number"
		) then
			typeError(state, enum, "Supported enum member types are: int, string, type, bool, number")
		end
	end

	local enumInfo = newTypeInfo(TypeInfoEnum)

	for i, decl in ipairs(enum.declarations) do
		local valExpr = decl.assignment.values[1]

		if valExpr.inferredType ~= enumMemberInfo then
			-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
			typeError(state, valExpr,
				"Incorrect value type for '%s'. (Wanted %s, got %s)",
				decl.names[1].name,
				getFriendlyTypeInfoName(enumMemberInfo),
				getFriendlyTypeInfoName(valExpr.inferredType)
			)
		end

		local member        = TypeInfoEnumMember()
		member.name         = decl.names[1].name
		enumInfo.members[i] = member
	end

	-- @Incomplete: enum.includedNamespaces[]

	table.insert(state.allTypeInfos, enumInfo)

	enum.representedType = enumInfo
	enum.inferredType    = getTypeInfoForBuiltinType"type"

	v2_moveToNextPipe(state, enum)
end

!NODE_INFERRER `function nodeInferrers.AstFileScope(state, fileScope)`
	for _, decl in ipairs(fileScope.declarations) do
		if decl.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`fileScope`, DEPEND_NODE_INFERRED, `decl`)
		end
	end

	-- @Incomplete: fileScope.includedNamespaces

	v2_moveToNextPipe(state, fileScope)
end

!NODE_INFERRER `function nodeInferrers.AstBlock(state, block)`
	for _, statement in ipairs(block) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`block`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	v2_moveToNextPipe(state, block)
end

function _G.v2_inferNode(state, node)
	local nodeInferrer = nodeInferrers[node.nodeType] or errorUnhandledNodeType(node)
	return nodeInferrer(state, node)
end


