--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	addDependency
	addToQueue, addToQueueRecursively, scheduleRemovalFromQueueRecursively, scheduleRemovalOfChildrenFromQueueRecursively, replaceQueuedNode
	getAssignmentValue
	getClosestScope, isScope*
	getLiteralValueFromExpressionIfConstant
	getTypeInfo*
	inferNode
	moveToNextPipe
	typeError, typeMessage

--============================================================]]



!(
_G.typeTags        = {}
local lastTypeTag  = 0
local typeTagNames = {}

local function structTypeInfo(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			lastTypeTag           = lastTypeTag+1
			fields._overrides     = fields._overrides or {}
			fields._overrides.tag = lastTypeTag

			typeTags[name]            = lastTypeTag
			typeTagNames[lastTypeTag] = name:gsub("^TypeInfo", ""):lower()
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_TypeInfo"{
	tag        = 0, -- This is like a "type of type info". The word "type" is used in so many places so we call it "tag" here to make it less confusing...
	id         = 0,
	definition = NIL, -- AstTypeDefinition (This node has the scope.) (Should typeInfos even have this field? Possibly.)
}

local !structTypeInfo"TypeInfoAny:_TypeInfo"{}
local !structTypeInfo"TypeInfoBool:_TypeInfo"{}
local !structTypeInfo"TypeInfoInt:_TypeInfo"{}
local !structTypeInfo"TypeInfoNil:_TypeInfo"{}
local !structTypeInfo"TypeInfoFloat:_TypeInfo"{}
local !structTypeInfo"TypeInfoString:_TypeInfo"{}
local !structTypeInfo"TypeInfoTable:_TypeInfo"{}
local !structTypeInfo"TypeInfoType:_TypeInfo"{}
local !structTypeInfo"TypeInfoNamespace:_TypeInfo"{}
local !structTypeInfo"TypeInfoVoid:_TypeInfo"{}

!!local SIMPLE_TYPE_TAG = {
	-- These small type infos don't have any extra information.
	[typeTags.TypeInfoAny]       = true,
	[typeTags.TypeInfoBool]      = true,
	[typeTags.TypeInfoInt]       = true,
	[typeTags.TypeInfoNil]       = true,
	[typeTags.TypeInfoFloat]     = true,
	[typeTags.TypeInfoString]    = true,
	[typeTags.TypeInfoTable]     = true,
	[typeTags.TypeInfoType]      = true,
	[typeTags.TypeInfoNamespace] = true,
}

local !structTypeInfo"TypeInfoArray:_TypeInfo"{
	itemType = NIL, -- TypeInfo
}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{ -- AKA function signature.
	argumentTypesIn  = {}, -- []TypeInfo  @Cleanup: Use TypeInfoList here.
	argumentTypesOut = {}, -- []TypeInfo  @Cleanup: Use TypeInfoList here.
	polymorphic      = false,
	inline           = false,
}

local !struct"TypeInfoStructMember"{
	name     = "",
	typeInfo = NIL,
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	name                  = "",  -- Filled in during definition.
	arguments             = {},  -- []TypeInfo  @Incomplete: Polymorphism.  @Cleanup: Use TypeInfoList here.
	members               = {},  -- []TypeInfoStructMember
	polymorphSourceStruct = NIL, -- TypeInfoStruct  @Incomplete: Polymorphism.
}

local !struct"TypeInfoEnumMember"{
	name = "",
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	name     = "",
	typeInfo = NIL, -- Must be one of these primitive types: int, string, type, bool or float.
	members  = {},  -- []TypeInfoEnumMember
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	-- [1]=typeInfo1, ...
}

local !structTypeInfo"TypeInfoList:_TypeInfo"{ -- Special type used for returns from calls (both when sending and receiving).
	-- [1]=typeInfo1, ...
}

_G.TYPE_TAG_NAMES = !(typeTagNames)



-- typeInfo = newTypeInfo( TypeInfoCreator [, definition=internal ] )
do
	local lastTypeId = 0

	function _G.newTypeInfo(TypeInfoCreator, defn)
		if not TypeInfoCreator then  errorInternal(2, "No TypeInfoCreator specified.")  end

		lastTypeId = lastTypeId+1

		local typeInfo      = TypeInfoCreator()
		typeInfo.id         = lastTypeId
		typeInfo.definition = defn

		--[[
		if lastTypeId == 22 then
			errorInternal("DEBUG")
		end
		--]]

		return typeInfo
	end
end

do
	local builtinTypeInfos = {}

	local BUILTIN_TYPE_STRUCTS = {
		["*"]         = TypeInfoAny,
		["bool"]      = TypeInfoBool,
		["int"]       = TypeInfoInt,
		["nil"]       = TypeInfoNil,
		["float"]     = TypeInfoFloat,
		["string"]    = TypeInfoString,
		["table"]     = TypeInfoTable,
		["type"]      = TypeInfoType,      -- The result of e.g. type_of(int) or type_of(type_of(myVariable)).
		["namespace"] = TypeInfoNamespace, -- Imports/loads.
		["void"]      = TypeInfoVoid,      -- Barely used, if at all.
	}

	function _G.getTypeInfoForBuiltinType(state, typeName)
		local typeInfo = builtinTypeInfos[typeName]

		if not typeInfo then
			local TypeInfoCreator      = BUILTIN_TYPE_STRUCTS[typeName] or errorInternal(tostring(typeName))
			typeInfo                   = newTypeInfo(TypeInfoCreator)
			builtinTypeInfos[typeName] = typeInfo

			table.insert(state.allTypeInfos, typeInfo)
		end

		return typeInfo
	end
end

function _G.getTypeInfoForLambda(state, lambda)
	for _, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if not arg.declaration.inferredTypes[1] then  return nil  end
	end
	for _, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if not arg.declaration.inferredTypes[1] then  return nil  end
	end

	-- Have we encountered an equal signature before?
	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoFunction) and doesLambdaHaveSignature(lambda, typeInfoCached) then
			return typeInfoCached
		end
	end

	local funcSig = newTypeInfo(TypeInfoFunction)

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		funcSig.argumentTypesIn[i] = arg.declaration.inferredTypes[1]
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		funcSig.argumentTypesOut[i] = arg.declaration.inferredTypes[1]
	end

	table.insert(state.allTypeInfos, funcSig)
	return funcSig
end

function _G.doesTypeListHaveSignature(typeList, listSig)
	if #typeList ~= #listSig then  return false   end

	for i = 1, #typeList do
		if typeList[i] ~= listSig[i] then  return false  end
	end

	return true
end

function _G.getTypeInfoForList(state, typeList)
	-- Have we encountered an equal signature before?
	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoList) and doesTypeListHaveSignature(typeList, typeInfoCached) then
			return typeInfoCached
		end
	end

	local listSig = newTypeInfo(TypeInfoList)
	copyToArray(typeList, listSig)
	table.insert(state.allTypeInfos, listSig)

	return listSig
end



function _G.doesLambdaHaveSignature(lambda, funcSig)
	if #(lambda.argumentsIn  or EMPTY_TABLE) ~= #funcSig.argumentTypesIn  then  return false  end
	if #(lambda.argumentsOut or EMPTY_TABLE) ~= #funcSig.argumentTypesOut then  return false  end

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if arg.declaration.inferredTypes[1] ~= funcSig.argumentTypesIn[i]  then  return false  end
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if arg.declaration.inferredTypes[1] ~= funcSig.argumentTypesOut[i] then  return false  end
	end

	-- @Incomplete: Check arg.isRequired for input args.

	return true
end



-- scope, childClosestToScope = getClosestScope( node )
function _G.getClosestScope(node)
	return astFindParent(node, !(nodeTypes.AstGlobalScope),!(nodeTypes.AstFileScope),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum),!(nodeTypes.AstBlock),!(nodeTypes.AstFor),!(nodeTypes.AstLambda))
end

function _G.isScope(node)
	return isAny(node.nodeType, !(nodeTypes.AstGlobalScope),!(nodeTypes.AstFileScope),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum),!(nodeTypes.AstBlock),!(nodeTypes.AstFor),!(nodeTypes.AstLambda))
end
function _G.isScopeDeclarative(scope)
	return isAny(scope.nodeType, !(nodeTypes.AstGlobalScope),!(nodeTypes.AstFileScope),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum))
end
function _G.isScopeImperative(scope)
	return isAny(scope.nodeType, !(nodeTypes.AstBlock),!(nodeTypes.AstFor),!(nodeTypes.AstLambda))
end



function _G.findDefinition(state, startNode, name)
	local scope = startNode

	-- @Speed: There's duplicate work being done here.

	-- Locals.
	while true do
		scope = getClosestScope(scope)
		if not scope then  break  end

		assert(scope.definitions, scope.nodeType)

		for _, defn in ipairs(scope.definitions) do
			if defn.name.name == name and isDefinitionVisibleToNode(defn, startNode) then
				return defn
			end
		end

		--[[ @Incomplete: Look in imports. (Not necessary when looking for globals.)  Also, look through usings for the scope.
		for _, import in ipairs(scope.imports or EMPTY_TABLE) do
			if import.fileScope then
				for _, defn in ipairs(import.fileScope.definitions) do
					if defn.name.name == name and defn.name.declaration.isGlobalOrExported then
						return defn
					end
				end
			end
		end
		--]]
	end

	-- Globals.  @Cleanup: Define globals in the actual global scope.
	for _, fileScope in ipairs(state.globalScope.fileScopes) do
		for _, defn in ipairs(fileScope.definitions) do
			if defn.name.name == name and defn.name.declaration.isGlobalOrExported then
				return defn
			end
		end
	end

	return nil
end

function _G.isDefinitionVisibleToNode(defn, node)
	local nodeScope, nodeScopeChild = getClosestScope(node)
	local canSeeImperativeVariables = not defn.isConst

	while true do
		if isScopeDeclarative(nodeScope) then
			if indexOf(nodeScope.definitions, defn) then  return true  end

		elseif isAny(nodeScope.nodeType, !(nodeTypes.AstFor),!(nodeTypes.AstLambda)) then
			if canSeeImperativeVariables and indexOf(nodeScope.definitions, defn) then  return true  end

		elseif nodeScope.nodeType == !(nodeTypes.AstBlock) then
			local block           = nodeScope
			local imperativeIndex = indexOf(block, nodeScopeChild) or errorInternal()

			for i, statement in ipairs(block) do
				if statement.what.nodeType == !(nodeTypes.AstDeclaration) then
					local decl = statement.what
					if decl.isConstant or (canSeeImperativeVariables and i < imperativeIndex) then
						if astHasParent(defn.name, decl) then  return true  end
					end
				end
			end

		else
			errorUnhandledNodeType(nodeScope)
		end

		if nodeScope.nodeType == !(nodeTypes.AstLambda) then
			-- Lambdas act as the only boundary between imperative and declarative
			-- scopes right now. Maybe this will change in the future? 2019-12-07
			canSeeImperativeVariables = false
		end

		nodeScope, nodeScopeChild = getClosestScope(nodeScope)
		if not nodeScope then  return false  end
	end
end

function _G.printDefinitionChain(file, state, defn, typeName)
	if type(file) ~= "userdata" then  return printDefinitionChain(io.stdout, file, state, defn)  end

	!local MAX_CHAIN_LENGTH = 10

	for i = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(file, state, defn.name, "Info", "...here is '%s' defined.", typeName)

		local placeDeclared = defn.name.placeDeclared
		if not placeDeclared then  break  end

		defn = nil

		if placeDeclared.nodeType == !(nodeTypes.AstDeclaration) then
			local decl      = placeDeclared
			local i         = indexWith1(decl.names, "name", typeName)
			local valueNode = decl.assignment and decl.assignment.values[i]

			if valueNode and valueNode.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = valueNode
				typeName    = ident.name
				defn        = findDefinition(state, ident, typeName)
			end
		end

		if not defn then  break  end
	end
end



-- typeError( compilationState, node, formatString, ... )
function _G.typeError(state, node, s, ...)
	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	errorInFile(buffer, path, tokens.position1[token], "Typer", s, ...)
end

-- typeMessage( [ outputFile=io.stdout, ] compilationState, node, label, formatString, ... )
function _G.typeMessage(file, state, node, label, s, ...)
	if type(file) ~= "userdata" then  return typeMessage(io.stdout, file, state, node, label, s, ...)  end

	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	reportMessageInFile(file, buffer, path, tokens.position1[token], label, "Typer", s, ...)
end



function _G.getFriendlyTypeInfoName(typeInfo)
	local name = ""

	if typeInfo.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		name             = structInfo.name -- @Incomplete: Include parameters for parameterized structs.

	elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo = typeInfo
		name           = enumInfo.name

	elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
		local funcSig      = typeInfo
		local typeTextsIn  = {}
		local typeTextsOut = {}

		for i, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			typeTextsIn[i] = getFriendlyTypeInfoName(argTypeInfo)
		end
		for i, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			typeTextsOut[i] = getFriendlyTypeInfoName(argTypeInfo)
		end

		name = typeTextsOut[1]
			and F("function(%s)->(%s)", table.concat(typeTextsIn, ","), table.concat(typeTextsOut, ","))
			or  F("function(%s)->void", table.concat(typeTextsIn, ","))
	end

	if name == "" then
		name = TYPE_TAG_NAMES[typeInfo.tag]
	end

	-- !(if DEBUG then)  name = name.."@"..typeInfo.id  !(end)

	return name
end



local !struct"Dependency"{ -- @Cleanup: Rename to something with "wait"?
	dependent  = NIL, -- Queued
	dependType = 0,   -- DEPEND_DEFINITION|DEPEND_NODE_INFERRED
	dependOn   = NIL, -- string|Queued  (The value depends on what dependType is.)
}

-- addDependency( state, dependent, DEPEND_DEFINITION,    name    )
-- addDependency( state, dependent, DEPEND_NODE_INFERRED, astNode )
function _G.addDependency(state, dependent, dependType, dependOn)
	assert(not dependent.queued.waitingOn)

	!if DEBUG then
		if dependType == !(DEPEND_DEFINITION) then
			assert(type(dependOn) == "string")
		elseif dependType == !(DEPEND_NODE_INFERRED) then
			assert(type(dependOn) == "table")
		else
			error(dependType)
		end
	!end

	if dependType == !(DEPEND_NODE_INFERRED) then
		assert(dependent ~= dependOn)
		dependOn = dependOn.queued
	end

	local dependency      = Dependency()
	dependency.dependent  = dependent.queued
	dependency.dependType = dependType
	dependency.dependOn   = dependOn

	dependent.queued.waitingOn = dependency

	assert(not itemWith3(state.dependencies, "dependent",dependency.dependent, "dependType",dependency.dependType, "dependOn",dependency.dependOn))
	table.insert(state.dependencies, dependency)

	!if DEBUG then
		--[[
		if debug_onlyInferTypes then
			io.stdout:write("DEPEND ")
			astPrint(dependent)

			io.stdout:write("    ON ", DEPEND_TITLES[dependType], " ")
			if dependType == !(DEPEND_DEFINITION) then
				print(dependOn)
			elseif dependType == !(DEPEND_NODE_INFERRED) then
				astPrint(dependOn.node)
			else
				print("? ("..tostring(dependOn)..")")
			end
		end
		--]]
	!end
end



local !struct"Queued"{
	node      = NIL, -- AstNode
	container = NIL,
	key       = NIL,
	pipe      = 0,
	waitingOn = NIL, -- Dependency
	removed   = false,
}

function _G.addToQueue(state, node, container, key, pipe)
	local queued     = Queued()
	queued.node      = node
	queued.container = container
	queued.key       = key
	queued.pipe      = pipe

	node.queued = queued
	table.insert(state.queue, queued)

	if node.nodeType == !(nodeTypes.AstIdentifier) and node.declaration and node.parent.nodeType == !(nodeTypes.AstAssignment) then
		local ident       = node
		local assignment  = node.parent
		local decl        = node.declaration
		local i           = indexOf(assignment.targets, ident) or errorInternal()
		local identSource = decl.names[i]
		addDependency(state, ident, !(DEPEND_NODE_INFERRED), identSource)
	end
end

function _G.addToQueueRecursively(state, topNode)
	astVisitAllNodesLeavesFirst(topNode, function(node, container, key)
		-- astPrint(node)
		addToQueue(state, node, container, key, !(PIPE_INFER))
	end)
end

function _G.scheduleRemovalFromQueueRecursively(state, topNode)
	astVisitAllNodes(topNode, function(node)
		node.queued.removed = true
	end)
end
function _G.scheduleRemovalOfChildrenFromQueueRecursively(state, topNode)
	astVisitAllNodes(topNode, function(node)
		if node ~= topNode then
			node.queued.removed = true
		end
	end)
end

function _G.replaceQueuedNode(state, nodeOld, nodeNew)
	assert(not nodeNew.queued)

	local queued   = nodeOld.queued or errorInternal()
	queued.node    = nodeNew
	nodeOld.queued = nil
	nodeNew.queued = queued

	if queued.container then
		queued.container[queued.key] = nodeNew
	end
end


function _G.moveToNextPipe(state, node)
	local queued = node.queued
	queued.pipe  = queued.pipe+1
end



!(
local function DEPEND_AND_RETURN(dependentCode, dependType, dependOnCode)
	__LUA("addDependency(state, ",dependentCode,", ",toLua(dependType),", ",dependOnCode,") ; return")
end

local function NODE_INFERRER(funcHeaderCode)
	local replacements

	funcHeaderCode, replacements = funcHeaderCode:gsub("function +nodeInferrers%.(Ast%w+)", function(nodeName)
		local nodeType = nodeTypes[nodeName] or error(nodeName)
		return "nodeInferrers[--[["..nodeName.."]]"..nodeType.."] = function"
	end)

	assert(replacements == 1, funcHeaderCode)

	__LUA(funcHeaderCode)
end
)

local nodeInferrers = {}

!NODE_INFERRER `function nodeInferrers.AstTypeDefinition(state, defn)`
	if not defn.typeInfo then
		!DEPEND_AND_RETURN(`defn`, DEPEND_NODE_INFERRED, `defn.name`)
	end

	-- @Refactor: Maybe move some logic from AstIdentifier to here?

	moveToNextPipe(state, defn)
end

!NODE_INFERRER `function nodeInferrers.AstIdentifier(state, ident)`
	local decl = ident.declaration

	-- Loose identifier.
	if not decl then
		assert(not ident.placeDeclared)

		local defn = findDefinition(state, ident, ident.name)
		if not defn then
			!DEPEND_AND_RETURN(`ident`, DEPEND_DEFINITION, `ident.name`)
		end
		ident.definition = defn

		if not defn.typeInfo then
			!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `defn`)
		end
		ident.inferredType = defn.typeInfo

		moveToNextPipe(state, ident)
		return

	-- Assignment target in declaration (which is a copy of the identifier in the declaration).
	elseif ident.parent.nodeType == !(nodeTypes.AstAssignment) then
		local identDecl, i = itemWith1(decl.names, "name", ident.name)
		if not identDecl then  errorInternal()  end

		local defn = identDecl.definition
		if not defn then
			!DEPEND_AND_RETURN(`ident`, DEPEND_DEFINITION, `identDecl`)
		end
		ident.definition = defn

		if not defn.typeInfo then
			!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `defn`)
		end
		ident.inferredType = defn.typeInfo

		moveToNextPipe(state, ident)
		return
	end

	-- At this point we're defining a declared identifier.

	local defn = ident.definition

	if not defn then
		local scope = getClosestScope(decl)
		if not scope then
			typeError(state, ident, "Internal compiler error: Could not find what scope '%s' is in.", ident.name)
		end

		local isMember = isAny(scope.nodeType, !(nodeTypes.AstStruct),!(nodeTypes.AstEnum))

		local isLambdaArgOut = (
			not isMember
			and scope.nodeType == !(nodeTypes.AstLambda)
			and scope.argumentsOut ~= nil
			and indexOf(scope.argumentsOut, astFindParent(decl, !(nodeTypes.AstArgument))) ~= nil
		)

		if not isLambdaArgOut then
			local defnExisting = findDefinition(state, ident, ident.name)

			if not defnExisting then
				-- void

			elseif isMember and scope ~= defnExisting.scope then
				-- void  (Members never shadow anything.)

			elseif not decl.canShadow then
				printerr()
				typeMessage(io.stderr, state, ident,             "Error", "'%s' has already been defined.", ident.name)
				typeMessage(io.stderr, state, defnExisting.name, "Info",  "...it was defined here.")
				exitFailure()

			elseif
				scope == defnExisting.scope
				or (
					-- We do not allow declarations on lambda bodies to shadow the lambda's arguments.
					-- @Robustness: Check the reverse is always true.
					scope.nodeType == !(nodeTypes.AstBlock)
					and getClosestScope(scope).nodeType == !(nodeTypes.AstLambda) -- @Cleanup: Store each node's enclosing scope on each respective node.
					and getClosestScope(scope) == defnExisting.scope
				)
			then
				printerr()
				typeMessage(io.stderr, state, ident,             "Error", "'%s' has already been defined in the same scope (which means name shadowing does not work).", ident.name)
				typeMessage(io.stderr, state, defnExisting.name, "Info",  "...it was defined here.")
				exitFailure()

			else
				-- void  (We're validly shadowing something in an outer scope.)
			end

			-- Make sure new globals are not shadowing any locals.
			if decl.isGlobalOrExported then
				local parentScope = scope
				repeat
					local defnExisting = parentScope.definedLocals[ident.name]

					if defnExisting then
						printerr()
						typeMessage(io.stderr, state, defnExisting.name, "Error", "'%s' is shadowing a global.", ident.name)
						typeMessage(io.stderr, state, ident,             "Info",  "...the global was defined here.")
						exitFailure()
					end

					parentScope = getClosestScope(parentScope)
				until not parentScope
			end
		end

		defn            = astNewNode(AstTypeDefinition, ident.token, scope)
		defn.name       = ident
		defn.scope      = scope
		defn.isConstant = decl.isConstant
		defn.canShadow  = decl.canShadow

		ident.definition = defn

		if isLambdaArgOut then
			addToQueue(state, defn, nil, nil, !(PIPE_INFER))
		else
			local i              = #scope.definitions+1
			scope.definitions[i] = defn
			addToQueue(state, defn, scope.definitions, i, !(PIPE_INFER))

			if not decl.canShadow then
				local parentScope = scope
				repeat
					parentScope.definedLocals[ident.name] = defn -- @Speed: Can we store this on the global scope only?
					parentScope = getClosestScope(parentScope)
				until not parentScope
			end
		end
	end

	for _, typeNode in ipairs(decl.types) do
		if not typeNode.inferredType then
			!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `typeNode`)
		end
	end

	local assignment = decl.assignment

	if assignment then
		for _, valueExpr in ipairs(assignment.values) do
			if not valueExpr.inferredType then
				!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `valueExpr`)
			end
		end
	end

	local typeInfo
	local typeInfoForDecl = nil

	-- Compound type.
	if decl.types[2] then
		errorInternal("@Incomplete: Compound types.")

	-- Single type.
	elseif decl.types[1] then
		local typeExpr = decl.types[1]

		if typeExpr.nodeType == !(nodeTypes.AstType) then
			local typeNode = typeExpr
			typeInfo       = typeNode.representedType

		elseif typeExpr.nodeType == !(nodeTypes.AstTypeOf) then
			local typeOf   = typeExpr
			typeInfo       = typeOf.expression.inferredType

		else
			errorUnhandledNodeType(typeExpr)
		end

	-- Infer type from value.
	else
		local i                        = indexWith1(decl.names, "name", ident.name) or errorInternal()
		local valueExpr, valueTypeInfo = getAssignmentValue(state, ident, assignment.values, i)

		typeInfo = valueTypeInfo

		if typeInfo ~= getTypeInfoForBuiltinType(state, "type") then
			-- void

		elseif valueExpr.nodeType == !(nodeTypes.AstType) then
			local typeNode  = valueExpr
			typeInfoForDecl = typeNode.representedType

		elseif valueExpr.nodeType == !(nodeTypes.AstIdentifier) then
			local identOther = valueExpr
			if not identOther.definition.typeInfo then
				!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `identOther.definition`)
			end
			typeInfoForDecl = identOther.definition.typeInfoForDeclaration -- May be nil.

		elseif valueExpr.nodeType == !(nodeTypes.AstTypeOf) then
			local typeOf    = valueExpr
			typeInfoForDecl = typeOf.expression.inferredType

		elseif valueExpr.nodeType == !(nodeTypes.AstStruct) then
			local struct    = valueExpr
			typeInfoForDecl = struct.representedType

		elseif valueExpr.nodeType == !(nodeTypes.AstEnum) then
			local enum      = valueExpr
			typeInfoForDecl = enum.representedType

		else
			errorUnhandledNodeType(valueExpr)
		end
	end

	if assignment and decl.types[1] then
		local i = indexWith1(decl.names, "name", ident.name) or errorInternal()
		getAssignmentValue(state, ident, assignment.values, i, typeInfo)
	end

	assert(typeInfo)

	-- print(typeInfoForDecl and getFriendlyTypeInfoName(typeInfoForDecl))
	if not typeInfoForDecl then
		-- void

	elseif typeInfoForDecl.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfoForDecl
		structInfo.name  = ident.name

	elseif typeInfoForDecl.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo = typeInfoForDecl
		enumInfo.name  = ident.name
	end

	defn.typeInfo               = typeInfo
	defn.typeInfoForDeclaration = typeInfoForDecl -- May be nil.
	ident.inferredType          = typeInfo

	!if DEBUG then
		if debug_onlyInferTypes then
			io.stdout:write("DEFINE ", ident.name ,":", getFriendlyTypeInfoName(typeInfo), " ")
			if defn.isConstant then  io.stdout:write("(CONST) ")  end
			if typeInfoForDecl then  io.stdout:write("(VALUE ", getFriendlyTypeInfoName(typeInfoForDecl), ") ")  end
			io.stdout:write("IN ") ; astPrint(defn.scope)
		end
	!end

	moveToNextPipe(state, ident)
end

!NODE_INFERRER `function nodeInferrers.AstType(state, typeNode)`
	local defn = nil
	local typeInfo, typeInfoRepresented

	if not typeNode.isUserType then
		typeInfoRepresented = getTypeInfoForBuiltinType(state, typeNode.typeName)
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.functionSignature then
		local lambda = typeNode.functionSignature

		if not lambda.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `lambda`)
		end
		assert(lambda.inferredType.tag == !(typeTags.TypeInfoFunction))

		local funcSig       = getTypeInfoForLambda(state, lambda)
		typeInfoRepresented = funcSig
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.arrayItemType then
		local itemTypeInfo = typeNode.arrayItemType

		if not itemTypeInfo.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `itemTypeInfo`)
		end
		assert(itemTypeInfo.inferredType == getTypeInfoForBuiltinType(state, "type"))

		typeInfoRepresented = itemTypeInfo
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	else
		assert(typeNode.typeName ~= "")

		defn = findDefinition(state, typeNode, typeNode.typeName)
		if not defn then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_DEFINITION, `typeNode.typeName`)
		end
		if not defn.typeInfo then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `defn`)
		end

		typeInfoRepresented = defn.typeInfoForDeclaration
		typeInfo            = defn.typeInfo
		assert(typeInfo)

		if typeInfo ~= getTypeInfoForBuiltinType(state, "type") then
			printerr()
			typeMessage(io.stderr, state, typeNode, "Error", "'%s' is not a type. (It is %s)", typeNode.typeName, getFriendlyTypeInfoName(typeInfo))
			printDefinitionChain(io.stderr, state, defn, typeNode.typeName)
			exitFailure()
		end

		for _, expr in ipairs(typeNode.arguments or EMPTY_TABLE) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		-- @Incomplete: Proper error messages here:

		if SIMPLE_TYPE_TAG[typeInfo.tag] then
			assert(not typeNode.arguments) -- This should have been caught during parsing, e.g. int(a,b).

		elseif typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			if structInfo.arguments[1] then
				errorInternal("@Incomplete: Struct arguments.")
			elseif typeNode.arguments then
				typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeNode.arguments[1]), "Parameters for structs are not supported yet.")
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			assert(not typeNode.arguments)

		elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
			assert(not typeNode.arguments) -- This should not be possible I think. The node should have been parsed as an AstCall - not an AstType without functionSignature... right? I may be wrong.

		else
			errorInternal("Incomplete: Unhandled type tag '%s'.", TYPE_TAG_NAMES[typeInfo.tag])
		end
	end

	assert(typeInfoRepresented)
	assert(typeInfo)

	typeNode.representedType = typeInfoRepresented
	typeNode.inferredType    = typeInfo
	typeNode.declaration     = defn and defn.name.declaration
	typeNode.definition      = defn

	moveToNextPipe(state, typeNode)
end

!NODE_INFERRER `function nodeInferrers.AstCall(state, call)`
	if not call.callee.inferredType then
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `call.callee`)
	end
	for _, arg in ipairs(call.arguments) do
		if not arg.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `arg`)
		end
	end

	local calleeTypeInfo = call.callee.inferredType

	if calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then -- @Incomplete: Parameterized structs.
		-- void

	elseif calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig   = calleeTypeInfo
		local typeInfo1 = listSig[1]

		if not typeInfo1 then
			typeError(state, call, "Trying to call void.")
		elseif typeInfo1.tag == !(typeTags.TypeInfoFunction) then
			-- void
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfo1))
		end

	else
		if call.callee.nodeType == !(nodeTypes.AstIdentifier) then
			local ident = call.callee
			typeError(state, ident, "'%s' is not a function. (It is %s)", ident.name, getFriendlyTypeInfoName(ident.inferredType))
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
		end
	end

	local effectiveCalleeTypeInfo

	if calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig           = calleeTypeInfo
		effectiveCalleeTypeInfo = listSig[1]
	else
		effectiveCalleeTypeInfo = calleeTypeInfo
	end
	assert(effectiveCalleeTypeInfo.tag == !(typeTags.TypeInfoFunction)) -- @Incomplete: Handle parameterized structs.

	-- @Incomplete: Check for optional arguments.
	if #call.arguments < #effectiveCalleeTypeInfo.argumentTypesIn then
		typeError(state, call, "Missing arguments.")
	elseif #call.arguments > #effectiveCalleeTypeInfo.argumentTypesIn then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(call.arguments[#effectiveCalleeTypeInfo.argumentTypesIn+1]), "Too many arguments.")
	end

	for i, argExpr in ipairs(call.arguments) do
		local typeInfoWanted = effectiveCalleeTypeInfo.argumentTypesIn[i]

		if argExpr.inferredType ~= typeInfoWanted then
			-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
			-- @UX: Tell the name of the argument. (Probably only possible for constants, and maybe not all. Not sure!)
			typeError(
				state, astGetExpressionVisuallyFurthestToTheLeft(argExpr),
				"Wrong type for argument #%d. (Wanted %s, got %s)",
				i,
				getFriendlyTypeInfoName(typeInfoWanted),
				getFriendlyTypeInfoName(argExpr.inferredType)
			)
		end
	end

	call.inferredType = getTypeInfoForList(state, effectiveCalleeTypeInfo.argumentTypesOut)
	moveToNextPipe(state, call)
end

!NODE_INFERRER `function nodeInferrers.AstDeclaration(state, decl)`
	if decl.assignment and decl.assignment.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `decl.assignment`)
	end

	for _, ident in ipairs(decl.names) do
		if not ident.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `ident`)
		end
	end

	for _, typeNode in ipairs(decl.types) do
		if not typeNode.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `typeNode`)
		end
	end

	-- @Incomplete: decl.notes (if we make them structured)

	if decl.assignment then
		local scope              = getClosestScope(decl) or errorInternal()
		local scopeIsDeclarative = isScopeDeclarative(scope)

		if scopeIsDeclarative or decl.isConstant then
			for i, ident in ipairs(decl.names) do
				local valueExpr = getAssignmentValue(state, ident, decl.assignment.values, i)

				if not getLiteralValueFromExpressionIfConstant(state, valueExpr) then
					typeError(
						state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
						"Value for declared %s '%s' is not a constant expression.%s",
						(decl.isConstant and "constant" or "variable"),
						ident.name,
						(scopeIsDeclarative and not decl.isConstant and " (All values in declarative scopes must be contant.)" or "")
					)
				end
			end
		end
	end

	for i, ident in ipairs(decl.names) do
		decl.inferredTypes[i] = ident.inferredType or errorInternal() -- Is decl.inferredTypes needed? @Cleanup
	end

	moveToNextPipe(state, decl)
end

-- !NODE_INFERRER `function nodeInferrers.AstVararg(state, vararg)`
-- end

local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = !({
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "nil",
	[LITERAL_FLOAT]   = "float",
	[LITERAL_STRING]  = "string",
})

!NODE_INFERRER `function nodeInferrers.AstLiteral(state, literal)`
	local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType] or errorUnhandledNodeType(literal)

	literal.inferredType = getTypeInfoForBuiltinType(state, typeName)

	moveToNextPipe(state, literal)
end

!NODE_INFERRER `function nodeInferrers.AstUnary(state, unary)`
	if not unary.expression.inferredType then
		!DEPEND_AND_RETURN(`unary`, DEPEND_NODE_INFERRED, `unary.expression`)
	end

	local typeInfo = unary.expression.inferredType

	if isAny(unary.operation, "+","-") then
		if not isAny(typeInfo,
			getTypeInfoForBuiltinType(state, "int"),
			getTypeInfoForBuiltinType(state, "float")
		) then
			typeError(state, unary.expression,
				"Unary operation: Expected a float or int. (Got %s)",
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "not" then
		if typeInfo ~= getTypeInfoForBuiltinType(state, "bool") then
			typeError(state, unary.expression,
				"Unary operation: Expected a bool. (Got %s)",
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "#" then
		errorInternal("@Incomplete: Length operator.")

	else
		errorUnhandledNodeType(unary)
	end

	unary.inferredType = typeInfo
	moveToNextPipe(state, unary)

	--
	-- Inferring complete! Now fold the expression if it's constant.
	--

	-- Not sure if all the following is necessary. Won't we be doing the same thing
	-- when running bytecode? Is it faster to do this here?

	local isConst, v = getLiteralValueFromExpressionIfConstant(state, unary.expression)
	if not isConst then
		-- void

	!for _, opArithmetic in ipairs{"+","-"} do
	elseif unary.operation == !(opArithmetic) then
		local literal = astNewNode(AstLiteral, unary.token, unary.parent)

		literal.literalType
			=  typeInfo == getTypeInfoForBuiltinType(state, "int")   and !(LITERAL_INTEGER)
			or typeInfo == getTypeInfoForBuiltinType(state, "float") and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = !!(opArithmetic ~= "+" and opArithmetic or "") v
		literal.inferredType = typeInfo

		scheduleRemovalOfChildrenFromQueueRecursively(state, unary)
		replaceQueuedNode(state, unary, literal)
	!end

	elseif unary.operation == "not" then
		local literal        = astNewNode(AstLiteral, unary.token, unary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = not v
		literal.inferredType = typeInfo
		scheduleRemovalOfChildrenFromQueueRecursively(state, unary)
		replaceQueuedNode(state, unary, literal)

	elseif unary.operation == "#" then
		errorUnhandledNodeType(unary)

	else
		errorUnhandledNodeType(unary)
	end

	-- astPrintTree(unary.parent)
end

!NODE_INFERRER `function nodeInferrers.AstBinary(state, binary)`
	local typeInfoL = binary.left.inferredType
	local typeInfoR = binary.right.inferredType

	if not typeInfoL then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.left`)
	end
	if not typeInfoR then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.right`)
	end

	-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
	-- For now, both sides need to be the same exact type.
	if typeInfoL ~= typeInfoR then
		typeError(
			state, binary,
			"Binary operation: Operands are different types. (Left is %s, right is %s)",
			getFriendlyTypeInfoName(typeInfoL),
			getFriendlyTypeInfoName(typeInfoR)
		)
	end

	-- Numeric operation.
	if isAny(binary.operation, "+","-","*","^","%","/","//") then
		if not isAny(typeInfoL,
			getTypeInfoForBuiltinType(state, "int"),
			getTypeInfoForBuiltinType(state, "float")
		) then
			typeError(
				state, binary.left,
				"Binary operation: Expected a float or int. (Got %s)",
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		if     binary.operation == "/"  then  typeInfo = getTypeInfoForBuiltinType(state, "float") -- Cast to float.
		elseif binary.operation == "//" then  typeInfo = getTypeInfoForBuiltinType(state, "int")   -- Cast to int.
		else                                  typeInfo = typeInfoL  end                            -- Keep type.

	-- Comparison.
	elseif isAny(binary.operation, "<",">","<=",">=") then
		if not isAny(typeInfoL,
			getTypeInfoForBuiltinType(state, "int"),
			getTypeInfoForBuiltinType(state, "float"),
			getTypeInfoForBuiltinType(state, "string")
		) then
			typeError(
				state, binary.left,
				"Binary operation: Expected a float, int or string. (Got %s)",
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		typeInfo = getTypeInfoForBuiltinType(state, "bool")

	-- Equality.
	elseif isAny(binary.operation, "==","~=") then
		typeInfo = getTypeInfoForBuiltinType(state, "bool")

	-- Boolean operation.
	elseif isAny(binary.operation, "and","or") then
		if typeInfoL ~= getTypeInfoForBuiltinType(state, "bool") then
			typeError(state, binary.left, "Binary operation: Expected a bool. (Got %s)", getFriendlyTypeInfoName(typeInfoL))
		end
		typeInfo = getTypeInfoForBuiltinType(state, "bool")

	-- String concatination.
	elseif isAny(binary.operation, "..") then
		if typeInfoL ~= getTypeInfoForBuiltinType(state, "string") then
			typeError(state, binary.left, "Binary operation: Expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoL))
		end
		typeInfo = getTypeInfoForBuiltinType(state, "string")

	-- Lookup, or similar.
	elseif isAny(binary.operation, ".") then
		errorInternal("@Incomplete: Handle '.' operator.")

	else
		errorUnhandledNodeType(binary)
	end

	assert(typeInfo)
	binary.inferredType = typeInfo

	moveToNextPipe(state, binary)

	--
	-- Inferring complete! Now fold the expression if it's constant.
	-- @Incomplete: Fold these kinds of expressions: (1+x)+2 => (1+2)+x => 3+x
	-- @Incomplete: Fold these kinds of expressions: 1 + -x => 1 - x
	--

	-- Not sure if all the following is necessary. Won't we be doing the same thing
	-- when running bytecode? Is it faster to do this here?

	local isConstL, valueL = getLiteralValueFromExpressionIfConstant(state, binary.left)
	local isConstR, valueR = getLiteralValueFromExpressionIfConstant(state, binary.right)
	if not (isConstL and isConstR) then
		-- void

	!for _, opArithmeticKeepType in ipairs{"+","-","*","^","%"} do
	elseif binary.operation == !(opArithmeticKeepType) then
		local literal = astNewNode(AstLiteral, binary.token, binary.parent)

		literal.literalType
			=  typeInfo == getTypeInfoForBuiltinType(state, "int")   and !(LITERAL_INTEGER)
			or typeInfo == getTypeInfoForBuiltinType(state, "float") and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = valueL !!(opArithmeticKeepType) valueR
		literal.inferredType = typeInfo

		scheduleRemovalOfChildrenFromQueueRecursively(state, binary)
		replaceQueuedNode(state, binary, literal)
	!end

	elseif binary.operation == "/" then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = valueL/valueR
		literal.inferredType = typeInfo
		scheduleRemovalOfChildrenFromQueueRecursively(state, binary)
		replaceQueuedNode(state, binary, literal)

	elseif binary.operation == "//" then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = math.floor(valueL/valueR) -- Do we need to floor valueL and valueR before the division too?
		literal.inferredType = typeInfo
		scheduleRemovalOfChildrenFromQueueRecursively(state, binary)
		replaceQueuedNode(state, binary, literal)

	!for _, opComparison in ipairs{"<",">","<=",">=","==","~=","and","or"} do
	elseif binary.operation == !(opComparison) then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = valueL !!(opComparison) valueR
		literal.inferredType = typeInfo
		scheduleRemovalOfChildrenFromQueueRecursively(state, binary)
		replaceQueuedNode(state, binary, literal)
	!end

	elseif binary.operation == ".." then
		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = valueL..valueR -- @Speed: Concatinate more than two values at a time. (Probably need to update parsing stage.)
		literal.inferredType = typeInfo
		replaceQueuedNode(state, binary, literal)
		scheduleRemovalOfChildrenFromQueueRecursively(state, binary)

	elseif binary.operation == "." then
		errorUnhandledNodeType(binary)

	else
		errorUnhandledNodeType(binary)
	end

	-- astPrintTree(binary.parent)
end

-- !NODE_INFERRER `function nodeInferrers.AstTable(state, tableNode)`
-- 	for _, tableField in ipairs(tableNode) do
-- 		tableField.key
-- 		tableField.value
-- 	end
-- end

!NODE_INFERRER `function nodeInferrers.AstArgument(state, arg)`
	if arg.declaration.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`arg`, DEPEND_NODE_INFERRED, `arg.declaration`)
	end
	moveToNextPipe(state, arg)
end

!NODE_INFERRER `function nodeInferrers.AstArguments(state, args)` -- @Cleanup: Make AstArguments obsolete.
	for _, arg in ipairs(args) do
		if arg.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`args`, DEPEND_NODE_INFERRED, `arg`)
		end
	end

	args.inferredType = getTypeInfoForBuiltinType(state, "void") -- AstArguments is an expression, for some reason. @Cleanup

	moveToNextPipe(state, args)
end

!NODE_INFERRER `function nodeInferrers.AstLambda(state, lambda)`
	if lambda.argumentsIn and not lambda.argumentsIn.inferredType then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.argumentsIn`)
	end
	if lambda.argumentsOut and not lambda.argumentsOut.inferredType then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.argumentsOut`)
	end

	-- Note: We don't require the body to inferred.

	lambda.inferredType = getTypeInfoForLambda(state, lambda)
	assert(lambda.inferredType)

	moveToNextPipe(state, lambda)
end

!NODE_INFERRER `function nodeInferrers.AstTypeOf(state, typeOf)`
	if not typeOf.expression.inferredType then
		!DEPEND_AND_RETURN(`typeOf`, DEPEND_NODE_INFERRED, `typeOf.expression`)

	elseif typeOf.expression.inferredType == getTypeInfoForBuiltinType(state, "namespace") then
		typeError(state, typeOf.expression, "Namespaces don't have a type.")
	end

	typeOf.inferredType = getTypeInfoForBuiltinType(state, "type")

	moveToNextPipe(state, typeOf)
end

!NODE_INFERRER `function nodeInferrers.AstCast(state, cast)`
	if not cast.targetType.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.targetType`)
	end
	if not cast.expression.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.expression`)
	end

	local castTypeInfo

	if cast.targetType.nodeType == !(nodeTypes.AstType) then
		local typeNode = cast.targetType
		castTypeInfo   = typeNode.representedType
	elseif cast.targetType.nodeType == !(nodeTypes.AstTypeOf) then
		local typeOf   = cast.targetType
		castTypeInfo   = typeOf.expression.inferredType
	else
		errorUnhandledNodeType(cast.targetType)
	end

	if isAny(castTypeInfo, getTypeInfoForBuiltinType(state, "float"),getTypeInfoForBuiltinType(state, "int")) then
		if not isAny(cast.expression.inferredType, getTypeInfoForBuiltinType(state, "float"),getTypeInfoForBuiltinType(state, "int")) then
			typeError(
				state, cast.expression,
				"Cannot cast from %s to %s.",
				getFriendlyTypeInfoName(cast.expression.inferredType),
				getFriendlyTypeInfoName(castTypeInfo)
			)
		end
	else
		errorUnhandledNodeType(cast)
	end

	cast.inferredType = castTypeInfo
	moveToNextPipe(state, cast)
end

!NODE_INFERRER `function nodeInferrers.AstStatement(state, statement)`
	if statement.what.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`statement`, DEPEND_NODE_INFERRED, `statement.what`)
	end

	moveToNextPipe(state, statement)
end

!NODE_INFERRER `function nodeInferrers.AstAssignment(state, assignment)`
	for _, ident in ipairs(assignment.targets) do
		if not ident.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `ident`)
		end
	end

	for _, expr in ipairs(assignment.values) do
		if not expr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `expr`)
		end
	end

	for i, ident in ipairs(assignment.targets) do
		getAssignmentValue(state, ident, assignment.values, i, ident.inferredType)
	end

	-- @Incomplete: Check that !must args from functions have an assignment target.

	moveToNextPipe(state, assignment)
end

!NODE_INFERRER `function nodeInferrers.AstReturn(state, returnNode)`
	for _, valueExpr in ipairs(returnNode.values) do
		if not valueExpr.inferredType then
			!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `valueExpr`)
		end
	end

	local scope = getClosestScope(returnNode) or errorInternal()

	while scope.nodeType ~= !(nodeTypes.AstLambda) do
		if not isScopeImperative(scope) then -- This may eventually be AstFileScope, at most.
			-- I think this is an internal compiler error, actually. Parsing must have goofed up or something.
			typeError(state, scope, "Return statement is not in a function.")
		end

		scope = getClosestScope(scope) or errorInternal()
	end

	local lambda = scope

	if not lambda.inferredType then
		!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `lambda`)
	end

	--
	-- From now on we check that the correct stuff is returned.
	-- @Cleanup: Use getAssignmentValue() or something here?
	--

	local argTypesOut      = lambda.inferredType.argumentTypesOut
	local lastValueExpr    = getLast(returnNode.values)
	local returnValueCount = #returnNode.values

	local lastValueIsListToUnpack
		=   lastValueExpr ~= nil
		and lastValueExpr.nodeType == !(nodeTypes.AstCall)
		and not lastValueExpr.surroundedByParenthesis
		and lastValueExpr.inferredType.tag == !(typeTags.TypeInfoList)

	if lastValueIsListToUnpack then
		local listSig    = lastValueExpr.inferredType
		returnValueCount = returnValueCount - 1 + #listSig
	end

	if returnValueCount == #argTypesOut then
		-- void

	-- Too few values.
	elseif returnValueCount < #argTypesOut then
		-- @UX: Show a better message if lastValueExpr is a function call (not wrapped in parenthesis).
		typeError(state, returnNode, "Too few values to return. (Expected %d, got %d)", #argTypesOut, returnValueCount)

	-- Too many values.
	elseif not lastValueIsListToUnpack then
		local expr = astGetExpressionVisuallyFurthestToTheLeft(returnNode.values[#argTypesOut+1])
		typeError(state, expr, "Too many values to return. (Expected %d, got %d)", #argTypesOut, returnValueCount)
	else
		local callOutArgCount = #returnNode.values-1
		local listSig         = lastValueExpr.inferredType
		typeError(state, lastValueExpr, "Too many values returned from call. (Expected %d, got %d)", #argTypesOut-callOutArgCount, #listSig)
	end

	if lastValueIsListToUnpack then
		local listSig = lastValueExpr.inferredType

		for i = #returnNode.values, returnValueCount do
			local callOutArgIndex = i-#returnNode.values+1
			local typeInfo        = listSig[callOutArgIndex]

			if typeInfo ~= argTypesOut[i] then
				-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
				typeError(state, lastValueExpr,
					"Return value #%d from call is of incorrect type. (Wanted %s, got %s)",
					callOutArgIndex,
					getFriendlyTypeInfoName(argTypesOut[i]),
					getFriendlyTypeInfoName(typeInfo)
				)
			end
		end
	end

	for i = 1, #returnNode.values - (lastValueIsListToUnpack and 1 or 0) do
		local expr     = returnNode.values[i]
		local typeInfo = expr.inferredType

		if typeInfo.tag == !(typeTags.TypeInfoList) then
			local listSig = typeInfo
			typeInfo      = listSig[1]

			if not typeInfo then
				-- Note: TypeInfoLists are only used when calling functions (at the moment, at least). 2019-12-06
				typeError(state, expr, "Function call returns nothing. (Expected at least one value.)")
			end
		end

		if typeInfo ~= argTypesOut[i] then
			-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr),
				"Return value #%d is of incorrect type. (Wanted %s, got %s)",
				i,
				getFriendlyTypeInfoName(argTypesOut[i]),
				getFriendlyTypeInfoName(typeInfo)
			)
		end
	end

	moveToNextPipe(state, returnNode)
end

-- !NODE_INFERRER `function nodeInferrers.AstBreak(state, breakNode)`
-- 	breakNode.loopName
-- end

-- !NODE_INFERRER `function nodeInferrers.AstContinue(state, continue)`
-- 	continue.loopName
-- end

-- !NODE_INFERRER `function nodeInferrers.AstDefer(state, defer)`
-- 	defer.body
-- end

!NODE_INFERRER `function nodeInferrers.AstImport(state, import)`
	local path
	if import.isLoad then
		path = import.importName
	else
		typeError(state, import, "@Incomplete: !import")
	end

	local globalScope = state.globalScope

	if not state.fileBuffers[path] then
		-- @Incomplete: Include the times in compilation stats.
		local timeStartLexing, timeEndLexing = readAndTokenizeFile(state, path)
		assert(state.fileBuffers[path], path)

		local timeStartParsing = os.clock()
		local fileScope        = parseFileScope(state, globalScope, path)
		local timeEndParsing   = os.clock()

		table.insert(globalScope.fileScopes, fileScope)

		if peekNextToken(state) then
			errorParsingNext(state, "Expected the end of the file.")
		end

		addToQueueRecursively(state, fileScope)
	end

	import.fileScope = itemWith1(globalScope.fileScopes, "path", path) or errorInternal(path)

	import.inferredType = getTypeInfoForBuiltinType(state, "namespace")
	moveToNextPipe(state, import)
end

-- !NODE_INFERRER `function nodeInferrers.AstIf(state, ifBranch)`
-- 	ifBranch.condition
-- 	ifBranch.branchTrue
-- 	ifBranch.branchFalse
-- end

-- !NODE_INFERRER `function nodeInferrers.AstWhile(state, whileLoop)`
--  whileLoop.condition
--  whileLoop.body
-- end

-- !NODE_INFERRER `function nodeInferrers.AstFor(state, forLoop)`
-- 	forLoop.names[]
-- 	forLoop.expressions[]
-- 	forLoop.body
-- end

!NODE_INFERRER `function nodeInferrers.AstStruct(state, struct)`
	for _, decl in ipairs(struct.declarations) do
		if decl.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `decl`)
		end
	end

	local structInfo = newTypeInfo(TypeInfoStruct)

	for i, decl in ipairs(struct.declarations) do
		local member          = TypeInfoStructMember()
		member.name           = decl.names[1].name -- Note: Struct member declarations only have one name.
		member.typeInfo       = decl.inferredTypes[1]
		structInfo.members[i] = member
	end

	-- @Incomplete: struct.includedNamespaces[]
	-- @Incomplete: struct.arguments

	table.insert(state.allTypeInfos, structInfo)

	struct.representedType = structInfo
	struct.inferredType    = getTypeInfoForBuiltinType(state, "type")

	moveToNextPipe(state, struct)
end

!NODE_INFERRER `function nodeInferrers.AstEnum(state, enum)`
	for _, decl in ipairs(enum.declarations) do
		if decl.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `decl`)
		end
	end

	assert(enum.declarations[1], "Enums must have members.") -- This should have been caught during parsing.

	local enumMemberInfo

	if enum.memberType then
		enumMemberInfo = getTypeInfoForBuiltinType(state, enum.memberType.typeName)
	else
		-- Just use the type of the first member as the wanted type for the enum.
		-- Note: Struct member declarations only have one name.
		enumMemberInfo = enum.declarations[1].inferredTypes[1]
		if not isAny(enumMemberInfo,
			getTypeInfoForBuiltinType(state, "int"),
			getTypeInfoForBuiltinType(state, "string"),
			getTypeInfoForBuiltinType(state, "type"),
			getTypeInfoForBuiltinType(state, "bool"),
			getTypeInfoForBuiltinType(state, "float")
		) then
			typeError(state, enum, "Supported enum member types are: int, string, type, bool, float")
		end
	end

	local enumInfo = newTypeInfo(TypeInfoEnum)

	for i, decl in ipairs(enum.declarations) do
		local valExpr = decl.assignment.values[1]

		if valExpr.inferredType ~= enumMemberInfo then
			-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
			typeError(state, valExpr,
				"Incorrect value type for '%s'. (Wanted %s, got %s)",
				decl.names[1].name,
				getFriendlyTypeInfoName(enumMemberInfo),
				getFriendlyTypeInfoName(valExpr.inferredType)
			)
		end

		local member        = TypeInfoEnumMember()
		member.name         = decl.names[1].name
		enumInfo.members[i] = member
	end

	-- @Incomplete: enum.includedNamespaces[]

	table.insert(state.allTypeInfos, enumInfo)

	enum.representedType = enumInfo
	enum.inferredType    = getTypeInfoForBuiltinType(state, "type")

	moveToNextPipe(state, enum)
end

!NODE_INFERRER `function nodeInferrers.AstFileScope(state, fileScope)`
	for _, decl in ipairs(fileScope.declarations) do
		if decl.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`fileScope`, DEPEND_NODE_INFERRED, `decl`)
		end
	end

	-- @Incomplete: fileScope.imports[]

	moveToNextPipe(state, fileScope)
end

!NODE_INFERRER `function nodeInferrers.AstGlobalScope(state, globalScope)`
	for _, fileScope in ipairs(globalScope.fileScopes) do
		if fileScope.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`globalScope`, DEPEND_NODE_INFERRED, `fileScope`)
		end
	end

	-- @Incomplete: globalScope.includedNamespaces[]

	moveToNextPipe(state, globalScope)
end

!NODE_INFERRER `function nodeInferrers.AstBlock(state, block)`
	for _, statement in ipairs(block) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`block`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextPipe(state, block)
end

function _G.inferNode(state, node)
	local nodeInferrer = nodeInferrers[node.nodeType] or errorUnhandledNodeType(node)
	return nodeInferrer(state, node)
end



-- expressionIsContant, value = getLiteralValueFromExpressionIfConstant( compilationState, expression )
-- Note: It's assumed that the expression tree has all types figured out.
function _G.getLiteralValueFromExpressionIfConstant(state, expr)
	-- @Incomplete: Return an AstNode?

	if expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		return true, literal.value

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local defn  = ident.definition
		local decl  = defn.name.declaration or errorInternal()

		if not decl.isConstant then  return false, nil  end

		assert(decl.assignment) -- Constant declarations must have a value.

		local i         = indexWith1(decl.names, "name", ident.name) or errorInternal()
		local valueExpr = getAssignmentValue(state, ident, decl.assignment.values, i)

		return getLiteralValueFromExpressionIfConstant(state, valueExpr)

	elseif isAny(expr.nodeType, !(nodeTypes.AstType),!(nodeTypes.AstTypeOf)) then
		return true, nil -- All types are constant, just like literals.

	elseif isAny(expr.nodeType, !(nodeTypes.AstLambda),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum)) then
		return true, nil -- Lambdas (which are function signatures), structs and enums are types (which are constant, just like literals).

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast       = expr
		local isConst, v = getLiteralValueFromExpressionIfConstant(state, cast.expression)
		if not isConst then  return false, nil  end

		if cast.inferredType == getTypeInfoForBuiltinType(state, "int") then
			return true, math.floor(v)
		elseif cast.inferredType == getTypeInfoForBuiltinType(state, "float") then
			return true, v
		else
			errorInternal("Unhandled cast type: %s", getFriendlyTypeInfoName(cast.inferredType))
		end

	elseif isAny(expr.nodeType, !(nodeTypes.AstBinary),!(nodeTypes.AstBinary)) then
		return false, nil -- We don't check child nodes as those should have been folded into 'expr' where this function is called.

	elseif expr.nodeType == !(nodeTypes.AstCall) then
		return false, nil -- Calls are always a runtime operation.

	elseif expr.nodeType == !(nodeTypes.AstImport) then
		return true, nil -- Namespaces, just like types, are always constant.

	else
		errorUnhandledNodeType(expr)
	end
end



-- expression, typeInfo = getAssignmentValue( state, ident, values, i [, expectedTypeInfo=any ] )
function _G.getAssignmentValue(state, ident, values, i, typeInfoExpected)
	local valueExpr = values[i]

	-- Non-call value or value not last in list.
	if valueExpr and not (valueExpr.nodeType == !(nodeTypes.AstCall) and not valueExpr.surroundedByParenthesis) then
		if typeInfoExpected and valueExpr.inferredType ~= typeInfoExpected then
			-- @Cleanup: Define isTypeCompatibleWith(typeToCheck, otherType) or something.
			if valueExpr.inferredType.tag ~= typeInfoExpected.tag then
				typeError(
					state, valueExpr,
					"Value and type mismatch. ('%s' is %s, value is %s)",
					ident.name,
					getFriendlyTypeInfoName(typeInfoExpected),
					getFriendlyTypeInfoName(valueExpr.inferredType)
				)

			elseif typeInfoExpected.tag == !(typeTags.TypeInfoFunction) then
				typeError(
					state, valueExpr,
					"Function signature is different from the type of '%s'. (Wanted %s, got %s)",
					ident.name,
					getFriendlyTypeInfoName(typeInfoExpected),
					getFriendlyTypeInfoName(valueExpr.inferredType)
				)

			elseif typeInfoExpected.tag == !(typeTags.TypeInfoStruct) then
				typeError(
					state, valueExpr,
					"Value and type mismatch. Expected a struct initializer for %s.",
					getFriendlyTypeInfoName(typeInfoExpected)
				)

			else
				typeError(state, valueExpr, "Value and type mismatch.")
			end
		end

		return valueExpr, valueExpr.inferredType
	end

	-- Value list ending in a call (hopefully).
	local call      = valueExpr
	local lastIndex = #values

	if not call then
		-- We're past the end of the list - get the last specified value.
		call = values[lastIndex]

		if call.nodeType ~= !(nodeTypes.AstCall) then
			typeError(state, call, "Expected a function call. Missing a value for '%s'.", ident.name)
		elseif call.surroundedByParenthesis then
			typeError(state, ident, "Missing a value for '%s'.", ident.name)
		end
	end

	local argIndex = i-lastIndex+1

	local typeInfoForCall = call.inferredType
	local listSig

	if typeInfoForCall.tag == !(typeTags.TypeInfoList) then
		listSig = typeInfoForCall
	elseif typeInfoForCall.tag == !(typeTags.TypeInfoVoid) then
		typeError(state, call, "Called function does not return anything.") -- Only function calls can be void at the moment. 2019-12-04
	else
		typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfoForCall))
	end

	local typeInfoForOutArg = listSig[argIndex]
	if not typeInfoForOutArg then
		typeError(state, call, "Function does not return anything for '%s' (return value #%d).", ident.name, argIndex)
	end

	if typeInfoExpected and typeInfoForOutArg ~= typeInfoExpected then
		local calleeName = (call.callee.nodeType == !(nodeTypes.AstIdentifier) and call.callee.name or "?")
		typeError(
			state, call,
			"The type of return value #%d of '%s' (%s) does not match the type of '%s' (%s).",
			argIndex,
			calleeName,
			getFriendlyTypeInfoName(typeInfoForOutArg),
			ident.name,
			getFriendlyTypeInfoName(typeInfoExpected)
		)
	end

	return call, typeInfoForOutArg
end


