--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	checkBinaryOperation
	createTypeNodeFromInfo
	findDeclaration, findDeclarationInScope, findMemberDeclaration, findDynamicMemberDeclaration, isDeclarationVisibleToNode, printDeclarationChain
	followIdentifiersToConstantValue
	getAssignmentValue
	getClosestScope, getClosestScopeForDeclaration, isScope, isScopeDeclarative, isScopeImperative
	getDeclarationValue
	inferNode
	isExpressionConstant
	isPartOfAnyDeclaration
	isTypeSimple, isTypeNumeric, isTypeTableLike, isTypeCompatibleWith, adjustTypeToOne
	newTypeInfo, isTypeBuiltin, getTypeInfo*
	simplifyExpressionIfConstant, simplifyTypeExpression
	typeError, typeErrorAfter, typeError2, typeMessage
	wrapInImplicitCast

--============================================================]]



!(
_G.typeTags        = {}
local lastTypeTag  = 0
local typeTagNames = {}

local function structTypeInfo(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			lastTypeTag               = lastTypeTag+1

			fields._overrides         = fields._overrides or {}
			table.insert(fields._overrides, {`tag`, lastTypeTag})

			typeTags[name]            = lastTypeTag
			typeTagNames[lastTypeTag] = name:gsub("^TypeInfo", ""):lower()
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_TypeInfo"{
	{`tag`, 0}, -- This is like a "type of type info". The word "type" is used in so many places so we call it "tag" here to make it less confusing...
	{`id`,  0},
}

local !structTypeInfo"TypeInfoAny:_TypeInfo"{}
local !structTypeInfo"TypeInfoBool:_TypeInfo"{}
local !structTypeInfo"TypeInfoInt:_TypeInfo"{}
local !structTypeInfo"TypeInfoNone:_TypeInfo"{}
local !structTypeInfo"TypeInfoFloat:_TypeInfo"{}
local !structTypeInfo"TypeInfoString:_TypeInfo"{}
local !structTypeInfo"TypeInfoTable:_TypeInfo"{}
local !structTypeInfo"TypeInfoType:_TypeInfo"{}

local !structTypeInfo"TypeInfoVoid:_TypeInfo"{}
local !structTypeInfo"TypeInfoPlaceholder:_TypeInfo"{}
local !structTypeInfo"TypeInfoForeignDummy:_TypeInfo"{}

_G.!(local )!!SIMPLE_TYPE_TAG = {
	-- These small type infos don't have any extra information.
	[typeTags.TypeInfoAny]    = true,
	[typeTags.TypeInfoBool]   = true,
	[typeTags.TypeInfoInt]    = true,
	[typeTags.TypeInfoNone]   = true,
	[typeTags.TypeInfoFloat]  = true,
	[typeTags.TypeInfoString] = true,
	[typeTags.TypeInfoTable]  = true,
	[typeTags.TypeInfoType]   = true,
}

local !structTypeInfo"TypeInfoArray:_TypeInfo"{
	{`itemType`, nil}, -- TypeInfo
}

local !structTypeInfo"TypeInfoVararg:_TypeInfo"{
	{`itemType`, nil}, -- TypeInfo
}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{ -- AKA function signature.
	{`argumentTypesIn`,      {}}, -- []TypeInfo  @Cleanup: Use TypeInfoList here?
	{`argumentTypesOut`,     {}}, -- []TypeInfo  @Cleanup: Use TypeInfoList here?
	{`requiredArgumentsIn`,  {}}, -- []bool
	{`requiredArgumentsOut`, {}}, -- []bool
	{`isPolymorphic`,        false},
}

local !struct"TypeInfoStructMember"{
	{`name`,     ""},
	{`typeInfo`, nil},
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	{`astNode`,       nil}, -- AstStruct
	{`name`,          ""},  -- Filled in during definition.

	{`members`,       {}},  -- []TypeInfoStructMember
	{`hasMembers`,    false},

	{`isPolymorphic`, false},
}

local !struct"TypeInfoEnumMember"{
	{`name`, ""},
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	{`astNode`,        nil}, -- AstEnum
	{`name`,           ""},
	{`memberTypeInfo`, nil}, -- Must be one of these primitive types: int, string, type, bool or float.
	{`members`,        {}},  -- []TypeInfoEnumMember
}

local !structTypeInfo"TypeInfoNamespace:_TypeInfo"{
	{`scope`, nil}, -- AstScope
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	-- [1]=typeInfo1, ...
}

local !structTypeInfo"TypeInfoList:_TypeInfo"{ -- Special type used for returns from calls (both when sending and receiving).
	-- [1]=typeInfo1, ...
}

_G.TYPE_TAG_NAMES         = !(typeTagNames)
_G.XXX_TYPE_TAG_FUNCTION  = !(typeTags.TypeInfoFunction)
_G.XXX_TYPE_TAG_NAMESPACE = !(typeTags.TypeInfoNamespace)



-- typeInfo = newTypeInfo( TypeInfoCreator )
do
	local lastTypeId = 0

	function _G.newTypeInfo(TypeInfoCreator)
		!ifDEBUG `if not TypeInfoCreator then  errorInternal(2, "No TypeInfoCreator specified.")  end`

		lastTypeId = lastTypeId+1

		local typeInfo = TypeInfoCreator()
		typeInfo.id    = lastTypeId

		--[[
		if lastTypeId == 22 then
			errorInternal("DEBUG")
		end
		--]]

		return typeInfo
	end
end

do
	local builtinTypeInfos = {}

	local BUILTIN_TYPE_STRUCTS = {
		["any"]         = TypeInfoAny,
		["bool"]        = TypeInfoBool,
		["int"]         = TypeInfoInt,
		["none"]        = TypeInfoNone,
		["float"]       = TypeInfoFloat,
		["string"]      = TypeInfoString,
		["table"]       = TypeInfoTable,
		["type"]        = TypeInfoType,         -- The result of e.g. type_of(int) or type_of(type_of(expression)).
		["void"]        = TypeInfoVoid,         -- Used when no useful type is expected or available.
		["placeholder"] = TypeInfoPlaceholder,  -- Used in polymorphic functions.
		["foreign"]     = TypeInfoForeignDummy, -- Dummy type used for foreign constants in bytecode pipe and forward.
	}

	function _G.getTypeInfoForBuiltinType(state, typeName)
		local typeInfo = builtinTypeInfos[typeName]

		if not typeInfo then
			local TypeInfoCreator      = BUILTIN_TYPE_STRUCTS[typeName] or errorInternal(tostring(typeName))
			typeInfo                   = newTypeInfo(TypeInfoCreator)
			builtinTypeInfos[typeName] = typeInfo

			table.insert(state.allTypeInfos, typeInfo)
		end

		return typeInfo
	end

	-- bool, typeName = isTypeBuiltin( typeInfo )
	function _G.isTypeBuiltin(typeInfo)
		!ASSERT `typeInfo`
		if typeInfo == builtinTypeInfos["any"]         then  return true, "any"          end
		if typeInfo == builtinTypeInfos["bool"]        then  return true, "bool"         end
		if typeInfo == builtinTypeInfos["int"]         then  return true, "int"          end
		if typeInfo == builtinTypeInfos["none"]        then  return true, "none"         end
		if typeInfo == builtinTypeInfos["float"]       then  return true, "float"        end
		if typeInfo == builtinTypeInfos["string"]      then  return true, "string"       end
		if typeInfo == builtinTypeInfos["table"]       then  return true, "table"        end
		if typeInfo == builtinTypeInfos["type"]        then  return true, "type"         end
		if typeInfo == builtinTypeInfos["placeholder"] then  return true, "placeholder"  end
		return false, ""
	end
end

local function doesLambdaHaveSignature(lambda, funcSig)
	if (lambda.argumentsIn  and #lambda.argumentsIn .arguments or 0) ~= #funcSig.argumentTypesIn  then  return false  end
	if (lambda.argumentsOut and #lambda.argumentsOut.arguments or 0) ~= #funcSig.argumentTypesOut then  return false  end

	if lambda.argumentsIn then
		for i, arg in ipairs(lambda.argumentsIn.arguments) do
			if arg.declaration.name.inferredType ~= funcSig.argumentTypesIn[i]      then  return false  end
			if arg.isRequired                    ~= funcSig.requiredArgumentsIn[i]  then  return false  end
		end
	end
	if lambda.argumentsOut then
		for i, arg in ipairs(lambda.argumentsOut.arguments) do
			if arg.declaration.name.inferredType ~= funcSig.argumentTypesOut[i] then  return false  end
		end
	end

	if lambda.isPolymorphic ~= funcSig.isPolymorphic then  return false  end

	return true
end

function _G.getTypeInfoForLambda(state, lambda)
	if lambda.argumentsIn then
		for _, arg in ipairs(lambda.argumentsIn.arguments) do
			if not arg.declaration.name.inferredType then  return nil  end
		end
	end
	if lambda.argumentsOut then
		for _, arg in ipairs(lambda.argumentsOut.arguments) do
			if not arg.declaration.name.inferredType then  return nil  end
		end
	end

	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoFunction) and doesLambdaHaveSignature(lambda, typeInfoCached) then
			return typeInfoCached
		end
	end

	local funcSig         = newTypeInfo(TypeInfoFunction)
	funcSig.isPolymorphic = lambda.isPolymorphic

	if lambda.argumentsIn then
		for i, arg in ipairs(lambda.argumentsIn.arguments) do
			funcSig.argumentTypesIn[i]      = arg.declaration.name.inferredType
			funcSig.requiredArgumentsIn[i]  = arg.isRequired
		end
	end
	if lambda.argumentsOut then
		for i, arg in ipairs(lambda.argumentsOut.arguments) do
			funcSig.argumentTypesOut[i]     = arg.declaration.name.inferredType
			funcSig.requiredArgumentsOut[i] = arg.isRequired
		end
	end

	table.insert(state.allTypeInfos, funcSig)
	return funcSig
end

do
	local function getTypeInfoForListOrCompoundType(state, typeInfos, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfos) do
			if typeInfoCached.tag == tag and areArraysEqual(typeInfos, typeInfoCached) then
				return typeInfoCached
			end
		end

		local typeInfo = newTypeInfo(schematicForTypeInfo)
		copyToArray(typeInfos, typeInfo)
		table.insert(state.allTypeInfos, typeInfo)

		return typeInfo
	end

	function _G.getTypeInfoForList(state, typeInfos)
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(typeTags.TypeInfoList), TypeInfoList)
	end

	-- Note: typeInfos is expected to be sorted by type ID.
	function _G.getTypeInfoForCompoundType(state, typeInfos)
		return getTypeInfoForListOrCompoundType(state, typeInfos, !(typeTags.TypeInfoCompound), TypeInfoCompound)
	end
end

do
	local function getTypeInfoForArrayOrVararg(state, itemType, tag, schematicForTypeInfo)
		for _, typeInfoCached in ipairs(state.allTypeInfos) do
			if typeInfoCached.tag == tag and itemType == typeInfoCached.itemType then
				return typeInfoCached
			end
		end

		local typeInfo    = newTypeInfo(schematicForTypeInfo)
		typeInfo.itemType = itemType
		table.insert(state.allTypeInfos, typeInfo)

		return typeInfo
	end

	function _G.getTypeInfoForArray(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(typeTags.TypeInfoArray), TypeInfoArray)
	end

	function _G.getTypeInfoForVararg(state, itemType)
		return getTypeInfoForArrayOrVararg(state, itemType, !(typeTags.TypeInfoVararg), TypeInfoVararg)
	end
end

function _G.getTypeInfoForNamespace(state, scope)
	!ASSERT `scope`

	for _, typeInfoCached in ipairs(state.allTypeInfos) do
		if typeInfoCached.tag == !(typeTags.TypeInfoNamespace) and scope == typeInfoCached.scope then
			return typeInfoCached
		end
	end

	local namespace = newTypeInfo(TypeInfoNamespace)
	namespace.scope = scope
	table.insert(state.allTypeInfos, namespace)

	return namespace
end



-- Note: The expression must already be inferred!
function _G.getTypeRepresentedByExpression(expr)
	!ASSERT `expr.inferredType`

	if expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		return typeNode.representedType
	elseif expr.nodeType == !(nodeTypes.AstStruct) then
		local struct = expr
		return struct.representedType
	elseif expr.nodeType == !(nodeTypes.AstEnum) then
		local enum = expr
		return enum.representedType
	elseif expr.nodeType == !(nodeTypes.AstTypeOf) then
		local typeOf = expr
		return typeOf.representedType
	elseif expr.nodeType == !(nodeTypes.AstAccess) then -- Not sure if this is needed. @Cleanup
		local access = expr
		return access.representedType -- May be nil.

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		return
			cast.inferredType.tag == !(typeTags.TypeInfoType) -- Is this check needed?
			and getTypeRepresentedByExpression(cast.expression)
			or  nil

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		return ident.declaration.valueTypeInfo -- May be nil.
	elseif expr.nodeType == !(nodeTypes.AstBake) then
		local bake = expr
		return bake.name.declaration.valueTypeInfo -- May be nil.

	elseif expr.inferredType.tag == !(typeTags.TypeInfoType) then
		errorInternal("Incomplete: Unhandled node type: %s", getFriendlyTypeInfoName(expr.inferredType))
	else
		return nil
	end
end

-- Note: The expression must already be inferred!
function _G.requireTypeRepresentedByExpression(state, expr)
	local typeInfoRepresented = getTypeRepresentedByExpression(expr)
	if typeInfoRepresented then  return typeInfoRepresented  end

	local typeInfo = expr.inferredType

	if typeInfo.tag ~= !(typeTags.TypeInfoType) then
		typeError(state, expr, "Expected a type. (Got %s)", getFriendlyTypeInfoName(typeInfo))
	elseif not isExpressionConstant(state, expr) then
		typeError(state, expr, "Expected a constant. (Got variable of type '%s')", getFriendlyTypeInfoName(typeInfo))
	else
		!ifDEBUG `print(getFriendlyTypeInfoName(typeInfo))`
		errorInternal(state, expr, "The expression should represent a type but we somehow don't have any TypeInfo.")
	end
end



-- scope, childClosestToScope = getClosestScope( node )
function _G.getClosestScope(node)
	-- @Incomplete: Treat global declarations differently and depricate
	-- getClosestScopeForDeclaration() (or simply change the parent of
	-- globals to the actual globalScope, though that has problems too).
	return astFindParent(node,
		!outputCommaSeparatedValues(unpack(scopeNodeTypes))
	)
end

-- Since the physical parent of global declarations actually is a file scope
-- we have to treat these declarations differently sometimes. This function
-- returns the correct scope for global declarations.
function _G.getClosestScopeForDeclaration(state, decl)
	-- do return getClosestScope(decl) end
	if decl.isGlobalOrExported then
		local fileScope = astFindParent(decl, !(nodeTypes.AstFileScope))
		if fileScope and not fileScope.isModule then  return state.globalScope  end
	end
	return (getClosestScope(decl))
end

function _G.isScope           (node)   return SCOPE_SET            [node .nodeType] or false  end
function _G.isScopeDeclarative(scope)  return SCOPE_SET_DECLARATIVE[scope.nodeType] or false  end
function _G.isScopeImperative (scope)  return SCOPE_SET_IMPERATIVE [scope.nodeType] or false  end



-- declaration, fromUsing = findDeclaration( state, startNode, name [, declarationToIgnore ] )
function _G.findDeclaration(state, startNode, name, declToIgnore)
	local scope = isScope(startNode) and startNode or getClosestScope(startNode)

	while scope do
		for _, decl in ipairs(scope.declarations) do
			if decl ~= declToIgnore and decl.name.name == name and isDeclarationVisibleToNode(decl, startNode) then
				return decl, nil
			end
		end

		-- @Speed: Don't re-check already checked declarations. (Any potential speed-up may be neglectable though. Need to test with a bigger program.)

		for _, import in ipairs(scope.imports) do
			if import.fileScope then
				for _, decl in ipairs(import.fileScope.declarations) do
					if decl ~= declToIgnore and decl.isGlobalOrExported and decl.name.name == name then
						return decl, nil
					end
				end
			end
		end

		for _, using in ipairs(scope.usings) do
			if using.scope then
				for _, decl in ipairs(using.scope.declarations) do
					if
						decl ~= declToIgnore and decl.name.name == name and (
							decl.isConstant or (
								using.variableDeclaration
								and isDeclarationVisibleToNode(using.variableDeclaration, startNode)
							)
						)
					then
						return decl, using
					end
				end
			end
		end

		for _, decl in ipairs(scope.declarationsInTree[name] or EMPTY_TABLE) do
			if decl ~= declToIgnore and isDeclarationVisibleToNode(decl, startNode) then
				return decl, nil
			end
		end

		-- Don't cross any module boundary!
		if scope.nodeType == !(nodeTypes.AstFileScope) and scope.isModule then
			break
		end

		scope = getClosestScope(scope)
	end

	return nil, nil
end

function _G.findDeclarationInScope(state, scope, name, onlyLookInExportsIfScopeIsModule)
	!ASSERT `type(onlyLookInExportsIfScopeIsModule) == "boolean"`

	if onlyLookInExportsIfScopeIsModule and scope.nodeType == !(nodeTypes.AstFileScope) and scope.isModule then
		for _, decl in ipairs(scope.declarations) do
			if decl.isGlobalOrExported and decl.name.name == name then  return decl  end
		end
	else
		for _, decl in ipairs(scope.declarations) do
			if decl.name.name == name then  return decl  end
		end
	end

	return nil
end

function _G.findMemberDeclaration(state, scope, name)
	for _, decl in ipairs(scope.declarations) do
		if decl.name.name == name then  return decl  end
	end
	return nil
end
function _G.findDynamicMemberDeclaration(state, scope, name)
	for _, decl in ipairs(scope.declarations) do
		if not decl.isConstant and decl.name.name == name then  return decl  end
	end
	return nil
end

function _G.isDeclarationVisibleToNode(decl, node)
	if decl.isGlobalOrExported then  return true  end

	local nodeScope, nodeScopeChild = getClosestScope(node)
	local canSeeImperativeVariables = not decl.isConstant -- It doesn't matter if this is true and we're in a declarative scope because we check that in the loop below.

	while true do
		if not indexOf(nodeScope.declarations, decl) then
			-- void  (Keep looking through parent scopes and update canSeeImperativeVariables as we go.)

		elseif decl.isConstant or isScopeDeclarative(nodeScope) then
			return true

		elseif not canSeeImperativeVariables then
			return false

		elseif isAny(nodeScope.nodeType, !(nodeTypes.AstFor),!(nodeTypes.AstLambda)) then -- These are really a combination of declarative and imperative scopes.
			return true

		elseif nodeScope.nodeType == !(nodeTypes.AstBlock) then
			local block = nodeScope

			-- Note: If the node is inside the initial assignment then we need to treat the declaration
			-- and the assignment as if they were the same statement. Otherwise the assignment will be
			-- able to see it's own declarations, which is illegal!
			local declScope, declScopeChild = getClosestScope(decl.assignment or decl)

			if declScope == block then
				local imperativeIndexForDecl = indexOf(block.statements, declScopeChild) or errorInternal()
				local imperativeIndexForNode = indexOf(block.statements, nodeScopeChild) or errorInternal()

				return (imperativeIndexForDecl < imperativeIndexForNode)

			else
				-- The declaration is probably from a using. The only things you can use right
				-- now are structs and enums, both being declarative scopes. 2020-01-03
				assert(isScopeDeclarative(declScope))
				return true
			end

		else
			errorUnhandledNodeType(state, nodeScope)
		end

		if canSeeImperativeVariables and nodeScope.nodeType == !(nodeTypes.AstLambda) then
			-- Lambdas act as the only boundary between imperative and declarative
			-- scopes right now. Maybe this will change in the future? 2019-12-07
			canSeeImperativeVariables = false
		end

		nodeScope, nodeScopeChild = getClosestScope(nodeScope)
		if not nodeScope then  return false  end -- This shouldn't happen I don't think, unless decl and node is not part of the same tree.
	end
end

-- printDeclarationChain( [ file=io.stdout, ] state, declaration, typeName )
function _G.printDeclarationChain(file, state, decl, typeName)
	if type(file) ~= "userdata" then  return printDeclarationChain(io.stdout, file, state, decl)  end

	!local MAX_CHAIN_LENGTH = 10

	for _ = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(file, state, decl.name, "Info", "...here is '%s' declared.", typeName)

		local declCurrent = decl.name.declaration -- @Cleanup: Can we use decl.name.declaration instead here?
		if not declCurrent then  break  end

		decl            = nil
		local valueExpr = getDeclarationValue(declCurrent)

		if valueExpr then
			while valueExpr.replacing do  valueExpr = valueExpr.replacing  end

			if valueExpr.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = valueExpr
				typeName    = ident.name
				decl        = ident.declaration or findDeclaration(state, ident, typeName, declCurrent)
			end
		end

		if not decl then  break  end
	end
end



function _G.typeError(state, node, s, ...)
	nodeError(state, node, "Typer", s, ...)
end
function _G.typeErrorAfter(state, node, s, ...)
	nodeErrorAfter(state, node, "Typer", s, ...)
end

function _G.typeError2(state, node1, s1, node2, s2)
	printerr()
	!ifDEBUG `astPrint(node1)`
	typeMessage(io.stderr, state, node1, "Error", "%s", s1)
	!ifDEBUG `astPrint(node2)`
	typeMessage(io.stderr, state, node2, "Info",  "%s", s2)
	exitFailure()
end

-- typeMessage( [ outputFile=io.stdout, ] compilationState, node, label, formatString, ... )
function _G.typeMessage(file, state, node, label, s, ...)
	if type(file) ~= "userdata" then  return typeMessage(io.stdout, file, state, node, label, s, ...)  end
	return nodeMessage(file, state, node, label, "Typer", s, ...)
end



function _G.getFriendlyTypeInfoName(typeInfo)
	local name = ""

	if typeInfo.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		name             = structInfo.name

		if structInfo.astNode.polymorphSourceStruct then
			local params = {}

			for argIndex, declBaked in ipairs(structInfo.astNode.bakeDeclarations) do
				local valueExpr = declBaked.value

				if valueExpr.nodeType == !(nodeTypes.AstLiteral) then
					local literal    = valueExpr
					params[argIndex] = literal.literalType == !(LITERAL_STRING) and F("%q", literal.value) or tostring(literal.value)

				elseif valueExpr.nodeType == !(nodeTypes.AstType) then
					local typeNode   = valueExpr
					params[argIndex] = getFriendlyTypeInfoName(typeNode.representedType)

				else
					params[argIndex] = "~"
				end
			end

			name
				= structInfo.astNode.polymorphSourceStruct.representedType.name
				.."("..table.concat(params, ",")..")"
		end

	elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo = typeInfo
		name           = enumInfo.name

	elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
		local funcSig      = typeInfo
		local typeTextsIn  = {}
		local typeTextsOut = {}

		for i, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			if i > 1 then
				table.insert(typeTextsIn, ",")
			end
			table.insert(typeTextsIn, getFriendlyTypeInfoName(argTypeInfo))
			if not (funcSig.requiredArgumentsIn[i] or argTypeInfo.tag == !(typeTags.TypeInfoVararg)) then
				table.insert(typeTextsIn, "?")
			end
		end

		for i, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			typeTextsOut[i] = getFriendlyTypeInfoName(argTypeInfo)
		end

		name = typeTextsOut[1]
			and F("function(%s)->(%s)", table.concat(typeTextsIn), table.concat(typeTextsOut, ","))
			or  F("function(%s)->void", table.concat(typeTextsIn))

	elseif typeInfo.tag == !(typeTags.TypeInfoCompound) then
		local compound  = typeInfo
		local typeTexts = {}

		for i, compoundItem in ipairs(compound) do
			typeTexts[i] = getFriendlyTypeInfoName(compoundItem)
		end

		name = table.concat(typeTexts, "|")

	elseif typeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig   = typeInfo
		local typeTexts = {}

		for i, typeInfo in ipairs(listSig) do
			typeTexts[i] = getFriendlyTypeInfoName(typeInfo)
		end

		name = "list("..table.concat(typeTexts, ", ")..")"

	elseif typeInfo.tag == !(typeTags.TypeInfoArray) then
		local arraySig = typeInfo
		name           = "array("..getFriendlyTypeInfoName(arraySig.itemType)..")"

	elseif typeInfo.tag == !(typeTags.TypeInfoVararg) then
		local varargSig = typeInfo
		name            = "..."..getFriendlyTypeInfoName(varargSig.itemType)
	end

	if name == "" then
		name = TYPE_TAG_NAMES[typeInfo.tag] or errorInternal("%d", typeInfo.tag)
	end

	-- !(if DEBUG then)  name = name.."@"..typeInfo.id  !(end)

	return name
end



local nodeInferrers = {}

!(
local nodeNames = {}

local function NODE_INFERRER(funcHeaderCode)
	local replacements

	funcHeaderCode, replacements = funcHeaderCode:gsub("function +nodeInferrers%.(Ast%w+)", function(nodeName)
		if nodeNames[nodeName] then
			error("Duplicate node inferrer: "..nodeName)
		end
		nodeNames[nodeName] = true

		local nodeType = nodeTypes[nodeName] or error(nodeName)
		return "nodeInferrers[--[["..nodeName.."]]"..nodeType.."] = function"
	end)

	assert(replacements == 1, funcHeaderCode)

	__LUA(funcHeaderCode)
end
)

function _G.isPartOfAnyDeclaration(identOrVararg)
	local parent = identOrVararg.parent

	if parent.nodeType == !(nodeTypes.AstDeclaration) then
		local decl = parent
		return identOrVararg == decl.name

	elseif parent.nodeType == !(nodeTypes.AstAssignment) then
		local assignment = parent
		return assignment.forDeclaration and indexOf(assignment.targets, identOrVararg) ~= nil

	else
		return false
	end
end

-- identifierEarly, identifierLate, extraShadowMessageEarly, extraShadowMessageLate = getEarlyAndLateForRedeclarationError( state, identifier1, identifier2 )
local function getEarlyAndLateForRedeclarationError(state, identEarly, identLate)
	local extraMessageEarly = ""
	local extraMessageLate  = ""

	-- Globals before locals.
	if identEarly.declaration.isGlobalOrExported ~= identLate.declaration.isGlobalOrExported then
		if identLate.declaration.isGlobalOrExported then
			identEarly, identLate = identLate, identEarly
		end

	-- Constants before variables.
	elseif identEarly.declaration.isConstant ~= identLate.declaration.isConstant then
		if identLate.declaration.isConstant then
			identEarly, identLate = identLate, identEarly
		end

		if isScopeImperative(getClosestScopeForDeclaration(state, identLate.declaration)) then
			extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope, unlike variables.)"
		end

	-- Low depth before high depth.
	-- Early in file before late in file.
	else
		local depthEarly = astGetDepth(identEarly)
		local depthLate  = astGetDepth(identLate)

		if depthLate < depthEarly or (depthLate == depthEarly and identLate.token < identEarly.token) then
			-- @Incomplete: Explicitly handle the identifiers being declared in different files. (May be unnecessary.)
			identEarly, identLate = identLate, identEarly
		end

		if identEarly.declaration.isConstant and isScopeImperative(getClosestScopeForDeclaration(state, identEarly.declaration)) then
			extraMessageEarly = " (Note that constants in imperative scopes are visible to the whole scope.)"
		end
	end

	return identEarly, identLate, extraMessageEarly, extraMessageLate
end

local function checkRedeclaration(state, ident, decl, isMember, scope)
	decl.checkedRedeclaration = true

	local declExisting = findDeclaration(state, ident, ident.name, decl)
	if not declExisting then  return  end
	!ASSERT `declExisting ~= decl`

	local scopeExisting = getClosestScopeForDeclaration(state, declExisting)

	-- Member.
	if isMember and not decl.isConstant and scope ~= scopeExisting then
		-- void  (Variable members never shadow anything.)

	-- Function overload. (Note: Overloads have to be registered before the identifier DEPEND_AND_RETURN on anything.)
	elseif
		decl            .isConstant
		and declExisting.isConstant
		and decl        .value.nodeType == !(nodeTypes.AstLambda)
		and declExisting.value.nodeType == !(nodeTypes.AstLambda)
	then
		while declExisting.overloadOf and declExisting.overloadOf ~= declExisting do  declExisting = declExisting.overloadOf  end

		if declExisting == decl then
			-- This simplifies finding an overload later.
			declExisting.overloadOf = declExisting
			table.insert(declExisting.overloads, declExisting)

		elseif scope ~= scopeExisting then
			local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, declExisting.name, ident)
			typeError2(state,
				identLate,  F("Trying to add a new overload to '%s' which is in another scope. Overloads must currently be declared in the same scope.", ident.name),
				identEarly, F("...here is the previous function.")
			)

		elseif declExisting.overloadsLocked then
			typeError2(state,
				declExisting.name, F("Trying to add a new overload to '%s' after it's type has been inferred. Overloads currently has to happen in the same 'parsing cycle'.", ident.name),
				ident,             F("...this is the new overload.")
			)

		else
			decl.overloadOf = declExisting
			table.insert(declExisting.overloads, decl)

			local lambda         = decl.value
			local lambdaExisting = declExisting.value

			assert(not lambdaExisting.inferredType)

			-- For now, polymorphic functions cannot be overloaded. Though maybe it should be allowed? Not sure!
			if lambda.isPolymorphic or lambdaExisting.isPolymorphic then
				local lambdaPoly  = lambda
				local lambdaOther = lambdaExisting
				if not lambda.isPolymorphic then
					lambdaPoly, lambdaOther = lambdaOther, lambdaPoly
				end
				typeError2(state,
					lambdaPoly,  F("Cannot overload polymorphic function '%s'.", ident.name),
					lambdaOther, F("...here is the other function.")
				)
			end

			-- This dependency means lambdaExisting won't get inferred until earliest next cycle
			-- by which time all overloads should have been added (I think). This should work as
			-- the first occurence of a name will make the second occurence wait before the
			-- second has been able to do anything. (This is true even when we remove unordered
			-- from the queue.)
			addDependency(state, lambdaExisting, !(DEPEND_NODE_INFERRED), lambda)
		end

	-- Non-shadow.
	elseif not decl.canShadow then
		local identEarly, identLate, extraMessageEarly, extraMessageLate = getEarlyAndLateForRedeclarationError(state, declExisting.name, ident)
		typeError2(state,
			identLate,  F("'%s' has already been declared.%s", ident.name, extraMessageLate),
			identEarly, F("...it was declared here.%s", extraMessageEarly)
		)

	-- Shadow in same scope.
	elseif
		scope == scopeExisting
		or (
			-- We do not allow declarations on lambda bodies to shadow the lambda's arguments.
			scope.nodeType                      == !(nodeTypes.AstBlock)
			and getClosestScope(scope).nodeType == !(nodeTypes.AstLambda)
			and getClosestScope(scope)          == scopeExisting
		)
	then
		typeError2(state,
			ident,             F("'%s' has already been declared in the same scope (which means name shadowing does not work).", ident.name),
			declExisting.name, F("...it was declared here.")
		)

	-- Shadowing something in an outer (or inner?) scope.
	-- @Robustness: Don't allow file-scope variables to be shadows (just like constants)?
	else
		-- void  (Valid shadow.)
	end
end

local function isPolymorphicLambda(node)
	return node.nodeType == !(nodeTypes.AstLambda) and node.isPolymorphic
end
local function isPolymorphicStruct(node)
	return node.nodeType == !(nodeTypes.AstStruct) and node.isPolymorphic
end

-- valueExpression = getDeclarationValue( declaration [, fallBackToLastAssignmentValue=false ] )
function _G.getDeclarationValue(decl, fallBackToLastAssignmentValue)
	return decl.value or decl.assignment and (
		decl.assignment.values[decl.assignmentIndex]
		or (fallBackToLastAssignmentValue and getLast(decl.assignment.values) or nil)
	)
end

local function inferIdentifierOrVararg(state, identOrVararg)
	local vararg = identOrVararg.nodeType == !(nodeTypes.AstVararg) and identOrVararg or nil
	local ident  = not vararg                                       and identOrVararg or nil
	local decl   = identOrVararg.declaration

	-- 1. Loose identifier.
	if not isPartOfAnyDeclaration(identOrVararg) then
		if not decl then
			local using
			decl, using = findDeclaration(state, identOrVararg, identOrVararg.name)

			if not decl then
				!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_DECLARATION, `identOrVararg.name`)
			end

			identOrVararg.declaration = decl
			identOrVararg.fromUsing   = using
		end

		if
			not ident
			or (ident.parent.nodeType == !(nodeTypes.AstCall)  and ident == ident.parent.callee)
			or (ident.parent.nodeType == !(nodeTypes.AstDebug) and ident.parent.action == "print")
		then
			-- void

		-- Overloaded names refer to multiple things, so that's an error!
		-- @Incomplete: Add a way to refer to a specific overload.
		elseif decl.overloadOf then
			local declBase = ident.declaration
			while declBase.overloadOf and declBase.overloadOf ~= declBase do  declBase = declBase.overloadOf  end

			if not declBase.name.inferredType then
				-- This is just so we get a better overload list in the error message.
				!DEPEND_AND_RETURN(`ident`, DEPEND_NODE_INFERRED, `declBase.name`)
			end

			printerr()
			typeMessage(io.stderr, state, ident, "Error", "'%s' has multiple overloads and we don't know which one this is referring to.", ident.name)
			for i, declOverload in ipairs(declBase.overloads) do
				typeMessage(io.stderr, state, declOverload.name, "Info", "...overload #%d.", i)
			end
			exitFailure()

		-- Polymorphic functions also contain the polymorphed functions and are thus a collection of functions, so referring to them may be a bad idea!
		-- (How does this work when calling a function from a module or a static struct member function? @Incomplete @Robustness)
		elseif isPolymorphicLambda(getDeclarationValue(decl) or decl) then
			typeError(state, ident, "Cannot refer to polymorphic function '%s' outside calls.", ident.name)

		-- Polymorphic structs are similar to polymorphed functions as they are collections of structs, so referring to them may be a bad idea too!
		-- (Also, like with the functions, think about modules. @Incomplete @Robustness)
		elseif isPolymorphicStruct(getDeclarationValue(decl) or decl) then
			typeErrorAfter(state, ident, "Missing arguments for polymorphic struct '%s'.", ident.name)
		end

		local typeInfo = decl.name.inferredType
		if not typeInfo then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `decl`)
		end

		identOrVararg.inferredType = typeInfo

		if identOrVararg.fromUsing then
			-- @Cleanup: Move this to simplifyExpressionIfConstant()?
			!ASSERT `ident`
			local access        = astNewNode(AstAccess, ident.token, ident.parent)
			access.object       = astCopy(ident.fromUsing.expression, access.token, access)

			local literal       = astNewNode(AstLiteral, access.token, access)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = ident.name
			access.member       = literal

			addUnqueuedChildrenToQueueRecursively(state, access)
			replaceQueuedNodeAndUnqueueOldTree(state, ident, access)
			-- Stay in the current pipe.

		else
			moveToNextRelevantPipe(state, identOrVararg)
			if ident then
				simplifyExpressionIfConstant(state, ident)
			end
		end

		return
	end

	!ASSERT("decl")
	!ASSERT("isAny(identOrVararg.parent.nodeType, "..nodeTypes.AstDeclaration..","..nodeTypes.AstAssignment..")")

	-- 2. Assignment target in declaration (which is a copy of the identifier in the declaration).
	if identOrVararg.parent.nodeType == !(nodeTypes.AstAssignment) then
		local identInDecl = decl.name
		if not identInDecl.inferredType then
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `identInDecl`)
		end
		identOrVararg.inferredType = identInDecl.inferredType

		moveToNextRelevantPipe(state, identOrVararg)
		return
	end

	-- 3. At this point we're defining a declared identifier.

	local scope = getClosestScopeForDeclaration(state, decl)

	if not scope then
		astPrint(identOrVararg)
		printTraceback(io.stderr)
		typeError(state, identOrVararg, "Internal compiler error: Could not find what scope '%s' is in.", identOrVararg.name)
	end

	local isEnumMember = scope.nodeType == !(nodeTypes.AstEnum)
	local isMember     = isEnumMember or scope.nodeType == !(nodeTypes.AstStruct)

	local isLambdaArgOut = (
		not isMember
		and scope.nodeType == !(nodeTypes.AstLambda)
		and scope.argumentsOut ~= nil
		and indexOf(scope.argumentsOut.arguments, astFindParent(decl, !(nodeTypes.AstArgument))) ~= nil
	)

	-- Check for redeclaration/shadowing (before we DEPEND_AND_RETURN).
	if not (isLambdaArgOut or vararg or decl.checkedRedeclaration) then
		checkRedeclaration(state, ident, decl, isMember, scope)
	end

	local typeExpr = decl.type
	if typeExpr and not typeExpr.inferredType then
		!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `typeExpr`)
	end

	if isEnumMember then
		local enum = scope
		if not enum.representedType then
			-- AstEnum is the only scope that gets inferred before its declarations.
			!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `enum`)
		end
	end

	local valueExpr = getDeclarationValue(decl, true)
	if (not typeExpr or decl.isConstant) and not valueExpr.inferredType then
		!DEPEND_AND_RETURN(`identOrVararg`, DEPEND_NODE_INFERRED, `valueExpr`)
	end

	--
	-- No more dependencies for this identifier after this point!
	--

	decl.overloadsLocked = true

	-- Check that call signatures aren't too similar. Optional arguments could make several overloads match calls, i.e.:
	--   local func :: () {}
	--   local func :: (n:int=0) {}
	--   func() -- First or second?
	if decl.overloadOf == decl then
		for i = 1, #decl.overloads-1 do
			local decl1         = decl.overloads[i]
			local funcSig1      = decl1.value.inferredType
			local argTypes1     = funcSig1.argumentTypesIn
			local argRequireds1 = funcSig1.requiredArgumentsIn

			for i = i+1, #decl.overloads do
				local decl2         = decl.overloads[i]
				local funcSig2      = decl2.value.inferredType
				local argTypes2     = funcSig2.argumentTypesIn
				local argRequireds2 = funcSig2.requiredArgumentsIn

				if funcSig1 == funcSig2 then
					local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
					typeError2(state,
						identLate,  F("Call signatures for function overloads for '%s' are identical. (%s)", ident.name, getFriendlyTypeInfoName(funcSig1)),
						identEarly, F("...here is the other function.")
					)
				end

				-- local requiredCount1 = 0
				-- local requiredCount2 = 0

				-- @Incomplete @Robustness: Check that vararg works.
				for argIndex = 1, math.min(#argTypes1, #argTypes2)+1 do
					local argTypeInfo1 = argTypes1[argIndex]
					local argTypeInfo2 = argTypes2[argIndex]
					argTypeInfo1       = argTypeInfo1 and adjustTypeToOne(state, decl1.name, argTypeInfo1)
					argTypeInfo2       = argTypeInfo2 and adjustTypeToOne(state, decl2.name, argTypeInfo2)

					local isRequired1  = argTypeInfo1 ~= nil and argRequireds1[argIndex]
					local isRequired2  = argTypeInfo2 ~= nil and argRequireds2[argIndex]

					-- if isRequired1 then  requiredCount1 = requiredCount1+1  end
					-- if isRequired2 then  requiredCount2 = requiredCount2+1  end

					if not (isRequired1 or isRequired2) then
						local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
						typeError2(state,
							identEarly, F("Call signatures for function overloads (%s) are too similar.", ident.name),
							identLate,  F("...here is the other function.")
						)
					end

					if not (argTypeInfo1 and argTypeInfo1 == argTypeInfo2) then  break  end
				end

				--[[ This is a bit too restrictive!
				if requiredCount1 == requiredCount2 then
					for argIndex = 1, requiredCount1 do
						local argTypeInfo1 = adjustTypeToOne(state, decl1.name, argTypes1[argIndex])
						local argTypeInfo2 = adjustTypeToOne(state, decl2.name, argTypes2[argIndex])
						if
							isTypeCompatibleWith(argTypeInfo1, argTypeInfo2) or
							isTypeCompatibleWith(argTypeInfo2, argTypeInfo1)
						then
							local identEarly, identLate = getEarlyAndLateForRedeclarationError(state, decl1.name, decl2.name)
							typeError2(state,
								identEarly, F("Call signatures for function overloads (%s) are too similar. (Argument #%d, %s vs. %s)",
									ident.name,
									argIndex,
									getFriendlyTypeInfoName(argTypeInfo1),
									getFriendlyTypeInfoName(argTypeInfo2)
								)
								identLate, F("...here is the other function.")
							)
						end
					end
				end
				--]]
			end
		end
	end

	-- Tell parents that this declaration exists so we can detect more cases of shadowing.
	if not (isLambdaArgOut or decl.canShadow or vararg) then -- Should vararg do this? I think it's not needed.
		local parentScope = scope

		repeat
			local declarationsInTree = parentScope.declarationsInTree[ident.name]

			if not declarationsInTree then
				declarationsInTree = {}
				parentScope.declarationsInTree[ident.name] = declarationsInTree
			end

			table.insert(declarationsInTree, decl)

			if parentScope.nodeType == !(nodeTypes.AstFileScope) and parentScope.isModule then  break  end

			parentScope = getClosestScope(parentScope)
		until not parentScope
	end

	local typeInfo

	-- Specified type.
	if typeExpr then
		typeInfo = requireTypeRepresentedByExpression(state, typeExpr)

	-- Infer type from value.
	else
		!ASSERT `valueExpr, "Missing both type and value from declaration."`
		!ASSERT `not vararg`

		if decl.value then
			typeInfo = valueExpr.inferredType
		else
			valueExpr, typeInfo = getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, nil, nil, nil)
		end
		typeInfo = adjustTypeToOne(state, valueExpr, typeInfo, true)
	end

	assert(typeInfo)
	local typeInfoForDecl = nil

	-- Check if the value is constant.
	if decl.isConstant then
		valueExpr       = valueExpr or getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, nil, nil, nil)
		typeInfoForDecl = getTypeRepresentedByExpression(valueExpr)

		if isEnumMember then
			-- Note: AstEnum already validated that valueExpr's type is compatible with the enum.
			local enum     = scope
			local enumInfo = enum.representedType
			typeInfo       = enumInfo -- Kind of a @Hack, but maybe it's fine for enum members!

			if enumInfo.memberTypeInfo.tag == !(typeTags.TypeInfoType) then
				-- This means you can for example say: local myVar:MyEnum.MY_TYPE
				assert(typeInfoForDecl)
			end
		end

		if typeInfo.tag == !(typeTags.TypeInfoType) then
			if not typeInfoForDecl then
				errorInternal(state, valueExpr, "Missing what type this constant expression represents.")
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then -- @Robustness: Actually detect whether we have a type enum and include it here above.
			-- void  (For now we may or may not have a type enum and typeInfoForDecl.)

		else
			assert(not typeInfoForDecl)
		end

		-- @Robustness: Here we set the name of structs and enums. Is this a good place to do that?
		if not typeInfoForDecl then
			-- void

		elseif typeInfoForDecl.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfoForDecl
			if structInfo.name == "" then -- Is this detection ok? Need testing or another solution.
				structInfo.name = ident.name
			end

		elseif typeInfoForDecl.tag == !(typeTags.TypeInfoEnum) then
			local enumInfo = typeInfoForDecl
			if enumInfo.name == "" then -- Is this detection ok? Need testing or another solution.
				enumInfo.name = ident.name
			end
		end
	end

	if vararg then
		typeInfo = getTypeInfoForVararg(state, typeInfo)
	end

	identOrVararg.inferredType = typeInfo
	decl.valueTypeInfo         = typeInfoForDecl -- May be nil.  @Cleanup: Move this and relevant code to AstDeclaration?

	!if DEBUG then
		if debug_onlyInferTypes then
			io.stdout:write("DEFINE ", identOrVararg.name ,":", getFriendlyTypeInfoName(typeInfo))
			if decl.isConstant then  io.stdout:write(" (CONST)")  end
			if typeInfoForDecl then  io.stdout:write(" (VALUE ", getFriendlyTypeInfoName(typeInfoForDecl), ")")  end
			io.stdout:write(" IN ")
			astPrint(getClosestScopeForDeclaration(state, decl))
		end
	!end

	moveToNextRelevantPipe(state, identOrVararg)
end

!NODE_INFERRER `function nodeInferrers.AstIdentifier(state, ident)`
	inferIdentifierOrVararg(state, ident)
end
!NODE_INFERRER `function nodeInferrers.AstVararg(state, vararg)`
	inferIdentifierOrVararg(state, vararg)
end

!NODE_INFERRER `function nodeInferrers.AstBlank(state, blank)`
	if blank.parent.nodeType == !(nodeTypes.AstDeclaration) then
		local decl = blank.parent

		if decl.isConstant then
			typeError(state, blank, "Blank names cannot be constant.")
		elseif not isScopeImperative(getClosestScope(decl)) then
			typeError(state, blank, "Blank names are only allowed in imperative context.")
		end

	elseif blank.parent.nodeType == !(nodeTypes.AstAssignment) then
		local assignment = blank.parent
		if assignment.binaryOperation ~= "" then
			typeError(state, blank, "Blank names cannot be used in assignments with binary operations.")
		end

	else
		errorUnhandledNodeType(state, blank)
	end

	blank.inferredType = getTypeInfoForBuiltinType(state, "any")
	moveToNextRelevantPipe(state, blank)
end

!NODE_INFERRER `function nodeInferrers.AstType(state, typeNode)`
	-- Note: typeNode.declaration may already be filled for generated type nodes.

	local decl = nil
	local typeInfo, typeInfoRepresented

	!if DEBUG then
		--[[
		if typeNode.kind == !(TYPE_KIND_UNSET) then
			astPrintTree(typeNode)
			errorInternal(state, typeNode)
		end
		--]]
	!end

	if typeNode.kind == !(TYPE_KIND_SIMPLE_BUILTIN) then
		typeInfoRepresented = getTypeInfoForBuiltinType(state, typeNode.typeName)
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.kind == !(TYPE_KIND_FUNCTION) then
		local lambda = typeNode.functionHeader or errorInternal()

		if not lambda.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `lambda`)
		end
		assert(lambda.inferredType.tag == !(typeTags.TypeInfoFunction))

		local funcSig       = getTypeInfoForLambda(state, lambda)
		typeInfoRepresented = funcSig
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.kind == !(TYPE_KIND_ARRAY) then
		local itemTypeNode = typeNode.arrayItemType or errorInternal(state, typeNode)

		if not itemTypeNode.inferredType then
			!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `itemTypeNode`)
		end

		local itemTypeInfo = requireTypeRepresentedByExpression(state, itemTypeNode)
		if itemTypeInfo.tag == !(typeTags.TypeInfoNone) then
			typeError(state, itemTypeNode, "Arrays cannot contain nil.")
		elseif itemTypeInfo.tag == !(typeTags.TypeInfoCompound) and indexWith1(itemTypeInfo, "tag", !(typeTags.TypeInfoNone)) then
			typeError(state, itemTypeNode, "Arrays cannot contain nil. (Item type is %s)", getFriendlyTypeInfoName(itemTypeInfo))
		end

		local arraySig      = getTypeInfoForArray(state, itemTypeInfo)
		typeInfoRepresented = arraySig
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	elseif typeNode.kind == !(TYPE_KIND_COMPOUND) then
		for _, typeExpr in ipairs(typeNode.components) do
			if not typeExpr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `typeExpr`)
			end
		end

		-- Note: It's ok that these share the same table!
		local typeInfos  = {}        -- Keys are numbers.
		local typeIds    = typeInfos -- Keys are AstNode.
		local duplicates = typeInfos -- Keys are TypeInfo.

		local isFromCompound = {}

		for _, typeExpr in ipairs(typeNode.components) do
			!(
			local TEMPLATE_ERROR_DUPLICATE_TYPE = `
				printerr()
				typeMessage(io.stderr, state, typeExpr, "Error", "Duplicate type specified in $siteTitle.")
				if isFromCompound[$typeInfoVar] then
					typeMessage(
						io.stderr, state, duplicates[$typeInfoVar],
						"Info", "...this sub-compound type contains the same type. (%s)",
						getFriendlyTypeInfoName($typeInfoVar)
					)
				else
					typeMessage(
						io.stderr, state, duplicates[$typeInfoVar],
						"Info", "...this is the same type. (%s)",
						getFriendlyTypeInfoName($typeInfoVar)
					)
				end
				exitFailure()
			`
			local function ERROR_DUPLICATE_TYPE(siteTitle, typeInfoVar)
				local lua = templateToLua(TEMPLATE_ERROR_DUPLICATE_TYPE, {
					siteTitle   = siteTitle,
					typeInfoVar = typeInfoVar,
				})
				__LUA(lua)
			end
			)

			local componentType = requireTypeRepresentedByExpression(state, typeExpr)

			if componentType.tag == !(typeTags.TypeInfoCompound) then
				-- Unpack the sub-compound type so we don't end up with compound types of other compound types.
				local compound = componentType

				for _, compoundItem in ipairs(compound) do
					if duplicates[compoundItem] then
						!ERROR_DUPLICATE_TYPE("compound type (through sub-compound type)", `compoundItem`)
					end

					table.insert(typeInfos, compoundItem)
					typeIds[typeExpr]            = compoundItem.id
					duplicates[compoundItem]     = typeExpr -- @UX: Should we ignore duplicate nil types?
					isFromCompound[compoundItem] = true
				end

			else
				if duplicates[componentType] then
					!ERROR_DUPLICATE_TYPE("compound type", `componentType`)
				elseif componentType.tag == !(typeTags.TypeInfoAny) then
					typeError(state, typeExpr, "Cannot include 'any' in compound types.")
				end

				table.insert(typeInfos, componentType)
				typeIds[typeExpr]         = componentType.id
				duplicates[componentType] = typeExpr -- @UX: Should we ignore duplicate nil types?
			end
		end

		table.sort(typeNode.components, function(a, b)  return typeIds[a] < typeIds[b]  end) -- @Cleanup @Speed: This is probably unnecessary.
		table.sort(typeInfos,           function(a, b)  return a.id       < b.id        end)

		typeInfoRepresented = getTypeInfoForCompoundType(state, typeInfos)
		typeInfo            = getTypeInfoForBuiltinType(state, "type")

	else
		decl = typeNode.declaration

		if not decl then
			assert(typeNode.typeName ~= "")

			decl = findDeclaration(state, typeNode, typeNode.typeName)
			if not decl then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_DECLARATION, `typeNode.typeName`)
			elseif not decl.name.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `decl.name`)
			end
		end

		typeInfoRepresented = decl.valueTypeInfo -- May be nil, in which case we'll get an error here below.
		typeInfo            = decl.name.inferredType or errorInternal()

		-- Type enum members can be used as types, as a special case.
		if decl.isConstant and typeInfo.tag == !(typeTags.TypeInfoEnum) then
			local enum     = typeInfo.astNode     or errorInternal()
			local enumInfo = enum.representedType or errorInternal()

			if enumInfo.memberTypeInfo.tag == !(typeTags.TypeInfoType) then
				typeInfo = getTypeInfoForBuiltinType(state, "type")
			end
		end

		if typeInfo.tag ~= !(typeTags.TypeInfoType) then
			printerr()
			typeMessage(io.stderr, state, typeNode, "Error", "'%s' is not a type. (It is %s)", typeNode.typeName, getFriendlyTypeInfoName(typeInfo))
			printDeclarationChain(io.stderr, state, decl, typeNode.typeName)
			exitFailure()
		end

		for _, expr in ipairs(typeNode.arguments or EMPTY_TABLE) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`typeNode`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		-- @Incomplete: Proper error messages here:

		if SIMPLE_TYPE_TAG[typeInfo.tag] then
			assert(not typeNode.arguments) -- This should have been caught during parsing, e.g. int(a,b).

		elseif typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			if structInfo.arguments[1] then
				errorInternal("@Incomplete: Struct arguments.")
			elseif typeNode.arguments then
				typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeNode.arguments[1]), "Parameters for structs are not supported yet.")
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			assert(not typeNode.arguments)

		elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
			assert(not typeNode.arguments) -- This should not be possible I think. The node should have been parsed as an AstCall - not an AstType without functionHeader... right? I may be wrong.

		else
			errorInternal("Incomplete: Handle type group '%s'.", TYPE_TAG_NAMES[typeInfo.tag])
		end
	end

	typeNode.representedType = typeInfoRepresented or errorInternal()
	typeNode.inferredType    = typeInfo            or errorInternal()
	typeNode.declaration     = decl

	moveToNextRelevantPipe(state, typeNode)
end

local function getArgumentNodeForError(callOrReturnNode, valueIndex, valueExpr)
	return
		callOrReturnNode.nodeType == !(nodeTypes.AstCall) and callOrReturnNode.isMethod and valueIndex == 1
		and valueExpr
		or  astGetExpressionVisuallyFurthestToTheLeft(valueExpr)
end

-- doesMatch, compatibilityScore = checkIfValuesMatchArgumentTypes( state, callOrReturnNode, values, valueTypes, typeInfos [, softCheck=false, calleeDeclarationForCurrentOverload ] )
local function checkIfValuesMatchArgumentTypes(state, callOrReturnNode, values, valueTypes, typeInfos, softCheck, calleeDecl)
	--[[
		Situations:

		two :: (x:int,   y:int) -> (x:int    y:int) -- accept in/out 2
		var :: (x:int, ...:int) -> (x:int, ...:int) -- accept in/out 1+vararg
		return  x, (two())  --- request 2
		func(   x, (two())  )-- request 2
		return  x, (var())  --- request 2
		func(   x, (var())  )-- request 2
		return  x, (...)    --- request 2  (Note: The vararg can result in nil.)
		func(   x, (...)    )-- request 2  (Note: The vararg can result in nil.)
		return  x, two()    --- request 1+list(2)
		func(   x, two()    )-- request 1+list(2)
		return  x, ...      --- request 1+vararg
		func(   x, ...      )-- request 1+vararg
		return  x, var()    --- request 1+list(1+vararg)
		func(   x, var()    )-- request 1+list(1+vararg)
	]]

	-- Get requested count.
	local valueExprLast = getLast(values)
	local valueCount    = #values
	local requestedMin  = valueCount
	local requestedMax  = valueCount
	local slotsToCheck  = valueCount -- Assuming the requested count is accepted.

	if valueExprLast then
		if valueExprLast.nodeType == !(nodeTypes.AstCall) then
			local valueCall = valueExprLast

			if not valueCall.surroundedByParentheses then
				local calleeTypeInfo = valueCall.callee.inferredType

				if calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
					local listSig  = calleeTypeInfo
					calleeTypeInfo = listSig[1] or errorInternal() -- The error should have happened when inferring AstCall.
				end

				assert(calleeTypeInfo.tag == !(typeTags.TypeInfoFunction))

				local argTypesOut = calleeTypeInfo.argumentTypesOut
				local argCount    = #argTypesOut

				if argCount == 0 then
					if softCheck then  return false, 0  end
					typeError(state, valueCall, "Function call returns nothing. (Expected at least one value.)")
				end

				local returnsVararg = argCount > 0 and argTypesOut[argCount].tag == !(typeTags.TypeInfoVararg)
				local returnsMin    = returnsVararg and argCount-1 or argCount
				local returnsMax    = returnsVararg and math.huge  or argCount

				requestedMin = valueCount-1+returnsMin
				requestedMax = valueCount-1+returnsMax
				slotsToCheck = valueCount-1+argCount
			end

		elseif valueExprLast.nodeType == !(nodeTypes.AstVararg) then
			local valueVararg = valueExprLast

			if not valueVararg.surroundedByParentheses then
				requestedMin = valueCount - 1
				requestedMax = math.huge
				slotsToCheck = valueCount
			end
		end
	end

	-- Get accepted count.
	local typeInfoCount   = #typeInfos
	local acceptingVararg = typeInfoCount > 0 and typeInfos[typeInfoCount].tag == !(typeTags.TypeInfoVararg)
	local acceptedMin     = acceptingVararg and typeInfoCount-1 or typeInfoCount
	local acceptedMax     = acceptingVararg and math.huge       or typeInfoCount

	-- Consider optional arguments for calls.
	-- @Robustness @Cleanup: We probably must have argument optionality be part of function types - not just the arguments types.
	-- @Robustness: Disallow this: local take2 :: (req:int, opt:int=0) {} ; local get1 :: () -> int {} ; take2(get1())  -- :DisallowListAsLastValueToFunctionWithOptionalArguments
	if callOrReturnNode.nodeType == !(nodeTypes.AstCall) and callOrReturnNode.callee.nodeType == !(nodeTypes.AstIdentifier) then
		calleeDecl = (calleeDecl or callOrReturnNode.callee.declaration)

		if calleeDecl.isConstant then
			local lambda = getDeclarationValue(calleeDecl) or errorInternal()
			assert(lambda.nodeType == !(nodeTypes.AstLambda))
			assert(lambda.inferredType)

			if not areArraysEqual(typeInfos, lambda.inferredType.argumentTypesIn) then
				-- We should only get here if checking overloads.
				if softCheck then  return false, 0  end
				assert(false)
			end

			for i = acceptedMin, 1, -1 do
				local arg = lambda.argumentsIn.arguments[i]
				if arg.isRequired then
					break
				else
					acceptedMin = acceptedMin-1
				end
			end
		end
	end

	-- io.stdout:write(F("requested %.0f-%.0f, accepted %.0f-%.0f  ", requestedMin, requestedMax, acceptedMin, acceptedMax)) ; astPrint(callOrReturnNode)

	-- Too few values.
	-- @UX: Better error message if the last value is a call (without parentheses).
	if requestedMin < acceptedMin then
		if softCheck then  return false, 0  end

		local exprForError = values[1] and getArgumentNodeForError(callOrReturnNode, 1, values[1]) or callOrReturnNode
		local prefix       = requestedMax+acceptedMax == math.huge and "Incorrect number of" or "Missing"
		local thingsStr    = callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "arguments" or "values to return"
		local gotStr       = (requestedMax ~= math.huge and F("%d", requestedMin)) or (requestedMin == 0 and "variable amount") or F("%d + variable amount", requestedMin)

		typeError(state, exprForError, "%s %s. (Wanted %d, got %s)", prefix, thingsStr, acceptedMin, gotStr)

	-- Too many values.
	-- @UX: Better error message if the last value is a call (without parentheses).
	elseif requestedMax > acceptedMax then
		!ASSERT `not acceptingVararg`

		if softCheck then  return false, 0  end

		local valueIndex          = math.min(acceptedMax+1, valueCount)
		local firstExtraValueExpr = values[valueIndex]
		local exprForError        = getArgumentNodeForError(callOrReturnNode, valueIndex, firstExtraValueExpr)
		local prefix              = requestedMax+acceptedMax == math.huge and "Incorrect number of" or "Too many"
		local thingsStr           = callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "arguments" or "values to return"
		local gotStr              = (requestedMax ~= math.huge and F("%d", requestedMin)) or (requestedMin == 0 and "variable amount") or F("%d + variable amount", requestedMin)

		typeError(state, exprForError, "%s %s. (Wanted %d, got %s)", prefix, thingsStr, acceptedMax, gotStr) -- Note: acceptedMax is never infinite here.
	end

	local compatibilityScoreSum = 0

	for slot = 1, slotsToCheck do
		local valueIndex      = math.min(slot, valueCount)
		local valueExpr       = values[valueIndex]
		local valueTypeInfo   = valueTypes[valueIndex]

		local typeInfoIndex   = math.min(slot, typeInfoCount)
		local typeInfoToMatch = typeInfos[typeInfoIndex]

		local isCompatible, compatibilityScore

		-- Function call (0..inf values).
		if valueTypeInfo.tag == !(typeTags.TypeInfoList) then
			local listSig         = valueTypeInfo
			local callOutArgIndex = slot-valueIndex+1
			valueTypeInfo         = listSig[callOutArgIndex]

			if not valueTypeInfo then
				if softCheck then  return false, 0  end
				typeError(state, valueExpr, "Function call returns nothing. (Expected at least one value.)") -- Note: "Nothing" is not the same as vararg of zero length.
			end

			local adjustVarargToIncludeNil   = not (valueTypeInfo.tag == !(typeTags.TypeInfoVararg) and typeInfoToMatch.tag == !(typeTags.TypeInfoVararg))
			local valueTypeInfoAdjusted      = adjustTypeToOne(state, valueExpr,        valueTypeInfo, adjustVarargToIncludeNil) -- We have a value with a type.
			local typeInfoToMatchAdjusted    = adjustTypeToOne(state, callOrReturnNode, typeInfoToMatch)                         -- We want a specific type.
			isCompatible, compatibilityScore = isTypeCompatibleWith(valueTypeInfoAdjusted, typeInfoToMatchAdjusted)

			if not isCompatible then
				if softCheck then  return false, 0  end
				-- @UX: Tell the name of the call/return argument. (For calls, probably only possible for constants, and maybe not all. Not sure! Returns just depend on the output arguments being named.)
				-- @UX: Tell the name of the value call's argument. (Probably only possible for constants, and maybe not all. Not sure!)
				typeError(
					state, valueExpr,
					"Type mismatch for %s #%d (return value #%d from call). (Wanted %s, got %s)",
					callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "argument" or "return value",
					slot,
					callOutArgIndex,
					getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
					getFriendlyTypeInfoName(valueTypeInfoAdjusted)
				)
			end

		-- Vararg (0..inf values) OR other (1 value).
		else
			local adjustVarargToIncludeNil   = not (valueTypeInfo.tag == !(typeTags.TypeInfoVararg) and typeInfoToMatch.tag == !(typeTags.TypeInfoVararg))
			local valueTypeInfoAdjusted      = adjustTypeToOne(state, valueExpr,        valueTypeInfo, adjustVarargToIncludeNil) -- We have a value with a type.
			local typeInfoToMatchAdjusted    = adjustTypeToOne(state, callOrReturnNode, typeInfoToMatch)                         -- We want a specific type.
			isCompatible, compatibilityScore = isTypeCompatibleWith(valueTypeInfoAdjusted, typeInfoToMatchAdjusted)

			if not isCompatible then
				if softCheck then  return false, 0  end
				typeError(
					state, getArgumentNodeForError(callOrReturnNode, valueIndex, valueExpr),
					"Type mismatch for %s #%d. (Wanted %s, got %s)",
					callOrReturnNode.nodeType == !(nodeTypes.AstCall) and "argument" or "return value",
					slot,
					getFriendlyTypeInfoName(typeInfoToMatchAdjusted),
					getFriendlyTypeInfoName(valueTypeInfoAdjusted)
				)
			end
		end

		compatibilityScoreSum = compatibilityScoreSum + compatibilityScore
	end

	-- @Incomplete: Decrease compatibilityScoreSum as optional arguments are left out?

	return true, compatibilityScoreSum
end

local function getMatchingFunctions(state, call, realArguments, realArgumentTypes, declarations)
	local matches = nil

	for _, decl in ipairs(declarations) do
		local funcSig = decl.name.inferredType

		!ASSERT("funcSig.tag == "..typeTags.TypeInfoFunction)

		local doesMatch, compatibilityScore = checkIfValuesMatchArgumentTypes(
			state, call, realArguments, realArgumentTypes, funcSig.argumentTypesIn, true, decl
		)
		if doesMatch then
			matches = matches or {}
			table.insert(matches, {declaration=decl, score=compatibilityScore})
		end
	end

	return matches
end

local function getBestMatchOrTriggerError(state, call, matches, matchTerm, errorTextOnDraw)
	table.sort(matches, function(a, b)
		return a.score > b.score
	end)

	local highscore = matches[1].score

	if not matches[2] or matches[2].score < highscore then
		return matches[1].declaration
	end

	printerr()
	typeMessage(io.stderr, state, call.callee, "Error", errorTextOnDraw)
	for i, matchData in ipairs(matches) do
		if matchData.score < highscore then  break  end
		typeMessage(io.stderr, state, matchData.declaration.name, "Info", "...%s #%d.", matchTerm, i)
	end
	exitFailure()
end

local function getPathToNode(state, topNode, node)
	!ASSERT `topNode`
	local locations = {}

	while node ~= topNode do
		local loc = {node=node.parent, container=node.queued.container, key=node.queued.key}
		table.insert(locations, loc)
		node = node.parent or errorInternal(state, topNode)
	end

	return reverseArray(locations)
end

local function handlePolymorphicCall(state, call, calleeTypeInfo, realArguments, realArgumentTypes)
	local ident = call.callee
	if ident.nodeType ~= !(nodeTypes.AstIdentifier) then
		errorInternal(state, ident, "Expected an identifier. Referring to unknown polymorphic function.")
	end

	local decl = ident.declaration
	if not decl.isConstant then
		errorInternal(state, ident, "Identifier is not a constant.")
	end

	local lambda = decl.value or errorInternal(state, decl)
	assert(lambda.nodeType == !(nodeTypes.AstLambda))

	for _, statement in ipairs(lambda.statements) do
		if statement.queued and statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	for _, morphDecl in ipairs(lambda.polymorphs) do
		if not morphDecl.name.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `morphDecl.name`)
		end
	end

	checkIfValuesMatchArgumentTypes(state, call, realArguments, realArgumentTypes, calleeTypeInfo.argumentTypesIn) -- Basically checks everything but placeholders.

	-- Check for previous matching polymorph(s).
	local matchingMorphs = getMatchingFunctions(state, call, realArguments, realArgumentTypes, lambda.polymorphs)

	if matchingMorphs then
		local morphDecl = getBestMatchOrTriggerError(
			state, call, matchingMorphs, "polymorph",
			"Internal compiler error: There are several matching polymorphs."
		)

		-- Update the callee to represent the correct polymorph.
		ident.declaration  = morphDecl
		ident.inferredType = nil

		moveToPipe(state, ident, !(PIPE_INFER)) -- Re-infer callee.

		-- !DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `ident`) -- This is an error as the same dependency already exists!
		local dependency      = getExistingDependency(state, call, !(DEPEND_NODE_INFERRED), ident) or errorInternal()
		call.queued.waitingOn = dependency
		return
	end

	-- Create declaration for the morphed lambda.
	local morphDecl            = astNewNode(AstDeclaration, lambda.token, lambda)
	morphDecl.isConstant       = true
	morphDecl.addedByPolymorph = true

	local morphIdent       = astNewNode(AstIdentifier, morphDecl.token, morphDecl)
	morphIdent.name        = ident.name.."_POLY"..(#lambda.polymorphs+1)
	morphIdent.declaration = morphDecl
	morphDecl.name         = morphIdent

	local morphLambda = astCopy(lambda, nil, morphDecl)
	morphDecl.value   = morphLambda

	-- Don't keep copies of previous polymorphs we've made - that would quickly create a mess!
	-- (@Speed: Don't even copy them in the first place.)
	do
		morphLambda.isPolymorphic = false
		morphLambda.polymorphs    = {}

		for i, statement in ipairsr(morphLambda.statements) do
			if isAny(statement.nodeType, !(nodeTypes.AstDeclaration),!(nodeTypes.AstAssignment)) and statement.addedByPolymorph then
				table.remove(morphLambda.statements, i) -- Should be fast enough. There shouldn't be that many statements in lambdas.
			end
		end
	end

	table.insert(lambda.polymorphs, morphDecl)

	astVisitAllNodes(morphLambda, function(node, container, key)
		if node == morphLambda.body then  return !(VISIT_IGNORE_CHILDREN)  end

		-- @Robustness @Robustness @Robustness: So much @Hack!
		node.inferredType    = nil
		node.valueTypeInfo   = nil
		node.representedType = nil

		-- AstBake nodes are only used before baking.
		if node.nodeType == !(nodeTypes.AstBake) then
			local bake       = node
			container[key]   = bake.name
			bake.name.parent = bake.parent
			return !(VISIT_IGNORE_CHILDREN)
		end
	end)

	-- Fill in baked values in morphed lambda.
	local bakeIndex = 0
	!ASSERT `lambda.argumentsIn`

	for argIndex, arg in ipairs(lambda.argumentsIn.arguments) do
		local declTypeExpr = arg.declaration.type -- This is probably an AstType.

		astVisitAllNodes(declTypeExpr, function(node)
			if node.nodeType ~= !(nodeTypes.AstBake) then  return  end

			local bake = node
			bakeIndex  = bakeIndex+1

			-- @Incomplete: Handle optional arguments.
			local valueExpr     = realArguments    [argIndex] or errorInternal(state, bake)
			local valueTypeInfo = realArgumentTypes[argIndex] or errorInternal(state, valueExpr)

			valueTypeInfo = adjustTypeToOne(state, valueExpr, valueTypeInfo)

			for _, loc in ipairs(getPathToNode(state, declTypeExpr, bake)) do
				if loc.node.nodeType == !(nodeTypes.AstType) then
					if loc.node.kind == !(TYPE_KIND_ARRAY) then
						if valueTypeInfo.tag ~= !(typeTags.TypeInfoArray) then
							typeError(
								state, valueExpr,
								"Polymorphic call: Unexpected type. (Wanted an array, got %s)",
								getFriendlyTypeInfoName(valueTypeInfo)
							)
						end
						local arraySig = valueTypeInfo
						valueTypeInfo  = arraySig.itemType or errorInternal(state, valueExpr)

					else
						errorUnhandledNodeType(state, loc.node)
					end
				else
					errorUnhandledNodeType(state, loc.node)
				end
			end

			local declBaked = morphLambda.bakeDeclarations[bakeIndex] or errorInternal(state, bake)
			local typeNode  = declBaked.value                         or errorInternal(state, bake)

			typeNode.inferredType    = getTypeInfoForBuiltinType(state, "type")
			typeNode.representedType = valueTypeInfo or errorInternal(state, valueExpr)

			-- For debugging:
			typeNode.typeName = ":generatedAutoInferredTypeNode:"
			typeNode.kind     = !(TYPE_KIND_UNSET)
		end)
	end
	!ASSERT `bakeIndex == #lambda.bakeDeclarations`

	-- Update the source lambda, add queueds etc.
	local i              = #lambda.statements+1
	lambda.statements[i] = morphDecl
	addToQueueRecursively(state, morphDecl, lambda.statements, i, !(PIPE_INFER))

	for _, declBaked in ipairs(morphLambda.bakeDeclarations) do
		local valueExpr         = declBaked.value
		declBaked.valueTypeInfo = getTypeRepresentedByExpression(valueExpr)
		moveToNextRelevantPipe(state, valueExpr)
	end

	-- Update the callee to represent the correct polymorph.
	ident.declaration  = morphDecl
	ident.inferredType = nil

	moveToPipe(state, ident, !(PIPE_INFER)) -- Re-infer callee.

	-- !DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `ident`) -- This is an error as the same dependency already exists!
	local dependency      = getExistingDependency(state, call, !(DEPEND_NODE_INFERRED), ident) or errorInternal()
	call.queued.waitingOn = dependency
	return
end

local function handleOverloadedCall(state, call, realArguments, realArgumentTypes)
	local ident    = call.callee
	local declBase = ident.declaration

	while declBase.overloadOf ~= declBase do  declBase = declBase.overloadOf  end

	local matchingOverloads = getMatchingFunctions(state, call, realArguments, realArgumentTypes, declBase.overloads)

	if not matchingOverloads then
		printerr()
		typeMessage(io.stderr, state, ident, "Error", "Did not find any matching overload to call.")
		for i, declOverload in ipairs(declBase.overloads) do
			typeMessage(io.stderr, state, declOverload.name, "Info", "...overload #%d.", i)
		end
		exitFailure()
	end

	local decl = getBestMatchOrTriggerError(
		state, call, matchingOverloads, "overload",
		"There are several matching overloads."
	)
	local calleeTypeInfo = decl.name.inferredType

	-- Update the callee to represent the correct overload.
	-- @Robustness: Is this safe? I don't think anything except the calls itself depends directly on, and uses values from, any callee.
	ident.declaration  = decl
	ident.inferredType = calleeTypeInfo

	return calleeTypeInfo
end

local function handlePolymorphicStruct(state, call)
	local typeNode = call.callee
	assert(typeNode.nodeType == !(nodeTypes.AstType))

	local structInfo = typeNode.representedType
	assert(structInfo.tag == !(typeTags.TypeInfoStruct))
	assert(structInfo.isPolymorphic)

	local struct = structInfo.astNode

	for _, morphDecl in ipairs(struct.polymorphs) do
		if not morphDecl.name.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `morphDecl.name`)
		end
	end

	-- Check arguments.
	for argIndex, argExpr in ipairs(call.arguments) do
		if not isExpressionConstant(state, argExpr) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(argExpr), "Struct argument #%d is not constant.", argIndex)
		end
	end

	local requested   = #call.arguments
	local acceptedMax = #struct.bakeDeclarations
	local acceptedMin = acceptedMax

	for argIndex = acceptedMax, 1, -1 do
		if not struct.bakeDeclarations[argIndex].value then  break  end
		acceptedMin = acceptedMin-1
	end

	if requested < acceptedMin then
		typeError(state, call, "Too few struct arguments. (Expected %d, got %d)", acceptedMin, requested)
	elseif requested > acceptedMax then
		typeError(
			state, astGetExpressionVisuallyFurthestToTheLeft(call.arguments[acceptedMax+1]),
			"Too many struct arguments. (Expected %d, got %d)",
			acceptedMax, requested
		)
	end

	-- Check for previous matching polymorph.
	for _, morphDecl in ipairs(struct.polymorphs) do
		local morphStruct = morphDecl.value
		local isMatch     = true

		for argIndex, declBaked in ipairs(morphStruct.bakeDeclarations) do
			local valueBaked = declBaked.value
			local valueExpr  = call.arguments[argIndex] or struct.bakeDeclarations[argIndex].value

			if valueExpr.nodeType ~= valueBaked.nodeType then
				isMatch = false ; break
			elseif valueExpr.nodeType == !(nodeTypes.AstLiteral) then
				if valueExpr.value ~= valueBaked.value then -- Note: We don't need to check the literalType.
					isMatch = false ; break
				end
			elseif valueExpr.nodeType == !(nodeTypes.AstType) then
				if valueExpr.representedType ~= valueBaked.representedType then
					isMatch = false ; break
				end
			else
				errorUnhandledNodeType(state, valueExpr)
			end
		end

		if isMatch then
			-- Change the call into a type node.
			local morphTypeNode       = astNewNode(AstType, morphDecl.name.token, call.parent)
			morphTypeNode.kind        = !(TYPE_KIND_SIMPLE_USER)
			morphTypeNode.typeName    = morphDecl.name.name
			morphTypeNode.declaration = morphDecl

			replaceQueuedNodeAndUnqueueOldTree(state, call, morphTypeNode)

			-- Stay in PIPE_INFER. Also, the next line is needed.
			!DEPEND_AND_RETURN(`morphTypeNode`, DEPEND_NODE_INFERRED, `morphDecl`)
		end
	end

	-- Create declaration for the morphed struct.
	local morphDecl            = astNewNode(AstDeclaration, struct.token, struct)
	morphDecl.isConstant       = true
	morphDecl.addedByPolymorph = true

	local morphIdent       = astNewNode(AstIdentifier, morphDecl.token, morphDecl)
	morphIdent.name        = typeNode.typeName.."_POLY"..(#struct.polymorphs+1)
	morphIdent.declaration = morphDecl
	morphDecl.name         = morphIdent

	local morphStruct                 = astCopy(struct, nil, morphDecl)
	morphStruct.inferredType          = nil
	morphStruct.representedType       = nil
	morphStruct.polymorphSourceStruct = struct
	morphDecl.value                   = morphStruct

	-- Don't keep copies of previous polymorphs we've made - that would quickly create a mess!
	-- (@Speed: Don't even copy them in the first place.)
	do
		morphStruct.isPolymorphic = false
		morphStruct.polymorphs    = {}

		for i, statement in ipairsr(morphStruct.statements) do
			if isAny(statement.nodeType, !(nodeTypes.AstDeclaration),!(nodeTypes.AstAssignment)) and statement.addedByPolymorph then
				table.remove(morphStruct.statements, i) -- This line should only trigger at most twice per polymorph.
			end
		end
	end

	table.insert(struct.polymorphs, morphDecl)

	-- Bake values into morphed struct.
	for argIndex, declBaked in ipairs(morphStruct.bakeDeclarations) do
		local valueExpr = call.arguments[argIndex] -- Is nil for optional arguments.
		if valueExpr then
			declBaked.value = astCopy(valueExpr, nil, declBaked) -- Overwrite any old value expression.
		end
		declBaked.checkedRedeclaration = true -- @Hack to prevent redeclaration errors between polymorphed struct and base struct.
	end

	-- Update the source struct, add queueds etc.
	local i              = #struct.statements+1
	struct.statements[i] = morphDecl
	addToQueueRecursively(state, morphDecl, struct.statements, i, !(PIPE_INFER))

	-- Change the call into a type node.
	local morphTypeNode       = astNewNode(AstType, morphDecl.name.token, call.parent)
	morphTypeNode.kind        = !(TYPE_KIND_SIMPLE_USER)
	morphTypeNode.typeName    = morphDecl.name.name
	morphTypeNode.declaration = morphDecl

	replaceQueuedNodeAndUnqueueOldTree(state, call, morphTypeNode)

	-- Stay in PIPE_INFER. Also, the next line is needed.
	!DEPEND_AND_RETURN(`morphTypeNode`, DEPEND_NODE_INFERRED, `morphDecl`)
end

local function doesExpressionRepresentPolymorphicStructType(expr)
	if expr.inferredType.tag ~= !(typeTags.TypeInfoType) then  return false  end

	local typeInfoRepresented = getTypeRepresentedByExpression(expr)
	return
		typeInfoRepresented ~= nil
		and typeInfoRepresented.tag == !(typeTags.TypeInfoStruct)
		and typeInfoRepresented.isPolymorphic
end

!NODE_INFERRER `function nodeInferrers.AstCall(state, call)`
	local callee         = call.callee
	local calleeTypeInfo = callee.inferredType

	if not calleeTypeInfo then
		!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `callee`)
	end

	if callee.nodeType == !(nodeTypes.AstIdentifier) and callee.declaration.overloadOf then
		-- Wait for all overloads to get inferred.
		local ident    = callee
		local declBase = ident.declaration

		while declBase.overloadOf ~= declBase do  declBase = declBase.overloadOf  end

		calleeTypeInfo = declBase.name.inferredType
		if not calleeTypeInfo then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `declBase.name`)
		end
	end

	for _, argExpr in ipairs(call.arguments) do
		if not argExpr.inferredType then
			!DEPEND_AND_RETURN(`call`, DEPEND_NODE_INFERRED, `argExpr`)
		end
	end

	if calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then
		-- void

	elseif calleeTypeInfo.tag == !(typeTags.TypeInfoList) then
		local listSig  = calleeTypeInfo
		calleeTypeInfo = listSig[1]

		if not calleeTypeInfo then
			typeError(state, call, "Trying to call void.")
		elseif calleeTypeInfo.tag == !(typeTags.TypeInfoFunction) then
			-- void
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
		end

	elseif doesExpressionRepresentPolymorphicStructType(callee) then -- @Cleanup: We can/should probably just check callee.declaration.valueTypeInfo here.
		handlePolymorphicStruct(state, call)
		return

	else
		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			local ident = callee
			typeError(state, ident, "'%s' is not a function. (It is %s)", ident.name, getFriendlyTypeInfoName(ident.inferredType))
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(calleeTypeInfo))
		end
	end

	!ASSERT("calleeTypeInfo.tag == "..typeTags.TypeInfoFunction)

	!if DEBUG then
		if call.isMethod and callee.nodeType ~= !(nodeTypes.AstAccess) then
			astPrint(callee)
			errorInternal(state, call)
		end
	!end

	local realArguments     = (call.isMethod and {call, unpack(call.arguments)} or call.arguments)
	local realArgumentTypes = {}

	if call.isMethod then
		local typeInfo       = callee.object.inferredType
		realArgumentTypes[1] = adjustTypeToOne(state, callee.object, typeInfo, true) -- Is adjustTypeToOne necessary? @Cleanup
	end
	for _, argExpr in ipairs(call.arguments) do
		local typeInfo = argExpr.inferredType
		if isAny(argExpr.nodeType, !(nodeTypes.AstVararg),!(nodeTypes.AstCall)) and argExpr.surroundedByParentheses then
			typeInfo = adjustTypeToOne(state, argExpr, typeInfo, true)
		end
		table.insert(realArgumentTypes, typeInfo)
	end

	-- Polymorphic call.
	if calleeTypeInfo.isPolymorphic then
		handlePolymorphicCall(state, call, calleeTypeInfo, realArguments, realArgumentTypes)
		return -- Wait for the polymorphed function to infer.

	-- Overloaded call.
	elseif callee.nodeType == !(nodeTypes.AstIdentifier) and callee.declaration.overloadOf then
		calleeTypeInfo = handleOverloadedCall(state, call, realArguments, realArgumentTypes) or errorInternal(state, call)

	-- Plain call.
	else
		checkIfValuesMatchArgumentTypes(state, call, realArguments, realArgumentTypes, calleeTypeInfo.argumentTypesIn)
	end

	call.inferredType              = getTypeInfoForList(state, calleeTypeInfo.argumentTypesOut)
	call.couldBeTypeWithParameters = false

	moveToNextRelevantPipe(state, call)
end

!NODE_INFERRER `function nodeInferrers.AstReturn(state, returnNode)`
	for _, valueExpr in ipairs(returnNode.values) do
		if not valueExpr.inferredType then
			!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `valueExpr`)
		end
	end

	local scope = getClosestScope(returnNode) or errorInternal()

	while scope.nodeType ~= !(nodeTypes.AstLambda) do
		if not isScopeImperative(scope) then -- This may eventually be AstFileScope, at most.
			-- I think this is an internal compiler error, actually. Parsing must have goofed up or something.
			typeError(state, scope, "Return statement is not in a function.")
		end

		scope = getClosestScope(scope) or errorInternal()
	end

	local lambda = scope

	if not lambda.inferredType then
		!DEPEND_AND_RETURN(`returnNode`, DEPEND_NODE_INFERRED, `lambda`)
	end

	local typeInfos = {}
	for i, valueExpr in ipairs(returnNode.values) do
		typeInfos[i] = valueExpr.inferredType
	end

	checkIfValuesMatchArgumentTypes(state, returnNode, returnNode.values, typeInfos, lambda.inferredType.argumentTypesOut)
	moveToNextRelevantPipe(state, returnNode)
end

!NODE_INFERRER `function nodeInferrers.AstDeclaration(state, decl)`
	local valueExpr = getDeclarationValue(decl, true)
	if valueExpr and not valueExpr.inferredType then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `valueExpr`)
	end

	local identOrVararg = decl.name
	if not identOrVararg.inferredType then
		!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `identOrVararg`)
	end

	local typeExpr = decl.type

	if typeExpr then
		if not typeExpr.inferredType then
			!DEPEND_AND_RETURN(`decl`, DEPEND_NODE_INFERRED, `typeExpr`)
		end

		local typeInfoRepresented = requireTypeRepresentedByExpression(state, typeExpr)

		if decl.parent.nodeType == !(nodeTypes.AstArgument) then
			-- void  (Ignore function arguments.)
		elseif typeInfoRepresented.tag ~= !(typeTags.TypeInfoCompound) then
			-- void
		elseif decl.isConstant then
			typeError(
				state, decl.name,
				"Constants cannot be compound types. (Type is %s)",
				getFriendlyTypeInfoName(typeInfoRepresented)
			)
		elseif not valueExpr then
			typeError(
				state, decl.name,
				"An initial value is required for compound types. (Type is %s)",
				getFriendlyTypeInfoName(typeInfoRepresented)
			)
		end
	end

	-- @Incomplete: decl.notes (if we make them structured, which we should!)

	if valueExpr then
		if valueExpr.inferredType.tag == !(typeTags.TypeInfoNamespace) and not decl.isConstant then
			typeError(state, valueExpr, "References to namespaces must be constant.")
		end

		local scope              = getClosestScope(decl) or errorInternal()
		local scopeIsDeclarative = isScopeDeclarative(scope)

		-- Validate that the assigned value is the same type as the declared name.
		--
		-- (Not needed for vararg as those only exist as arguments and don't have default values.
		-- Also, this doesn't run for enum members as those declarations never have any specified types.)
		--
		if typeExpr and identOrVararg.nodeType ~= !(nodeTypes.AstVararg) then
			local ident = identOrVararg

			if decl.assignment then
				getAssignmentValue(state, ident, decl.assignment.values, decl.assignmentIndex, ident.inferredType, nil, nil)

			elseif not isTypeCompatibleWith(decl.value.inferredType, ident.inferredType) then -- Note: No need to call adjustTypeToOne() for decl.value.
				-- @UX: Use the same error message as getAssignmentValue().
				typeError(
					state, valueExpr, "Value type mismatch for assignment target #%d. (Wanted %s, got %s)",
					decl.assignmentIndex,
					getFriendlyTypeInfoName(ident.inferredType),
					getFriendlyTypeInfoName(decl.value.inferredType)
				)
			end
		end

		if scopeIsDeclarative or decl.isConstant then
			if isExpressionConstant(state, valueExpr) then
				-- void

			elseif valueExpr.nodeType == !(nodeTypes.AstForeign) then
				-- void
				-- We usually treat foreign values as runtime values. The only exception is when
				-- it's placed directly on a declaration. (Can this be solved in a better way?)
				-- :SpecialForeignValueRules

			elseif astFindInTree(valueExpr, !(nodeTypes.AstForeign)) then
				local foreign = astFindInTree(valueExpr, !(nodeTypes.AstForeign))
				typeError(state, foreign, "Cannot evaluate foreign values during compile time.")

			else
				-- @UX: If the expression is/contains a table with a non-constant field, point out which field key or value!
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
					"Value for declared %s '%s' is not a constant expression.%s",
					(decl.isConstant and "constant" or "variable"),
					identOrVararg.name,
					(scopeIsDeclarative and not decl.isConstant and " (All values in declarative scopes must be constant.)" or "")
				)
			end
		end

	elseif identOrVararg.parent.parent.nodeType ~= !(nodeTypes.AstArgument) and not doesTypeHaveAnyDefaultValue(identOrVararg.inferredType) then
		!ASSERT `not decl.isConstant` -- This should have been detected in inferIdentifierOrVararg() (I think).
		typeError(state, identOrVararg, "Variables in type group '%s' must have a specified initial value.", TYPE_TAG_NAMES[identOrVararg.inferredType.tag])
	end

	moveToNextRelevantPipe(state, decl)
end

!!local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = {
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "none",
	[LITERAL_FLOAT]   = "float",
	[LITERAL_STRING]  = "string",
}
_G.!(local )!!BUILTIN_TYPE_TAG_TO_LITERAL_TYPE = {
	[typeTags.TypeInfoBool]   = LITERAL_BOOLEAN,
	[typeTags.TypeInfoInt]    = LITERAL_INTEGER,
	[typeTags.TypeInfoNone]   = LITERAL_NIL,
	[typeTags.TypeInfoFloat]  = LITERAL_FLOAT,
	[typeTags.TypeInfoString] = LITERAL_STRING,
}

!NODE_INFERRER `function nodeInferrers.AstLiteral(state, literal)`
	local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType] or errorUnhandledNodeType(state, literal)

	literal.inferredType = getTypeInfoForBuiltinType(state, typeName)

	moveToNextRelevantPipe(state, literal)
end

!NODE_INFERRER `function nodeInferrers.AstUnary(state, unary)`
	local typeInfo = unary.expression.inferredType
	if not typeInfo then
		!DEPEND_AND_RETURN(`unary`, DEPEND_NODE_INFERRED, `unary.expression`)
	end

	typeInfo = adjustTypeToOne(state, unary.expression, typeInfo, true)

	if isAny(unary.operation, "+","-") then
		-- @Incomplete: Allow int|float compound type here (or disallow declarations of that specific compound type).
		if not isTypeNumeric(typeInfo) then
			typeError(
				state, unary.expression,
				"Unary numeric operation (%s): Expected a float or int. (Got %s)",
				unary.operation,
				getFriendlyTypeInfoName(typeInfo)
			)
		end

	elseif unary.operation == "not" then
		if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
			wrapInImplicitCast(state, unary.expression, getTypeInfoForBuiltinType(state, "bool"), true)
			return
		end

	elseif unary.operation == "#" then
		if not isAny(typeInfo.tag, !(typeTags.TypeInfoArray),!(typeTags.TypeInfoTable)) then
			typeError(
				state, unary.expression,
				"Unary length operation (#): Expected an array or a table. (Got %s)",
				getFriendlyTypeInfoName(typeInfo)
			)
		end

		typeInfo = getTypeInfoForBuiltinType(state, "int")

	else
		errorUnhandledNodeType(state, unary)
	end

	unary.inferredType = typeInfo

	moveToNextRelevantPipe(state, unary)
	simplifyExpressionIfConstant(state, unary)
end

local function isArrayItemOrTableFieldCheck(state, binary, typeInfoL, typeInfoR)
	-- Detect situations like these: myArray[i]==nil or myTable[k]==nil

	local maybeAccess = binary.left
	local nilExpr     = binary.right

	if nilExpr.inferredType.tag == !(typeTags.TypeInfoNone) then
		-- void
	elseif maybeAccess.inferredType.tag == !(typeTags.TypeInfoNone) then
		nilExpr, maybeAccess = maybeAccess, nilExpr
	else
		return false
	end

	if maybeAccess.nodeType ~= !(nodeTypes.AstAccess) then  return false  end
	if not isAny(maybeAccess.object.inferredType.tag, !(typeTags.TypeInfoArray),!(typeTags.TypeInfoTable)) then  return false  end

	return true
end

local function isCompoundCompare(state, binary, typeInfoL, typeInfoR)
	-- Detect situations like these: local v:int|string = 0 ; if v == ""

	local compound    = typeInfoL
	local otherType   = typeInfoR

	local lIsCompound = (compound.tag  == !(typeTags.TypeInfoCompound))
	local rIsCompound = (otherType.tag == !(typeTags.TypeInfoCompound))

	if lIsCompound and rIsCompound then
		-- The compound types must be the same for a theoretical test here to pass
		-- since both compounds must contain all of the other one's types, but we
		-- should already have checked for that and thus shouldn't be here. So, we
		-- simply say they are incompatible right away.
		return false
	elseif lIsCompound then
		-- void
	elseif rIsCompound then
		compound, otherType = otherType, compound
	else
		return false
	end

	return indexOf(compound, otherType) ~= nil -- We don't use isTypeCompatibleWith() here - the compound must contain exactly otherType!
end

local function isValidEqualityCheck(state, binary, typeInfoL, typeInfoR)
	if typeInfoL     == typeInfoR               then  return true  end
	if typeInfoL.tag == !(typeTags.TypeInfoAny) then  return true  end
	if typeInfoR.tag == !(typeTags.TypeInfoAny) then  return true  end

	if isArrayItemOrTableFieldCheck(state, binary, typeInfoL, typeInfoR) then  return true  end
	if isCompoundCompare           (state, binary, typeInfoL, typeInfoR) then  return true  end

	return false
end

-- resultingTypeInfo = checkBinaryOperation( state, expressionForError, mainExpression, leftExpression, rightExpression, binaryOperation, typeInfoL, typeInfoR, inAssignment )
-- Resurns nil if a cast was added and we're now waiting for it to infer.
function _G.checkBinaryOperation(state, exprForError, exprMain,exprL,exprR, binOp, typeInfoL,typeInfoR, inAssignment)
	!local TYPE_MISMATCH = `typeError(
		state, exprForError,
		"Binary operation (%s): Type mismatch for operands. (Left is %s, right is %s)",
		binOp,
		getFriendlyTypeInfoName(typeInfoL),
		getFriendlyTypeInfoName(typeInfoR)
	)`

	-- Numeric operation.
	if isAny(binOp, "+","-","*","^","%","/","//") then
		if not (isTypeNumeric(typeInfoL) and isTypeNumeric(typeInfoR)) then
			typeError(
				state, exprMain,
				"Binary numeric operation (%s): Expected operands to be numeric. (Got %s and %s)",
				binOp,
				getFriendlyTypeInfoName(typeInfoL),
				getFriendlyTypeInfoName(typeInfoR)
			)
		end

		if binOp == "/" then
			return getTypeInfoForBuiltinType(state, "float")
		elseif binOp == "//" then
			return getTypeInfoForBuiltinType(state, "int")
		elseif isAny(!(typeTags.TypeInfoFloat), typeInfoL.tag,typeInfoR.tag) then
			return getTypeInfoForBuiltinType(state, "float")
		else
			return getTypeInfoForBuiltinType(state, "int")
		end

	-- Comparison.
	elseif isAny(binOp, "<",">","<=",">=") then
		if typeInfoL ~= typeInfoR then
			!!(TYPE_MISMATCH)
		elseif not isAny(typeInfoL.tag, !(typeTags.TypeInfoInt),!(typeTags.TypeInfoFloat),!(typeTags.TypeInfoString)) then
			typeError(
				state, exprMain,
				"Binary comparison (%s): Expected a float, int or string. (Got %s)",
				binOp,
				getFriendlyTypeInfoName(typeInfoL)
			)
		end

		return getTypeInfoForBuiltinType(state, "bool")

	-- Equality.
	elseif isAny(binOp, "==","~=") then
		if not isValidEqualityCheck(state, exprForError, typeInfoL, typeInfoR) then
			!!(TYPE_MISMATCH)
		end
		return getTypeInfoForBuiltinType(state, "bool")

	-- Boolean operation.
	elseif isAny(binOp, "and","or") then
		local bothAreBool = true
		local typeInfo    = getTypeInfoForBuiltinType(state, "bool")

		if typeInfoL.tag ~= !(typeTags.TypeInfoBool) then
			!ASSERT `not inAssignment`
			bothAreBool = false
			wrapInImplicitCast(state, exprL, typeInfo, true)
		end
		if typeInfoR.tag ~= !(typeTags.TypeInfoBool) then
			bothAreBool = false
			wrapInImplicitCast(state, exprR, typeInfo, true)
		end

		if not bothAreBool then  return nil  end
		return typeInfo

	-- String concatenation.
	elseif binOp == ".." then
		if typeInfoL.tag ~= !(typeTags.TypeInfoString) then
			typeError(state, exprL, "String concatenation expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoL))
		elseif typeInfoR.tag ~= !(typeTags.TypeInfoString) then
			typeError(state, exprR, "String concatenation expected a string. (Got %s)", getFriendlyTypeInfoName(typeInfoR))
		end
		return getTypeInfoForBuiltinType(state, "string")

	else
		errorUnhandledNodeType(state, exprForError)
	end
end

!NODE_INFERRER `function nodeInferrers.AstBinary(state, binary)`
	local typeInfoL = binary.left.inferredType
	local typeInfoR = binary.right.inferredType

	if not typeInfoL then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.left`)
	end
	if not typeInfoR then
		!DEPEND_AND_RETURN(`binary`, DEPEND_NODE_INFERRED, `binary.right`)
	end

	typeInfoL = adjustTypeToOne(state, binary.left,  typeInfoL, true)
	typeInfoR = adjustTypeToOne(state, binary.right, typeInfoR, true)

	local typeInfo = checkBinaryOperation(state, binary, binary.left,binary.left,binary.right, binary.operation, typeInfoL,typeInfoR, false)
	if not typeInfo then  return  end

	binary.inferredType = typeInfo

	moveToNextRelevantPipe(state, binary)
	simplifyExpressionIfConstant(state, binary)
end

function _G.getConstantNameOrTriggerError(state, node)
	if not (node.nodeType == !(nodeTypes.AstLiteral) and node.literalType == !(LITERAL_STRING)) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(node), "Expected a name constant as the member.")
	end

	local literal = node
	local name    = literal.value

	if not name:find"^[%a_\128-\255][%w_\128-\255]*$" then
		typeError(state, literal, "Bad format or invalid characters in name '%s'.", name)
	end

	return name
end

local function checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode(state, topNodeToCheck, staticObjectNode)
	astVisitAllNodes(topNodeToCheck, function(node)
		if not (
			node.nodeType == !(nodeTypes.AstAccess)
			or (
				node.nodeType == !(nodeTypes.AstIdentifier)
				and node == node.parent.object -- We know this is an access because astVisitAllNodes() visit parents first.
			)
			or (
				node.nodeType == !(nodeTypes.AstLiteral)
				and node == node.parent.member -- We know this is an access because astVisitAllNodes() visit parents first.
			)
		) then
			typeError2(state,
				staticObjectNode, F("Trying to access a static object using code that looks like it's supposed to do something at runtime. Ambigous intension."),
				node,             F("...this looks like a runtime expression.")
			)
		end
	end)
end

!NODE_INFERRER `function nodeInferrers.AstAccess(state, access)`
	local typeInfoObject = access.object.inferredType
	local typeInfoMember = access.member.inferredType

	if not typeInfoObject then
		!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `access.object`)
	end
	if not typeInfoMember then
		!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `access.member`)
	end

	typeInfoObject = adjustTypeToOne(state, access.object, typeInfoObject, true)
	typeInfoMember = adjustTypeToOne(state, access.member, typeInfoMember, true)

	local isDirectObj    = access.object.inferredType == typeInfoObject
	local isDirectMember = access.member.inferredType == typeInfoMember

	local isLeftValue         = access.parent.nodeType == !(nodeTypes.AstAssignment) and indexOf(access.parent.targets, access) ~= nil
	local typeInfoRepresented = getTypeRepresentedByExpression(access.object)

	if typeInfoObject.tag == !(typeTags.TypeInfoTable) then
		if typeInfoMember.tag == !(typeTags.TypeInfoNone) then
			typeError(state, access.member, "Table keys cannot be nil.")

		elseif typeInfoMember.tag == !(typeTags.TypeInfoCompound) and indexOf(typeInfoMember, getTypeInfoForBuiltinType(state, "none")) then
			typeError(state, access.member, "Table keys cannot be nil. (Type is %s)", getFriendlyTypeInfoName(typeInfoMember))

		--[[ This warning message may be too noisy in some programs.
		elseif typeInfoMember.tag == !(typeTags.TypeInfoAny) then
			-- @Incomplete: Add a setting to suppress warnings.
			typeMessage(
				io.stderr, state, astGetExpressionVisuallyFurthestToTheLeft(access.member),
				"Warning", "Table key is 'any' and thus possibly nil."
			)
		--]]
		end

		access.inferredType = getTypeInfoForBuiltinType(state, "any")
		moveToNextRelevantPipe(state, access)

	elseif typeInfoObject.tag == !(typeTags.TypeInfoArray) then
		local arraySig = typeInfoObject

		if typeInfoMember.tag == !(typeTags.TypeInfoInt) then
			-- @Incomplete: Check for isLeftValue and constantness.

			if access.member.nodeType == !(nodeTypes.AstLiteral) and access.member.value < 1 then
				local indexLiteral = access.member
				typeError(state, indexLiteral, "Array index is %d.", indexLiteral.value)
			end

			access.inferredType = arraySig.itemType

			if not (isExpressionConstant(state, access.object) and isExpressionConstant(state, access.member)) then
				moveToNextRelevantPipe(state, access)
				return
			end

			-- Check that the item in the constant array exists.
			local indexLiteral = access.member
			assert(indexLiteral.nodeType == !(nodeTypes.AstLiteral))
			local i = indexLiteral.value

			local tableNode = followIdentifiersToConstantValue(access.object)
			assert(tableNode.nodeType == !(nodeTypes.AstTable))

			local itemExpr = nil

			for _, tableField in ipairs(tableNode.fields) do
				assert(tableField.key.nodeType == !(nodeTypes.AstLiteral))
				if tableField.key.value == i then
					itemExpr = tableField.value
				end
			end

			if not itemExpr then
				typeError(state, indexLiteral, "No item at index %d in constant array. (Length is %d)", i, #tableNode.fields)
			end

			moveToNextRelevantPipe(state, access)

		-- elseif not isLeftValue and typeInfoMember.tag == !(typeTags.TypeInfoString) then
		-- 	local abstractMemberLiteral = access.member
		-- 	local abstractMemberName    = getConstantNameOrTriggerError(state, abstractMemberLiteral)
		-- 	if abstractMemberName == ? then ... end

		else
			typeError(state, access.member, "Expected an array index of type int. (Got %s)", getFriendlyTypeInfoName(typeInfoMember))
		end

	elseif typeInfoObject.tag == !(typeTags.TypeInfoStruct) or (typeInfoRepresented and typeInfoRepresented.tag == !(typeTags.TypeInfoStruct)) then
		local structInfo = typeInfoRepresented or typeInfoObject
		if not structInfo.hasMembers then
			!DEPEND_AND_RETURN(`access`, DEPEND_STRUCT_MEMBERS_READY, `structInfo`)
		end

		local memberLiteral = access.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)
		local decl          = findDeclarationInScope(state, structInfo.astNode, memberName, false)

		if not decl then
			typeError(state, memberLiteral, "'%s' is not a member of %s.", memberName, getFriendlyTypeInfoName(structInfo))
		elseif isLeftValue and decl.isConstant then
			typeError(state, memberLiteral, "Cannot assign value to constant member %s.%s", getFriendlyTypeInfoName(structInfo), memberName)
		end

		if not decl.isConstant then
			access.inferredType    = decl.name.inferredType or errorInternal()
			access.representedType = decl.valueTypeInfo -- May be nil.

			moveToNextRelevantPipe(state, access)
			return
		end

		if not isExpressionConstant(state, access.object) then
			checkForStaticAccessThatUsesWhatLooksLikeRuntimeCode(state, access.object, access.member)
		end

		local valueExpr = decl.value
		local replacement

		if valueExpr.nodeType == !(nodeTypes.AstLiteral) then
			replacement = astCopy(valueExpr, memberLiteral.token)

		elseif valueExpr.nodeType == !(nodeTypes.AstType) then
			replacement = astCopy(valueExpr, memberLiteral.token)
			addUnqueuedChildrenToQueueRecursively(state, replacement, !(PIPE_DONE))

		elseif valueExpr.nodeType == !(nodeTypes.AstIdentifier) and valueExpr.inferredType.tag == !(typeTags.TypeInfoEnum) then
			replacement = astCopy(valueExpr, memberLiteral.token)

		elseif valueExpr.nodeType == !(nodeTypes.AstLambda) then
			if access.parent.nodeType == !(nodeTypes.AstCall) and access == access.parent.callee and access.parent.isMethod then
				--
				-- Change obj.staticMethod!(...) into staticMethod(obj, ...)
				--
				-- AstCall (method)
				--   CALLEE AstAccess
				--     AstIdentifier (object)
				--     AstLiteral (string)
				--   ARG1...
				--
				-- AstCall (normal)
				--   CALLEE AstIdentifier (static function)
				--   ARG1 AstIdentifier (object)
				--   ARG2...
				--
				local call = access.parent

				-- Move object from access to call arguments.
				local obj = access.object
				table.insert(call.arguments, 1, obj)
				obj.parent = call

				-- Update all argument queueds.
				for i, argExpr in ipairs(call.arguments) do
					argExpr.queued.container = call.arguments
					argExpr.queued.key       = i
				end

				-- Update callee using access. (Note: access==callee)
				local ident        = astNewNode(AstIdentifier, memberLiteral.token, call)
				ident.name         = decl.name.name
				ident.declaration  = decl
				ident.inferredType = decl.name.inferredType
				replaceQueuedNode(state, access, ident)
				moveToNextRelevantPipe(state, ident)

				-- Update call.
				call.isMethod = false

				-- Unqueue now unused nodes.
				unqueue(memberLiteral)

				astPrintTree(call)
				return

			else
				local ident        = astNewNode(AstIdentifier, memberLiteral.token, access.parent)
				ident.name         = decl.name.name
				ident.declaration  = decl
				ident.inferredType = decl.name.inferredType
				replacement        = ident
			end

		else
			where(state, valueExpr)
			errorUnhandledNodeType(state, valueExpr)
		end

		assert(replacement) -- Constants must be simplified!

		replaceQueuedNodeAndUnqueueOldTree(state, access, replacement)
		moveToNextRelevantPipe(state, replacement, !(PIPE_INFER))

	elseif typeInfoObject.tag == !(typeTags.TypeInfoEnum) or (typeInfoRepresented and typeInfoRepresented.tag == !(typeTags.TypeInfoEnum)) then
		local memberLiteral = access.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)

		local enumInfo      = typeInfoRepresented or typeInfoObject
		local decl          = findDeclarationInScope(state, enumInfo.astNode, memberName, false)

		if not decl then
			typeError(state, memberLiteral, "'%s' is not a member of %s.", memberName, getFriendlyTypeInfoName(enumInfo))
		elseif isLeftValue then
			typeError(state, memberLiteral, "Cannot assign values to enum members. (Enum is %s)", getFriendlyTypeInfoName(enumInfo))
		end

		assert(decl.isConstant)

		local ident = astCopy(decl.name, access.token, access.parent)
		replaceQueuedNodeAndUnqueueOldTree(state, access, ident)
		-- Stay in the current pipe so we get simplified. (Needed? Or maybe we can @Speed things up here?)

	elseif typeInfoObject.tag == !(typeTags.TypeInfoNamespace) then
		assert(isDirectObj)

		local memberLiteral = access.member
		local memberName    = getConstantNameOrTriggerError(state, memberLiteral)

		local namespace     = typeInfoObject
		local decl          = findDeclarationInScope(state, namespace.scope, memberName, true)

		if not decl then
			!DEPEND_AND_RETURN(`access`, DEPEND_DECLARATION, `memberName`, `namespace.scope`)
		elseif not decl.name.inferredType then
			!DEPEND_AND_RETURN(`access`, DEPEND_NODE_INFERRED, `decl.name`)
		end

		local ident = astCopy(decl.name, access.token, access.parent)
		replaceQueuedNodeAndUnqueueOldTree(state, access, ident)
		-- Stay in the current pipe so we get simplified. (Needed? Or maybe we can @Speed things up here?)

	else
		typeError(state, access, "Values of type '%s' do not have members.", getFriendlyTypeInfoName(typeInfoObject))
	end
end

!NODE_INFERRER `function nodeInferrers.AstTable(state, tableNode)`
	-- Note: tableNode.inferredType may get set before all child nodes are inferred.
	local typeInfoExpected = tableNode.inferredType or getExpectedTypeInfo(state, tableNode, false, "constructor", tableNode)
	if not typeInfoExpected then  return  end

	if typeInfoExpected.tag == !(typeTags.TypeInfoAny) and tableNode.parent.nodeType == !(nodeTypes.AstTable) then
		typeInfoExpected = getTypeInfoForBuiltinType(state, "table")
	end

	if typeInfoExpected.tag == !(typeTags.TypeInfoTable) then
		-- @Incomplete: Check for duplicate fields (among constant keys).
		-- @Incomplete: Check for nil keys.
		tableNode.inferredType = typeInfoExpected

	elseif typeInfoExpected.tag == !(typeTags.TypeInfoArray) then
		local arraySig = typeInfoExpected

		for _, tableField in ipairs(tableNode.fields) do
			local indexLiteral = tableField.key

			if not indexLiteral.inferredType then
				!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `indexLiteral`)
			elseif indexLiteral.inferredType.tag ~= !(typeTags.TypeInfoInt) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(indexLiteral),
					"Array indices must be integers. (This is %s)",
					getFriendlyTypeInfoName(indexLiteral.inferredType)
				)
			elseif indexLiteral.nodeType ~= !(nodeTypes.AstLiteral) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(indexLiteral),
					"Indices must be constant in array constructors."
				)
			end

			local itemExpr     = tableField.value
			local itemTypeInfo = itemExpr.inferredType

			if itemTypeInfo then
				if not isTypeCompatibleWith(adjustTypeToOne(state, itemExpr, itemTypeInfo, true), arraySig.itemType) then
					typeError(
						state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
						"Array item type mismatch. (Wanted %s, got %s)",
						getFriendlyTypeInfoName(arraySig.itemType),
						getFriendlyTypeInfoName(adjustTypeToOne(state, itemExpr, itemTypeInfo, true))
					)
				end
			elseif itemExpr.nodeType == !(nodeTypes.AstTable) then
				if isTypeTableLike(arraySig.itemType) then
					-- void  (Wait with validation.)
				else
					typeError(
						state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
						"Expected array item to be %s.",
						getFriendlyTypeInfoName(arraySig.itemType)
					)
				end
			else
				!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `itemExpr`)
			end
		end

		tableNode.inferredType = arraySig

		-- Validate indices and sequence.
		local indexLiterals       = {}
		local highestLiteralIndex = 0

		for _, tableField in ipairs(tableNode.fields) do
			local literal    = tableField.key
			local arrayIndex = literal.value

			if indexLiterals[arrayIndex] then
				typeError2(state,
					literal,                   F("Duplicate index %d.", arrayIndex),
					indexLiterals[arrayIndex], F("...first occurance is here.")
				)
			end

			indexLiterals[arrayIndex] = literal
			highestLiteralIndex       = math.max(highestLiteralIndex, arrayIndex)
		end

		for arrayIndex = 1, highestLiteralIndex do
			if not indexLiterals[arrayIndex] then
				typeError(state, tableNode, "Array is not a sequence. Missing item at index %d.", arrayIndex)
			end
		end

	elseif typeInfoExpected.tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfoExpected

		-- @Incomplete: This dependency is problematic in these cases:
		-- local Struct :: struct{ bad:Struct = {} }
		-- local Struct :: struct{ bad = cast(Struct) {} }
		if not structInfo.hasMembers then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_STRUCT_MEMBERS_READY, `structInfo`)
		end

		for _, tableField in ipairs(tableNode.fields) do
			local memberLiteral = tableField.key

			if not memberLiteral.inferredType then
				!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `memberLiteral`)
			elseif memberLiteral.inferredType.tag ~= !(typeTags.TypeInfoString) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(memberLiteral),
					"Struct constructor keys must be strings. (This is %s)",
					getFriendlyTypeInfoName(memberLiteral.inferredType)
				)
			elseif memberLiteral.nodeType ~= !(nodeTypes.AstLiteral) then
				typeError(
					state, astGetExpressionVisuallyFurthestToTheLeft(memberLiteral),
					"Keys must be constant in struct constructors."
				)
			end

			local memberName = memberLiteral.value
			local member     = itemWith1(structInfo.members, "name", memberName)

			if member then
				-- void
			elseif findDeclarationInScope(state, structInfo.astNode, memberName, false) then
				typeError(state, memberLiteral, "'%s' is a static member in %s.", memberName, getFriendlyTypeInfoName(structInfo))
			else
				typeError(state, memberLiteral, "'%s' is not a member of %s.", memberName, getFriendlyTypeInfoName(structInfo))
			end

			local fieldValue    = tableField.value
			local valueTypeInfo = fieldValue.inferredType

			if valueTypeInfo then
				if not isTypeCompatibleWith(adjustTypeToOne(state, fieldValue, valueTypeInfo, true), member.typeInfo) then
					typeError(
						state, astGetExpressionVisuallyFurthestToTheLeft(fieldValue),
						"Type mismatch for struct field '%s'. (Wanted %s, got %s)",
						memberName,
						getFriendlyTypeInfoName(member.typeInfo),
						getFriendlyTypeInfoName(valueTypeInfo)
					)
				end
			elseif fieldValue.nodeType == !(nodeTypes.AstTable) then
				if isTypeTableLike(member.typeInfo) then
					-- void  (Wait with validation.)
				else
					typeError(
						state, astGetExpressionVisuallyFurthestToTheLeft(itemExpr),
						"Expected value for struct field '%s' to be %s.",
						memberName, getFriendlyTypeInfoName(member.typeInfo)
					)
				end
			else
				!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `fieldValue`)
			end
		end

		tableNode.inferredType = structInfo

		-- Validate keys.
		local keyLiterals = {}

		for _, tableField in ipairs(tableNode.fields) do
			local memberLiteral = tableField.key
			local memberName    = memberLiteral.value

			if keyLiterals[memberName] then
				typeError2(state,
					memberLiteral,           F("Duplicate field '%s'.", memberName),
					keyLiterals[memberName], F("...first occurance is here.")
				)
			end

			keyLiterals[memberName] = memberLiteral
		end

	else
		typeError(
			state, tableNode,
			"This constructor is trying to get inferred as %s (type group '%s') which is illegal. (The inferred type must be array, struct or table.)",
			getFriendlyTypeInfoName(typeInfoExpected),
			TYPE_TAG_NAMES[typeInfoExpected.tag]
		)
	end

	!ASSERT `tableNode.inferredType`

	-- Make sure all children, including table-likes, are inferred before we advance to the next pipe.
	for _, tableField in ipairs(tableNode.fields) do
		if not tableField.value.inferredType then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `tableField.value`)
		end
		if not tableField.key.inferredType then
			!DEPEND_AND_RETURN(`tableNode`, DEPEND_NODE_INFERRED, `tableField.key`)
		end
	end

	moveToNextRelevantPipe(state, tableNode)
end

!NODE_INFERRER `function nodeInferrers.AstArgument(state, arg)`
	if arg.declaration.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`arg`, DEPEND_NODE_INFERRED, `arg.declaration`)
	end
	moveToNextRelevantPipe(state, arg)
end

!NODE_INFERRER `function nodeInferrers.AstArguments(state, args)`
	for _, arg in ipairs(args.arguments) do
		if arg.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`args`, DEPEND_NODE_INFERRED, `arg`)
		end
	end
	moveToNextRelevantPipe(state, args)
end

!NODE_INFERRER `function nodeInferrers.AstLambda(state, lambda)`
	if lambda.argumentsIn and lambda.argumentsIn.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.argumentsIn`)
	end
	if lambda.argumentsOut and lambda.argumentsOut.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_INFERRED, `lambda.argumentsOut`)
	end

	-- Note: We don't require the body to inferred - just the "header".

	if lambda.argumentsIn then
		for _, arg in ipairs(lambda.argumentsIn.arguments) do
			if arg.declaration.value and not isExpressionConstant(state, arg.declaration.value) then
				typeError(state, astGetExpressionVisuallyFurthestToTheLeft(arg.declaration.value), "Non-constant default values for arguments are not supported yet.")
			end
		end
	end

	lambda.inferredType = getTypeInfoForLambda(state, lambda) or errorInternal()

	if lambda.bodyIsForeign then
		if lambda.foreignSourceName == "" then
			errorInternal(state, lambda, "@Incomplete: Infer lambda.foreignSourceName")
		end
		validateForeignSource(state, lambda.foreignSource, lambda.foreignSourceName, lambda)
		lambda.foreignSourceId = lambda.foreignSource.." "..lambda.foreignSourceName
	end

	moveToNextRelevantPipe(state, lambda)
end

!NODE_INFERRER `function nodeInferrers.AstTypeOf(state, typeOf)`
	-- @Robustness: Check that the expression doesn't have code that looks like it's going to be executed, because it's not!

	local exprTypeInfo = typeOf.expression.inferredType

	if not exprTypeInfo then
		!DEPEND_AND_RETURN(`typeOf`, DEPEND_NODE_INFERRED, `typeOf.expression`)
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoNamespace) then
		typeError(state, typeOf.expression, "Namespaces don't have a type.")
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoList) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(typeOf.expression), "Cannot get the type of function calls.")
	end

	typeOf.inferredType    = getTypeInfoForBuiltinType(state, "type")
	typeOf.representedType = exprTypeInfo

	if typeOf.representedType.tag == !(typeTags.TypeInfoVararg) then
		local varargSig        = typeOf.representedType
		typeOf.representedType = varargSig.itemType
	end

	moveToNextRelevantPipe(state, typeOf)
	simplifyTypeExpression(state, typeOf, typeOf.representedType)
end

!NODE_INFERRER `function nodeInferrers.AstCast(state, cast)`
	-- Note: For convenience, cast.targetType may be nil here for generated casts. cast.inferredType must be set in those cases.

	!local INVALID_CAST = `
		typeError(
			state, astGetExpressionVisuallyFurthestToTheLeft(cast.expression),
			"Cannot cast from %s to %s.",
			getFriendlyTypeInfoName(exprTypeInfo),
			getFriendlyTypeInfoName(castTypeInfo)
		)
	`

	if cast.targetType and not cast.targetType.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.targetType`)
	end
	if not cast.expression.inferredType then
		!DEPEND_AND_RETURN(`cast`, DEPEND_NODE_INFERRED, `cast.expression`)
	end

	local castTypeInfo = cast.inferredType or requireTypeRepresentedByExpression(state, cast.targetType)
	local exprTypeInfo = adjustTypeToOne(state, cast.expression, cast.expression.inferredType, true)

	if castTypeInfo == exprTypeInfo then
		moveToPipe(state, cast, cast.expression.queued.pipe) -- @Cleanup: Maybe cutOutPartOfNodeTree()/replaceQueuedNode() should do this.
		cutOutPartOfNodeTree(state, cast, cast.expression)
		return

	elseif isTypeCompatibleWith(exprTypeInfo, castTypeInfo) then
		-- void  (Valid cast.)

	elseif isTypeNumeric(castTypeInfo) and isTypeNumeric(exprTypeInfo) then
		-- void  (Valid cast.)

	elseif castTypeInfo.tag == !(typeTags.TypeInfoBool) and isAny(
		exprTypeInfo.tag,
		!(typeTags.TypeInfoInt),
		!(typeTags.TypeInfoFloat),
		!(typeTags.TypeInfoString),
		!(typeTags.TypeInfoArray)
	) then
		-- void  (Valid cast.)

	elseif exprTypeInfo.tag == !(typeTags.TypeInfoEnum) and isTypeCompatibleWith(castTypeInfo, exprTypeInfo.memberTypeInfo) then
		-- void  (Enum members can cast to the real member type.)

	elseif exprTypeInfo.tag == !(typeTags.TypeInfoEnum) and isTypeNumeric(castTypeInfo) and isTypeNumeric(exprTypeInfo.memberTypeInfo) then
		-- We need two casts to happen in sequence here so we wrap ourselves in another cast.
		wrapInImplicitCast(state, cast, exprTypeInfo.memberTypeInfo, false)

	elseif castTypeInfo.tag ~= !(typeTags.TypeInfoCompound) and exprTypeInfo.tag == !(typeTags.TypeInfoCompound) then
		-- We get here for situations like these: local xMaybe:int|nil = 0 ; local x = cast(int) xMaybe
		-- The user better know what they're doing!
		local compound = exprTypeInfo
		if not indexOf(compound, castTypeInfo) then
			!!(INVALID_CAST)
		end

	else
		!!(INVALID_CAST)
	end

	cast.inferredType = castTypeInfo

	moveToNextRelevantPipe(state, cast)
	simplifyExpressionIfConstant(state, cast)
end

!NODE_INFERRER `function nodeInferrers.AstAssignment(state, assignment)`
	for _, targetExpr in ipairs(assignment.targets) do
		if not targetExpr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `targetExpr`)
		end
	end
	for _, expr in ipairs(assignment.values) do
		if not expr.inferredType then
			!DEPEND_AND_RETURN(`assignment`, DEPEND_NODE_INFERRED, `expr`)
		end
	end

	-- Validate targets.
	for _, targetExpr in ipairs(assignment.targets) do
		if not isAny(targetExpr.nodeType, !(nodeTypes.AstIdentifier),!(nodeTypes.AstAccess),!(nodeTypes.AstBlank)) then
			!ifDEBUG`astPrint(targetExpr)`
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(targetExpr), "Invalid assignment target. Expected a variable name or object field.")
		end
	end

	-- Validate values.
	-- Note: Enum member values are already validated by the enum itself.
	local declScope        = assignment.forDeclaration and getClosestScope(assignment) or nil
	local isEnumMemberDecl = declScope ~= nil and declScope.nodeType == !(nodeTypes.AstEnum)

	if not isEnumMemberDecl then
		for i, targetExpr in ipairs(assignment.targets) do
			getAssignmentValue(state, targetExpr, assignment.values, i, targetExpr.inferredType, assignment.binaryOperation, nil)
		end
	end

	-- @Incomplete: Check that !must args from functions have an assignment target.

	moveToNextRelevantPipe(state, assignment)
end

!NODE_INFERRER `function nodeInferrers.AstBreak(state, breakNode)`
	moveToNextRelevantPipe(state, breakNode)
end
!NODE_INFERRER `function nodeInferrers.AstContinue(state, continue)`
	moveToNextRelevantPipe(state, continue)
end

!NODE_INFERRER `function nodeInferrers.AstDefer(state, defer)`
	if defer.body.queued.pipe <= !(PIPE_INFER) then
		!DEPEND_AND_RETURN(`defer`, DEPEND_NODE_INFERRED, `defer.body`)
	end
	moveToNextRelevantPipe(state, defer)
end

!NODE_INFERRER `function nodeInferrers.AstImport(state, import)`
	local path
	if import.isLoad then
		path = isPathAbsolute(import.importName) and import.importName or state.projectDirectory.."/"..import.importName
	else
		path = COMPILER_DIRECTORY.."/modules/"..import.importName..".gloa"
	end

	local globalScope = state.globalScope

	if not state.fileBuffers[path] then
		-- @Incomplete: Include times in compilation stats.
		local timeStartLexing, timeEndLexing = readAndTokenizeFile(state, path)
		!ASSERT `state.fileBuffers[path], path`

		local timeStartParsing = os.clock()
		local fileScope        = parseFileScope(state, globalScope, path, (not import.isLoad), import.importName)
		local timeEndParsing   = os.clock()

		if peekNextToken(state) then
			errorParsingNext(state, "Expected the end of the file.")
		end

		table.insert(globalScope.statements, fileScope)
		if import.isLoad then
			astMoveGlobalDeclarationsToGlobalScope(state, fileScope)
		else
			table.insert(globalScope.fileScopes, fileScope) -- @Cleanup: Don't do this in astMoveGlobalDeclarationsToGlobalScope()!
		end
		local i = indexOf(globalScope.fileScopes, fileScope) or errorInternal()
		addToQueueRecursively(state, fileScope, globalScope.fileScopes, i)
	end

	import.fileScope    = itemWith1(globalScope.fileScopes, "path", path) or errorInternal(path)
	import.inferredType = getTypeInfoForNamespace(state, import.fileScope)

	moveToNextRelevantPipe(state, import)
end

!NODE_INFERRER `function nodeInferrers.AstUsing(state, using)`
	local expr     = using.expression
	local typeInfo = expr.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`using`, DEPEND_NODE_INFERRED, `expr`)
	end

	local usingScope

	if expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration

		if typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			usingScope       = structInfo.astNode

			if not decl.isConstant then
				using.variableDeclaration = decl
			end

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			-- Using an enum value is the same as using the enum type. Is this good?
			local enumInfo = typeInfo
			usingScope     = enumInfo.astNode

		else
			typeError(state, ident, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_TAG_NAMES[typeInfo.tag])
		end

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		typeInfo       = typeNode.representedType

		if typeInfo.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = typeInfo
			usingScope       = structInfo.astNode

		elseif typeInfo.tag == !(typeTags.TypeInfoEnum) then
			local enumInfo = typeInfo
			usingScope     = enumInfo.astNode

		else
			typeError(state, typeNode, "Invalid or unsupported type group (%s) in 'using' expression.", TYPE_TAG_NAMES[typeInfo.tag])
		end

	else
		!ifDEBUG`astPrint(expr)`
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Invalid or unsupported 'using' expression.")
	end

	local scopeOfUsing  = getClosestScope(using)
	local usingExisting = itemWith1(scopeOfUsing.usings, "scope", usingScope)

	if usingExisting then
		local usingEarly = usingExisting
		local usingLate  = using

		if usingLate.token < usingEarly.token then
			usingEarly, usingLate = usingLate, usingEarly
		end

		typeError2(state,
			usingLate,  F("Duplicate using in the same scope."),
			usingEarly, F("...first using is here.")
		)
	end

	using.scope = usingScope

	moveToNextRelevantPipe(state, using)
end

!NODE_INFERRER `function nodeInferrers.AstForeign(state, foreign)`
	-- @Robustness: Limit places the "expected" type can be inferred from.
	local typeInfoExpected = getExpectedTypeInfo(state, foreign, true, "foreign value", foreign)
	if not typeInfoExpected then  return  end

	foreign.inferredType = typeInfoExpected

	assert((foreign.sourceName ~= ""), "@Incomplete: Infer foreign.sourceName")
	validateForeignSource(state, foreign.source, foreign.sourceName, foreign)
	foreign.sourceId = foreign.source.." "..foreign.sourceName

	moveToNextRelevantPipe(state, foreign)
end

!NODE_INFERRER `function nodeInferrers.AstBake(state, bake)`
	if not bake.name.inferredType then
		!DEPEND_AND_RETURN(`bake`, DEPEND_NODE_INFERRED, `bake.name`)
	end

	local scope, statement = getClosestScope(bake)
	if not (scope and scope.nodeType == !(nodeTypes.AstLambda) and statement == scope.argumentsIn) then
		errorParsing(state, bake.token, "Unexpected '$'.")
	end

	bake.inferredType = bake.name.inferredType
	moveToNextRelevantPipe(state, bake)
end

!NODE_INFERRER `function nodeInferrers.AstDebug(state, debugNode)`
	local expr     = debugNode.expression
	local typeInfo = expr.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`debugNode`, DEPEND_NODE_INFERRED, `expr`)
	end

	if debugNode.action == "assert" then
		if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
			wrapInImplicitCast(state, expr, getTypeInfoForBuiltinType(state, "bool"), true)
			return
		end

		if not isExpressionConstant(state, expr) then
			typeError(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Expression is not constant.")
		elseif not (expr.nodeType == !(nodeTypes.AstLiteral) and expr.literalType == !(LITERAL_BOOLEAN)) then
			errorInternal(state, astGetExpressionVisuallyFurthestToTheLeft(expr), "Constant expression did not result in a boolean literal.")
		elseif not expr.value then
			typeError(state, debugNode, "Assertion failed!")
		end

	elseif debugNode.action == "print" then
		astPrintTree(expr)
		typeMessage(state, expr, "!print", "The expression above is here.")

	else
		errorInternal(state, debugNode)
	end

	moveToNextRelevantPipe(state, debugNode)
end

local function inferIfOrWhile(state, ifOrWhile)
	local cond     = ifOrWhile.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`ifOrWhile`, DEPEND_NODE_INFERRED, `cond`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
		wrapInImplicitCast(state, cond, getTypeInfoForBuiltinType(state, "bool"), true)
		return
	end

	-- @Optimize: Remove/replace the branch if the condition is statically known.

	moveToNextRelevantPipe(state, ifOrWhile)
end

!NODE_INFERRER `function nodeInferrers.AstIf(state, ifBranch)`
	inferIfOrWhile(state, ifBranch)
end
!NODE_INFERRER `function nodeInferrers.AstWhile(state, whileLoop)`
	inferIfOrWhile(state, whileLoop)
end

!NODE_INFERRER `function nodeInferrers.AstStaticIf(state, staticIf)`
	local cond     = staticIf.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`staticIf`, DEPEND_NODE_INFERRED, `cond`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
		wrapInImplicitCast(state, cond, getTypeInfoForBuiltinType(state, "bool"), true)
		return
	end

	if not isExpressionConstant(state, cond) then
		typeError(state, astGetExpressionVisuallyFurthestToTheLeft(cond), "Static if: The condition must be a constant expression.")
	elseif not (cond.nodeType == !(nodeTypes.AstLiteral) and cond.literalType == !(LITERAL_BOOLEAN)) then
		errorInternal(state, astGetExpressionVisuallyFurthestToTheLeft(cond), "Constant condition expression did not result in a boolean literal.")
	end

	local scope = staticIf.parent
	assert(isScope(scope))

	local statements     = scope.statements
	local statementIndex = indexOf(statements, staticIf) or errorInternal(state, staticIf)
	local statementsNew  = {}
	local newlyDeclared  = {}

	local branchToUse = (cond.value and staticIf.branchTrue or staticIf.branchFalse)

	if branchToUse then
		!ASSERT("branchToUse.nodeType == "..nodeTypes.AstBlock)
		addUnqueuedChildrenToQueueRecursively(state, branchToUse) -- Note: We update the queueds in a moment.

		for iNew, statement in ipairs(branchToUse.statements) do
			statement.parent    = scope
			statementsNew[iNew] = statement
		end
		for _, decl in ipairs(branchToUse.declarations) do
			table.insert(scope.declarations, decl)
			newlyDeclared[decl]           = true
			newlyDeclared[decl.name.name] = true
		end
		for _, import in ipairs(branchToUse.imports) do
			table.insert(scope.imports, import)
		end
		for _, using in ipairs(branchToUse.usings) do
			table.insert(scope.usings, using)
		end
	end

	for i = statementIndex+1, #statements do
		table.insert(statementsNew, statements[i])
	end

	local iNew = 0
	for i = statementIndex, math.max(#statements, statementIndex + #statementsNew - 1) do
		iNew          = iNew+1
		statements[i] = statementsNew[iNew]
	end

	for i = statementIndex, #statements do
		local statement            = statements[i]
		statement.queued.container = statements
		statement.queued.key       = i
	end

	moveToPipe(state, staticIf, !(PIPE_DONE)) -- Not sure if needed. @Cleanup
	unqueue(staticIf) -- @Robustness: Check if the correct thing happens for things waiting on staticIf (i.e. the scope).

	-- Re-check redeclarations for already-inferred things later in the scope.
	if branchToUse and branchToUse.declarations[1] then
		for _, decl in ipairs(scope.declarations) do
			if not newlyDeclared[decl] and newlyDeclared[decl.name.name] and decl.token > staticIf.token and decl.queued.pipe > !(PIPE_INFER) then
				checkRedeclaration(state, decl.name, decl, false, scope)
			end
		end
	end
end

!NODE_INFERRER `function nodeInferrers.AstConditional(state, conditional)`
	local cond     = conditional.condition
	local typeInfo = cond.inferredType

	if not typeInfo then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `cond`)
	end
	if conditional.branchTrue and not conditional.branchTrue.inferredType then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `conditional.branchTrue`)
	end
	if not conditional.branchFalse.inferredType then
		!DEPEND_AND_RETURN(`conditional`, DEPEND_NODE_INFERRED, `conditional.branchFalse`)
	end

	typeInfo = adjustTypeToOne(state, cond, typeInfo, true)

	if typeInfo.tag ~= !(typeTags.TypeInfoBool) then
		-- Note: This wrap will not affect conditional.conditionAndBranchTrue which is the actual expression we use in the output.
		wrapInImplicitCast(state, cond, getTypeInfoForBuiltinType(state, "bool"), true)
		return
	end

	local branchTrue    = conditional.branchTrue or conditional.conditionAndBranchTrue
	local branchFalse   = conditional.branchFalse

	local typeInfoTrue  = adjustTypeToOne(state, branchTrue,  branchTrue.inferredType,  true)
	local typeInfoFalse = adjustTypeToOne(state, branchFalse, branchFalse.inferredType, true)

	if typeInfoTrue ~= typeInfoFalse then
		typeError(
			state, astGetExpressionVisuallyFurthestToTheLeft(branchFalse),
			"Type mismatch in conditional. (Left branch is %s, right branch is %s)",
			getFriendlyTypeInfoName(typeInfoTrue),
			getFriendlyTypeInfoName(typeInfoFalse)
		)
	end

	conditional.inferredType = typeInfoTrue
	moveToNextRelevantPipe(state, conditional)

	-- @Optimize: Remove/replace the branch if the condition is statically known.
end

local function addDeclarationInForLoop(state, forLoop, name, typeInfo)
	-- @Incomplete: Care about name shadowing.

	local decl         = astNewNode(AstDeclaration, forLoop.token, forLoop)
	local ident        = astNewNode(AstIdentifier, decl.token, decl)
	ident.name         = name
	ident.declaration  = decl
	ident.inferredType = typeInfo
	decl.name          = ident

	table.insert(forLoop.statements,   decl)
	table.insert(forLoop.declarations, decl)

	addToQueueRecursively(state, decl, forLoop, #forLoop, !(PIPE_DONE))
	moveToNextRelevantPipe(state, decl, !(PIPE_INFER))
end

!NODE_INFERRER `function nodeInferrers.AstFor(state, forLoop)`
	if not forLoop.declarations[1] then
		local names  = forLoop.names
		local values = forLoop.expressions

		-- @Incomplete: Add all declarations now and infer their types later to fix confusing "undeclared identifier" errors.

		for _, expr in ipairs(values) do
			if not expr.inferredType then
				!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `expr`)
			end
		end

		-- for [ i = ] start, end [, step ]
		if forLoop.forType == !(FOR_NUMERIC) then
			!ASSERT `#names <= 1`
			!ASSERT `values[2] and not values[4]`

			for _, valueExpr in ipairs(values) do
				if valueExpr.inferredType.tag ~= !(typeTags.TypeInfoInt) then
					typeError(
						state, astGetExpressionVisuallyFurthestToTheLeft(valueExpr),
						"For loop: Expected an int. (Got %s)",
						getFriendlyTypeInfoName(valueExpr.inferredType)
					)
				end
			end

			if values[3] and values[3].nodeType == !(nodeTypes.AstLiteral) and values[3].value == 0 then
				typeError(state, values[3], "The step value is 0.")
			end

			if
				values[1].nodeType == !(nodeTypes.AstLiteral) and
				values[2].nodeType == !(nodeTypes.AstLiteral) and
				(not values[3] or values[3].nodeType == !(nodeTypes.AstLiteral))
			then
				local i1   = values[1].value
				local i2   = values[2].value
				local step = values[3] and values[3].value or 1

				if step > 0 and i2 < i1 then
					typeError(state, values[2], "The final value is lower than the starting value in ascending loop.")
				elseif step < 0 and i2 > i1 then
					typeError(state, values[2], "The final value is higher than the starting value in descending loop.")
				end
			end

			addDeclarationInForLoop(state, forLoop, (names[1] and names[1].name or "it"), values[1].inferredType)

		-- for [ v1, ... : ] obj
		elseif forLoop.forType == !(FOR_SHORT) then
			!ASSERT `#values == 1`

			-- Note: Built-in short-form for loops have the value first and then the index/key.
			local objExpr = values[1]

			if objExpr.inferredType.tag == !(typeTags.TypeInfoArray) then
				local name1 = (names[1] and names[1].name) or "it"
				local name2 = (names[2] and names[2].name) or "itIndex"
				addDeclarationInForLoop(state, forLoop, name2, getTypeInfoForBuiltinType(state, "int"))
				addDeclarationInForLoop(state, forLoop, name1, values[1].inferredType.itemType)

			elseif objExpr.inferredType.tag == !(typeTags.TypeInfoTable) then
				local name1    = (names[1] and names[1].name) or "it"
				local name2    = (names[2] and names[2].name) or "itIndex"
				local typeInfo = getTypeInfoForBuiltinType(state, "any")
				addDeclarationInForLoop(state, forLoop, name2, typeInfo)
				addDeclarationInForLoop(state, forLoop, name1, typeInfo)

			elseif objExpr.inferredType.tag == !(typeTags.TypeInfoStruct) then
				-- We need custom iterators to work AND default iterators for structs before we can do this!
				typeError(state, objExpr, "@Incomplete: Iterate over struct instances using custom default iterators.")

			else
				typeError(
					state, objExpr,
					"Cannot iterate over values in type group '%s'. (Type is %s)",
					TYPE_TAG_NAMES[objExpr.inferredType.tag],
					getFriendlyTypeInfoName(objExpr.inferredType)
				)
			end

		-- for v1, ... in iter [, state [, init ] ]
		else--if forType == FOR_ITERATOR
			!ASSERT `#names >= 1`
			!ASSERT `values[1]`

			-- @Incomplete: Support 'for' loops/iterators that don't require an iterator value or
			-- even a state (e.g. if values are read from somewhere else, like an event queue).

			-- @Incomplete: Complain if getAssignmentValue() can return a fourth value.

			local iterExpr, iterTypeInfo = getAssignmentValue(state, forLoop, values, 1, nil, nil, "loop value")

			if iterTypeInfo.tag ~= !(typeTags.TypeInfoFunction) then
				typeError(state, iterExpr, "Expected a function. (Got %s)", getFriendlyTypeInfoName(iterTypeInfo))

			elseif #iterTypeInfo.argumentTypesIn ~= 2 then
				-- @Incomplete: Consider optional arguments.
				typeError(
					state, iterExpr,
					"Iterators must take two arguments - an invariant state object and a control value. (The signature of this function is %s)",
					getFriendlyTypeInfoName(iterTypeInfo)
				)

			elseif not iterTypeInfo.argumentTypesOut[1] then
				typeError(state, iterExpr, "Iterator does not return anything.")

			elseif iterTypeInfo.argumentTypesOut[1].tag == !(typeTags.TypeInfoNone) then
				typeError(state, iterExpr, "The type of the first returned value from iterators cannot be simply nil. It must be a compound type where nil is included.")

			elseif not (
				iterTypeInfo.argumentTypesOut[1].tag == !(typeTags.TypeInfoAny)
				or (
					iterTypeInfo.argumentTypesOut[1].tag == !(typeTags.TypeInfoCompound)
					and itemWith1(iterTypeInfo.argumentTypesOut[1], "tag", !(typeTags.TypeInfoNone))
				)
			) then
				typeError(
					state, iterExpr,
					"The type of the first returned value from iterators must be a compound type where nil is included. (This function returns %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesOut[1])
				)

			elseif #iterTypeInfo.argumentTypesOut ~= #names then
				-- @Incomplete: Consider !must and make everything else optional.
				typeError(
					state, names[math.min(#iterTypeInfo.argumentTypesOut+1, #names)],
					"Incorrect number of names specified for iterator. (Expected %d, got %d)",
					#iterTypeInfo.argumentTypesOut,
					#names
				)
			end

			local stateExpr, stateTypeInfo = getAssignmentValue(state, forLoop, values, 2, nil, nil, "loop value")
			local initExpr,  initTypeInfo  = getAssignmentValue(state, forLoop, values, 3, nil, nil, "loop value")

			if not isTypeCompatibleWith(adjustTypeToOne(state, stateExpr, stateTypeInfo, true), iterTypeInfo.argumentTypesIn[1]) then
				typeError(
					state, stateExpr,
					"Type mismatch for iterator state (value #2). (Wanted %s, got %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[1]),
					getFriendlyTypeInfoName(adjustTypeToOne(state, stateExpr, stateTypeInfo, true))
				)
			end
			if not isTypeCompatibleWith(adjustTypeToOne(state, initExpr, initTypeInfo, true), iterTypeInfo.argumentTypesIn[2]) then
				typeError(
					state, initExpr,
					"Type mismatch for initial control value (value #3). (Wanted %s, got %s)",
					getFriendlyTypeInfoName(iterTypeInfo.argumentTypesIn[2]),
					getFriendlyTypeInfoName(adjustTypeToOne(state, initExpr, initTypeInfo, true))
				)
			end

			for i, ident in ipairs(names) do
				local typeInfo = iterTypeInfo.argumentTypesOut[i]

				if i > 1 or typeInfo.tag == !(typeTags.TypeInfoAny) then
					-- void

				-- Strip nil from the compound type for the first value (unless it's 'any').
				elseif #typeInfo > 2 then
					local typeInfos = {unpack(typeInfo)}
					removeItem(typeInfos, getTypeInfoForBuiltinType(state, "none"))
					typeInfo = getTypeInfoForCompoundType(state, typeInfos)
				else
					typeInfo = typeInfo[2].tag == !(typeTags.TypeInfoNone) and typeInfo[1] or typeInfo[2] or errorInternal()
				end

				addDeclarationInForLoop(state, forLoop, ident.name, typeInfo)
			end
		end
	end

	for _, statement in ipairs(forLoop) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`forLoop`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, forLoop)
end

local function checkForRecursiveStruct(state, declThatWeAreChecking, memberPath, member, structInfo, parentStructInfo)
	local typeInfo = member.typeInfo

	if typeInfo == structInfo then
		for i, member in ipairs(memberPath) do
			memberPath[i] = member.name
		end

		-- @Incomplete: In the case of compound types, trigger this error if the default value has the type of the struct.
		typeError(
			state, declThatWeAreChecking.name,
			"%s.%s is of type %s. This creates an infinite recursive loop. (Note: Compound types containing the struct are ok (unless the default value is the struct type), e.g. %s|nil)",
			getFriendlyTypeInfoName(structInfo),
			table.concat(memberPath, "."),
			getFriendlyTypeInfoName(structInfo),
			getFriendlyTypeInfoName(structInfo)
		)
	end

	if typeInfo.tag ~= !(typeTags.TypeInfoStruct) then  return  end
	local structInfoInner = typeInfo

	local memberPathIndex = #memberPath+1

	for _, member in ipairs(structInfoInner.members) do
		memberPath[memberPathIndex] = member
		checkForRecursiveStruct(state, declThatWeAreChecking, memberPath, member, structInfo, structInfoInner)
	end

	memberPath[memberPathIndex] = nil
end

!NODE_INFERRER `function nodeInferrers.AstStruct(state, struct)`
	if struct.isPolymorphic then
		local structInfo         = newTypeInfo(TypeInfoStruct)
		structInfo.astNode       = struct
		structInfo.isPolymorphic = true
		structInfo.hasMembers    = true -- Probably doesn't matter.

		table.insert(state.allTypeInfos, structInfo)

		struct.representedType = structInfo
		struct.inferredType    = getTypeInfoForBuiltinType(state, "type")

		moveToNextRelevantPipe(state, struct)
		return
	end

	local structInfo = struct.representedType

	if not structInfo then
		structInfo         = newTypeInfo(TypeInfoStruct)
		structInfo.astNode = struct

		-- Note: We don't populate structInfo.members just yet. (Is this gonna a problem?)

		table.insert(state.allTypeInfos, structInfo)

		struct.representedType = structInfo
		struct.inferredType    = getTypeInfoForBuiltinType(state, "type")
	end

	for _, statement in ipairs(struct.statements) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`struct`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	for i, decl in ipairs(struct.declarations) do
		if not decl.isConstant then
			local member          = TypeInfoStructMember()
			member.name           = decl.name.name
			member.typeInfo       = decl.name.inferredType or errorInternal()
			table.insert(structInfo.members, member)

			checkForRecursiveStruct(state, decl, {member}, member, structInfo, structInfo)
		end
	end
	structInfo.hasMembers = true

	moveToNextRelevantPipe(state, struct)
end

!NODE_INFERRER `function nodeInferrers.AstEnum(state, enum)`
	for _, statement in ipairs(enum.statements) do
		if statement.nodeType == !(nodeTypes.AstDeclaration) then
			local decl = statement
			!ASSERT `decl.value`
			if not decl.value.inferredType then
				!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `decl.value`)
			end

		elseif statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`enum`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	assert(enum.declarations[1]) -- This should have been caught during parsing.

	local enumMemberInfo

	if enum.memberType then
		!ASSERT `enum.memberType.typeName`
		enumMemberInfo = getTypeInfoForBuiltinType(state, enum.memberType.typeName)
	else
		-- Just use the type of the first member as the wanted type for the enum.
		enumMemberInfo = enum.declarations[1].value.inferredType
		if not isAny(enumMemberInfo.tag, !(typeTags.TypeInfoInt),!(typeTags.TypeInfoString),!(typeTags.TypeInfoType),!(typeTags.TypeInfoBool),!(typeTags.TypeInfoFloat)) then
			typeError(state, enum, "Supported enum member types are: int, string, type, bool, float")
		end
	end

	local enumInfo          = newTypeInfo(TypeInfoEnum)
	enumInfo.astNode        = enum
	enumInfo.memberTypeInfo = enumMemberInfo or errorInternal()

	for i, decl in ipairs(enum.declarations) do
		local valueExpr = decl.value

		if not isTypeCompatibleWith(valueExpr.inferredType, enumMemberInfo) then
			typeError(state, valueExpr,
				"Value type mismatch for '%s'. (Wanted %s, got %s)",
				decl.name.name,
				getFriendlyTypeInfoName(enumMemberInfo),
				getFriendlyTypeInfoName(valueExpr.inferredType)
			)
		end

		-- Note: valueExpr may not be a constant expression, but the
		-- declaration will check that after this enum gets inferred.

		local member        = TypeInfoEnumMember()
		member.name         = decl.name.name
		enumInfo.members[i] = member
	end

	table.insert(state.allTypeInfos, enumInfo)

	enum.representedType = enumInfo
	enum.inferredType    = getTypeInfoForBuiltinType(state, "type")

	moveToNextRelevantPipe(state, enum)
end

!NODE_INFERRER `function nodeInferrers.AstFileScope(state, fileScope)`
	for _, statement in ipairs(fileScope.statements) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`fileScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, fileScope)
end

!NODE_INFERRER `function nodeInferrers.AstGlobalScope(state, globalScope)`
	for _, statement in ipairs(globalScope.statements) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`globalScope`, DEPEND_NODE_INFERRED, `statement`)
		end
	end

	moveToNextRelevantPipe(state, globalScope)
end

!NODE_INFERRER `function nodeInferrers.AstBlock(state, block)`
	for _, statement in ipairs(block.statements) do
		if statement.queued.pipe <= !(PIPE_INFER) then
			!DEPEND_AND_RETURN(`block`, DEPEND_NODE_INFERRED, `statement`)
		end
	end
	moveToNextRelevantPipe(state, block)
end

local function prepareForRunning(state, runNode, unit, visited)
	astVisitAllNodes(unit, function(node)
		visited[node] = true

		if not node.queued then
			return !(VISIT_IGNORE_CHILDREN)

		elseif node.queued.pipe <= !(PIPE_BYTECODE) then
			!DEPEND_AND_RETURN(`runNode`, DEPEND_NODE_EMITTED, `node`, nil, toLua(VISIT_BREAK))

		elseif node.nodeType == !(nodeTypes.AstIdentifier) then
			local ident = node
			local decl  = ident.declaration or errorInternal()

			if not visited[decl] then
				prepareForRunning(state, runNode, decl, visited)
				if runNode.queued.waitingOn then  return !(VISIT_BREAK)  end

				local valueExpr = getDeclarationValue(decl)

				if valueExpr then
					prepareForRunning(state, runNode, valueExpr, visited)
					if runNode.queued.waitingOn then  return !(VISIT_BREAK)  end
				end
			end
		end
	end)
end

local function createRunReplacementFromTypeAndLuaValue(state, runNode, parent, typeInfo, v)
	local tag = typeInfo.tag

	if tag == !(typeTags.TypeInfoInt) or (tag == !(typeTags.TypeInfoAny) and type(v) == "number" and v == math.floor(v)) then
		local n = v
		assert(type(n) == "number" and n == math.floor(n))
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = n
		literal.inferredType = getTypeInfoForBuiltinType(state, "int")
		return literal

	elseif tag == !(typeTags.TypeInfoFloat) or (tag == !(typeTags.TypeInfoAny) and type(v) == "number") then
		local n = v
		assert(type(n) == "number")
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = n
		literal.inferredType = getTypeInfoForBuiltinType(state, "float")
		return literal

	elseif tag == !(typeTags.TypeInfoString) or (tag == !(typeTags.TypeInfoAny) and type(v) == "string") then
		local s = v
		assert(type(s) == "string")
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_STRING)
		literal.value        = s
		literal.inferredType = getTypeInfoForBuiltinType(state, "string")
		return literal

	elseif tag == !(typeTags.TypeInfoBool) or (tag == !(typeTags.TypeInfoAny) and type(v) == "boolean") then
		local flag = v
		assert(type(flag) == "boolean")
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = flag
		literal.inferredType = getTypeInfoForBuiltinType(state, "bool")
		return literal

	elseif tag == !(typeTags.TypeInfoNone) or (tag == !(typeTags.TypeInfoAny) and v == nil) then
		assert(v == nil)
		local literal        = astNewNode(AstLiteral, runNode.token, parent)
		literal.literalType  = !(LITERAL_NIL)
		literal.value        = nil
		literal.inferredType = getTypeInfoForBuiltinType(state, "none")
		return literal

	elseif tag == !(typeTags.TypeInfoTable) or (tag == !(typeTags.TypeInfoAny) and type(v) == "table") then
		local t = v
		assert(type(t) == "table")
		local tableNode = astNewNode(AstTable, runNode.token, parent)
		local anyType   = getTypeInfoForBuiltinType(state, "any")

		for k, v in pairsSorted(t, naturalCompare) do
			local tableField    = TableField()
			tableField.key      = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, anyType, k)
			tableField.value    = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, anyType, v)
			table.insert(tableNode.fields, tableField)
		end

		tableNode.inferredType = getTypeInfoForBuiltinType(state, "table")
		return tableNode

	elseif tag == !(typeTags.TypeInfoArray) then
		local t = v
		assert(type(t) == "table")
		local arraySig  = typeInfo
		local tableNode = astNewNode(AstTable, runNode.token, parent)
		local intType   = getTypeInfoForBuiltinType(state, "int")

		-- @Robustness: Check that all keys in 't' are valid.
		for i, v in ipairs(t) do
			local tableField          = TableField()

			local indexLiteral        = astNewNode(AstLiteral, runNode.token, tableNode)
			indexLiteral.literalType  = !(LITERAL_INTEGER)
			indexLiteral.value        = i
			indexLiteral.inferredType = intType
			tableField.key            = indexLiteral

			tableField.value          = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, arraySig.itemType, v)

			tableNode.fields[i]       = tableField
		end

		tableNode.inferredType = arraySig
		return tableNode

	elseif tag == !(typeTags.TypeInfoStruct) then
		local t = v
		assert(type(t) == "table")
		local structInfo = typeInfo
		local tableNode  = astNewNode(AstTable, runNode.token, parent)
		local stringType = getTypeInfoForBuiltinType(state, "string")
		assert(structInfo.hasMembers)

		-- @Robustness: Check that all keys in 't' are valid.
		for _, member in ipairs(structInfo.members) do
			local tableField           = TableField()

			local memberLiteral        = astNewNode(AstLiteral, runNode.token, tableNode)
			memberLiteral.literalType  = !(LITERAL_STRING)
			memberLiteral.value        = member.name
			memberLiteral.inferredType = stringType
			tableField.key             = memberLiteral

			tableField.value           = createRunReplacementFromTypeAndLuaValue(state, runNode, tableNode, member.typeInfo, t[member.name])

			table.insert(tableNode.fields, tableField)
		end

		tableNode.inferredType = structInfo
		return tableNode

	elseif tag == !(typeTags.TypeInfoEnum) then
		local enumInfo     = typeInfo
		local ident        = astNewNode(AstIdentifier, runNode.token, parent)
		ident.inferredType = enumInfo

		if isAny(enumInfo.memberTypeInfo.tag, !(typeTags.TypeInfoInt),!(typeTags.TypeInfoString),!(typeTags.TypeInfoBool),!(typeTags.TypeInfoFloat)) then
			for _, decl in ipairs(enumInfo.astNode.declarations) do
				local literal = decl.value
				assert(literal.nodeType == !(nodeTypes.AstLiteral))
				if literal.value == v then
					ident.name        = decl.name.name
					ident.declaration = decl
					break
				end
			end

		elseif enumInfo.memberTypeInfo.tag == !(typeTags.TypeInfoType) then
			for _, decl in ipairs(enumInfo.astNode.declarations) do
				if requireTypeRepresentedByExpression(state, decl.value).id == v then
					ident.name        = decl.name.name
					ident.declaration = decl
					break
				end
			end

		else
			errorUnhandledType(state, runNode, enumInfo.memberTypeInfo)
		end

		if not ident.declaration then
			typeError(state, runNode, "Got an invalid enum value. (Enum '%s', value: %s)", getFriendlyTypeInfoName(enumInfo), tostring(v))
		end

		return ident

	elseif tag == !(typeTags.TypeInfoFunction) then
		local func = v
		assert(type(func) == "function")

		local const = nil

		for _, _const in ipairs(state.constants) do
			if _const.valueType.tag == !(typeTags.TypeInfoFunction) and state.runnerEnvironment[_const.name] == func then
				const = _const
				break
			end
		end

		if not const then
			errorInternal(state, runNode, "The resulting function is no an existing constant for some reason.")
		end

		local lambda = const.value

		if lambda.parent.nodeType == !(nodeTypes.AstDeclaration) then
			local decl  = lambda.parent
			local ident = astCopy(decl.name, runNode.token, parent)
			return ident
		else
			local copy = astCopy(lambda, nil, parent)
			copy.token = runNode.token
			return copy
		end

	elseif tag == !(typeTags.TypeInfoType) then
		local typeId = v
		assert(type(typeId) == "number" and typeId == math.floor(typeId))

		local typeRepresented = itemWith1(state.allTypeInfos, "id", typeId)
		if not typeRepresented then
			typeError(state, runNode, "Got the ID of a type that doesn't exist. (Type ID %d)", typeId)
		end

		local typeNode = createTypeNodeFromInfo(state, typeRepresented, runNode.token, parent)
		return typeNode

	elseif tag == !(typeTags.TypeInfoCompound) then
		typeError(state, runNode, "!run expression is, or contains something, of a compound type which is illegal. (Type is %s)", getFriendlyTypeInfoName(typeInfo))
	elseif tag == !(typeTags.TypeInfoNamespace) then
		typeError(state, runNode, "!run expression is a namespace which is illegal here.")
	else
		errorUnhandledType(state, runNode, typeInfo)
	end
end

!NODE_INFERRER `function nodeInferrers.AstRun(state, runNode)`
	local lambda = runNode.lambda

	if lambda.queued.pipe <= !(PIPE_BYTECODE) then
		!DEPEND_AND_RETURN(`runNode`, DEPEND_NODE_EMITTED, `lambda`)
	end
	-- for _, const in ipairs(state.constants) do
	-- 	if not const.isReady and const.valueType.tag ~= !(typeTags.TypeInfoFunction) then
	-- 		!DEPEND_AND_RETURN(`runNode`, DEPEND_CONSTANT_READY, `const`)
	-- 	end
	-- end

	local visited = {}

	prepareForRunning(state, runNode, lambda, visited)
	if runNode.queued.waitingOn then  return  end

	for _, const in ipairs(state.constants) do
		if not const.isReady and const.valueType.tag == !(typeTags.TypeInfoFunction) and visited[const.value] then
			!DEPEND_AND_RETURN(`runNode`, DEPEND_CONSTANT_READY, `const`)
		end
	end

	runnerSetup(state)

	local newConstants            = {}
	local newTopScopeDeclarations = {}

	for _, const in ipairs(state.constants) do
		if not state.runnerWrittenObjects[const] and const.isReady then
			state.runnerWrittenObjects[const] = true
			table.insert(newConstants, const)
			const.nameLocked = true -- @UX: Update constant names as they are allocated (and not when declarations pass PIPE_BYTECODE).
		end
	end

	for _, decl in ipairs(state.globalScope.declarations) do
		if visited[decl] and not state.runnerWrittenObjects[decl] then
			state.runnerWrittenObjects[decl] = true
			table.insert(newTopScopeDeclarations, decl)
		end
	end
	for _, fileScope in ipairs(state.globalScope.fileScopes) do
		for __, decl in ipairs(fileScope.declarations) do
			if visited[decl] and not state.runnerWrittenObjects[decl] then
				state.runnerWrittenObjects[decl] = true
				table.insert(newTopScopeDeclarations, decl)
			end
		end
	end

	local writer = state.runnerWriter

	writeForeignImports                (state, writer, newConstants, true)
	writeConstantObjectsExceptFunctions(state, writer, newConstants, true)
	writeFunctionObjects               (state, writer, newConstants)
	writeTopScopeDeclarations          (state, writer, newTopScopeDeclarations)

	-- !ifDEBUG `print(writer.file:getBuffer())`
	runnerRunBufferAsChunk(state)

	local constName = lambda.valueConstant.name
	local func      = state.runnerEnvironment[constName]

	if type(func) ~= "function" then
		errorInternal(state, runNode, "Missing the compiled object to run for some reason. (Constant '%s')", constName)
	end

	local v = func() -- @Incomplete: Better error messages using xpcall().

	if not isAnExpressionExpected(state, runNode) then
		runNode.inferredType = getTypeInfoForBuiltinType(state, "void")
		moveToNextRelevantPipe(state, runNode)
		return
	end

	-- Replace the directive with a constant value.

	local returnNode = getLast(lambda.body.statements)
	assert(returnNode.nodeType == !(nodeTypes.AstReturn))

	local typeInfo = returnNode.values[1].inferredType
	typeInfo       = adjustTypeToOne(state, runNode, typeInfo, true)

	local replacement = createRunReplacementFromTypeAndLuaValue(state, runNode, runNode.parent, typeInfo, v)
	addUnqueuedChildrenToQueueRecursively(state, replacement, !(PIPE_INFER))

	replaceQueuedNodeAndUnqueueOldTree(state, runNode, replacement)
	if typeInfo.tag == !(typeTags.TypeInfoAny) and replacement.inferredType.tag ~= !(typeTags.TypeInfoAny) then
		replacement = wrapInImplicitCast(state, replacement, typeInfo, true)
	end

	moveChildrenToNextRelevantPipe(state, replacement)
	moveToNextRelevantPipe(state, replacement)
end

function _G.inferNode(state, node)
	local nodeInferrer = nodeInferrers[node.nodeType] or errorUnhandledNodeType(state, node)
	return nodeInferrer(state, node)
end



-- Note: It's assumed that the expression tree has all types figured out.
function _G.isExpressionConstant(state, expr)
	if expr.nodeType == !(nodeTypes.AstLiteral) then
		return true

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration or errorInternal()
		return decl.isConstant and isExpressionConstant(state, decl.value)

	elseif isAny(expr.nodeType, !(nodeTypes.AstType),!(nodeTypes.AstTypeOf)) then
		return true--, expr.representedType.id -- All types are constant, just like literals.

	elseif isAny(expr.nodeType, !(nodeTypes.AstStruct),!(nodeTypes.AstEnum)) then
		return true--, expr.representedType.id -- Structs and enums are types (which are constant, just like literals).
	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda = expr
		return true--, lambda.inferredType.id -- Lambdas (which are function signatures) are types too, thus constant.

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		return isExpressionConstant(state, cast.expression)

	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		local unary = expr
		return isExpressionConstant(state, unary.expression)

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr
		return (isExpressionConstant(state, binary.left) and isExpressionConstant(state, binary.right))

	elseif expr.nodeType == !(nodeTypes.AstConditional) then
		local conditional = expr
		return (
			isExpressionConstant(state, conditional.condition)
			and (conditional.branchTrue == nil or isExpressionConstant(state, conditional.branchTrue))
			and isExpressionConstant(state, conditional.branchFalse)
		)

	elseif expr.nodeType == !(nodeTypes.AstCall) then
		return false -- Calls are always a runtime operation.

	elseif expr.nodeType == !(nodeTypes.AstAccess) then
		local access              = expr
		local typeInfoRepresented = getTypeRepresentedByExpression(access.object)

		if typeInfoRepresented and typeInfoRepresented.tag == !(typeTags.TypeInfoEnum) then
			return true
		else
			return false -- Other accesses resolving to constants should have simplified to something else already (I think).
		end

	elseif expr.nodeType == !(nodeTypes.AstImport) then
		return true -- Namespaces, just like types, are always constant.

	elseif expr.nodeType == !(nodeTypes.AstTable) then
		local tableNode = expr
		for _, tableField in ipairs(tableNode.fields) do
			if not isExpressionConstant(state, tableField.key)   then  return false  end
			if not isExpressionConstant(state, tableField.value) then  return false  end
		end
		return true

	elseif expr.nodeType == !(nodeTypes.AstVararg) then
		return false

	elseif expr.nodeType == !(nodeTypes.AstForeign) then
		-- Technically foreign values are seen as constant at runtime, but since we don't know
		-- what they are at compile-time we (usually) treat them as runtime values.
		return false

	else
		errorUnhandledNodeType(state, expr)
	end
end



-- expression, typeInfo = getAssignmentValue( state, assignmentTarget, values, valueIndex, expectedTypeInfo=any, extraBinaryOperation="", targetTerm="assignment target" )
-- Note: Vararg node/type may be returned.
function _G.getAssignmentValue(state, targetExpr, values, i, typeInfoExpected, binOp, targetTerm)
	!(
	local TEMPLATE_TARGET_NAME = trimTemplate`
		targetExpr.nodeType == $nodeTypeIdent  and " ('"..targetExpr.name.."')" or
		targetExpr.nodeType == $nodeTypeAccess and targetExpr.member.nodeType == $nodeTypeLiteral and targetExpr.member.literalType == $literalTypeString and " ('"..targetExpr.member.value.."')" or
		""
	`
	local TARGET_NAME = templateToLua(TEMPLATE_TARGET_NAME, {
		nodeTypeIdent     = nodeTypes.AstIdentifier,
		nodeTypeAccess    = nodeTypes.AstAccess,
		nodeTypeLiteral   = nodeTypes.AstLiteral,
		literalTypeString = LITERAL_STRING,
	})

	local TEMPLATE_CALL_RETURNS_NOTHING = trimTemplate`
		typeError(state, call, "Called function returns nothing for %s #%d%s (return value #%d).", targetTerm, i, $targetName, argIndex)
	`
	local CALL_RETURNS_NOTHING = templateToLua(TEMPLATE_CALL_RETURNS_NOTHING, {
		targetName = TARGET_NAME,
	})

	local TEMPLATE_CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN = `
		if binOp == "" then
			if isTypeCompatibleWith($valueTypeInfoAdjusted, typeInfoExpected) then  return $valueExpr, $valueTypeInfo  end

		else
			$valueTypeInfoAdjusted = checkBinaryOperation(
				state,
				targetExpr,
				$valueExpr, targetExpr, $valueExpr,
				binOp,
				typeInfoExpected, $valueTypeInfoAdjusted,
				true
			) or errorInternal()

			if not isTypeCompatibleWith($valueTypeInfoAdjusted, typeInfoExpected) then
				typeError(
					state, targetExpr,
					"Type mismatch between %s #%d%s (%s) and result of binary operation (%s) (%s).",
					targetTerm, i, $targetName, getFriendlyTypeInfoName(typeInfoExpected),
					binOp, getFriendlyTypeInfoName($valueTypeInfoAdjusted))
			end

			return $valueExpr, $valueTypeInfo
		end
	`
	local function CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(valueExprVar, typeInfoVar, typeInfoAdjustedVar)
		local lua = templateToLua(TEMPLATE_CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN, {
			valueExpr             = valueExprVar,
			valueTypeInfo         = typeInfoVar,
			valueTypeInfoAdjusted = typeInfoAdjustedVar,
			targetName            = TARGET_NAME,
		})
		__LUA(lua)
	end
	)

	binOp      = binOp      or ""
	targetTerm = targetTerm or "assignment target"

	local valueExpr = values[i]

	if valueExpr then
		local valueTypeInfo = valueExpr.inferredType

		if valueTypeInfo.tag == !(typeTags.TypeInfoList) then
			valueTypeInfo = valueTypeInfo[1]

			if not valueTypeInfo then
				local call     = valueExpr
				local argIndex = 1
				!!(CALL_RETURNS_NOTHING)
			end
		end

		if not typeInfoExpected then  return valueExpr, valueTypeInfo  end

		local valueTypeInfoAdjusted = adjustTypeToOne(state, valueExpr, valueTypeInfo, true)
		!CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(`valueExpr`, `valueTypeInfo`, `valueTypeInfoAdjusted`)

		local messageFormat
			=   valueTypeInfoAdjusted.tag == !(typeTags.TypeInfoFunction) and typeInfoExpected.tag == !(typeTags.TypeInfoFunction)
			and "Function signature is different from %s #%d%s. (Wanted %s, got %s)"
			or  "Value type mismatch for %s #%d%s. (Wanted %s, got %s)"

		typeError(
			state, valueExpr, messageFormat,
			targetTerm, i, !!(TARGET_NAME),
			getFriendlyTypeInfoName(typeInfoExpected),
			getFriendlyTypeInfoName(valueTypeInfoAdjusted)
		)
	end

	valueExpr = values[#values]

	if not valueExpr then
		typeError(state, targetExpr, "Missing a value for %s #%d%s.", targetTerm, i, !!(TARGET_NAME))

	elseif valueExpr.nodeType == !(nodeTypes.AstCall) and not valueExpr.surroundedByParentheses then
		local call      = valueExpr
		local lastIndex = #values
		local argIndex  = i-lastIndex+1

		local typeInfoForCall = call.inferredType
		local listSig

		if typeInfoForCall.tag == !(typeTags.TypeInfoList) then
			listSig = typeInfoForCall
		else
			typeError(state, call, "The object being called is not a function. (It is %s)", getFriendlyTypeInfoName(typeInfoForCall))
		end

		local typeInfoForOutArg = listSig[argIndex]

		if typeInfoForOutArg then
			-- void
		elseif listSig[1] and listSig[#listSig].tag == !(typeTags.TypeInfoVararg) then
			typeInfoForOutArg = listSig[#listSig]
		else
			!!(CALL_RETURNS_NOTHING)
		end

		if not typeInfoExpected then  return call, typeInfoForOutArg  end

		local typeInfoForOutArgAdjusted = adjustTypeToOne(state, call, typeInfoForOutArg, true)
		!CHECK_TYPE_COMPATABILITY_AND_MAYBE_RETURN(`call`, `typeInfoForOutArg`, `typeInfoForOutArgAdjusted`)

		local calleeName = (call.callee.nodeType == !(nodeTypes.AstIdentifier) and " of '"..call.callee.name.."'" or "")

		typeError(
			state, call,
			"The type of return value #%d%s (%s) does not match the type of %s #%d%s (%s).",
			argIndex, calleeName, getFriendlyTypeInfoName(typeInfoForOutArgAdjusted),
			targetTerm, i, !!(TARGET_NAME), getFriendlyTypeInfoName(typeInfoExpected)
		)

	elseif valueExpr.nodeType == !(nodeTypes.AstVararg) and not valueExpr.surroundedByParentheses then
		local vararg = valueExpr
		return vararg, vararg.inferredType

	else
		typeError(state, targetExpr, "Missing a value for %s #%d%s.", targetTerm, i, !!(TARGET_NAME))
	end
end



local function createLambdaArgumentsFromTypes(state, typeInfos, lambda)
	local args = astNewNode(AstArguments, lambda.token, lambda)

	for i, argTypeInfo in ipairs(typeInfos) do
		local arg          = astNewNode(AstArgument,    lambda.token, args)
		local decl         = astNewNode(AstDeclaration, lambda.token, arg)
		local ident        = astNewNode(AstIdentifier,  lambda.token, decl)

		ident.name         = "_"..i
		ident.declaration  = decl
		ident.inferredType = argTypeInfo

		decl.name          = ident

		arg.declaration    = decl
		arg.group          = i

		-- @Incomplete: Handle default values for input arguments. (Needed?)

		args.arguments[i] = arg
	end

	return args
end

local function createLambdaFromSignature(state, funcSig, parent)
	local lambda = astNewNode(AstLambda, parent.token, parent)

	if funcSig.argumentTypesIn[1] then
		lambda.argumentsIn = createLambdaArgumentsFromTypes(state, funcSig.argumentTypesIn, lambda)
		table.insert(lambda.statements, lambda.argumentsIn)
	end
	if funcSig.argumentTypesOut[1] then
		lambda.argumentsOut = createLambdaArgumentsFromTypes(state, funcSig.argumentTypesOut, lambda)
		table.insert(lambda.statements, lambda.argumentsOut)
	end

	return lambda
end

function _G.createTypeNodeFromInfo(state, typeRepresented, token, parent)
	local typeNode            = astNewNode(AstType, token, parent)
	local isBuiltin, typeName = isTypeBuiltin(typeRepresented)

	typeNode.inferredType    = getTypeInfoForBuiltinType(state, "type")
	typeNode.representedType = typeRepresented

	if isBuiltin then
		typeNode.kind           = !(TYPE_KIND_SIMPLE_BUILTIN)
		typeNode.typeName       = typeName

	elseif typeRepresented.tag == !(typeTags.TypeInfoStruct) then
		local structInfo        = typeRepresented
		typeNode.kind           = structInfo.isPolymorphic and !(TYPE_KIND_POLY_STRUCT) or !(TYPE_KIND_SIMPLE_USER)
		typeNode.typeName       = structInfo.name

	elseif typeRepresented.tag == !(typeTags.TypeInfoEnum) then
		local enumInfo          = typeRepresented
		typeNode.kind           = !(TYPE_KIND_SIMPLE_USER)
		typeNode.typeName       = enumInfo.name

	elseif typeRepresented.tag == !(typeTags.TypeInfoFunction) then
		local funcSig           = typeRepresented
		typeNode.kind           = !(TYPE_KIND_FUNCTION)
		typeNode.functionHeader = createLambdaFromSignature(state, funcSig, typeNode) -- Is this really needed? I doubt it. @Cleanup

	elseif typeRepresented.tag == !(typeTags.TypeInfoCompound) then
		typeNode.kind           = !(TYPE_KIND_COMPOUND)

	elseif typeRepresented.tag == !(typeTags.TypeInfoArray) then
		local arraySig          = typeRepresented
		typeNode.kind           = !(TYPE_KIND_ARRAY)
		typeNode.arrayItemType  = createTypeNodeFromInfo(state, arraySig.itemType, token, typeNode)

	elseif typeRepresented.tag == !(typeTags.TypeInfoVararg) then
		errorInternal() -- When do we get here?
	else
		!ifDEBUG `print(getFriendlyTypeInfoName(typeRepresented))`
		errorInternal("Incomplete: Handle type group '%s'.", TYPE_TAG_NAMES[typeRepresented.tag])
	end

	return typeNode
end

local function isTypeOrDoesTypeContainPlaceholder(typeInfo)
	if typeInfo.tag == !(typeTags.TypeInfoPlaceholder) then
		return true

	elseif typeInfo.tag == !(typeTags.TypeInfoCompound) then
		local compound = typeInfo
		return itemWith1(compound, "tag", !(typeTags.TypeInfoPlaceholder)) ~= nil

	elseif typeInfo.tag == !(typeTags.TypeInfoFunction) then
		local funcSig = typeInfo
		for _, argTypeInfo in ipairs(funcSig.argumentTypesIn) do
			if isTypeOrDoesTypeContainPlaceholder(argTypeInfo) then  return true  end
		end
		for _, argTypeInfo in ipairs(funcSig.argumentTypesOut) do
			if isTypeOrDoesTypeContainPlaceholder(argTypeInfo) then  return true  end
		end
		return false

	else
		return false
	end
end

function _G.simplifyTypeExpression(state, expr, typeRepresented)
	!ASSERT("expr.nodeType ~= "..nodeTypes.AstType)
	!ASSERT("typeRepresented")

	if isTypeOrDoesTypeContainPlaceholder(typeRepresented) then  return nil  end

	local typeNode = createTypeNodeFromInfo(state, typeRepresented, expr.token, expr.parent)

	if expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident          = expr
		typeNode.declaration = ident.declaration
	end

	addUnqueuedChildrenToQueueRecursively(state, typeNode, !(PIPE_INFER))
	moveChildrenToNextRelevantPipe(state, typeNode)

	replaceQueuedNodeAndUnqueueOldTree(state, expr, typeNode)

	return typeNode
end

local function simplifyCast(state, cast)
	local exprTypeInfo = cast.expression.inferredType
	local castTypeInfo = cast.inferredType

	local parent = cast.parent
	if
		parent.nodeType == !(nodeTypes.AstConditional)
		and parent.conditionAndBranchTrue
		and parent.conditionAndBranchTrue ~= parent.condition
		and cast == parent.condition
	then
		-- Simplifying this cast would mess up the output. Example situation:
		-- local x = if myString "a" else "b"
		return
	end

	if exprTypeInfo == castTypeInfo then
		errorInternal(state, cast) -- This should have been simplified away already.

	-- int -> float
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoInt) and castTypeInfo.tag == !(typeTags.TypeInfoFloat) then
		assert(cast.expression.nodeType == !(nodeTypes.AstLiteral))
		assert(type(cast.expression.value) == "number")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = cast.expression.value
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- float -> int
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoFloat) and castTypeInfo.tag == !(typeTags.TypeInfoInt) then
		assert(cast.expression.nodeType == !(nodeTypes.AstLiteral))
		assert(type(cast.expression.value) == "number")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = math.modf(cast.expression.value)
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- (numeric) -> bool
	elseif isTypeNumeric(exprTypeInfo) and castTypeInfo.tag == !(typeTags.TypeInfoBool) then
		assert(cast.expression.nodeType == !(nodeTypes.AstLiteral))
		assert(type(cast.expression.value) == "number")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = cast.expression.value ~= 0
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- string -> bool
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoString) and castTypeInfo.tag == !(typeTags.TypeInfoBool) then
		assert(cast.expression.nodeType == !(nodeTypes.AstLiteral))
		assert(type(cast.expression.value) == "string")

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = cast.expression.value ~= ""
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- array -> bool
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoArray) and castTypeInfo.tag == !(typeTags.TypeInfoBool) then
		local tableNode = followIdentifiersToConstantValue(cast.expression)
		assert(tableNode.nodeType == !(nodeTypes.AstTable))

		local literal        = astNewNode(AstLiteral, cast.token, cast.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = tableNode.fields[1] ~= nil -- (Assume the array constructor is valid.)
		literal.inferredType = castTypeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, cast, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	-- enum -> enumMemberType (int, float, string, bool or type)
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoEnum) and isTypeCompatibleWith(exprTypeInfo.memberTypeInfo, castTypeInfo) then
		local castIsDirect = (castTypeInfo == exprTypeInfo.memberTypeInfo)

		local enumInfo = exprTypeInfo
		local ident    = cast.expression

		assert(ident.nodeType == !(nodeTypes.AstIdentifier)) -- All enums should have been simplified to identifiers.

		!ASSERT `ident.declaration.isConstant`
		local valueExpr = ident.declaration.value

		if BUILTIN_TYPE_TAG_TO_LITERAL_TYPE[castTypeInfo.tag] then
			local literal = valueExpr
			assert(literal.nodeType == !(nodeTypes.AstLiteral))

			local literalCopy = astCopy(literal, cast.token)

			if castIsDirect then
				assert(literalCopy.inferredType == castTypeInfo)

			elseif exprTypeInfo.memberTypeInfo.tag == !(typeTags.TypeInfoInt) and castTypeInfo.tag == !(typeTags.TypeInfoFloat) then
				literalCopy.literalType  = !(LITERAL_FLOAT)
				literalCopy.inferredType = castTypeInfo

			else
				errorInternal(
					state, cast,
					"Incomplete: Implicitly cast enum from %s to %s.",
					getFriendlyTypeInfoName(exprTypeInfo.memberTypeInfo),
					getFriendlyTypeInfoName(castTypeInfo)
				)
			end

			replaceQueuedNodeAndUnqueueOldTree(state, cast, literalCopy)
			moveToNextRelevantPipe(state, literalCopy, !(PIPE_INFER))

		elseif castTypeInfo.tag == !(typeTags.TypeInfoType) then
			assert(castIsDirect)

			local typeNode = valueExpr
			assert(typeNode.nodeType == !(nodeTypes.AstType))

			local typeNodeCopy = astCopy(typeNode, cast.token)

			addUnqueuedChildrenToQueueRecursively(state, typeNodeCopy, !(PIPE_DONE)) -- Only does something if the type has parameters.
			replaceQueuedNodeAndUnqueueOldTree(state, cast, typeNodeCopy)
			moveToNextRelevantPipe(state, typeNodeCopy, !(PIPE_INFER))

		else
			errorInternal(state, cast, "Incomplete: Handle casting enum to %s.", getFriendlyTypeInfoName(castTypeInfo))
		end

	-- (whatever) -> any
	-- any -> (whatever)
	elseif exprTypeInfo.tag == !(typeTags.TypeInfoAny) or castTypeInfo.tag == !(typeTags.TypeInfoAny) then
		-- void

	else
		errorInternal(
			state, cast,
			"Incomplete: Handle casting constant from %s to %s.",
			getFriendlyTypeInfoName(exprTypeInfo),
			getFriendlyTypeInfoName(castTypeInfo)
		)
	end
end

local function simplifyUnary(state, unary)
	-- @Incomplete: Simplify these kinds of expressions (including implicit casts): not (str ~= "") => str == ""
	local typeInfo = unary.inferredType

	if nil then

	!for _, opArithmetic in ipairs{"+","-"} do
	elseif unary.operation == !(opArithmetic) then
		assert(unary.expression.nodeType == !(nodeTypes.AstLiteral))
		assert(type(unary.expression.value) == "number")

		local literal = astNewNode(AstLiteral, unary.token, unary.parent)

		literal.literalType
			=  typeInfo.tag == !(typeTags.TypeInfoInt)   and !(LITERAL_INTEGER)
			or typeInfo.tag == !(typeTags.TypeInfoFloat) and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = !!(opArithmetic ~= "+" and opArithmetic or "") unary.expression.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	elseif unary.operation == "not" then
		assert(unary.expression.nodeType == !(nodeTypes.AstLiteral))
		assert(type(unary.expression.value) == "boolean")

		local literal        = astNewNode(AstLiteral, unary.token, unary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = not unary.expression.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	elseif unary.operation == "#" then
		local tableNode = followIdentifiersToConstantValue(unary.expression)
		local length    = 0
		assert(tableNode.nodeType == !(nodeTypes.AstTable))

		if tableNode.inferredType.tag == !(typeTags.TypeInfoArray) then
			for _, tableField in ipairs(tableNode.fields) do
				length = math.max(length, tableField.key.value)
			end

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoTable) then
			errorUnhandledNodeType(state, unary)

		else
			errorInternal(state, tableNode)
		end

		local literal        = astNewNode(AstLiteral, unary.token, unary.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = length
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, unary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	else
		errorUnhandledNodeType(state, unary)
	end
end

local function simplifyBinary(state, binary)
	local l  = binary.left
	local r  = binary.right
	local op = binary.operation

	!local ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS = templateToLua(
		`
			assert(l.nodeType == $nodeTypeLiteral)
			assert(r.nodeType == $nodeTypeLiteral)
			assert(type(l.value) == "number")
			assert(type(r.value) == "number")
		`, {
			nodeTypeLiteral = toLua(nodeTypes.AstLiteral),
		}
	)

	-- @Incomplete: Simplify these kinds of expressions: (1+x)+2 => (1+2)+x => 3+x
	-- @Incomplete: Simplify these kinds of expressions: 1 + -x => 1 - x
	local typeInfo = binary.inferredType

	if nil then
		-- void

	!for _, opArithmeticKeepType in ipairs{"+","-","*","^","%"} do
	elseif op == !(opArithmeticKeepType) then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		local literal = astNewNode(AstLiteral, binary.token, binary.parent)

		literal.literalType
			=  typeInfo.tag == !(typeTags.TypeInfoInt)   and !(LITERAL_INTEGER)
			or typeInfo.tag == !(typeTags.TypeInfoFloat) and !(LITERAL_FLOAT)
			or errorInternal(getFriendlyTypeInfoName(typeInfo))

		literal.value        = l.value !!(opArithmeticKeepType) r.value -- This should produce the correct result for any combination of int and float.
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	elseif op == "/" then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_FLOAT)
		literal.value        = l.value / r.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	elseif op == "//" then
		!!(ASSERT_BOTH_OPERANDS_NUMERIC_LITERALS)

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_INTEGER)
		literal.value        = math.floor(l.value / r.value)
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	!for _, opComparison in ipairs{"<",">","<=",">="} do
	elseif op == !(opComparison) then
		assert(l.nodeType == !(nodeTypes.AstLiteral))
		assert(r.nodeType == !(nodeTypes.AstLiteral))
		assert(type(l.value) == type(r.value))
		assert(isAny(type(l.value), "number","string"))

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = l.value !!(opComparison) r.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	!for _, opEquality in ipairs{"==","~="} do
	elseif op == !(opEquality) then
		local valueL, valueR

		if l.inferredType.tag == !(typeTags.TypeInfoType) then
			assert(r.inferredType.tag == !(typeTags.TypeInfoType))
			valueL = getTypeRepresentedByExpression(l).id
			valueR = getTypeRepresentedByExpression(r).id

		elseif l.inferredType.tag == !(typeTags.TypeInfoEnum) then
			assert(r.inferredType.tag == !(typeTags.TypeInfoEnum))
			assert(l.nodeType == !(nodeTypes.AstIdentifier))
			assert(r.nodeType == !(nodeTypes.AstIdentifier))
			valueL = l.name
			valueR = r.name

		elseif l.nodeType == !(nodeTypes.AstLiteral) then
			assert(r.nodeType == !(nodeTypes.AstLiteral))
			assert(type(l.value) == type(r.value))
			valueL = l.value
			valueR = r.value

		else
			!ifDEBUG `astPrintTree(binary)`
			errorInternal(state, binary)
		end

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = valueL !!(opEquality) valueR
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	!for _, opLogical in ipairs{"and","or"} do
	elseif op == !(opLogical) then
		assert(l.nodeType == !(nodeTypes.AstLiteral))
		assert(r.nodeType == !(nodeTypes.AstLiteral))
		assert(type(l.value) == "boolean")
		assert(type(r.value) == "boolean")

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_BOOLEAN)
		literal.value        = l.value !!(opLogical) r.value
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))
	!end

	elseif op == ".." then
		assert(l.nodeType == !(nodeTypes.AstLiteral))
		assert(r.nodeType == !(nodeTypes.AstLiteral))
		assert(type(l.value)  == "string")
		assert(type(r.value) == "string")

		local literal        = astNewNode(AstLiteral, binary.token, binary.parent)
		literal.literalType  = !(LITERAL_STRING)
		literal.value        = l.value .. r.value -- @Speed: Concatinate more than two values at a time. (Should maybe update parsing stage.)
		literal.inferredType = typeInfo

		replaceQueuedNodeAndUnqueueOldTree(state, binary, literal)
		moveToNextRelevantPipe(state, literal, !(PIPE_INFER))

	else
		errorUnhandledNodeType(state, binary)
	end
end

function _G.simplifyExpressionIfConstant(state, expr)
	if not isExpressionConstant(state, expr) then
		if
			-- :SpecialForeignValueRules
			expr.nodeType == !(nodeTypes.AstIdentifier)
			and expr.declaration.isConstant
			and expr.declaration.value.nodeType == !(nodeTypes.AstForeign)
		then
			local ident       = expr
			local foreign     = ident.declaration.value
			local foreignCopy = astCopy(foreign, ident.token)

			replaceQueuedNodeAndUnqueueOldTree(state, ident, foreignCopy)
			moveToNextRelevantPipe(state, foreignCopy, !(PIPE_INFER))
		end

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration or errorInternal(state, ident)

		if not decl.isConstant then  return  end

		local typeInfo = ident.inferredType

		if typeInfo.tag == !(typeTags.TypeInfoEnum) then
			if ident.name ~= decl.name.name then
				local copy = astCopy(decl.name, ident.token)
				replaceQueuedNodeAndUnqueueOldTree(state, ident, copy)
				moveToNextRelevantPipe(state, copy, !(PIPE_INFER))
			end
			return
		end

		local typeInfoRepresented = decl.valueTypeInfo

		if typeInfoRepresented then
			simplifyTypeExpression(state, ident, typeInfoRepresented)
			return
		end

		!ASSERT("typeInfo.tag ~= "..typeTags.TypeInfoType)
		if not isTypeSimple(typeInfo) then  return  end

		-- At this point we should have a literal to copy. Hopefully the expression we copy
		-- has been simplified into a literal if it wasn't a literal to begin with.
		local literal = decl.value
		if literal.nodeType ~= !(nodeTypes.AstLiteral) then
			errorInternal(state, literal)
		end

		local copy = astCopy(literal, ident.token)
		replaceQueuedNodeAndUnqueueOldTree(state, ident, copy)
		moveToNextRelevantPipe(state, copy, !(PIPE_INFER))

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		simplifyCast(state, expr)
	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		simplifyUnary(state, expr)
	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		simplifyBinary(state, expr)

	else
		-- void
	end
end



-- Values of simple types are non-objects (e.g. ints) in the outputted Lua code.
-- Note: Glóa types are represented as ints in Lua and thus are 'simple'.
function _G.isTypeSimple(typeInfo)
	return isAny(typeInfo.tag,
		!(typeTags.TypeInfoBool),
		!(typeTags.TypeInfoInt),
		!(typeTags.TypeInfoNone),
		!(typeTags.TypeInfoFloat),
		!(typeTags.TypeInfoString),
		!(typeTags.TypeInfoType),
		!(typeTags.TypeInfoEnum) -- The true enum member types are simple.
	)
end

function _G.isTypeNumeric(typeInfo)
	return isAny(typeInfo.tag, !(typeTags.TypeInfoInt),!(typeTags.TypeInfoFloat))
end

function _G.isTypeTableLike(typeInfo)
	return isAny(typeInfo.tag, !(typeTags.TypeInfoTable),!(typeTags.TypeInfoStruct),!(typeTags.TypeInfoArray))
end

-- isCompatible, compatibilityScore = isTypeCompatibleWith( typeToCheck, otherType )
function _G.isTypeCompatibleWith(typeToCheck, otherType)
	!local SCORE = 0x10000
	if typeToCheck == otherType then  return true, !(SCORE)  end

	-- Namespaces are never compatible with anything but themselves as they're not allowed in most places.
	if typeToCheck.tag == !(typeTags.TypeInfoNamespace) or otherType.tag == !(typeTags.TypeInfoNamespace) then  return false, 0  end

	-- Placeholders cannot actually be checked - we just say they are compatible with
	-- everything (except namespaces) until the situation is handled elsewhere.
	!local SCORE = .1
	if typeToCheck.tag == !(typeTags.TypeInfoPlaceholder) or otherType.tag == !(typeTags.TypeInfoPlaceholder) then  return true, !(SCORE)  end

	-- Everything is compatible with the 'any' type. The user better know what they're doing!
	!local SCORE = 0x1
	if typeToCheck.tag == !(typeTags.TypeInfoAny) or otherType.tag == !(typeTags.TypeInfoAny) then  return true, !(SCORE)  end

	-- Ints are always compatible with floats (but the opposite is false).
	-- This should be safe as all numbers are 64-bit floats in Lua 5.1 (I think).
	!local SCORE = 0x1000
	if typeToCheck.tag == !(typeTags.TypeInfoInt) and otherType.tag == !(typeTags.TypeInfoFloat) then  return true, !(SCORE)  end

	-- Structs and arrays are outputted as tables in Lua, so they are always compatible with tables in Glóa.
	!local SCORE = 0x10
	if
		otherType.tag == !(typeTags.TypeInfoTable)
		and isAny(typeToCheck.tag, !(typeTags.TypeInfoStruct),!(typeTags.TypeInfoArray))
	then
		return true, !(SCORE)
	end

	!local SCORE = 0x100
	if typeToCheck.tag == !(typeTags.TypeInfoCompound) then
		-- All compound items has to match the target. (If only one item matches, an explicit cast is needed.)
		local compoundToCheck = typeToCheck
		for _, compoundItemToCheck in ipairs(compoundToCheck) do
			if not isTypeCompatibleWith(compoundItemToCheck, otherType) then  return false, 0  end
		end
		return true, !(SCORE)
	end

	!local SCORE = 0x100
	if otherType.tag == !(typeTags.TypeInfoCompound) then
		-- typeToCheck has to match at least one compound item.
		local otherCompound = otherType
		for _, otherCompoundItem in ipairs(otherCompound) do
			if isTypeCompatibleWith(typeToCheck, otherCompoundItem) then  return true, !(SCORE)  end
		end
		return false, 0
	end

	-- Array compatability completely depends on the item type.
	if typeToCheck.tag == !(typeTags.TypeInfoArray) and otherType.tag == !(typeTags.TypeInfoArray) then
		return isTypeCompatibleWith(typeToCheck.itemType, otherType.itemType)
	end

	return false, 0
end

-- singleTypeInfo = adjustTypeToOne( state, expressionForError, typeInfo [, adjustVarargToIncludeNil=false ] )
-- Types that aren't single: TypeInfoVararg and TypeInfoList.
do
	local function compareIdsOfTypes(a, b)
		return a.id < b.id
	end

	local function adjustVarargItemTypeToOneAndToIncludeNil(state, itemType)
		if isAny(itemType.tag, !(typeTags.TypeInfoNone),!(typeTags.TypeInfoAny)) then
			return itemType
		end

		local nilTypeInfo = getTypeInfoForBuiltinType(state, "none")

		if itemType.tag ~= !(typeTags.TypeInfoCompound) then
			local typeInfos = {itemType, nilTypeInfo}
			table.sort(typeInfos, compareIdsOfTypes)
			return getTypeInfoForCompoundType(state, typeInfos)
		end

		local compound = itemType
		if indexOf(compound, nilTypeInfo) then  return compound  end

		local typeInfos = {nilTypeInfo, unpack(compound)}
		table.sort(typeInfos, compareIdsOfTypes)
		return getTypeInfoForCompoundType(state, typeInfos)
	end

	function _G.adjustTypeToOne(state, exprForError, typeInfo, adjustVarargToIncludeNil)
		if typeInfo.tag == !(typeTags.TypeInfoList) then
			typeInfo = typeInfo[1]
			if not typeInfo then
				typeError(state, exprForError, "Function call returns nothing. (Expected at least one value.)") -- Note: "Nothing" is not the same as vararg of zero length.
			end
		end

		if typeInfo.tag == !(typeTags.TypeInfoVararg) then
			typeInfo = typeInfo.itemType
			if adjustVarargToIncludeNil then
				typeInfo = adjustVarargItemTypeToOneAndToIncludeNil(state, typeInfo)
			end
		end

		return typeInfo
	end
end



-- Returns nil if we're now waiting for something. Errors on failure.
function _G.getExpectedTypeInfo(state, node, strict, expectantTerm, nodeForError)
	!(
	local NO_EXPECTATION = 'typeError(state, nodeForError, "Could not determine the type of this %s.", expectantTerm)'
	if DEBUG then
		NO_EXPECTATION = 'astPrintTree(node) ; '..NO_EXPECTATION
	end
	)
	local parentNodeType  = node.parent.nodeType

	if parentNodeType == !(nodeTypes.AstAssignment) then
		local assignment = node.parent
		local i          = indexOf(assignment.values, node)
		if not i then  !!(NO_EXPECTATION)  end

		if assignment.forDeclaration then
			local decl = assignment.declarations[i] or errorInternal()

			if decl.name.inferredType then
				return decl.name.inferredType
			elseif not decl.type then
				!!(NO_EXPECTATION)
			elseif not decl.type.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
			else
				return getTypeRepresentedByExpression(decl.type) or errorInternal()
			end

		else
			if not assignment.targets[i].inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `assignment.targets[i]`, nil, `nil`)
			end
			return assignment.targets[i].inferredType
		end

	elseif parentNodeType == !(nodeTypes.AstDeclaration) then
		local decl = node.parent
		if node ~= decl.value then  !!(NO_EXPECTATION)  end

		if decl.name.inferredType then
			return decl.name.inferredType
		elseif not decl.type then
			!!(NO_EXPECTATION)
		elseif not decl.type.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `decl.type`, nil, `nil`)
		else
			return getTypeRepresentedByExpression(decl.type) or errorInternal()
		end

	elseif parentNodeType == !(nodeTypes.AstCast) then
		local cast = node.parent
		if node ~= cast.expression then  !!(NO_EXPECTATION)  end

		if not cast.targetType.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `cast.targetType`, nil, `nil`)
		end

		return getTypeRepresentedByExpression(cast.targetType) or errorInternal()

	elseif parentNodeType == !(nodeTypes.AstBinary) then
		local binary = node.parent
		local other  = node == binary.left and binary.right or binary.left

		if not other.inferredType then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `other`, nil, `nil`)
		end

		return other.inferredType

	elseif parentNodeType == !(nodeTypes.AstTable) then
		local tableNode = node.parent
		if not tableNode.inferredType then
			-- Note: Tables will always get inferred before child tables.
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `tableNode`, nil, `nil`)
		end

		local tableField = nil
		local isKey      = false

		for _, _tableField in ipairs(tableNode.fields) do
			if node == _tableField.key then
				isKey      = true
				tableField = _tableField
				break
			elseif node == _tableField.value then
				tableField = _tableField
				break
			end
		end

		!ASSERT `tableField`

		if tableNode.inferredType.tag == !(typeTags.TypeInfoTable) then
			return getTypeInfoForBuiltinType(state, "any")

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoArray) then
			if isKey then  return getTypeInfoForBuiltinType(state, "int")  end

			local arraySig = tableNode.inferredType
			return arraySig.itemType

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoStruct) then
			if isKey then  return getTypeInfoForBuiltinType(state, "string")  end

			local structInfo = tableNode.inferredType
			assert(structInfo.hasMembers) -- Not sure if we have to wait for this here.

			local memberLiteral = tableField.key
			if not memberLiteral.inferredType then
				!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `memberLiteral`)
			end

			local memberName = memberLiteral.value
			local member     = itemWith1(structInfo.members, "name", memberName) or errorInternal(state, memberLiteral, memberName)

			return member.typeInfo

		else
			errorInternal(getFriendlyTypeInfoName(tableNode.inferredType))
		end

	elseif parentNodeType == !(nodeTypes.AstReturn) then
		local returnNode = node.parent

		if returnNode.runDirective then
			return getExpectedTypeInfo(state, returnNode.runDirective, strict, expectantTerm, nodeForError)
		end

		local i = indexOf(returnNode.values, node)
		if not i then  !!(NO_EXPECTATION)  end

		local lambda  = astFindParent(returnNode, !(nodeTypes.AstLambda))
		local funcSig = lambda.inferredType

		if not funcSig then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `lambda`, nil, `nil`)
		end

		local argTypesOut = funcSig.argumentTypesOut
		local argTypeInfo = argTypesOut[i]

		if
			(not argTypeInfo and argTypesOut[1] and argTypesOut[#argTypesOut].tag == !(typeTags.TypeInfoVararg))
			or (argTypeInfo.tag == !(typeTags.TypeInfoVararg))
		then
			local varargSig = argTypeInfo or argTypesOut[#argTypesOut]
			argTypeInfo     = varargSig.itemType
		end

		-- Note: We don't need to get too fancy with validation here as the return is validated later.
		if not argTypeInfo then
			typeError(state, returnNode, "Too many values specified for return.")
		end

		return argTypeInfo

	elseif strict then
		!!(NO_EXPECTATION)

	elseif parentNodeType == !(nodeTypes.AstCall) then
		local call = node.parent
		local i    = indexOf(call.arguments, node)
		if not i then  !!(NO_EXPECTATION)  end

		local calleeTypeInfo = call.callee.inferredType

		if not calleeTypeInfo then
			!DEPEND_AND_RETURN(`node`, DEPEND_NODE_INFERRED, `call.callee`, nil, `nil`)
		end

		local argTypesIn  = calleeTypeInfo.argumentTypesIn
		local argTypeInfo = argTypesIn[i]

		if
			(not argTypeInfo and argTypesIn[1] and argTypesIn[#argTypesIn].tag == !(typeTags.TypeInfoVararg))
			or (argTypeInfo.tag == !(typeTags.TypeInfoVararg))
		then
			local varargSig = argTypeInfo or argTypesIn[#argTypesIn]
			argTypeInfo     = varargSig.itemType
		end

		-- Note: We don't need to get too fancy with validation here as the call is validated later.
		if not argTypeInfo then
			typeError(state, call, "Too many arguments specified for call.")
		end

		return argTypeInfo

	else
		!!(NO_EXPECTATION)
	end
	errorInternal()
end



-- Note: The expression must be constant!
function _G.followIdentifiersToConstantValue(constExpr)
	while constExpr.nodeType == !(nodeTypes.AstIdentifier) do
		local decl = constExpr.declaration
		constExpr  = decl.value
	end
	return constExpr
end



function _G.wrapInImplicitCast(state, nodeToWrap, resultingTypeInfo, addToInferPipe)
	local cast        = astNewNode(AstCast, nodeToWrap.token, nodeToWrap.parent)
	cast.isImplicit   = true
	cast.inferredType = resultingTypeInfo
	pokeAndQueueUnqueuedNodeIntoTree(state, nodeToWrap, cast, cast,"expression", (addToInferPipe and !(PIPE_INFER) or !(PIPE_DONE)))
	return cast
end



local EXPRESSION_EXPECTED = !(Set{
	nodeTypes.AstType,
	nodeTypes.AstUnary,
	nodeTypes.AstBinary,
	nodeTypes.AstAccess,
	nodeTypes.AstTable,
	nodeTypes.AstCall,
	nodeTypes.AstTypeOf,
	nodeTypes.AstCast,
	nodeTypes.AstConditional,
	nodeTypes.AstBake,
	nodeTypes.AstRun, -- Good?
	nodeTypes.AstUsing,
	nodeTypes.AstDebug,
	nodeTypes.AstAssignment,
	nodeTypes.AstReturn,
})
local EXPRESSION_NOT_EXPECTED = !(Set{
	nodeTypes.AstArgument,
	nodeTypes.AstArguments,
	nodeTypes.AstDefer,
	nodeTypes.AstBlock,
	nodeTypes.AstFileScope,
	nodeTypes.AstGlobalScope,
	nodeTypes.AstStruct,
	nodeTypes.AstEnum,
	nodeTypes.AstLambda,
})

function _G.isAnExpressionExpected(state, node)
	local parent         = node.parent
	local parentNodeType = parent.nodeType

	if EXPRESSION_EXPECTED[parentNodeType] then
		return true
	elseif EXPRESSION_NOT_EXPECTED[parentNodeType] then
		return false
	elseif parentNodeType == !(nodeTypes.AstDeclaration) then
		return node == parent.name or node == parent.type or node == parent.value
	elseif parentNodeType == !(nodeTypes.AstFor) then
		return node ~= parent.body
	elseif isAny(parentNodeType, !(nodeTypes.AstIf),!(nodeTypes.AstStaticIf),!(nodeTypes.AstWhile)) then
		return node == parent.condition
	else
		errorUnhandledNodeType(state, node.parent)
	end
end


