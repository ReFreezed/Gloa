--[[============================================================
--=
--=  Typer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	typeError, typeMessage, errorUnhandledNodeType
	inferType*

--============================================================]]

!(
local function WAITING_OR_ERROR(errCode)
	__LUA("if state.mustInfer then ")
		__LUA("state.errorStep = state.errorStep-1 ")
		__LUA("if state.errorStep <= 0 then ")
			__LUA(errCode," ")
		__LUA("end ")
	__LUA("end ")
	__LUA("state.waiting = state.waiting+1 ")
end
)



_G.!struct"TyperState"{
	fileBuffers = {},
	tokens      = {},

	progress    = 0,
	waiting     = 0,

	mustInfer   = false,
	errorStep   = 0,

	functionSignatureTypes = {},
}



!(
_G.typeInfoKinds    = {}
local typeInfoN     = 0
local typeInfoNames = {}

local function structTypeInfo(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			typeInfoN              = typeInfoN+1
			fields._overrides      = fields._overrides or {}
			fields._overrides.kind = typeInfoN

			typeInfoKinds[name]      = typeInfoN
			typeInfoNames[typeInfoN] = name
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_TypeInfo"{
	kind       = 0,
	group      = 0,
	id         = 0,
	definition = NIL, -- AstTypeDefinition (This node has the scope.)
}

!structTypeInfo"_TypeInfoPrimitive:_TypeInfo"{
	_overrides = {group=TYPEDEF_BUILTIN},
}
local !structTypeInfo"TypeInfoBool:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoInt:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoNil:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoNumber:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoString:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoTable:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoType:_TypeInfoPrimitive"{}
local !structTypeInfo"TypeInfoAny:_TypeInfoPrimitive"{}

local !structTypeInfo"TypeInfoFunction:_TypeInfo"{
	-- Are missing a 'name' field here? TypeInfoStruct has one, but maybe the situation is more complex with functions.
	_overrides       = {group=TYPEDEF_FUNCTION},
	argumentTypesIn  = {}, -- []TypeInfo
	argumentTypesOut = {}, -- []TypeInfo
	polymorphic      = false,
	inline           = false,
}

local !struct"TypeInfoStructMember"{
	name     = "",
	typeInfo = NIL,
}
local !structTypeInfo"TypeInfoStruct:_TypeInfo"{
	_overrides            = {group=TYPEDEF_STRUCT},
	name                  = "",
	members               = {},  -- []TypeInfoStructMember
	polymorphSourceStruct = NIL, -- TypeInfoStruct
}

local !struct"TypeInfoEnumMember"{
	name = "",
}
local !structTypeInfo"TypeInfoEnum:_TypeInfo"{
	_overrides            = {group=TYPEDEF_ENUM},
	name                  = "",
	members               = {}, -- []TypeInfoEnumMember
}

local !structTypeInfo"TypeInfoCompound:_TypeInfo"{
	_overrides = {group=TYPEDEF_BUILTIN},
	-- [1]=typeInfo1, ...
}

local TYPEDEF_NAMES = !(typeInfoNames)



-- typeInfo = newTypeInfo( TypeInfoCreator [, definition=internal ] )
do
	local lastTypeId = 0

	function _G.newTypeInfo(TypeInfoCreator, defn)
		if not TypeInfoCreator then  error("No TypeInfoCreator specified.", 2)  end

		lastTypeId = lastTypeId+1

		local typeInfo      = TypeInfoCreator()
		typeInfo.id         = lastTypeId
		typeInfo.definition = defn

		--[[
		if lastTypeId == 22 then
			error("DEBUG")
		end
		--]]

		return typeInfo
	end
end

do
	local builtinTypeInfos = {}

	local BUILTIN_TYPE_STRUCTS = {
		["bool"]   = TypeInfoBool,
		["int"]    = TypeInfoInt,
		["nil"]    = TypeInfoNil,
		["number"] = TypeInfoNumber,
		["string"] = TypeInfoString,
		["table"]  = TypeInfoTable,
		["type"]   = TypeInfoType,
	}

	function _G.getTypeInfoForBuiltinType(state, typeName)
		local typeInfo = builtinTypeInfos[typeName]

		if not typeInfo then
			local TypeInfoCreator      = BUILTIN_TYPE_STRUCTS[typeName] or error(typeName)
			typeInfo                   = newTypeInfo(TypeInfoCreator)
			builtinTypeInfos[typeName] = typeInfo
		end

		return typeInfo
	end
end

-- typeInfo, definition = getTypeInfo( state, identType )
-- Can return nil. The definition is always nil for built-in types.
function _G.getTypeInfo(state, identType)
	-- print(">>>>>>>>>") astPrint(identType) print("<<<<<<<<<")

	if not identType.isUserType then
		return getTypeInfoForBuiltinType(state, identType.typeName), nil

	elseif identType.functionSignature then
		local lambda = identType.functionSignature

		for _, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
			if not arg.declaration.inferredTypes[1] then  return nil  end
		end
		for _, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
			if not arg.declaration.inferredTypes[1] then  return nil  end
		end

		-- Have we encountered an equal signature before?
		for _, funcSigCached in ipairs(state.functionSignatureTypes) do
			if doesLambdaHaveSignature(lambda, funcSigCached) then
				return funcSigCached, nil
			end
		end

		funcSig = newTypeInfo(TypeInfoFunction)

		for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
			funcSig.argumentTypesIn[i] = arg.declaration.inferredTypes[1]
		end
		for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
			funcSig.argumentTypesOut[i] = arg.declaration.inferredTypes[1]
		end

		table.insert(state.functionSignatureTypes, funcSig)
		return funcSig, nil

	else
		assert(identType.typeName ~= "")

		local defn     = findDefinition(state, identType, identType.typeName)
		local typeInfo = defn and defn.typeInfo

		if not typeInfo then  return nil  end

		if typeInfo.group == !(TYPEDEF_BUILTIN) then
			assert(not identType.arguments)

		elseif typeInfo.group == !(TYPEDEF_STRUCT) then
			error("@Incomplete: Handle group==TYPEDEF_STRUCT")

		elseif typeInfo.group == !(TYPEDEF_ENUM) then
			error("@Incomplete: Handle group==TYPEDEF_ENUM")

		elseif typeInfo.group == !(TYPEDEF_FUNCTION) then
			error("@Incomplete: Handle group==TYPEDEF_FUNCTION")

		else
			error(typeInfo.group)
		end

		return typeInfo, defn
	end
end



function _G.doesLambdaHaveSignature(lambda, funcSig)
	if #(lambda.argumentsIn  or EMPTY_TABLE) ~= #funcSig.argumentTypesIn  then  return false  end
	if #(lambda.argumentsOut or EMPTY_TABLE) ~= #funcSig.argumentTypesOut then  return false  end

	for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
		if arg.declaration.inferredTypes[1] ~= funcSig.argumentTypesIn[i] then  return false  end
	end
	for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
		if arg.declaration.inferredTypes[1] ~= funcSig.argumentTypesIn[i] then  return false  end
	end

	-- @Incomplete: Check arg.isRequired for input args.

	return true
end



function _G.getClosestScope(node)
	return astFindParent(node, !(nodeTypes.AstFileScope),!(nodeTypes.AstBlock),!(nodeTypes.AstStruct),!(nodeTypes.AstEnum),!(nodeTypes.AstFor),!(nodeTypes.AstLambda))
end



function _G.findDefinition(state, startNode, name)
	local scope = startNode

	while true do
		scope = getClosestScope(scope)
		if not scope then  return nil  end

		assert(scope.definitions, scope.nodeType)

		for _, defn in ipairs(scope.definitions) do
			if defn.name.name == name then  return defn  end
		end
	end
end

function _G.defineInClosestScope(state, ident, typeInfo)
	-- @Incomplete: (Sometimes) add hints in all parent scopes about this definition so we can detect name shadowing.

	local defnExisting = findDefinition(state, ident, ident.name)

	if defnExisting then
		-- @Incomplete: We're not following imperative scope rules for name shadowing (if that's what happening here).
		typeMessage(state, ident,             "Error", "'%s' has already been defined.", ident.name)
		typeMessage(state, defnExisting.name, "Info",  "...it was defined here.")
		exitFailure()
	end

	local scope = getClosestScope(ident)
	if not scope then
		typeError(state, ident, "Could not find what scope '%s' is in.", ident.name)
	end

	local defn    = astNewNode(AstTypeDefinition, ident.token, scope)
	defn.name     = ident
	defn.scope    = scope
	defn.typeInfo = typeInfo

	table.insert(scope.definitions, defn)
end

function _G.printDefinitionChain(state, defn, typeName)
	!local MAX_CHAIN_LENGTH = 10

	for i = 1, !(MAX_CHAIN_LENGTH) do
		typeMessage(state, defn.name, "Info", "...here is '%s' defined.", typeName)

		local placeDeclared = defn.name.placeDeclared
		if not placeDeclared then  break  end

		defn = nil

		if placeDeclared.nodeType == !(nodeTypes.AstDeclaration) then
			local decl      = placeDeclared
			local i         = indexWith1(decl.names, "name", typeName)
			local valueNode = decl.assignment and decl.assignment.values[i]

			if valueNode and valueNode.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = valueNode
				typeName    = ident.name
				defn        = findDefinition(state, ident, typeName)
			end
		end

		if not defn then  break  end
	end
end



local LITERAL_TYPE_TO_BUILTIN_TYPE_NAME = !({
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_INTEGER] = "int",
	[LITERAL_NIL]     = "nil",
	[LITERAL_NUMBER]  = "number",
	[LITERAL_STRING]  = "string",
})

function _G.inferExpression(state, expr)
	local typeInfo

	if expr.nodeType == !(nodeTypes.AstType) then
		local identType = expr

		if identType.functionSignature and not identType.functionSignature.inferredType then
			inferExpression(state, identType.functionSignature)
		end

		if not getTypeInfo(state, identType) then
			-- Note: typeName is empty for lambdas, but function signatures always have a valid type so it doesn't matter (I think).
			!WAITING_OR_ERROR `typeError(state, identType, "No type '%s'.", identType.typeName)`
			return
		end

		typeInfo = getTypeInfoForBuiltinType(state, "type")

	elseif expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal  = expr
		local typeName = LITERAL_TYPE_TO_BUILTIN_TYPE_NAME[literal.literalType]

		if typeName then
			typeInfo = getTypeInfoForBuiltinType(state, typeName)
		else
			errorUnhandledNodeType(expr)
		end

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local defn  = findDefinition(state, ident, ident.name)

		if defn then
			typeInfo = defn.typeInfo
		else
			!WAITING_OR_ERROR `typeError(state, ident, "Undeclared identifier '%s'.", ident.name)`
			return
		end

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda          = expr
		local argsAreInferred = true

		-- Infer arguments.
		!for argsVarI, argsVar in ipairs{`lambda.argumentsIn`,`lambda.argumentsOut`} do
			local args = !!(argsVar)

			for i, arg in ipairs(args or EMPTY_TABLE) do
				local decl = arg.declaration

				if not decl.inferredTypes[1] then
					inferDeclaration(state, decl, !(argsVarI == 2))

					if decl.inferredTypes[1] then
						for i = i+1, #args do
							local arg2 = args[i]
							if arg2.group ~= arg.group then  break  end
							arg2.declaration.inferredTypes[1] = decl.inferredTypes[1]
						end
					else
						argsAreInferred = false
					end
				end
			end
		!end

		if not argsAreInferred then
			-- Should we have WAITING_OR_ERROR here?
			return
		end

		typeInfo = newTypeInfo(TypeInfoFunction--[[, defn]])

		for i, arg in ipairs(lambda.argumentsIn or EMPTY_TABLE) do
			typeInfo.argumentTypesIn[i] = arg.declaration.inferredTypes[1]
		end
		for i, arg in ipairs(lambda.argumentsOut or EMPTY_TABLE) do
			typeInfo.argumentTypesOut[i] = arg.declaration.inferredTypes[1]
		end

		-- @Incomplete: typeInfo.polymorphic
		-- @Incomplete: typeInfo.inline

	elseif expr.nodeType == !(nodeTypes.AstCall) then
		-- @Incomplete: Check that the callee can take the args we give it.
		local call          = expr
		local allIsInferred = true

		if not call.callee.inferredType then
			inferExpression(state, call.callee)

			if not call.callee.inferredType then
				allIsInferred = false
			elseif call.callee.inferredType.group ~= !(TYPEDEF_FUNCTION) then -- @Incomplete: Allow parameterized structs.
				typeError(state, call.callee, "This is not a function.")
			end
		end

		for _, argExpr in ipairs(call.arguments) do
			if not argExpr.inferredType then
				inferExpression(state, argExpr)
				allIsInferred = allIsInferred and (argExpr.inferredType ~= nil)
			end
		end

		if not allIsInferred then
			-- Should we have WAITING_OR_ERROR here?
			return
		end

		typeInfo = call.callee.inferredType -- Note: We've already assured we're calling a function.  @Incomplete: Handle parameterized structs.

	else
		errorUnhandledNodeType(expr)
	end

	assert(typeInfo)
	expr.inferredType = typeInfo
end

-- typeInfo = inferDeclarationAssignmentValue( state, assignment, identifier, assignmentTargetIndex [, expectedTypeInfo=any ] )
local function inferDeclarationAssignmentValue(state, assignment, ident, i, typeInfoExpected)
	local expr      = assignment.values[i]
	local lastIndex = #assignment.values

	local typeInfoForValueForName

	-- Value list ending in a call (hopefully).
	-- @Incomplete: Check that !must args from functions have an assignment target.
	if not expr or expr.nodeType == !(nodeTypes.AstCall) then
		local call = expr

		if not call then
			-- We're past the end of the list - get the last specified value.
			call = assignment.values[lastIndex]

			if call.nodeType ~= !(nodeTypes.AstCall) then
				typeError(state, call, "Expected a function call. Missing a value for '%s'.", ident.name)
			elseif call.surroundedByParenthesis then
				typeError(state, ident, "Missing a value for '%s'.", ident.name)
			end
		end

		local argIndex = i-lastIndex+1

		if not call.inferredType then
			inferExpression(state, call)
			-- :OncePerValue
		end

		if call.inferredType then
			-- @Speed: Only do this once per name. (Moving this to :OncePerValue doesn't work
			-- if argIndex > 1 because call.inferredType is already set at that point.)
			local typeInfoForCall = call.inferredType
			assert(typeInfoForCall.group == !(TYPEDEF_FUNCTION))

			local typeInfoForOutArg = typeInfoForCall.argumentTypesOut[argIndex]
			if not typeInfoForOutArg then
				typeError(state, call, "Call does not return anything for '%s' (output argument #%d).", ident.name, argIndex)
			end

			if typeInfoExpected and typeInfoForOutArg ~= typeInfoExpected then
				-- @UX: Mention the declaration type in the message (maybe with getKindOfFriendlyTypeInfoName()).
				local calleeName = (call.callee.nodeType == !(nodeTypes.AstIdentifier) and call.callee.name or "?")
				typeError(
					state, assignment.values[math.min(i, lastIndex)],
					"Type of return value #%d of '%s' does not match specified type in declaration.",
					argIndex, calleeName
				)
			end

			return typeInfoForOutArg
		end

		return nil -- Could not infer type yet.

	-- Non-call value or value not last in list.
	else
		if not expr.inferredType then
			inferExpression(state, expr)

			if typeInfoExpected and expr.inferredType ~= typeInfoExpected then
				-- printobj('typeInfoExpected', TYPEDEF_TITLES[typeInfoExpected.group], typeInfoExpected)
				-- printobj('expr.inferredType', expr.inferredType and TYPEDEF_TITLES[expr.inferredType.group], expr.inferredType)
				-- @UX: Mention the declaration type in the message (maybe with getKindOfFriendlyTypeInfoName()).
				typeError(state, assignment.values[math.min(i, lastIndex)], "Value and type mismatch in declaration.")
			end
		end

		return expr.inferredType
	end
end

-- inferDeclaration( state, declaration [, isOutArg=false ] )
function _G.inferDeclaration(state, decl, isOutArg)
	-- Infer values (if no type is specified).
	if decl.assignment and not decl.types[1] then
		for i, expr in ipairs(decl.assignment.values) do
			if not expr.inferredType then  inferExpression(state, expr)  end
		end
	end

	-- Infer names and declare them.
	for i, ident in ipairs(decl.names) do
		local typeInfo = decl.inferredTypes[i]

		if not typeInfo then
			-- Specified compound type.
			-- local x:int|string
			if decl.types[2] then
				error("@Incomplete: TypeInfoCompound")

			-- Single specified type.
			-- local x:int
			elseif decl.types[1] then
				local typeNode = decl.types[1]

				-- local x:int
				if typeNode.nodeType == !(nodeTypes.AstType) then
					local identType = typeNode
					local typeName  = identType.typeName

					if not identType.inferredType then
						inferExpression(state, identType)
					end

					if not identType.inferredType then
						!WAITING_OR_ERROR `typeError(state, identType, "Undeclared type '%s'.", typeName)`

					else
						typeInfo, defn = getTypeInfo(state, identType)

						if identType.isUserType and typeInfo.kind ~= !(typeInfoKinds.TypeInfoType) then -- Do we need to include TypeInfoStruct etc here?
							typeMessage(state, identType, "Error", "'%s' is not a type. (It is '%s')", typeName, getKindOfFriendlyTypeInfoName(typeInfo))
							printDefinitionChain(state, defn, typeName)
							exitFailure()
						end
					end

				-- local x:[]int
				elseif typeNode.nodeType == !(nodeTypes.AstLiteral) then
					local literal = typeNode
					assert(literal.literalType == !(LITERAL_ARRAY))
					errorUnhandledNodeType(typeNode) -- @Incomplete

				-- local x:typeOf(y)
				elseif typeNode.nodeType == !(nodeTypes.AstTypeOf) then
					local typeOf = typeNode
					local expr   = typeOf.expression

					inferExpression(state, expr)

					typeInfo            = expr.inferredType
					typeOf.inferredType = typeInfo

					if not typeInfo then
						-- !WAITING_OR_ERROR `typeError(state, expr, "Could not infer type of expression.")` -- Unhelpful...
					end

				else
					errorUnhandledNodeType(typeNode)
				end

			-- No type specified - infer from initial values.
			else
				assert(decl.assignment) -- This should have been caught during parsing.
				typeInfo = inferDeclarationAssignmentValue(state, decl.assignment, ident, i, nil)
			end

			if typeInfo then
				state.progress        = state.progress+1
				decl.inferredTypes[i] = typeInfo

				if not isOutArg then
					defineInClosestScope(state, ident, typeInfo)
				end
			end

			-- [[ DEBUG
			if typeInfo then
				printf("DECLARE %s:%s%s%s",
					ident.name,
					getKindOfFriendlyTypeInfoName(typeInfo),
					ident.placeDeclared and " IN "..AST_NODE_TYPE_NAMES[ident.placeDeclared.nodeType] or "",
					(isOutArg and " (isOutArg)" or "")
				)
			else
				printf("(declare failed %s)", ident.name)
			end
			--]]
		end--if not typeInfo

		-- Infer values (if types are specified).
		if typeInfo and decl.types[1] and decl.assignment --[[and decl.assignment.values[1] ]]then
			inferDeclarationAssignmentValue(state, decl.assignment, ident, i, typeInfo)
		end--if specified value and type
	end--for decl.names
end

function _G.inferFileScope(state, fileScope)
	for _, decl in ipairs(fileScope.declarations) do
		inferDeclaration(state, decl)
	end
end



-- typeError( typerState, node, formatString, ... )
function _G.typeError(state, node, s, ...)
	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	errorInFile(buffer, path, tokens.position1[token], "Typer", s, ...)
end

-- typeMessage( typerState, node, label, formatString, ... )
function _G.typeMessage(state, node, label, s, ...)
	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	reportMessageInFile(buffer, path, tokens.position1[token], label, "Typer", s, ...)
end

function _G.errorUnhandledNodeType(node)
	!if DEBUG then
		astPrint(node)
	!end
	errorInternal(2, "Incomplete: Unhandled node type '%s'.", (AST_NODE_TYPE_NAMES[node.nodeType] or node.nodeType))
end



function _G.getKindOfFriendlyTypeInfoName(typeInfo)
	-- @Cleanup: This just ain't nice.
	return TYPEDEF_NAMES[typeInfo.kind]:gsub("^TypeInfo", ""):lower()
end


