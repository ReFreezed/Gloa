--[[============================================================
--=
--=  General functions
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	copyTable, copyArray, copyToArray, emptyArray, fillArray, reverseArray, flipArray
	errorInternal, errorLine, errorOnLine, errorInFile
	exit, exitFailure
	F
	formatNumber, formatBinary
	generateRandomString
	getFileContents
	getKeys
	getLast, nextItem
	indexOf, lastIndexOf
	indexWith*, lastIndexWith*, itemWith*, lastItemWith*, nextItemWith*, previousItemWith*
	isAny
	iterate
	pack
	pairsSorted
	printf, printTraceback, printobj
	recycleTable, recycleTablesInArray, getRecycledTable, getRecycledTableCount
	reportMessageInFile
	setFields
	sort, sortByColumn, sortNatural, naturalCompare
	timeIt
	trim, triml, trimr
	utf8Char

--============================================================]]



_G.F = string.format



function math.clamp(n, nMin, nMax)
	return math.min(math.max(n, nMin), nMax)
end



function _G.printf(s, ...)
	print(F(s, ...))
end

function _G.printTraceback(level)
	print("stack traceback:")

	for level = 1+(level or 1), math.huge do
		local info = debug.getinfo(level, "nSl")
		if not info then  break  end

		-- print(level, "source   ", info.source)
		-- print(level, "short_src", info.short_src)
		-- print(level, "name     ", info.name)
		-- print(level, "what     ", info.what)

		local where = info.source:match"^@(.+)" or info.short_src
		local lnStr = info.currentline > 0 and ":"..info.currentline or ""

		local name
			=  info.name --and (info.namewhat ~= "" and "in "..info.namewhat.." "..info.name or info.name)
			or info.linedefined > 0 and where..":"..info.linedefined
			or info.what == "main" and "main chunk"
			or info.what == "tail" and "tail call"
			or "?"

		printf("\t%s%s  (%s)", where, lnStr, name)
	end
end

-- printobj( ... )
do
	local out    = io.stdout
	local _write = out.write
	local function write(...)
		_write(out, ...)
	end

	local _tostring = tostring
	local function tostring(v)
		return (_tostring(v):gsub("^table: 0x", ""))
	end

	local function compareKeys(a, b)
		return naturalCompare(tostring(a), tostring(b))
	end

	local function _printobj(v, tables, isDepth1, depth)
		local vType = type(v)

		if vType == "table" then
			if tables[v] then
				write("0x", tostring(v))

			else
				write(tostring(v), (isDepth1 and "{" or "{ "))
				tables[v] = true

				local indices = {}
				for i = 1, #v do  indices[i] = true  end

				for _, k in ipairs(sort(getKeys(v), compareKeys)) do
					if not indices[k] then
						if isDepth1 then  write("\n\t")  end
						write(tostring(k), (isDepth1 and " = " or "="))
						_printobj(v[k], tables, false, depth+1)
					end
				end

				for i = 1, #v do
					if isDepth1 then  write("\n\t")  end
					write(i, (isDepth1 and " = " or "="))
					_printobj(v[i], tables, false, depth+1)
				end

				write(isDepth1 and "\n}" or "}")
			end

		elseif vType == "number" then
			write(F("%g", v))

		elseif vType == "string" then
			if #v > 1000 then
				write('"', v:sub(1, 1000):gsub("%z", "\\0"):gsub("\n", "\\n"), '..."')
			else
				write('"', v:gsub("%z", "\\0"):gsub("\n", "\\n"), '"')
			end

		else
			write(tostring(v))
		end

		write(depth>2 and " " or "")
	end

	function _G.printobj(...)
		for i = 1, select("#", ...) do
			if i > 1 then  write("\t")  end

			_printobj(select(i, ...), {}, true, 1)
		end
		write("\n")
	end
end



-- errorInternal( [ level=1, ] formatString, ... )
local function _errorInternal(level, s, ...)
	printf("Error: "..s, ...)
	printTraceback(1+level)
	exitFailure()
end
function _G.errorInternal(levelOrS, ...)
	if type(levelOrS) == "number" then
		_errorInternal(1+levelOrS, ...)
	else
		_errorInternal(2, levelOrS, ...)
	end
end

function _G.errorLine(agent, s, ...)
	if agent then
		printf("[%s] Error: "..s, agent, ...)
	else
		printf("Error: "..s, ...)
	end
	exitFailure()
end

function _G.errorOnLine(path, ln, agent, s, ...)
	s = F(s, ...)
	if agent then
		printf("Error @ %s:%d: [%s] %s\n", path, ln, agent, s)
	else
		printf("Error @ %s:%d: %s\n",      path, ln,        s)
	end
	exitFailure()
end

function _G.errorInFile(buffer, path, ptr, agent, s, ...)
	reportMessageInFile(buffer, path, ptr, "Error", agent, s, ...)
	exitFailure()
end




function _G.reportMessageInFile(buffer, path, ptr, label, agent, s, ...)
	!local BUFFER_LINES_TO_PRINT = 3

	s   = F(s, ...)
	ptr = math.clamp(ptr, 1, #buffer+1)

	!for i = 1, BUFFER_LINES_TO_PRINT do
		!local varThisPtr = "lineStart"..i
		!local varPrevPtr = "lineStart"..i-1

		!if i == 1 then
			local !!(varThisPtr) = ptr
		!else
			local !!(varThisPtr) = !!(varPrevPtr)-1
		!end

		while !!(varThisPtr) > 1 and buffer:byte(!!(varThisPtr)-1) ~= !(getByte"\n") do
			!!(varThisPtr) = !!(varThisPtr)-1
		end
	!end

	local lineEnd = ptr-1 -- We start at ptr-1 so that we may get lineEnd==lineStart1-1 in the end.
	while lineEnd < #buffer and buffer:byte(lineEnd+1) ~= !(getByte"\n") do
		lineEnd = lineEnd+1
	end

	local lastLinePre = buffer:sub(lineStart1, ptr-1):gsub("\t", "    ")

	!for i = 1, BUFFER_LINES_TO_PRINT do
		!local varThis    = "lastLine" ..i
		!local varThisPtr = "lineStart"..i
		!local varPrevPtr = "lineStart"..i-1

		local !!(varThis) = ""

		!if i == 1 then
			!!(varThis) = buffer:sub(!!(varThisPtr), lineEnd         ):gsub("\t", "    ")
		!else
			if !!(varPrevPtr)-2 >= 1 then
				!!(varThis) = buffer:sub(!!(varThisPtr), !!(varPrevPtr)-2):gsub("\t", "    ")
			end
		!end
	!end

	local _, nlCount  = buffer:sub(1, ptr-1):gsub("\n", "%0")
	local ln          = nlCount+1

	local len         = 0
	local lenPtr      = 1

	while true do
		if lenPtr > #lastLinePre then  break  end

		local _, i2 = lastLinePre:find("^[%z\1-\127\194-\244][\128-\191]*", lenPtr)

		len    = len+1 -- The length isn't going to be perfect, depending on what Unicode characters are encountered.
		lenPtr = i2+1
	end

	local col = 1+len

	if agent then
		printf("%s @ %s:%d: [%s] %s", label, path, ln, agent, s)
	else
		printf("%s @ %s:%d: %s",      label, path, ln,        s)
	end

	print()

	!for i = BUFFER_LINES_TO_PRINT, 1, -1 do
		!local varThis = "lastLine"..i

		!if i == 1 then
			print("> "..!!(varThis))
		!else
			if !!(varThis) ~= "" then
				print("> "..!!(varThis))
			end
		!end
	!end

	printf("> %s^\n", ("-"):rep(col-1))
end



function _G.exit(code)
	-- @Incomplete: Close log file and whatnot.
	os.exit(code or 0)
end

function _G.exitFailure()
	exit(1)
end



-- contents, error = getFileContents( path [, isText=false ] )
function _G.getFileContents(path, isText)
	local file, err = io.open(path, (isText and "r" or "rb"))
	if not file then  return nil, err  end

	local s = file:read"*a"
	file:close()
	return s
end



do
	local function _utf8Char(cp)
		if cp < 128 then  return string.char(cp)  end

		local suffix = cp%64
		local c4     = 128+suffix
		cp           = (cp-suffix)/64
		if cp < 32 then  return string.char(192+cp, c4)  end

		suffix   = cp%64
		local c3 = 128+suffix
		cp       = (cp-suffix)/64
		if cp < 16 then  return string.char(224+cp, c3, c4)  end

		suffix = cp%64
		cp     = (cp-suffix)/64
		return string.char(240+cp, 128+suffix, c3, c4)
	end

	local cache = {}

	function _G.utf8Char(cp)
		cache[cp] = cache[cp] or _utf8Char(cp)
		return cache[cp]
	end
end



function _G.isAny(v, ...)
	for i = 1, select("#", ...) do
		if v == select(i, ...) then  return true  end
	end
	return false
end



function _G.indexOf(t, v)
	for i = 1, #t do
		if t[i] == v then  return i  end
	end
	return nil
end

function _G.lastIndexOf(t, v)
	for i = #t, 1, -1 do
		if t[i] == v then  return i  end
	end
	return nil
end




do
	local select = select

	local function _itemWith(t, i1, i2, iDir, ...)
		local argCount = select("#", ...)
		local item, isMatch, k, v

		for i = i1, i2, iDir do
			item    = t[i]
			isMatch = true

			for argIndex = 1, argCount, 2 do
				k, v = select(argIndex, ...)

				if item[k] ~= v then
					isMatch = false
					break
				end
			end

			if isMatch then  return item, i  end
		end

		return nil, nil
	end
	local function _itemWith1(t, i1,i2,iDir, k,v)
		local item
		for i = i1, i2, iDir do
			item = t[i]
			if item[k] == v then  return item, i  end
		end
		return nil, nil
	end
	local function _itemWith2(t, i1,i2,iDir, k1,v1, k2,v2)
		local item
		for i = i1, i2, iDir do
			item = t[i]
			if item[k1] == v1 and item[k2] == v2 then  return item, i  end
		end
		return nil, nil
	end
	local function _itemWith3(t, i1,i2,iDir, k1,v1, k2,v2, k3,v3)
		local item
		for i = i1, i2, iDir do
			item = t[i]
			if item[k1] == v1 and item[k2] == v2 and item[k3] == v3 then  return item, i  end
		end
		return nil, nil
	end

	-- index = indexWith ( array, key1, value1, ... )
	-- index = indexWith1( array, key,  value )
	-- index = indexWith2( array, key1, value1, key2, value2 )
	-- index = indexWith3( array, key1, value1, key2, value2, key3, value3 )
	-- index = lastIndexWith ( array, key1, value1, ... )
	-- index = lastIndexWith1( array, key,  value )
	-- index = lastIndexWith2( array, key1, value1, key2, value2 )
	-- index = lastIndexWith3( array, key1, value1, key2, value2, key3, value3 )
	-- item, index = itemWith ( array, key1, value1, ... )
	-- item, index = itemWith1( array, key,  value )
	-- item, index = itemWith2( array, key1, value1, key2, value2 )
	-- item, index = itemWith3( array, key1, value1, key2, value2, key3, value3 )
	-- item, index = lastItemWith ( array, key1, value1, ... )
	-- item, index = lastItemWith1( array, key,  value )
	-- item, index = lastItemWith2( array, key1, value1, key2, value2 )
	-- item, index = lastItemWith3( array, key1, value1, key2, value2, key3, value3 )
	-- item, index = nextItemWith ( array, startIndex, key1, value1, ... )
	-- item, index = nextItemWith1( array, startIndex, key,  value )
	-- item, index = nextItemWith2( array, startIndex, key1, value1, key2, value2 )
	-- item, index = nextItemWith3( array, startIndex, key1, value1, key2, value2, key3, value3 )
	-- item, index = previousItemWith ( array, startIndex, key1, value1, ... )
	-- item, index = previousItemWith1( array, startIndex, key,  value )
	-- item, index = previousItemWith2( array, startIndex, key1, value1, key2, value2 )
	-- item, index = previousItemWith3( array, startIndex, key1, value1, key2, value2, key3, value3 )
	function _G.indexWith     (t, ...)  return select(2, _itemWith (t, 1, #t,  1, ...))  end
	function _G.indexWith1    (t, ...)  return select(2, _itemWith1(t, 1, #t,  1, ...))  end
	function _G.indexWith2    (t, ...)  return select(2, _itemWith2(t, 1, #t,  1, ...))  end
	function _G.indexWith3    (t, ...)  return select(2, _itemWith3(t, 1, #t,  1, ...))  end
	function _G.lastIndexWith (t, ...)  return select(2, _itemWith (t, #t, 1, -1, ...))  end
	function _G.lastIndexWith1(t, ...)  return select(2, _itemWith1(t, #t, 1, -1, ...))  end
	function _G.lastIndexWith2(t, ...)  return select(2, _itemWith2(t, #t, 1, -1, ...))  end
	function _G.lastIndexWith3(t, ...)  return select(2, _itemWith3(t, #t, 1, -1, ...))  end
	function _G.itemWith         (t, ...)     return _itemWith (t, 1, #t,  1, ...)  end
	function _G.itemWith1        (t, ...)     return _itemWith1(t, 1, #t,  1, ...)  end
	function _G.itemWith2        (t, ...)     return _itemWith2(t, 1, #t,  1, ...)  end
	function _G.itemWith3        (t, ...)     return _itemWith3(t, 1, #t,  1, ...)  end
	function _G.lastItemWith     (t, ...)     return _itemWith (t, #t, 1, -1, ...)  end
	function _G.lastItemWith1    (t, ...)     return _itemWith1(t, #t, 1, -1, ...)  end
	function _G.lastItemWith2    (t, ...)     return _itemWith2(t, #t, 1, -1, ...)  end
	function _G.lastItemWith3    (t, ...)     return _itemWith3(t, #t, 1, -1, ...)  end
	function _G.nextItemWith     (t, i, ...)  return _itemWith (t, i, #t,  1, ...)  end
	function _G.nextItemWith1    (t, i, ...)  return _itemWith1(t, i, #t,  1, ...)  end
	function _G.nextItemWith2    (t, i, ...)  return _itemWith2(t, i, #t,  1, ...)  end
	function _G.nextItemWith3    (t, i, ...)  return _itemWith3(t, i, #t,  1, ...)  end
	function _G.previousItemWith (t, i, ...)  return _itemWith (t, i,  1, -1, ...)  end
	function _G.previousItemWith1(t, i, ...)  return _itemWith1(t, i,  1, -1, ...)  end
	function _G.previousItemWith2(t, i, ...)  return _itemWith2(t, i,  1, -1, ...)  end
	function _G.previousItemWith3(t, i, ...)  return _itemWith3(t, i,  1, -1, ...)  end
end



-- copy = copyTable( table [, deep=false ] )
do
	local function deepCopy(t, copy, tableCopies)
		for k, v in pairs(t) do
			if type(v) == "table" then
				local vCopy = tableCopies[v]

				if vCopy then
					copy[k] = vCopy
				else
					vCopy          = {}
					tableCopies[v] = vCopy
					copy[k]        = deepCopy(v, vCopy, tableCopies)
				end

			else
				copy[k] = v
			end
		end
		return copy
	end

	function _G.copyTable(t, deep)
		if deep then
			return deepCopy(t, {}, {})
		end

		local copy = {}
		for k, v in pairs(t) do  copy[k] = v  end

		return copy
	end
end

function _G.copyArray(t)
	local copy = {}
	for i = 1, #t, 2 do
		-- Copying 2 elements on 2 rows at a time seems to be the fastest in LuaJIT.
		copy[i  ] = t[i  ]
		copy[i+1] = t[i+1]
	end
	return copy
end

-- copyToArray( fromArray, toArray [, fromIndex=1, toIndex=#from ] )
function _G.copyToArray(from, to, i1, i2)
	for i = (i1 or 1), (i2 or #from) do
		to[i] = from[i]
	end
end

-- emptyArray( array [, fromIndex=1 ] )
function _G.emptyArray(t, i)
	for i = (i or 1), #t do
		t[i] = nil
	end
end

function _G.fillArray(t, i1, i2, v)
	for i = i1, i2 do  t[i] = v  end
	return t
end

-- Modifies the array!
function _G.reverseArray(t)
	local len = #t
	for i = 1, len/2 do
		local i2 = len-i+1
		t[i], t[i2] = t[i2], t[i]
	end
	return t
end

function _G.flipArray(t)
	local flipped = {}
	for i, v in ipairs(t) do
		flipped[v] = i
	end
	return flipped
end



-- number:string = formatNumber( number )
function _G.formatNumber(n)
	return (F"%d"(n):reverse():gsub("%d%d%d", "%0,"):reverse():gsub("^,", ""))
end

-- hex:string, bits:string = formatBinary( data:string )
do
	local HEX_TO_BITS = {
		["0"]="0000",["1"]="0001",["2"]="0010",["3"]="0011",
		["4"]="0100",["5"]="0101",["6"]="0110",["7"]="0111",
		["8"]="1000",["9"]="1001",["a"]="1010",["b"]="1011",
		["c"]="1100",["d"]="1101",["e"]="1110",["f"]="1111",
	}
	function _G.formatBinary(s)
		local hex = s:gsub(".", function(c)  return F("%02x", c:byte())  end)
		local bitsStr = hex:gsub(".", HEX_TO_BITS)
		return hex, bitsStr
	end
end



function _G.generateRandomString(len)
	local random = math.random
	local buffer = {}

	for i = 1, len do
		buffer[i] = random(0, 255)
	end

	return string.char(unpack(buffer))
end



function _G.getLast(arr)
	return arr[#arr]
end

-- nextValue = nextItem( array, currentValue [, steps=1 ] )
-- Note: The values wrap.
function _G.nextItem(t, v, steps)
	local i = indexOf(t, v)
	return i and t[(i-1+(steps or 1)) % #t + 1]
end



-- for index, item in ipairsr( array ) do
do
	local function iprev(t, i)
		i = i-1
		local v = t[i]
		if v ~= nil then  return i, v  end
	end
	function _G.ipairsr(t)
		return iprev, t, #t+1
	end
end



-- for value1, ... in iterate( callback, argument1, ... ) do
-- 'value1, ...' is whatever the callback yields.
do
	local coroutine_create = coroutine.create
	local coroutine_resume = coroutine.resume
	local coroutine_wrap   = coroutine.wrap
	local coroutine_yield  = coroutine.yield

	local function initiator(cb, ...)
		coroutine_yield()
		return cb(...)
	end

	local function iterator(co)
		return select(2, assert(coroutine_resume(co)))
	end

	function _G.iterate(cb, ...)
		if select("#", ...) <= 2 then
			return coroutine_wrap(cb), ...
		end

		local co = coroutine_create(initiator)
		assert(coroutine_resume(co, cb, ...))

		return iterator, co
	end
end



-- array = pack( ... )
function _G.pack(...)
	return {n=select("#", ...), ...}
end



-- for key, value, count in pairsSorted( table ) do
do
	local function yieldPairs(t)
		for i, k in ipairs(sort(getKeys(t))) do
			coroutine.yield(k, t[k], i)
		end
	end
	function _G.pairsSorted(t)
		return iterate(yieldPairs, t)
	end
end



-- array = sort( array [, compareFunction ] )
function _G.sort(t, comp)
	table.sort(t, comp)
	return t
end

-- sortByColumn( array, key [, compareFunction ] )
function _G.sortByColumn(t, k, comp)
	if comp then
		table.sort(t, function(a, b)
			return comp(a[k], b[k])
		end)
	else
		table.sort(t, function(a, b)
			return a[k] < b[k]
		end)
	end
	return t
end

-- array = sortNatural( array [, attribute ] )
function _G.sortNatural(t, k)
	if k then
		table.sort(t, function(a, b)
			return naturalCompare(a[k], b[k])
		end)
	else
		table.sort(t, naturalCompare)
	end
	return t
end

-- Sorts a string array containing numbers using a natural algorithm
-- table.sort( array, naturalCompare )
do
	local function pad(numStr)
		return F("%03d%s", #numStr, numStr)
	end
	function _G.naturalCompare(a, b)
		return tostring(a):gsub("%d+", pad) < tostring(b):gsub("%d+", pad)
	end
end



do
	!local EXTRA_ERROR_CHECKING = false

	local tables    = {}
	local freeIndex = 1

	!if EXTRA_ERROR_CHECKING then
	local recycled  = {}
	!end

	function _G.recycleTable(t)
		!if EXTRA_ERROR_CHECKING then
			if recycled[t] then  error("Table is already recycled.", 2)  end
			recycled[t] = true
		!end

		tables[freeIndex] = t
		freeIndex         = freeIndex+1
	end

	function _G.recycleTablesInArray(ts)
		for i = 1, #ts do
			!if EXTRA_ERROR_CHECKING then
				if recycled[ts[i]] then  error("At least one table is already recycled.", 2)  end
				recycled[ts[i]] = true
			!end

			tables[freeIndex] = ts[i]
			freeIndex         = freeIndex+1
		end
	end

	function _G.getRecycledTable()
		if freeIndex == 1 then  return nil  end

		freeIndex = freeIndex-1
		!if EXTRA_ERROR_CHECKING then
			recycled[tables[freeIndex]] = nil
		!end
		return tables[freeIndex]
	end

	function _G.getRecycledTableCount()
		return freeIndex-1
	end
end



-- target = setFields( target, source )
function _G.setFields(target, source)
	for k, v in pairs(source) do
		target[k] = v
	end
	return target
end



function _G.timeIt(f, count, ...)
	collectgarbage()
	local time = LT.getTime()
	for i = 1, count do
		f(...)
	end
	print(LT.getTime()-time)
end



function _G.trim(s)
	return (s:gsub("^%s+", ""):gsub("%s+$", ""))
end

function _G.triml(s)
	return (s:gsub("^%s+", ""))
end

function _G.trimr(s)
	return (s:gsub("%s+$", ""))
end



function _G.getKeys(t)
	local keys = {}
	for k in pairs(t) do  table.insert(keys, k)  end
	return keys
end


