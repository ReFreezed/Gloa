--[[============================================================
--=
--=  General functions
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	areArraysEqual
	copyTable, copyArray, copyToArray, emptyArray, fillArray, reverseArray, flipArray, removeItem, removeUnordered, insertArrayItems
	profiler*
	errorInternal, errorLine, errorOnLine, errorInFile, assert
	exit, exitFailure
	F
	formatNumber, formatBinary
	generateRandomString
	getKeys
	getLast, nextItem
	getUpvalues, getLocals, getStack
	indexOf, lastIndexOf
	indexWith*, lastIndexWith*, itemWith*, lastItemWith*, nextItemWith*, previousItemWith*
	isAny
	isPathAbsolute
	isReadableFile, getFileContents
	iterate
	newVirtualFile
	pack
	pairsSorted
	printf, printTraceback, printobj, printerr, printerrf
	recycleTable, recycleTablesInArray, getRecycledTable, getRecycledTableCount
	reportMessageOnLine, reportMessageInFile
	setFields
	sort, sortByColumn, sortNatural, naturalCompare
	timeIt
	trim, triml, trimr
	utf8Char, utf8Codepoint

--============================================================]]



_G.F = string.format



function math.clamp(n, nMin, nMax)
	return math.min(math.max(n, nMin), nMax)
end



function _G.printf(s, ...)
	print(s:format(...))
end

-- printTraceback( [ outputFile=io.stdout, ] [ level=1 ] )
function _G.printTraceback(file, level)
	if type(file) ~= "userdata" then  return printTraceback(io.stdout, file)  end

	file:write("stack traceback:\n")

	for level = 1+(level or 1), math.huge do
		local info = debug.getinfo(level, "nSl")
		if not info then  break  end

		-- file:write(level, " source    ", tostring(info.source),    "\n")
		-- file:write(level, " short_src ", tostring(info.short_src), "\n")
		-- file:write(level, " name      ", tostring(info.name),      "\n")
		-- file:write(level, " what      ", tostring(info.what),      "\n")

		local where = info.source:match"^@(.+)"
		where       = where and where:gsub("\\", "/") or info.short_src

		local lnStr = info.currentline > 0 and ":"..info.currentline or ""

		local name
			=  info.name -- May be "".
			or info.linedefined > 0 and where..":"..info.linedefined
			or info.what == "main" and "main chunk"
			or info.what == "tail" and "tail call"
			or ""

		file:write("\t",where,lnStr)
		if name ~= "" then  file:write("  (",name,")")  end
		file:write("\n")
	end
end

-- printobj( ... )
do
	local out    = io.stdout
	local _write = out.write
	local function write(...)
		_write(out, ...)
	end

	local _tostring = tostring
	local function tostring(v)
		return (_tostring(v):gsub("^table: ", ""))
	end

	local function compareKeys(a, b)
		return naturalCompare(tostring(a), tostring(b))
	end

	local function _printobj(v, tables, isDepth1, depth)
		local vType = type(v)

		if vType == "table" then
			if tables[v] then
				write("0x", tostring(v))

			else
				write(tostring(v), (isDepth1 and "{" or "{ "))
				tables[v] = true

				local indices = {}
				for i = 1, #v do  indices[i] = true  end

				for _, k in ipairs(sort(getKeys(v), compareKeys)) do
					if not indices[k] then
						if isDepth1 then  write("\n    ")  end
						write(tostring(k), (isDepth1 and " = " or "="))
						_printobj(v[k], tables, false, depth+1)
					end
				end

				for i = 1, #v do
					if isDepth1 then  write("\n    ")  end
					write(i, (isDepth1 and " = " or "="))
					_printobj(v[i], tables, false, depth+1)
				end

				write(isDepth1 and "\n}" or "}")
			end

		elseif vType == "number" then
			write(F("%g", v))

		elseif vType == "string" then
			if #v > 1000 then
				write('"', v:sub(1, 1000):gsub("%z", "\\0"):gsub("\n", "\\n"), '..."')
			else
				write('"', v:gsub("%z", "\\0"):gsub("\n", "\\n"), '"')
			end

		else
			write(tostring(v))
		end

		write(depth>2 and " " or "")
	end

	function _G.printobj(...)
		for i = 1, select("#", ...) do
			if i > 1 then  write("    ")  end

			_printobj(select(i, ...), {}, true, 1)
		end
		write("\n")
	end
end

function _G.printerr(...)
	local file = io.stderr
	for i = 1, select("#", ...) do
		if i > 1 then  file:write("\t")  end
		file:write(tostring((select(i, ...))))
	end
	file:write("\n")
end

function _G.printerrf(s, ...)
	io.stderr:write(s:format(...), "\n")
end



-- errorInternal( [ level=1, ] [[ state, node, ] formatString, ... ] )
local function _errorInternal(level, state, node, s, ...)
	if type(state) == "string" then  _errorInternal(1+level, nil, nil, state, node, s, ...)  end

	s = s and F("Internal compiler error: "..s, ...) or "Internal compiler error."
	if node then
		printTraceback(io.stderr, 1+level)
		printerr()
		!ifDEBUG `astPrint(io.stderr, node)`
		printerr()
		nodeMessage(io.stderr, state, node, "Error", nil, "%s", s)
	else
		printerr("\nError: "..s)
		printTraceback(io.stderr, 1+level)
	end

	exitFailure()
end
function _G.errorInternal(level, state, node, ...)
	if type(level) == "number" then
		_errorInternal(1+level, state, node, ...)
	else
		_errorInternal(2, level, state, node, ...)
	end
end

function _G.errorLine(agent, s, ...)
	if agent then
		printerrf("\n[%s] Error: "..s, agent, ...)
	else
		printerrf("\nError: "..s, ...)
	end
	exitFailure()
end

function _G.errorOnLine(path, ln, agent, s, ...)
	printerr()
	reportMessageOnLine(io.stderr, path, ln, "Error", agent, s, ...)
	printerr()
	exitFailure()
end

function _G.errorInFile(buffer, path, ptr, agent, s, ...)
	printerr()
	reportMessageInFile(io.stderr, buffer, path, ptr, "Error", agent, s, ...)
	exitFailure()
end

function _G.assert(...)
	if ... then  return ...  end

	local _, err = ...
	err          = tostring(err or "Assertion failed!")
	errorInternal(2, "%s", err)
end



-- reportMessageOnLine( [ outputFile=io.stdout, ] path, ln, label, agent, s, ...)
function _G.reportMessageOnLine(file, path, ln, label, agent, s, ...)
	if type(file) ~= "userdata" then  return reportMessageOnLine(io.stdout, file, path, ln, label, agent, s, ...)  end

	s = F(s, ...)

	if agent then
		file:write(F("%s @ %s:%d: [%s] %s\n", label, path, ln, agent, s))
	else
		file:write(F("%s @ %s:%d: %s\n",      label, path, ln,        s))
	end
end

-- reportMessageInFile( [ outputFile=io.stdout, ] buffer, path, ptr, label, agent, s, ...)
function _G.reportMessageInFile(file, buffer, path, ptr, label, agent, s, ...)
	if type(file) ~= "userdata" then  return reportMessageInFile(io.stdout, file, buffer, path, ptr, label, agent, s, ...)  end

	!local BUFFER_LINES_TO_PRINT = 3

	s   = F(s, ...)
	ptr = math.clamp(ptr, 1, #buffer+1)

	!for i = 1, BUFFER_LINES_TO_PRINT do
		!local varThisPtr = "lineStart"..i
		!local varPrevPtr = "lineStart"..i-1

		!if i == 1 then
			local !!(varThisPtr) = ptr
		!else
			local !!(varThisPtr) = !!(varPrevPtr)-1
		!end

		while !!(varThisPtr) > 1 and buffer:byte(!!(varThisPtr)-1) ~= !(getByte"\n") do
			!!(varThisPtr) = !!(varThisPtr)-1
		end
	!end

	local lineEnd = ptr-1 -- We start at ptr-1 so that we may get lineEnd==lineStart1-1 in the end.
	while lineEnd < #buffer and buffer:byte(lineEnd+1) ~= !(getByte"\n") do
		lineEnd = lineEnd+1
	end

	local lastLinePre = buffer:sub(lineStart1, ptr-1):gsub("\t", "    ")

	!for i = 1, BUFFER_LINES_TO_PRINT do
		!local varThis    = "lastLine" ..i
		!local varThisPtr = "lineStart"..i
		!local varPrevPtr = "lineStart"..i-1

		local !!(varThis) = ""

		!if i == 1 then
			!!(varThis) = buffer:sub(!!(varThisPtr), lineEnd         ):gsub("\t", "    ")
		!else
			if !!(varPrevPtr)-2 >= 1 then
				!!(varThis) = buffer:sub(!!(varThisPtr), !!(varPrevPtr)-2):gsub("\t", "    ")
			end
		!end
	!end

	local _, nlCount  = buffer:sub(1, ptr-1):gsub("\n", "%0")
	local ln          = nlCount+1

	local len         = 0
	local lenPtr      = 1

	while true do
		if lenPtr > #lastLinePre then  break  end

		local _, i2 = lastLinePre:find(!("^"..UTF8_CHARACTER_PATTERN), lenPtr)

		len    = len+1 -- The length isn't going to be perfect, depending on what Unicode characters are encountered.
		lenPtr = i2+1
	end

	local col = 1+len

	if agent then
		file:write(F("%s @ %s:%d: [%s] %s\n", label, path, ln, agent, s))
	else
		file:write(F("%s @ %s:%d: %s\n",      label, path, ln,        s))
	end

	file:write("\n")

	!for i = BUFFER_LINES_TO_PRINT, 1, -1 do
		!local varThis = "lastLine"..i

		!if i == 1 then
			file:write("> ", !!(varThis), "\n")
		!else
			if !!(varThis) ~= "" then
				file:write("> ", !!(varThis), "\n")
			end
		!end
	!end

	file:write(F("> %s^\n\n", ("-"):rep(col-1)))
end



function _G.exit(code)
	-- @Incomplete: Close log file and whatnot.
	os.exit(code or 0)
end

function _G.exitFailure()
	exit(1)
end



function _G.isReadableFile(path)
	local file = io.open(path, "rb")
	if not file then  return false  end

	file:close()
	return true
end

-- contents, error = getFileContents( path [, isText=false ] )
function _G.getFileContents(path, isText)
	local file, err = io.open(path, (isText and "r" or "rb"))
	if not file then  return nil, err  end

	local s = file:read"*a"
	file:close()
	return s
end



do
	local function _utf8Char(cp)
		if cp < 128 then  return string.char(cp)  end

		local suffix = cp%64
		local c4     = 128+suffix
		cp           = (cp-suffix)/64
		if cp < 32 then  return string.char(192+cp, c4)  end

		suffix   = cp%64
		local c3 = 128+suffix
		cp       = (cp-suffix)/64
		if cp < 16 then  return string.char(224+cp, c3, c4)  end

		suffix = cp%64
		cp     = (cp-suffix)/64
		return string.char(240+cp, 128+suffix, c3, c4)
	end

	local cache = {}

	function _G.utf8Char(cp)
		cache[cp] = cache[cp] or _utf8Char(cp)
		return cache[cp]
	end

	-- codepoint = utf8Codepoint( string [, startBytePosition=1 ] )
	-- It's assumed the string is valid UTF-8.
	function _G.utf8Codepoint(s, pos)
		pos = (pos or 1)
		--[[
			Bits  Last code point  Range for byte 1  Bytes
			7     U+007F           000-127           0xxxxxxx
			11    U+07FF           192-223           110xxxxx  10xxxxxx
			16    U+FFFF           224-239           1110xxxx  10xxxxxx  10xxxxxx
			21    U+1FFFFF         240-247           11110xxx  10xxxxxx  10xxxxxx  10xxxxxx
		]]
		local b1, b2, b3, b4 = s:byte(pos, pos+3)
		if     b1 < 128 then  return b1
		elseif b1 < 224 then  return (b1-192)*!(2^(1*6)) + (b2-128)
		elseif b1 < 240 then  return (b1-224)*!(2^(2*6)) + (b2-128)*!(2^(1*6)) + (b3-128)
		else                  return (b1-240)*!(2^(3*6)) + (b2-128)*!(2^(2*6)) + (b3-128)*!(2^(1*6)) + (b4-128)  end
	end

	--[[ UTF-8 tests:
	printf("%s $ %s",          utf8Char(0x0024), (utf8Char(0x0024)=="$" and "ok" or "FAIL"))
	printf("%s £ %s",          utf8Char(0x00A3), (utf8Char(0x00A3)=="£" and "ok" or "FAIL"))
	printf("%s β %s",          utf8Char(0x03B2), (utf8Char(0x03B2)=="β" and "ok" or "FAIL"))
	printf("%s Я %s",          utf8Char(0x042F), (utf8Char(0x042F)=="Я" and "ok" or "FAIL"))
	printf("U+%04X U+0024 %s", utf8Codepoint"$", (utf8Codepoint"$"==0x0024 and "ok" or "FAIL"))
	printf("U+%04X U+00A3 %s", utf8Codepoint"£", (utf8Codepoint"£"==0x00A3 and "ok" or "FAIL"))
	printf("U+%04X U+03B2 %s", utf8Codepoint"β", (utf8Codepoint"β"==0x03B2 and "ok" or "FAIL"))
	printf("U+%04X U+042F %s", utf8Codepoint"Я", (utf8Codepoint"Я"==0x042F and "ok" or "FAIL"))
	os.exit(2)
	--]]
end



function _G.isAny(v, ...)
	for i = 1, select("#", ...) do
		if v == select(i, ...) then  return true  end
	end
	return false
end



function _G.indexOf(t, v)
	for i = 1, #t do
		if t[i] == v then  return i  end
	end
	return nil
end

function _G.lastIndexOf(t, v)
	for i = #t, 1, -1 do
		if t[i] == v then  return i  end
	end
	return nil
end




do
	local select = select

	local function _itemWith(t, i1, i2, iDir, ...)
		local argCount = select("#", ...)
		local item, isMatch, k, v

		for i = i1, i2, iDir do
			item    = t[i]
			isMatch = true

			for argIndex = 1, argCount, 2 do
				k, v = select(argIndex, ...)

				if item[k] ~= v then
					isMatch = false
					break
				end
			end

			if isMatch then  return item, i  end
		end

		return nil, nil
	end
	local function _itemWith1(t, i1,i2,iDir, k,v)
		local item
		for i = i1, i2, iDir do
			item = t[i]
			if item[k] == v then  return item, i  end
		end
		return nil, nil
	end
	local function _itemWith2(t, i1,i2,iDir, k1,v1, k2,v2)
		local item
		for i = i1, i2, iDir do
			item = t[i]
			if item[k1] == v1 and item[k2] == v2 then  return item, i  end
		end
		return nil, nil
	end
	local function _itemWith3(t, i1,i2,iDir, k1,v1, k2,v2, k3,v3)
		local item
		for i = i1, i2, iDir do
			item = t[i]
			if item[k1] == v1 and item[k2] == v2 and item[k3] == v3 then  return item, i  end
		end
		return nil, nil
	end

	-- index = indexWith ( array, key1, value1, ... )
	-- index = indexWith1( array, key,  value )
	-- index = indexWith2( array, key1, value1, key2, value2 )
	-- index = indexWith3( array, key1, value1, key2, value2, key3, value3 )
	-- index = lastIndexWith ( array, key1, value1, ... )
	-- index = lastIndexWith1( array, key,  value )
	-- index = lastIndexWith2( array, key1, value1, key2, value2 )
	-- index = lastIndexWith3( array, key1, value1, key2, value2, key3, value3 )
	-- item, index = itemWith ( array, key1, value1, ... )
	-- item, index = itemWith1( array, key,  value )
	-- item, index = itemWith2( array, key1, value1, key2, value2 )
	-- item, index = itemWith3( array, key1, value1, key2, value2, key3, value3 )
	-- item, index = lastItemWith ( array, key1, value1, ... )
	-- item, index = lastItemWith1( array, key,  value )
	-- item, index = lastItemWith2( array, key1, value1, key2, value2 )
	-- item, index = lastItemWith3( array, key1, value1, key2, value2, key3, value3 )
	-- item, index = nextItemWith ( array, startIndex, key1, value1, ... )
	-- item, index = nextItemWith1( array, startIndex, key,  value )
	-- item, index = nextItemWith2( array, startIndex, key1, value1, key2, value2 )
	-- item, index = nextItemWith3( array, startIndex, key1, value1, key2, value2, key3, value3 )
	-- item, index = previousItemWith ( array, startIndex, key1, value1, ... )
	-- item, index = previousItemWith1( array, startIndex, key,  value )
	-- item, index = previousItemWith2( array, startIndex, key1, value1, key2, value2 )
	-- item, index = previousItemWith3( array, startIndex, key1, value1, key2, value2, key3, value3 )
	function _G.indexWith     (t, ...)  return select(2, _itemWith (t, 1, #t,  1, ...))  end
	function _G.indexWith1    (t, ...)  return select(2, _itemWith1(t, 1, #t,  1, ...))  end
	function _G.indexWith2    (t, ...)  return select(2, _itemWith2(t, 1, #t,  1, ...))  end
	function _G.indexWith3    (t, ...)  return select(2, _itemWith3(t, 1, #t,  1, ...))  end
	function _G.lastIndexWith (t, ...)  return select(2, _itemWith (t, #t, 1, -1, ...))  end
	function _G.lastIndexWith1(t, ...)  return select(2, _itemWith1(t, #t, 1, -1, ...))  end
	function _G.lastIndexWith2(t, ...)  return select(2, _itemWith2(t, #t, 1, -1, ...))  end
	function _G.lastIndexWith3(t, ...)  return select(2, _itemWith3(t, #t, 1, -1, ...))  end
	function _G.itemWith         (t, ...)     return _itemWith (t, 1, #t,  1, ...)  end
	function _G.itemWith1        (t, ...)     return _itemWith1(t, 1, #t,  1, ...)  end
	function _G.itemWith2        (t, ...)     return _itemWith2(t, 1, #t,  1, ...)  end
	function _G.itemWith3        (t, ...)     return _itemWith3(t, 1, #t,  1, ...)  end
	function _G.lastItemWith     (t, ...)     return _itemWith (t, #t, 1, -1, ...)  end
	function _G.lastItemWith1    (t, ...)     return _itemWith1(t, #t, 1, -1, ...)  end
	function _G.lastItemWith2    (t, ...)     return _itemWith2(t, #t, 1, -1, ...)  end
	function _G.lastItemWith3    (t, ...)     return _itemWith3(t, #t, 1, -1, ...)  end
	function _G.nextItemWith     (t, i, ...)  return _itemWith (t, i, #t,  1, ...)  end
	function _G.nextItemWith1    (t, i, ...)  return _itemWith1(t, i, #t,  1, ...)  end
	function _G.nextItemWith2    (t, i, ...)  return _itemWith2(t, i, #t,  1, ...)  end
	function _G.nextItemWith3    (t, i, ...)  return _itemWith3(t, i, #t,  1, ...)  end
	function _G.previousItemWith (t, i, ...)  return _itemWith (t, i,  1, -1, ...)  end
	function _G.previousItemWith1(t, i, ...)  return _itemWith1(t, i,  1, -1, ...)  end
	function _G.previousItemWith2(t, i, ...)  return _itemWith2(t, i,  1, -1, ...)  end
	function _G.previousItemWith3(t, i, ...)  return _itemWith3(t, i,  1, -1, ...)  end
end



-- copy = copyTable( table [, deep=false ] )
do
	local function deepCopy(t, copy, tableCopies)
		for k, v in pairs(t) do
			if type(v) == "table" then
				local vCopy = tableCopies[v]

				if vCopy then
					copy[k] = vCopy
				else
					vCopy          = {}
					tableCopies[v] = vCopy
					copy[k]        = deepCopy(v, vCopy, tableCopies)
				end

			else
				copy[k] = v
			end
		end
		return copy
	end

	function _G.copyTable(t, deep)
		if deep then
			return deepCopy(t, {}, {})
		end

		local copy = {}
		for k, v in pairs(t) do  copy[k] = v  end

		return copy
	end
end

function _G.copyArray(t)
	local copy = {}
	for i = 1, #t, 2 do
		-- Copying 2 elements on 2 rows at a time seems to be the fastest in LuaJIT.
		copy[i  ] = t[i  ]
		copy[i+1] = t[i+1]
	end
	return copy
end

-- copyToArray( fromArray, toArray [, fromIndex=1, toIndex=#from ] )
function _G.copyToArray(from, to, i1, i2)
	for i = (i1 or 1), (i2 or #from) do
		to[i] = from[i]
	end
end

-- emptyArray( array [, fromIndex=1 ] )
function _G.emptyArray(t, i)
	for i = (i or 1), #t do
		t[i] = nil
	end
end

function _G.fillArray(t, i1, i2, v)
	for i = i1, i2 do  t[i] = v  end
	return t
end

-- Modifies the array!
function _G.reverseArray(t)
	local len = #t
	for i = 1, len/2 do
		local i2 = len-i+1
		t[i], t[i2] = t[i2], t[i]
	end
	return t
end

function _G.flipArray(t)
	local flipped = {}
	for i, v in ipairs(t) do
		flipped[v] = i
	end
	return flipped
end

-- index = removeItem( array, item )
function _G.removeItem(t, v)
	local i = indexOf(t, v)
	if i then  table.remove(t, i)  end
	return i
end

-- removedValue = removeUnordered( array, index )
function _G.removeUnordered(t, i)
	if i < 1 then  return nil  end

	local len = #t
	if i > len then  return nil  end

	local v = t[i]
	t[i]    = t[len]
	t[len]  = nil

	return v
end

function _G.insertArrayItems(t, toInsert)
	local insert = table.insert
	for _, v in ipairs(toInsert) do
		insert(t, v)
	end
end



function _G.areArraysEqual(t1, t2)
	if #t1 ~= #t2 then  return false  end

	for i = 1, #t1 do
		if t1[i] ~= t2[i] then  return false  end
	end

	return true
end



-- number:string = formatNumber( number )
function _G.formatNumber(n)
	local s = F("%.0f", n)
	if #s <= 4 then  return s  end
	return (s:reverse():gsub("%d%d%d", "%0 "):reverse():gsub("^ ", ""))
end

-- hex:string, bits:string = formatBinary( data:string )
do
	local HEX_TO_BITS = {
		["0"]="0000",["1"]="0001",["2"]="0010",["3"]="0011",
		["4"]="0100",["5"]="0101",["6"]="0110",["7"]="0111",
		["8"]="1000",["9"]="1001",["a"]="1010",["b"]="1011",
		["c"]="1100",["d"]="1101",["e"]="1110",["f"]="1111",
	}
	function _G.formatBinary(s)
		local hex = s:gsub(".", function(c)  return F("%02x", c:byte())  end)
		local bitsStr = hex:gsub(".", HEX_TO_BITS)
		return hex, bitsStr
	end
end



function _G.generateRandomString(len)
	local random = math.random
	local buffer = {}

	for i = 1, len do
		buffer[i] = random(0, 255)
	end

	return string.char(unpack(buffer))
end



-- item = getLast( array [, indexFromEnd=1 ] )
function _G.getLast(arr, i)
	return arr[#arr+1-(i or 1)]
end

-- nextValue = nextItem( array, currentValue [, steps=1 ] )
-- Note: The values wrap.
function _G.nextItem(t, v, steps)
	local i = indexOf(t, v)
	return i and t[(i-1+(steps or 1)) % #t + 1]
end



-- for index, item in ipairsr( array ) do
do
	local function iprev(t, i)
		i = i-1
		local v = t[i]
		if v ~= nil then  return i, v  end
	end
	function _G.ipairsr(t)
		return iprev, t, #t+1
	end
end



-- for value1, ... in iterate( callback, argument1, ... ) do
-- 'value1, ...' is whatever the callback yields.
do
	local coroutine_create = coroutine.create
	local coroutine_resume = coroutine.resume
	local coroutine_wrap   = coroutine.wrap
	local coroutine_yield  = coroutine.yield

	local function initiator(cb, ...)
		coroutine_yield()
		return cb(...)
	end

	local function iterator(co)
		return select(2, assert(coroutine_resume(co)))
	end

	function _G.iterate(cb, ...)
		if select("#", ...) <= 2 then
			return coroutine_wrap(cb), ...
		end

		local co = coroutine_create(initiator)
		assert(coroutine_resume(co, cb, ...))

		return iterator, co
	end
end



-- array = pack( ... )
function _G.pack(...)
	return {n=select("#", ...), ...}
end



-- for key, value, count in pairsSorted( table [, compareFunction ] ) do
do
	local function yieldPairs(t, comp)
		for i, k in ipairs(sort(getKeys(t), comp)) do
			coroutine.yield(k, t[k], i)
		end
	end
	function _G.pairsSorted(t, comp)
		return iterate(yieldPairs, t, comp)
	end
end



-- array = sort( array [, compareFunction ] )
function _G.sort(t, comp)
	table.sort(t, comp)
	return t
end

-- sortByColumn( array, key [, compareFunction ] )
function _G.sortByColumn(t, k, comp)
	if comp then
		table.sort(t, function(a, b)
			return comp(a[k], b[k])
		end)
	else
		table.sort(t, function(a, b)
			return a[k] < b[k]
		end)
	end
	return t
end

-- array = sortNatural( array [, attribute ] )
function _G.sortNatural(t, k)
	if k then
		table.sort(t, function(a, b)
			return naturalCompare(a[k], b[k])
		end)
	else
		table.sort(t, naturalCompare)
	end
	return t
end

-- Sorts a string array containing numbers using a natural algorithm
-- table.sort( array, naturalCompare )
do
	local function pad(numStr)
		return F("%03d%s", #numStr, numStr)
	end
	function _G.naturalCompare(a, b)
		return tostring(a):gsub("%d+", pad) < tostring(b):gsub("%d+", pad)
	end
end



do
	!local EXTRA_ERROR_CHECKING = false

	local tables    = {}
	local freeIndex = 1

	!if EXTRA_ERROR_CHECKING then
	local recycled  = {}
	!end

	function _G.recycleTable(t)
		!if EXTRA_ERROR_CHECKING then
			if recycled[t] then  errorInternal(2, "Table is already recycled.")  end
			recycled[t] = true
		!end

		tables[freeIndex] = t
		freeIndex         = freeIndex+1
	end

	function _G.recycleTablesInArray(ts)
		for i = 1, #ts do
			!if EXTRA_ERROR_CHECKING then
				if recycled[ts[i]] then  errorInternal(2, "At least one table is already recycled.")  end
				recycled[ts[i]] = true
			!end

			tables[freeIndex] = ts[i]
			freeIndex         = freeIndex+1
		end
	end

	function _G.getRecycledTable()
		if freeIndex == 1 then  return nil  end

		freeIndex = freeIndex-1
		!if EXTRA_ERROR_CHECKING then
			recycled[tables[freeIndex]] = nil
		!end
		return tables[freeIndex]
	end

	function _G.getRecycledTableCount()
		return freeIndex-1
	end
end



-- target = setFields( target, source )
function _G.setFields(target, source)
	for k, v in pairs(source) do
		target[k] = v
	end
	return target
end



function _G.timeIt(f, count, ...)
	collectgarbage()
	local time = LT.getTime()
	for i = 1, count do
		f(...)
	end
	print(LT.getTime()-time)
end



function _G.trim(s)
	return (s:gsub("^%s+", ""):gsub("%s+$", ""))
end

function _G.triml(s)
	return (s:gsub("^%s+", ""))
end

function _G.trimr(s)
	return (s:gsub("%s+$", ""))
end



function _G.getKeys(t)
	local keys = {}
	for k in pairs(t) do  table.insert(keys, k)  end
	return keys
end



-- names, values = getUpvalues( function )
function _G.getUpvalues(f)
	local names  = {}
	local values = {}

	for i = 1, math.huge do
		local name, v = debug.getupvalue(f, i)
		if not name then  break  end

		names[i]  = name
		values[i] = v
	end

	return names, values
end

-- names, values = getLocals( [ level=1 ] )
function _G.getLocals(level)
	level = (level or 1)+1

	local names  = {}
	local values = {}

	if not debug.getinfo(level, "") then
		return names, values
	end

	local localIndex = 0

	for i = 1, math.huge do
		local name, v = debug.getlocal(level, i)
		if not name then  break  end

		if not name:find"^%(%*" then -- Special names include "(for generator)" and "(*temporary)" etc.
			localIndex = localIndex+1
			names [localIndex] = name
			values[localIndex] = v
		end
	end

	return names, values
end

-- stack = getStack( [ level=1 ] )
-- stack = { entry1, ... }
-- entry = { where=where, names=names, values=values }
function _G.getStack(level)
	local stack = {}

	for level = 1+(level or 1), math.huge do
		local info = debug.getinfo(level, "nSl")
		if not info then  break  end

		local where
			=  info.source:match"^@(.+)"
			or info.short_src:match'^%[string "(.+%.lua)"%]$' -- Not great, but needed for e.g. boot.lua
			or info.short_src

		local lnStr = info.currentline > 0 and ":"..info.currentline or ""

		local name
			=  info.name
			or info.linedefined > 0 and where..":"..info.linedefined
			or info.what == "main" and "main chunk"
			or info.what == "tail" and "tail call"
			or "?"

		local names, values = getLocals(level)

		local entry = {
			where  = where..lnStr.."  ("..name..")",
			names  = names,
			values = values,
		}
		table.insert(stack, entry)
	end

	return stack
end



function _G.isPathAbsolute(path)
	return (path:find"^%a:" or path:find"^/") ~= nil
end



function _G.newVirtualFile()
	local file     = {}
	local buffer   = {}
	local select   = select
	local insert   = table.insert
	local tostring = tostring

	function file:write(...)
		for i = 1, select("#", ...) do
			local v = select(i, ...)
			!ASSERT `type(v) == "string" or type(v) == "number"`
			insert(buffer, tostring(v))
		end
	end

	function file:getBuffer()
		return table.concat(buffer)
	end
	function file:clearBuffer()
		buffer = {}
	end
	function file:isBufferEmpty()
		return buffer[1] == nil
	end

	return file
end



do
	local isRunning  = false
	local pauseDepth = 0

	local calls = {}
	local n     = 0
	local names = {}
	local times = {}
	local file  = nil

	-- !local PROF_CALLS = true
	-- !local PROF_CALLEES = true
	-- !local PROF_TIMES = true

	function _G.profilerStart()
		!if PROF_CALLS or PROF_CALLEES or PROF_TIMES then
			if isRunning then  return  end

			isRunning     = true
			pauseDepth    = 0

			local getinfo = debug.getinfo
			local clock   = os.clock

			!if PROF_CALLS then
				debug.sethook(function()
					local name = getinfo(2, "n").name or "?"
					calls[name] = (calls[name] or 0)+1
				end, "c")

			!elseif PROF_CALLEES then
				debug.sethook(function()
					local name = getinfo(2, "n").name
					if name ~= "assert" then  return  end
					name = getinfo(3, "n").name or "?"
					calls[name] = (calls[name] or 0)+1
				end, "c")

			!elseif PROF_TIMES then
				n        = n+1
				names[n] = "__PROFILER"
				times[n] = os.clock()

				collectgarbage()

				debug.sethook(function(event, ln)
					local info = getinfo(2, "nS")
					local name = info.name or info.linedefined or "?"
					if name == names[n] then  return  end

					n        = n+1
					names[n] = name
					times[n] = clock()
				end, "l")
			!end
		!end
	end
	function _G.profilerStop()
		debug.sethook(nil)
		!if PROF_TIMES then
			n        = n+1
			names[n] = "__PROFILER"
			times[n] = os.clock()
		!end
		pauseDepth = 0
		isRunning  = false
	end

	function _G.profilerPause()
		if isRunning then
			profilerStop()
			pauseDepth = 1
		elseif pauseDepth > 0 then
			pauseDepth = pauseDepth+1
		end
	end
	function _G.profilerUnpause()
		if pauseDepth == 0 then  return  end
		pauseDepth = pauseDepth-1
		if pauseDepth == 0 then  profilerStart()  end
	end

	function _G.profilerPrint()
		!if PROF_CALLS or PROF_CALLEES then
			local sources = {}

			for source in pairs(calls) do
				table.insert(sources, source)
			end

			table.sort(sources, function(a, b)
				if calls[a] ~= calls[b] then  return calls[a] > calls[b]  end
				return a < b
			end)

			print(os.date"calls %Y-%m-%d %H:%M:%S")
			for _, source in ipairs(sources) do
				printf("%d  %s", calls[source], source)
			end

		!elseif PROF_TIMES then
			local runTimes = {}

			for i = 2, n-1 do
				local name     = type(names[i]) == "number" and ":"..names[i] or tostring(names[i])
				runTimes[name] = (runTimes[name] or 0) + (times[i+1] - times[i])
			end

			local sources = {}

			for source in pairs(runTimes) do
				table.insert(sources, source)
			end

			table.sort(sources, function(a, b)
				if runTimes[a] ~= runTimes[b] then  return runTimes[a] > runTimes[b]  end
				return a < b
			end)

			print(os.date"times %Y-%m-%d %H:%M:%S")
			for _, source in ipairs(sources) do
				printf("%.3f  %s", runTimes[source], source)
			end
		!end
	end

	--[[ TEST
	local function deep()
		local x = 0
	end
	local function first()
		local x = 0
		deep()
		local y = 0
	end
	local function tail()
		local x = 0
		return first()
	end

	debug.sethook(function(event, ln)
		local name = debug.getinfo(2, "n").name or "?"
		_print(event, (ln or "    "), name)
	end, "crl")

	first()
	_print("--------")
	tail()

	debug.sethook(nil)
	os.exit(2)
	--]]
end


