--[[============================================================
--=
--=  General functions
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	areArraysEqual
	copyTable, copyArray, copyToArray, emptyArray, fillArray, reverseArray, flipArray, removeItem, removeUnordered, insertArrayItems
	errorInternal, errorLine, errorOnLine, errorInFile, assert
	exit, exitFailure
	F
	formatNumber, formatBinary
	generateRandomString
	getKeys
	getLast, nextItem
	getUpvalues, getLocals, getStack
	indexOf, lastIndexOf
	indexOfRemember, itemWith*Remember
	indexWith*, lastIndexWith*, itemWith*, lastItemWith*, nextItemWith*, previousItemWith*
	insertN, removeN, removeUnorderedN, ipairsN, ipairsrN
	isAny
	isPathAbsolute, normalizeDirectoryPath
	isReadableFile, getFileContents
	iterate
	newVirtualFile
	pack
	pairsSorted, ipairsFrom
	printf, printTraceback, printobj, printerr, printerrf
	profiler*
	recycleTable, recycleTablesInArray, getRecycledTable, getRecycledTableCount
	reportMessageOnLine, reportMessageInFile
	setFields
	sort, sortByColumn, sortNatural, naturalCompare
	storeInCache
	timeIt, stall
	trim, triml, trimr
	tryToFixLocationForCompilerError
	utf8Char, utf8Codepoint
	valueToStringForMessage

--============================================================]]
!recordLineNumber(@file, @line)

!(
local PROFILE_CALLS   = 1==0
local PROFILE_CALLEES = 1==0
local PROFILE_TIMES   = 1==0

local PROFILER_TARGET_NAME = "indexOf" -- Used for PROFILE_CALLEES.

local HIRES_TIMER = DEBUG and 1==1 -- Uses Alien FFI library and kernel32.dll in Windows.
)



!if HIRES_TIMER then
do
	local alien    = require"alien"
	local kernel32 = alien.load"kernel32.dll"

	local QueryPerformanceCounter = kernel32.QueryPerformanceCounter
	QueryPerformanceCounter:types{ ret="int", abi="stdcall", "pointer" }

	local QueryPerformanceFrequency = kernel32.QueryPerformanceFrequency
	QueryPerformanceFrequency:types{ ret="int", abi="stdcall", "pointer" }

	!(
	local _LONG_SIGNED_TO_UNSIGNED = `($var < 0 and 0x100000000+$var or $var)`
	local function LONG_SIGNED_TO_UNSIGNED(var)
		return templateToLua(_LONG_SIGNED_TO_UNSIGNED, {var=var})
	end
	)

	local twoLongs       = alien.array("long", 2)
	local twoLongsBuffer = twoLongs.buffer

	local function timerQueryPerformanceFrequency()
		QueryPerformanceFrequency(twoLongsBuffer)
		local lo = twoLongs[1] ; local hi = twoLongs[2]
		return !!(LONG_SIGNED_TO_UNSIGNED`lo`) + !!(LONG_SIGNED_TO_UNSIGNED`hi`) * !(2^32)
	end

	local function timerQueryPerformanceCounter()
		QueryPerformanceCounter(twoLongsBuffer)
		local lo = twoLongs[1] ; local hi = twoLongs[2]
		return !!(LONG_SIGNED_TO_UNSIGNED`lo`) + !!(LONG_SIGNED_TO_UNSIGNED`hi`) * !(2^32)
	end

	local freq   = timerQueryPerformanceFrequency() -- This shouldn't change while the program is running according to the documentation.
	local count0 = timerQueryPerformanceCounter()   -- Is this needed?

	_G.timerGetCurrent = timerQueryPerformanceCounter
	function _G.timerGetCurrentInSeconds()
		return (timerQueryPerformanceCounter() - count0) / freq
	end

	function _G.timerAbsoluteToSeconds(count)
		return (count - count0) / freq
	end
	function _G.timerRelativeToSeconds(count)
		return count / freq
	end

	function _G.timerGetDiffInSeconds(count1, count2)
		return (count2 - count1) / freq
	end
end
!else
	_G.timerGetCurrent          = os.clock
	_G.timerGetCurrentInSeconds = timerGetCurrent

	function _G.timerAbsoluteToSeconds(time)  return time  end
	_G.timerRelativeToSeconds = timerAbsoluteToSeconds

	function _G.timerGetDiffInSeconds(time1, time2)
		return time2 - time1
	end
!end



_G.F = string.format



function math.clamp(n, nMin, nMax)
	return math.min(math.max(n, nMin), nMax)
end



function _G.printf(s, ...)
	print(s:format(...))
end

-- printTraceback( [ outputFile=io.stdout, ] [ level=1 ] )
function _G.printTraceback(file, level)
	if type(file) ~= "userdata" then  file, level = io.stdout, file  end

	file:write("stack traceback:\n")

	for level = 1+(level or 1), 1/0 do
		local info = debug.getinfo(level, "nSl")
		if not info then  break  end

		-- file:write(level, " source    ", tostring(info.source),    "\n")
		-- file:write(level, " short_src ", tostring(info.short_src), "\n")
		-- file:write(level, " name      ", tostring(info.name),      "\n")
		-- file:write(level, " what      ", tostring(info.what),      "\n")

		local where = info.source:match"^@(.+)"
		where       = where and where:gsub("\\", "/") or info.short_src

		local ln = info.currentline

		!if DEBUG and 1==1 then
			if where == COMPILER_PATH then
				ln        = tonumber(ln)
				where, ln = tryToFixLocationForCompilerError(where, ln)
			end
		!end

		local lnStr = (ln > 0) and ":"..ln or ""

		local name
			=  info.name ~= ""      and info.name
			or info.linedefined > 0 and where..":"..info.linedefined
			or info.what == "main"  and "main chunk"
			or info.what == "tail"  and "tail call"
			or ""

		file:write("\t", where, lnStr)
		if name ~= "" then  file:write("  (", name, ")")  end
		file:write("\n")
	end
end

-- printobj( ... )
do
	local out    = io.stdout
	local _write = out.write
	local function write(...)
		_write(out, ...)
	end

	local _tostring = tostring
	local function tostring(v)
		return (_tostring(v):gsub("^table: ", ""))
	end

	local function compareKeys(a, b)
		return naturalCompare(tostring(a), tostring(b))
	end

	local function _printobj(v, tables, isDepth1, depth)
		local vType = type(v)

		if vType == "table" then
			if tables[v] then
				write("0x", tostring(v))

			else
				write(tostring(v), (isDepth1 and "{" or "{ "))
				tables[v] = true

				local indices = {}
				for i = 1, #v do  indices[i] = true  end

				for _, k in ipairs(sort(getKeys(v), compareKeys)) do
					if not indices[k] then
						if isDepth1 then  write("\n    ")  end
						write(tostring(k), (isDepth1 and " = " or "="))
						_printobj(v[k], tables, false, depth+1)
					end
				end

				for i = 1, #v do
					if isDepth1 then  write("\n    ")  end
					write(i, (isDepth1 and " = " or "="))
					_printobj(v[i], tables, false, depth+1)
				end

				write(isDepth1 and "\n}" or "}")
			end

		elseif vType == "number" then
			write(F("%g", v))

		elseif vType == "string" then
			if #v > 1000 then
				write('"', v:sub(1, 1000):gsub("%z", "\\0"):gsub("\n", "\\n"), '..."')
			else
				write('"', v:gsub("%z", "\\0"):gsub("\n", "\\n"), '"')
			end

		else
			write(tostring(v))
		end

		write(depth>2 and " " or "")
	end

	function _G.printobj(...)
		for i = 1, select("#", ...) do
			if i > 1 then  write("    ")  end

			_printobj(select(i, ...), {}, true, 1)
		end
		write("\n")
	end
end

function _G.printerr(...)
	local file = io.stderr
	for i = 1, select("#", ...) do
		if i > 1 then  file:write("\t")  end
		file:write(tostring((select(i, ...))))
	end
	file:write("\n")
end

function _G.printerrf(s, ...)
	io.stderr:write(s:format(...), "\n")
end



-- errorInternal( [ level=1, ] [[ state, node, ] formatString, ... ] )
local function _errorInternal(level, state, node, s, ...)
	if type(state) == "string" then  _errorInternal(1+level, nil, nil, state, node, s, ...)  end

	_G.assert = _assert -- Prevent recursive errors. @Cleanup

	s = s and F("Internal compiler error: "..s, ...) or "Internal compiler error."
	if node then
		printTraceback(io.stderr, 1+level)
		printerr()
		!ifDEBUG `astPrint(io.stderr, node)`
		printerr()
		nodeMessage(io.stderr, state, node, "Error", nil, "%s", s)
	else
		printerr("\nError: "..s)
		printTraceback(io.stderr, 1+level)
	end

	exitFailure()
end
function _G.errorInternal(level, state, node, ...)
	if type(level) == "number" then
		_errorInternal(1+level, state, node,  ...)
	else
		_errorInternal(2,       level, state, node, ...)
	end
end

function _G.errorLine(agent, s, ...)
	if agent then
		printerrf("\n[%s] Error: "..s, agent, ...)
	else
		printerrf("\nError: "..s, ...)
	end
	exitFailure()
end

function _G.errorOnLine(path, ln, agent, s, ...)
	printerr()
	reportMessageOnLine(io.stderr, path, ln, "Error", agent, s, ...)
	printerr()
	exitFailure()
end

function _G.errorInFile(buffer, path, ptr, agent, s, ...)
	printerr()
	reportMessageInFile(io.stderr, buffer, path, ptr, "Error", agent, s, ...)
	exitFailure()
end

_G._assert = assert
function _G.assert(...)
	if ... then  return ...  end

	local _, err = ...
	err          = tostring(err or "Assertion failed!")
	errorInternal(2, "%s", err)
end



-- reportMessageOnLine( [ outputFile=io.stdout, ] path, ln, label, agent, s, ...)
function _G.reportMessageOnLine(file, path, ln, label, agent, s, ...)
	if type(file) ~= "userdata" then  return reportMessageOnLine(io.stdout, file, path, ln, label, agent, s, ...)  end

	s = F(s, ...)

	if agent then
		file:write(F("%s @ %s:%d: [%s] %s\n", label, path, ln, agent, s))
	else
		file:write(F("%s @ %s:%d: %s\n",      label, path, ln,        s))
	end
end

-- reportMessageInFile( [ outputFile=io.stdout, ] buffer, path, ptr, label, agent, s, ...)
function _G.reportMessageInFile(file, buffer, path, ptr, label, agent, s, ...)
	if type(file) ~= "userdata" then  return reportMessageInFile(io.stdout, file, buffer, path, ptr, label, agent, s, ...)  end

	!local BUFFER_LINES_TO_PRINT = 3

	s   = F(s, ...)
	ptr = math.clamp(ptr, 1, #buffer+1)

	!for i = 1, BUFFER_LINES_TO_PRINT do
		!local varThisPtr = "lineStart"..i
		!local varPrevPtr = "lineStart"..i-1

		!if i == 1 then
			local !!(varThisPtr) = ptr
		!else
			local !!(varThisPtr) = !!(varPrevPtr)-1
		!end

		while !!(varThisPtr) > 1 and buffer:byte(!!(varThisPtr)-1) ~= @@BYTE"\n" do
			!!(varThisPtr) = !!(varThisPtr)-1
		end
	!end

	local lineEnd = ptr-1 -- We start at ptr-1 so that we may get lineEnd==lineStart1-1 in the end.
	while lineEnd < #buffer and buffer:byte(lineEnd+1) ~= @@BYTE"\n" do
		lineEnd = lineEnd+1
	end

	local lastLinePre = buffer:sub(lineStart1, ptr-1):gsub("\t", "    ")

	!for i = 1, BUFFER_LINES_TO_PRINT do
		!local varThis    = "lastLine" ..i
		!local varThisPtr = "lineStart"..i
		!local varPrevPtr = "lineStart"..i-1

		local !!(varThis) = ""

		!if i == 1 then
			!!(varThis) = buffer:sub(!!(varThisPtr), lineEnd         ):gsub("\t", "    ")
		!else
			if !!(varPrevPtr)-2 >= 1 then
				!!(varThis) = buffer:sub(!!(varThisPtr), !!(varPrevPtr)-2):gsub("\t", "    ")
			end
		!end
	!end

	local _, nlCount  = buffer:sub(1, ptr-1):gsub("\n", "%0")
	local ln          = nlCount+1

	local len         = 0
	local lenPtr      = 1

	while true do
		if lenPtr > #lastLinePre then  break  end

		local _, i2 = lastLinePre:find(!("^"..UTF8_CHARACTER_PATTERN), lenPtr)

		len    = len+1 -- The length isn't going to be perfect, depending on what Unicode characters are encountered.
		lenPtr = i2+1
	end

	local col = 1+len

	if agent then
		file:write(F("%s @ %s:%d: [%s] %s\n", label, path, ln, agent, s))
	else
		file:write(F("%s @ %s:%d: %s\n",      label, path, ln,        s))
	end

	file:write("\n")

	!for i = BUFFER_LINES_TO_PRINT, 1, -1 do
		!local varThis = "lastLine"..i

		!if i == 1 then
			file:write("> ", !!(varThis), "\n")
		!else
			if !!(varThis) ~= "" then
				file:write("> ", !!(varThis), "\n")
			end
		!end
	!end

	file:write(F("> %s^\n\n", ("-"):rep(col-1)))
end



function _G.exit(code)
	-- @Incomplete: Close log file and whatnot.
	os.exit(code or 0)
end

function _G.exitFailure()
	exit(1)
end



function _G.isReadableFile(path)
	local file = io.open(path, "rb")
	if not file then  return false  end

	file:close()
	return true
end

-- contents, error = getFileContents( path [, isText=false ] )
function _G.getFileContents(path, isText)
	local file, err = io.open(path, (isText and "r" or "rb"))
	if not file then  return nil, err  end

	local s = file:read"*a"
	file:close()
	return s
end



do
	local function _utf8Char(cp)
		if cp < 128 then  return string.char(cp)  end

		local suffix = cp%64
		local c4     = 128+suffix
		cp           = (cp-suffix)/64
		if cp < 32 then  return string.char(192+cp, c4)  end

		suffix   = cp%64
		local c3 = 128+suffix
		cp       = (cp-suffix)/64
		if cp < 16 then  return string.char(224+cp, c3, c4)  end

		suffix = cp%64
		cp     = (cp-suffix)/64
		return string.char(240+cp, 128+suffix, c3, c4)
	end

	local cache = {}

	function _G.utf8Char(cp)
		return cache[cp] or storeInCache(cache, cp, _utf8Char(cp))
	end

	-- codepoint = utf8Codepoint( string [, startBytePosition=1 ] )
	-- It's assumed the string is valid UTF-8.
	function _G.utf8Codepoint(s, pos)
		pos = (pos or 1)
		--[[
			Bits  Last code point  Range for byte 1  Bytes
			7     U+007F           000-127           0xxxxxxx
			11    U+07FF           192-223           110xxxxx  10xxxxxx
			16    U+FFFF           224-239           1110xxxx  10xxxxxx  10xxxxxx
			21    U+1FFFFF         240-247           11110xxx  10xxxxxx  10xxxxxx  10xxxxxx
		]]
		local b1, b2, b3, b4 = s:byte(pos, pos+3)
		if     b1 < 128 then  return b1
		elseif b1 < 224 then  return (b1-192)*!(2^(1*6)) + (b2-128)
		elseif b1 < 240 then  return (b1-224)*!(2^(2*6)) + (b2-128)*!(2^(1*6)) + (b3-128)
		else                  return (b1-240)*!(2^(3*6)) + (b2-128)*!(2^(2*6)) + (b3-128)*!(2^(1*6)) + (b4-128)  end
	end

	--[[ UTF-8 tests:
	printf("%s $ %s",          utf8Char(0x0024), (utf8Char(0x0024)=="$" and "ok" or "FAIL"))
	printf("%s £ %s",          utf8Char(0x00A3), (utf8Char(0x00A3)=="£" and "ok" or "FAIL"))
	printf("%s β %s",          utf8Char(0x03B2), (utf8Char(0x03B2)=="β" and "ok" or "FAIL"))
	printf("%s Я %s",          utf8Char(0x042F), (utf8Char(0x042F)=="Я" and "ok" or "FAIL"))
	printf("U+%04X U+0024 %s", utf8Codepoint"$", (utf8Codepoint"$"==0x0024 and "ok" or "FAIL"))
	printf("U+%04X U+00A3 %s", utf8Codepoint"£", (utf8Codepoint"£"==0x00A3 and "ok" or "FAIL"))
	printf("U+%04X U+03B2 %s", utf8Codepoint"β", (utf8Codepoint"β"==0x03B2 and "ok" or "FAIL"))
	printf("U+%04X U+042F %s", utf8Codepoint"Я", (utf8Codepoint"Я"==0x042F and "ok" or "FAIL"))
	os.exit(2)
	--]]
end



function _G.isAny(v, ...)
	for i = 1, select("#", ...) do
		if v == select(i, ...) then  return true  end
	end
	return false
end



function _G.indexOf(t, v)
	for i = 1, #t do
		if t[i] == v then  return i  end
	end
	return nil
end

function _G.lastIndexOf(t, v)
	for i = #t, 1, -1 do
		if t[i] == v then  return i  end
	end
	return nil
end




do
	local select = select

	local function _itemWith(t, i1, i2, iDir, ...)
		local argCount = select("#", ...)
		local item, isMatch, k, v

		for i = i1, i2, iDir do
			item    = t[i]
			isMatch = true

			for argIndex = 1, argCount, 2 do
				k, v = select(argIndex, ...)

				if item[k] ~= v then
					isMatch = false
					break
				end
			end

			if isMatch then  return item, i  end
		end

		return nil, nil
	end
	local function _itemWith1(t, i1,i2,iDir, k,v)
		local item
		for i = i1, i2, iDir do
			item = t[i]
			if item[k] == v then  return item, i  end
		end
		return nil, nil
	end
	local function _itemWith2(t, i1,i2,iDir, k1,v1, k2,v2)
		local item
		for i = i1, i2, iDir do
			item = t[i]
			if item[k1] == v1 and item[k2] == v2 then  return item, i  end
		end
		return nil, nil
	end
	local function _itemWith3(t, i1,i2,iDir, k1,v1, k2,v2, k3,v3)
		local item
		for i = i1, i2, iDir do
			item = t[i]
			if item[k1] == v1 and item[k2] == v2 and item[k3] == v3 then  return item, i  end
		end
		return nil, nil
	end

	-- index = indexWith ( array, key1, value1, ... )
	-- index = indexWith1( array, key,  value )
	-- index = indexWith2( array, key1, value1, key2, value2 )
	-- index = indexWith3( array, key1, value1, key2, value2, key3, value3 )
	-- index = lastIndexWith ( array, key1, value1, ... )
	-- index = lastIndexWith1( array, key,  value )
	-- index = lastIndexWith2( array, key1, value1, key2, value2 )
	-- index = lastIndexWith3( array, key1, value1, key2, value2, key3, value3 )
	-- item, index = itemWith ( array, key1, value1, ... )
	-- item, index = itemWith1( array, key,  value )
	-- item, index = itemWith2( array, key1, value1, key2, value2 )
	-- item, index = itemWith3( array, key1, value1, key2, value2, key3, value3 )
	-- item, index = lastItemWith ( array, key1, value1, ... )
	-- item, index = lastItemWith1( array, key,  value )
	-- item, index = lastItemWith2( array, key1, value1, key2, value2 )
	-- item, index = lastItemWith3( array, key1, value1, key2, value2, key3, value3 )
	-- item, index = nextItemWith ( array, startIndex, key1, value1, ... )
	-- item, index = nextItemWith1( array, startIndex, key,  value )
	-- item, index = nextItemWith2( array, startIndex, key1, value1, key2, value2 )
	-- item, index = nextItemWith3( array, startIndex, key1, value1, key2, value2, key3, value3 )
	-- item, index = previousItemWith ( array, startIndex, key1, value1, ... )
	-- item, index = previousItemWith1( array, startIndex, key,  value )
	-- item, index = previousItemWith2( array, startIndex, key1, value1, key2, value2 )
	-- item, index = previousItemWith3( array, startIndex, key1, value1, key2, value2, key3, value3 )
	function _G.indexWith        (t,    ...                )  local _, i = _itemWith (t, 1, #t,  1, ...                ) ; return i  end
	function _G.indexWith1       (t,    k1,v1              )  local _, i = _itemWith1(t, 1, #t,  1, k1,v1              ) ; return i  end
	function _G.indexWith2       (t,    k1,v1, k2,v2       )  local _, i = _itemWith2(t, 1, #t,  1, k1,v1, k2,v2       ) ; return i  end
	function _G.indexWith3       (t,    k1,v1, k2,v2, k3,v3)  local _, i = _itemWith3(t, 1, #t,  1, k1,v1, k2,v2, k3,v3) ; return i  end
	function _G.lastIndexWith    (t,    ...                )  local _, i = _itemWith (t, #t, 1, -1, ...                ) ; return i  end
	function _G.lastIndexWith1   (t,    k1,v1              )  local _, i = _itemWith1(t, #t, 1, -1, k1,v1              ) ; return i  end
	function _G.lastIndexWith2   (t,    k1,v1, k2,v2       )  local _, i = _itemWith2(t, #t, 1, -1, k1,v1, k2,v2       ) ; return i  end
	function _G.lastIndexWith3   (t,    k1,v1, k2,v2, k3,v3)  local _, i = _itemWith3(t, #t, 1, -1, k1,v1, k2,v2, k3,v3) ; return i  end
	function _G.itemWith         (t,    ...                )  return       _itemWith (t, 1, #t,  1, ...                )  end
	function _G.itemWith1        (t,    k1,v1              )  return       _itemWith1(t, 1, #t,  1, k1,v1              )  end
	function _G.itemWith2        (t,    k1,v1, k2,v2       )  return       _itemWith2(t, 1, #t,  1, k1,v1, k2,v2       )  end
	function _G.itemWith3        (t,    k1,v1, k2,v2, k3,v3)  return       _itemWith3(t, 1, #t,  1, k1,v1, k2,v2, k3,v3)  end
	function _G.lastItemWith     (t,    ...                )  return       _itemWith (t, #t, 1, -1, ...                )  end
	function _G.lastItemWith1    (t,    k1,v1              )  return       _itemWith1(t, #t, 1, -1, k1,v1              )  end
	function _G.lastItemWith2    (t,    k1,v1, k2,v2       )  return       _itemWith2(t, #t, 1, -1, k1,v1, k2,v2       )  end
	function _G.lastItemWith3    (t,    k1,v1, k2,v2, k3,v3)  return       _itemWith3(t, #t, 1, -1, k1,v1, k2,v2, k3,v3)  end
	function _G.nextItemWith     (t, i, ...                )  return       _itemWith (t, i, #t,  1, ...                )  end
	function _G.nextItemWith1    (t, i, k1,v1              )  return       _itemWith1(t, i, #t,  1, k1,v1              )  end
	function _G.nextItemWith2    (t, i, k1,v1, k2,v2       )  return       _itemWith2(t, i, #t,  1, k1,v1, k2,v2       )  end
	function _G.nextItemWith3    (t, i, k1,v1, k2,v2, k3,v3)  return       _itemWith3(t, i, #t,  1, k1,v1, k2,v2, k3,v3)  end
	function _G.previousItemWith (t, i, ...                )  return       _itemWith (t, i,  1, -1, ...                )  end
	function _G.previousItemWith1(t, i, k1,v1              )  return       _itemWith1(t, i,  1, -1, k1,v1              )  end
	function _G.previousItemWith2(t, i, k1,v1, k2,v2       )  return       _itemWith2(t, i,  1, -1, k1,v1, k2,v2       )  end
	function _G.previousItemWith3(t, i, k1,v1, k2,v2, k3,v3)  return       _itemWith3(t, i,  1, -1, k1,v1, k2,v2, k3,v3)  end
end



function _G.indexOfRemember(memory, t, v)
	if memory[v] == nil then
		memory[v] = indexOf(t, v) or false
	end

	return memory[v] or nil
end

function _G.itemWith1Remember(memory, t, k, v)
	if memory[k] == nil then
		memory[k] = {}
		memory    = memory[k]
	else
		memory    = memory[k]
	end

	if memory[v] == nil then
		memory[v] = itemWith1(t, k, v) or false
	end

	return memory[v] or nil
end



-- copy = copyTable( table [, deep=false ] )
do
	local function deepCopy(t, copy, tableCopies)
		for k, v in pairs(t) do
			if type(v) == "table" then
				local vCopy = tableCopies[v]

				if vCopy then
					copy[k] = vCopy
				else
					vCopy          = {}
					tableCopies[v] = vCopy
					copy[k]        = deepCopy(v, vCopy, tableCopies)
				end

			else
				copy[k] = v
			end
		end
		return copy
	end

	function _G.copyTable(t, deep)
		if deep then
			return deepCopy(t, {}, {})
		end

		local copy = {}
		for k, v in pairs(t) do  copy[k] = v  end

		return copy
	end
end

function _G.copyArray(t)
	local copy = {}
	for i = 1, #t, 2 do
		-- Copying 2 elements on 2 rows at a time seems to be the fastest in LuaJIT.
		copy[i  ] = t[i  ]
		copy[i+1] = t[i+1]
	end
	return copy
end

-- copyToArray( fromArray, toArray [, fromIndex=1, toIndex=#from ] )
function _G.copyToArray(from, to, i1, i2)
	for i = (i1 or 1), (i2 or #from) do
		to[i] = from[i]
	end
end

-- emptyArray( array [, fromIndex=1 ] )
function _G.emptyArray(t, i)
	for i = (i or 1), #t do
		t[i] = nil
	end
end

function _G.fillArray(t, i1, i2, v)
	for i = i1, i2 do  t[i] = v  end
	return t
end

-- Modifies the array!
function _G.reverseArray(t)
	local len = #t
	for i = 1, len/2 do
		local i2 = len-i+1
		t[i], t[i2] = t[i2], t[i]
	end
	return t
end

function _G.flipArray(t)
	local flipped = {}
	for i, v in ipairs(t) do
		flipped[v] = i
	end
	return flipped
end

-- index = removeItem( array, item )
function _G.removeItem(t, v)
	local i = indexOf(t, v)
	if i then  table.remove(t, i)  end
	return i
end

-- removedValue = removeUnordered( array, index )
function _G.removeUnordered(t, i)
	if i < 1 then  return nil  end

	local len = #t
	if i > len then  return nil  end

	local v = t[i]
	t[i]    = t[len]
	t[len]  = nil

	return v
end

function _G.insertArrayItems(t, toInsert)
	local insert = table.insert
	for _, v in ipairs(toInsert) do
		insert(t, v)
	end
end



function _G.insertN(t, v)
-- function _G.insertN(t, i, v) -- @Incomplete
	t.n    = t.n + 1
	t[t.n] = v
end

-- removedValue = removeN( array [, index=array.n ] )
function _G.removeN(t, i)
	local len = t.n
	i         = i or len
	if i < 1 or i > len then  return nil  end

	local v = t[i]
	for i = i, len-1 do
		t[i] = t[i+1]
	end
	t.n = len - 1 -- Don't unset t[len] - we don't care about fields outside 1..len-1 as they are garbage!

	return v
end

-- removedValue = removeUnorderedN( array, index )
function _G.removeUnorderedN(t, i)
	if i < 1 then  return nil  end

	local len = t.n
	if i > len then  return nil  end

	local v = t[i]
	t[i]    = t[len]
	t.n     = len - 1 -- Don't unset t[len] - we don't care about fields outside 1..len-1 as they are garbage!

	return v
end

-- for index, value in ipairsN ( array )
-- for index, value in ipairsrN( array )
do
	local function inextN(t, i)
		i = i + 1
		if i <= t.n then  return i, t[i]  end
	end
	local function iprevN(t, i)
		i = i - 1
		if i >= 1 then  return i, t[i]  end
	end

	function _G.ipairsN(t)
		return inextN, t, 0
	end
	function _G.ipairsrN(t)
		return iprevN, t, t.n+1
	end
end



function _G.areArraysEqual(t1, t2)
	if #t1 ~= #t2 then  return false  end

	for i = 1, #t1 do
		if t1[i] ~= t2[i] then  return false  end
	end

	return true
end



-- number:string = formatNumber( number )
function _G.formatNumber(n)
	local s = F("%.0f", n)
	if #s <= 4 then  return s  end
	return (s:reverse():gsub("%d%d%d", "%0 "):reverse():gsub("^ ", ""))
end

-- hex:string, bits:string = formatBinary( data:string )
do
	local HEX_TO_BITS = {
		["0"]="0000",["1"]="0001",["2"]="0010",["3"]="0011",
		["4"]="0100",["5"]="0101",["6"]="0110",["7"]="0111",
		["8"]="1000",["9"]="1001",["a"]="1010",["b"]="1011",
		["c"]="1100",["d"]="1101",["e"]="1110",["f"]="1111",
	}
	function _G.formatBinary(s)
		local hex = s:gsub(".", function(c)  return F("%02x", c:byte())  end)
		local bitsStr = hex:gsub(".", HEX_TO_BITS)
		return hex, bitsStr
	end
end



function _G.generateRandomString(len)
	local random = math.random
	local buffer = {}

	for i = 1, len do
		buffer[i] = random(0, 255)
	end

	return string.char(unpack(buffer))
end



-- item = getLast( array [, indexFromEnd=1 ] )
function _G.getLast(arr, i)
	return arr[#arr+1-(i or 1)]
end

-- nextValue = nextItem( array, currentValue [, steps=1 ] )
-- Note: The values wrap.
function _G.nextItem(t, v, steps)
	local i = indexOf(t, v)
	return i and t[(i-1+(steps or 1)) % #t + 1]
end



-- for index, item in ipairsr( array )
do
	local function iprev(t, i)
		i = i-1
		local v = t[i]
		if v ~= nil then  return i, v  end
	end
	function _G.ipairsr(t)
		return iprev, t, #t+1
	end
end



--[[
-- for value1, ... in iterate( callback, argument1, ... )
-- 'value1, ...' is whatever the callback yields.
do
	local coroutine_create = coroutine.create
	local coroutine_resume = coroutine.resume
	local coroutine_wrap   = coroutine.wrap
	local coroutine_yield  = coroutine.yield

	local function initiator(cb, ...)
		coroutine_yield()
		return cb(...)
	end

	local function iterator(co)
		return select(2, assert(coroutine_resume(co)))
	end

	function _G.iterate(cb, ...)
		if select("#", ...) <= 2 then
			return coroutine_wrap(cb), ...
		end

		local co = coroutine_create(initiator)
		assert(coroutine_resume(co, cb, ...))

		return iterator, co
	end
end
--]]



-- array = pack( ... )
function _G.pack(...)
	return {n=select("#", ...), ...}
end



-- for key, value in pairsSorted( table [, compareFunction ] )
function _G.pairsSorted(t, comp)
	local keys = sort(getKeys(t), comp)
	local i    = 0

	return function()
		i       = i + 1
		local k = keys[i]

		if k ~= nil then  return k, t[k]  end
	end
end

local inext = ipairs(EMPTY_TABLE)
function _G.ipairsFrom(t, firstIndex)
	return inext, t, firstIndex-1
end



-- array = sort( array [, compareFunction ] )
function _G.sort(t, comp)
	table.sort(t, comp)
	return t
end

-- sortByColumn( array, key [, compareFunction ] )
function _G.sortByColumn(t, k, comp)
	if comp then
		table.sort(t, function(a, b)
			return comp(a[k], b[k])
		end)
	else
		table.sort(t, function(a, b)
			return a[k] < b[k]
		end)
	end
	return t
end

-- array = sortNatural( array [, attribute ] )
function _G.sortNatural(t, k)
	if k then
		table.sort(t, function(a, b)
			return naturalCompare(a[k], b[k])
		end)
	else
		table.sort(t, naturalCompare)
	end
	return t
end

-- Sorts a string array containing numbers using a natural algorithm
-- table.sort( array, naturalCompare )
do
	local function pad(numStr)
		return F("%03d%s", #numStr, numStr)
	end
	function _G.naturalCompare(a, b)
		return tostring(a):gsub("%d+", pad) < tostring(b):gsub("%d+", pad)
	end
end



do
	!local EXTRA_ERROR_CHECKING = 1==0

	local tables    = {}
	local freeIndex = 1

	!if EXTRA_ERROR_CHECKING then
	local recycled  = {}
	!end

	function _G.recycleTable(t)
		!if EXTRA_ERROR_CHECKING then
			if recycled[t] then  errorInternal(2, "Table is already recycled.")  end
			recycled[t] = true
		!end

		tables[freeIndex] = t
		freeIndex         = freeIndex + 1
	end

	function _G.recycleTablesInArray(ts)
		for i = 1, #ts do
			!if EXTRA_ERROR_CHECKING then
				if recycled[ts[i]] then  errorInternal(2, "At least one table is already recycled.")  end
				recycled[ts[i]] = true
			!end

			tables[freeIndex] = ts[i]
			freeIndex         = freeIndex + 1
		end
	end

	function _G.getRecycledTable()
		if freeIndex == 1 then  return nil  end

		freeIndex = freeIndex - 1
		!if EXTRA_ERROR_CHECKING then
			recycled[tables[freeIndex]] = nil
		!end
		return tables[freeIndex]
	end

	function _G.getRecycledTableCount()
		return freeIndex - 1
	end
end



-- target = setFields( target, source )
function _G.setFields(target, source)
	for k, v in pairs(source) do
		target[k] = v
	end
	return target
end



function _G.timeIt(f, count, ...)
	collectgarbage()

	local timeDataStart = timerGetCurrent()
	for i = 1, count do
		f(...)
	end
	local timeDataEnd = timerGetCurrent()

	print(timerGetDiffInSeconds(timeDataStart, timeDataEnd))
end

function _G.stall(duration)
	local untilTime = os.clock() + duration
	while os.clock() < untilTime do
		local x = 2
		local y = x^100
	end
end



function _G.trim(s)
	return (s:gsub("^%s+", ""):gsub("%s+$", ""))
end

function _G.triml(s)
	return (s:gsub("^%s+", ""))
end

function _G.trimr(s)
	return (s:gsub("%s+$", ""))
end



function _G.getKeys(t)
	local keys = {}
	for k in pairs(t) do  table.insert(keys, k)  end
	return keys
end



-- names, values = getUpvalues( function )
function _G.getUpvalues(f)
	local names  = {}
	local values = {}

	for i = 1, 1/0 do
		local name, v = debug.getupvalue(f, i)
		if not name then  break  end

		names[i]  = name
		values[i] = v
	end

	return names, values
end

-- names, values = getLocals( [ level=1 ] )
function _G.getLocals(level)
	level = (level or 1)+1

	local names  = {}
	local values = {}

	if not debug.getinfo(level, "") then
		return names, values
	end

	local localIndex = 0

	for i = 1, 1/0 do
		local name, v = debug.getlocal(level, i)
		if not name then  break  end

		if not name:find"^%(%*" then -- Special names include "(for generator)" and "(*temporary)" etc.
			localIndex = localIndex+1
			names [localIndex] = name
			values[localIndex] = v
		end
	end

	return names, values
end

-- stack = getStack( [ level=1 ] )
-- stack = { entry1, ... }
-- entry = { where=where, names=names, values=values }
function _G.getStack(level)
	local stack = {}

	for level = 1+(level or 1), 1/0 do
		local info = debug.getinfo(level, "nSl")
		if not info then  break  end

		local where
			=  info.source:match"^@(.+)"
			or info.short_src:match'^%[string "(.+%.lua)"%]$' -- Not great, but needed for e.g. boot.lua
			or info.short_src

		local lnStr = info.currentline > 0 and ":"..info.currentline or ""

		local name
			=  info.name
			or info.linedefined > 0 and where..":"..info.linedefined
			or info.what == "main" and "main chunk"
			or info.what == "tail" and "tail call"
			or "?"

		local names, values = getLocals(level)

		local entry = {
			where  = where..lnStr.."  ("..name..")",
			names  = names,
			values = values,
		}
		table.insert(stack, entry)
	end

	return stack
end



function _G.isPathAbsolute(path)
	-- Note: Network paths or weird paths ("C:foo.png") are not supported.
	return (path:find"^%a:" or path:find"^[/~]") ~= nil
end

do
	function _G.normalizeDirectoryPath(path)
		-- Note: Network paths or weird paths ("C:foo.png") are not supported.
		local            drive, root, dir =     path:match"^(%a:)(/)(.*)"
		if not dir then  drive, root, dir =     path:match"^(~)(/)(.*)"  end
		if not dir then  drive, root, dir = "", path:match"^(/?)(.*)"    end

		local segments = {}
		for segment in dir:gmatch"[^/]+" do
			table.insert(segments, segment)
		end

		for i = #segments, 1, -1 do
			if segments[i] == "." then
				table.remove(segments, i)
			end
		end

		local i = 1
		while segments[i] do
			if segments[i+1] == ".." and segments[i] ~= ".." then
				table.remove(segments, i+1)
				table.remove(segments, i)
				i = math.max(i-1, 1)
			else
				i = i+1
			end
		end

		segments[1] = segments[1] or "." -- Prevent an empty string or a trailing slash so it's easy to append stuff to the resulting path.
		path        = drive..root..table.concat(segments, "/")

		return path
	end

	--[[ Path normalization tests:
	local tests = {
		"C:/foo/bar",             "C:/foo/bar",
		"/majestic/doggo/.",      "/majestic/doggo",
		"~/Only trees",           "~/Only trees",
		"My Game/src/",           "My Game/src",
		"./cutest/cat/..",        "cutest",
		"ceiling/cat/../..",      ".",
		"../almighty/cricket/..", "../almighty",
		"",                       ".",
		".",                      ".",
		"..",                     "..",
		"foo/../..",              "..",
		"C:/",                    "C:/.",
		"C/",                     "C",
		"/",                      "/.",
	}
	for i = 1, #tests, 2 do
		printf('IN  "%s"', tests[i])
		printf('OUT "%s"', normalizeDirectoryPath(tests[i]))
		assert(normalizeDirectoryPath(tests[i]) == tests[i+1])
		print(("-"):rep(20))
	end
	os.exit(2)
	--]]
end



function _G.newVirtualFile()
	local file     = {}
	local buffer   = {}
	local select   = select
	local insert   = table.insert
	local tostring = tostring

	function file:write(...)
		for i = 1, select("#", ...) do
			local v = select(i, ...)
			!ASSERT `type(v) == "string" or type(v) == "number"`
			insert(buffer, tostring(v))
		end
	end

	function file:getBuffer()
		return table.concat(buffer)
	end
	function file:clearBuffer()
		buffer = {}
	end
	function file:isBufferEmpty()
		return buffer[1] == nil
	end

	return file
end



!if DEBUG then
do
	local isRunning  = false
	local pauseDepth = 0

	local calls      = {}
	local n          = 0
	local names      = {}
	local times      = {}
	local lastName   = nil

	!if HIRES_TIMER then
	local timerGetCurrent = timerGetCurrent
	!end

	do
		local countCalls   = {}
		local timeCalls    = {}
		local timeSubcalls = {[0]=0}
		local timeStarts   = {}
		local depth        = 0

		function _G.staticProfilerPush(name)
			!if STATIC_PROFILER then
				countCalls[name]    = (countCalls[name] or 0) + 1
				depth               = depth + 1
				timeStarts[depth]   = timerGetCurrent()
				timeSubcalls[depth] = 0
			!end
		end
		function _G.staticProfilerPop(name)
			!if STATIC_PROFILER then
				local time          = timerGetCurrent() - timeStarts[depth]
				timeCalls[name]     = (timeCalls[name] or 0) + time - timeSubcalls[depth]
				depth               = depth - 1
				timeSubcalls[depth] = timeSubcalls[depth] + time
			!end
		end

		function _G.staticProfilerPrint()
			!if STATIC_PROFILER then
				local names = {}
				for name in pairs(timeCalls) do
					table.insert(names, name)
				end

				table.sort(names, function(a, b)
					if timeCalls[a] ~= timeCalls[b] then  return timeCalls[a] > timeCalls[b]  end
					return a < b
				end)

				local time = os.time()
				print(os.date("all.%Y%m%d-%H%M%S.txt", time))
				print(os.date("all %Y-%m-%d %H:%M:%S", time))

				for _, name in ipairs(names) do
					printf(!(HIRES_TIMER and "%.7f  %8.0f  %s" or "%.3f  %8.0f  %s"), timerRelativeToSeconds(timeCalls[name]), countCalls[name], name)
				end
			!end
		end
	end

	function _G.profilerStart()
		!if PROFILE_CALLS or PROFILE_CALLEES or PROFILE_TIMES then
			if isRunning then  return  end

			isRunning     = true
			pauseDepth    = 0

			local getinfo = debug.getinfo

			!if PROFILE_CALLS then
				debug.sethook(function()
					local name = getinfo(2, "n").name or "?"
					calls[name] = (calls[name] or 0)+1
				end, "c")

			!elseif PROFILE_CALLEES then
				debug.sethook(function()
					local name = getinfo(2, "n").name
					if name ~= !(PROFILER_TARGET_NAME) then  return  end
					name = getinfo(3, "n").name or "?"
					calls[name] = (calls[name] or 0)+1
				end, "c")

			!elseif PROFILE_TIMES then
				n        = n+1
				names[n] = "__PROFILER"
				times[n] = timerGetCurrent()
				lastName = "__PROFILER"

				collectgarbage()

				debug.sethook(function(event, ln)
					local name = getinfo(2, "n").name or getinfo(2, "S").linedefined or "?"
					if name == lastName then  return  end

					n        = n+1
					names[n] = name
					times[n] = timerGetCurrent()
					lastName = name
				end, "l")
			!end
		!end
	end
	function _G.profilerStop()
		debug.sethook(nil)

		!if PROFILE_TIMES then
			n        = n+1
			names[n] = "__PROFILER"
			times[n] = timerGetCurrent()
			lastName = "__PROFILER"
		!end

		pauseDepth = 0
		isRunning  = false
	end

	function _G.profilerPause()
		if isRunning then
			profilerStop()
			pauseDepth = 1
		elseif pauseDepth > 0 then
			pauseDepth = pauseDepth+1
		end
	end
	function _G.profilerUnpause()
		if pauseDepth == 0 then  return  end
		pauseDepth = pauseDepth-1
		if pauseDepth == 0 then  profilerStart()  end
	end

	function _G.profilerPrint()
		!if PROFILE_CALLS or PROFILE_CALLEES then
			local sources = {}
			local sum     = 0

			for source in pairs(calls) do
				table.insert(sources, source)
				sum = sum+calls[source]
			end

			table.sort(sources, function(a, b)
				if calls[a] ~= calls[b] then  return calls[a] > calls[b]  end
				return a < b
			end)

			local time = os.time()
			print(os.date("calls.%Y%m%d-%H%M%S.txt", time))
			print(os.date("calls %Y-%m-%d %H:%M:%S", time))

			print(sum)
			for _, source in ipairs(sources) do
				printf("%d  %s", calls[source], source)
			end

		!elseif PROFILE_TIMES then
			local runTimes = {}

			for i = 2, n-1 do
				local name     = type(names[i]) == "number" and ":"..names[i] or tostring(names[i])
				runTimes[name] = (runTimes[name] or 0) + (times[i+1] - times[i])
			end

			local sources = {}

			for source in pairs(runTimes) do
				table.insert(sources, source)
			end

			table.sort(sources, function(a, b)
				if runTimes[a] ~= runTimes[b] then  return runTimes[a] > runTimes[b]  end
				return a < b
			end)

			printf("n = %.0f", n)

			local time = os.time()
			print(os.date("times.%Y%m%d-%H%M%S.txt", time))
			print(os.date("times %Y-%m-%d %H:%M:%S", time))

			for _, source in ipairs(sources) do
				printf(!(HIRES_TIMER and "%.7f  %s" or "%.3f  %s"), timerRelativeToSeconds(runTimes[source]), source)
			end
		!end
	end

	--[[ TEST
	local function deep()
		local x = 0
	end
	local function first()
		local x = 0
		deep()
		local y = 0
	end
	local function tail()
		local x = 0
		return first()
	end

	debug.sethook(function(event, ln)
		local name = debug.getinfo(2, "n").name or "?"
		_print(event, (ln or "    "), name)
	end, "crl")

	first()
	_print("--------")
	tail()

	debug.sethook(nil)
	os.exit(2)
	--]]
end
!end



-- value = storeInCache( cache, key, value )
function _G.storeInCache(cache, k, v)
	cache[k] = v
	return v
end



!if DEBUG then
	local lineNumberMap = nil

	local function init()
		if lineNumberMap then  return  end

		lineNumberMap = {}

		local file = io.open(COMPILER_PATH)
		if not file then  return  end

		local outputLn = 0
		local sourceLn = 0

		for outputLine in file:lines() do
			outputLn = outputLn + 1
			sourceLn = tonumber(outputLine:match"%-%-%[%[@(%d+)%]%]") or sourceLn+1

			lineNumberMap[outputLn] = sourceLn
		end

		file:close()
	end

	-- path, lineNumber = tryToFixLocationForCompilerError( path, lineNumber )
	function _G.tryToFixLocationForCompilerError(path, outputLn)
		init()
		if not lineNumberMap[outputLn] then  return path, outputLn  end

		for _, lnInfo in ipairsr(compilerLineNumbers) do
			if lnInfo.outputLine <= outputLn then
				return lnInfo.sourcePath, lineNumberMap[outputLn]
			end
		end

		-- We shouldn't ever get here unless recordLineNumber() is messed up.
		return path, outputLn
	end
!end



function _G.valueToStringForMessage(v)
	!local MAX_CHARS = 100
	local vStr       = tostring(v):sub(1, !(MAX_CHARS))

	vStr = vStr:gsub(".", function(c)
		local b = c:byte()
		return (
			b == @@BYTE "\n"     and "{NL}"  or
			b == @@BYTE "\r"     and "{CR}"  or
			b == @@BYTE "\t"     and "{TAB}" or
			b >= 32 and b <= 126 and c       or -- Printable ASCII characters.
			"?"
		)
	end)

	return vStr:sub(1, !(MAX_CHARS))
end


