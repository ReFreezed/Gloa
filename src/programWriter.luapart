--[[============================================================
--=
--=  Program Writer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	unicodeToLuaIdentifier
	writeProgram, write*

--============================================================]]



function _G.writeIdentifierName(state, file, ident)
	local decl = ident.declaration
	local name = decl.topScopeName

	if name == "" then  name = decl.localName  end

	if name == "" then
		astPrint(ident)
		printTraceback(io.stderr)
		nodeError(state, ident, "ProgramWriter", "Internal compiler error: Missing name to write for '%s'.", ident.name)
	end

	file:write(name)
end

function _G.writeStringConcatination(state, file, binary)
	if binary.left.nodeType == !(nodeTypes.AstBinary) and binary.left.operation == ".." then
		writeStringConcatination(state, file, binary.left)
	else
		writeExpression(state, file, binary.left)
	end
	file:write(" .. ")
	if binary.right.nodeType == !(nodeTypes.AstBinary) and binary.right.operation == ".." then
		writeStringConcatination(state, file, binary.right)
	else
		writeExpression(state, file, binary.right)
	end
end

function _G.writeLookup(state, file, lookup)
	if isAny(lookup.object.inferredType.tag, !(typeTags.TypeInfoStruct),!(typeTags.TypeInfoTable)) then
		writeExpression(state, file, lookup.object)

		if lookup.member.nodeType == !(nodeTypes.AstLiteral) and lookup.member.literalType == !(LITERAL_STRING) and lookup.member.value:find"^[%a_][%w_]*$" then
			local stringLiteral = lookup.member
			file:write(".", stringLiteral.value)
		else
			file:write("[")
			writeExpression(state, file, lookup.member)
			file:write("]")
		end

	elseif lookup.object.inferredType.tag == !(typeTags.TypeInfoEnum) then
		errorInternal() -- Enum lookups should have been simplified away.

	else
		errorUnhandledNodeType(lookup.object)
	end
end

function _G.writeCast(state, file, cast)
	local typeInfoSource = cast.expression.inferredType
	local typeInfoTarget = cast.inferredType

	if typeInfoSource == typeInfoTarget then
		writeExpression(state, file, cast.expression)

	-- int -> float
	elseif typeInfoSource.tag == !(typeTags.TypeInfoInt) and typeInfoTarget.tag == !(typeTags.TypeInfoFloat) then
		writeExpression(state, file, cast.expression)

	-- float -> int
	elseif typeInfoSource.tag == !(typeTags.TypeInfoFloat) and typeInfoTarget.tag == !(typeTags.TypeInfoInt) then
		file:write("math.floor(")
		writeExpression(state, file, cast.expression)
		file:write(")")

	else
		errorInternal("@Incomplete: Handle casting from %s to %s.", getFriendlyTypeInfoName(typeInfoSource), getFriendlyTypeInfoName(typeInfoTarget))
	end
end

function _G.writeExpression(state, file, expr)
	if expr.nodeType == !(nodeTypes.AstCall) then
		local call   = expr
		local callee = call.callee

		if call.surroundedByParenthesis then  file:write("(")  end

		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			assert(callee.declaration.valueConstant)
			writeConstantValueOrReference(state, file, callee.declaration.valueConstant)
		else
			writeExpression(state, file, callee)
		end

		file:write("(")
		for i, argExpr in ipairs(call.arguments) do
			if i > 1 then  file:write(", ")  end
			writeExpression(state, file, argExpr)
		end
		file:write(")")

		if call.surroundedByParenthesis then  file:write(")")  end

	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		local unary = expr
		file:write("(", unary.operation)
		writeExpression(state, file, unary.expression)
		file:write(")")

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr
		file:write("(")
		if binary.operation == ".." then
			-- This makes sure consecutive string concatinations appear as one operation without any parenthesis.
			writeStringConcatination(state, file, binary)
		else
			writeExpression(state, file, binary.left)
			file:write(" ", binary.operation, " ")
			writeExpression(state, file, binary.right)
		end
		file:write(")")

	elseif expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		writeConstantValue(state, file, literal.valueConstant)

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr

		if ident.inferredType.tag == !(typeTags.TypeInfoEnum) and not isPartOfAnyDeclaration(ident) then -- @Cleanup: This detection is a bit misplaced, I think.
			local valueExpr = ident.declaration.assignment.values[1] or errorInternal()
			writeExpression(state, file, valueExpr)
		else
			writeIdentifierName(state, file, ident)
		end

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		file:write(F("%d", typeNode.representedType.id)) -- @Cleanup: We probably have a constant for the type ID to use with writeConstantValue() here, but who cares...
		if state.settings.outputDebugInfo then
			file:write("--[[", getFriendlyTypeInfoName(typeNode.representedType):gsub("%]", "%0 "), "]]")
		end

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda   = expr
		local constant = itemWith1(state.constants, "valueType", lambda.inferredType) or errorInternal()
		writeConstantValueOrReference(state, file, constant)

	elseif expr.nodeType == !(nodeTypes.AstVararg) then
		local vararg = expr
		file:write(vararg.surroundedByParenthesis and "(...)" or "...")

	elseif expr.nodeType == !(nodeTypes.AstLookup) then
		local lookup = expr
		writeLookup(state, file, lookup)

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		writeCast(state, file, cast)

	else
		errorUnhandledNodeType(expr)
	end
end

function _G.writeDefaultValueForType(state, file, typeInfo, nodeForError)
	local tag = typeInfo.tag

	if tag == !(typeTags.TypeInfoBool) then
		file:write("false")
	elseif tag == !(typeTags.TypeInfoInt) then
		file:write("0")
	elseif tag == !(typeTags.TypeInfoNil) then
		file:write("nil")
	elseif tag == !(typeTags.TypeInfoFloat) then
		file:write("0.0")
	elseif tag == !(typeTags.TypeInfoString) then
		file:write('""')
	elseif tag == !(typeTags.TypeInfoType) then
		file:write("0") -- @Robustness: Maybe 'type' variables should have no defult value and this should be an error.

	elseif tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		file:write("{")

		for i, member in ipairs(structInfo.members) do
			if i > 1 then  file:write(",")  end

			if member.name:find"^[%a_][%w_]*$" then
				file:write(member.name)
			else
				file:write(F("[%q]", member.name))
			end
			file:write("=")

			local assignment = findDeclarationInScope(state, structInfo.astNode, member.name, false).assignment
			if assignment then
				local valueExpr = assignment.values[1] or errorInternal()
				writeExpression(state, file, valueExpr)
			else
				writeDefaultValueForType(state, file, member.typeInfo, nodeForError)
			end
		end

		file:write("}")

	elseif tag == !(typeTags.TypeInfoEnum) then
		nodeError(state, nodeForError, "ProgramWriter", "Enums do not have default values.") -- @Cleanup: This can be detected in the infer pipe.

	else
		errorInternal("Incomplete: Default initial value for type '%s'.", (TYPE_TAG_NAMES[tag] or "?"))
	end
end

-- writeImperativeBlock( state, file, block, indentation, nextLocalNumber )
function _G.writeImperativeBlock(state, file, block, indent, nextLocalN)
	local outputDebugInfo = state.settings.outputDebugInfo
	local indentStr       = ("\t"):rep(indent)

	if not block[1] then
		if outputDebugInfo then
			file:write(indentStr, "-- Empty block.\n")
		end
		return
	end

	local inDecl = false

	for _, statement in ipairs(block) do
		local nodeType = statement.what.nodeType

		if nodeType == !(nodeTypes.AstDeclaration) then
			local decl = statement.what

			if decl.isConstant then
				skipNextAssignment = true

			else
				decl.localName = outputDebugInfo and "L"..nextLocalN.."_"..unicodeToLuaIdentifier(decl.name.name) or "L"..nextLocalN
				nextLocalN     = nextLocalN+1

				if decl.assignment then
					inDecl = true
					if decl.assignmentIndex == 1 then
						file:write(indentStr, "local ")
					end

				else
					local tag = decl.name.inferredType.tag
					file:write(indentStr, "local ", decl.localName, " = ")
					writeDefaultValueForType(state, file, decl.name.inferredType, decl.name)
					file:write("\n")
				end

				-- The initial assignment, if there is one, should be written as the next statement (or after several declarations).
			end

		elseif nodeType == !(nodeTypes.AstAssignment) then
			if not skipNextAssignment then
				local assignment = statement.what
				assert(assignment.operation == "=", "@Incomplete: Support more than '='.")

				if not inDecl then
					file:write(indentStr)
				end
				for i, targetExpr in ipairs(assignment.targets) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, file, targetExpr)
				end
				file:write(" ", assignment.operation, " ")
				for i, expr in ipairs(assignment.values) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, file, expr)
				end
				file:write(";\n") -- The ';' removes ambiguity is some cases.
			end

			inDecl             = false
			skipNextAssignment = false

		elseif nodeType == !(nodeTypes.AstReturn) then
			local returnNode = statement.what

			if block.parent.nodeType == !(nodeTypes.AstLambda) and not returnNode.values[1] then
				if outputDebugInfo then
					file:write(indentStr, "-- return\n")
				end

			else
				file:write(indentStr, "return")
				for i, expr in ipairs(returnNode.values) do
					if i > 1 then  file:write(",")  end
					file:write(" ")
					writeExpression(state, file, expr)
				end
				file:write("\n")
			end

		elseif nodeType == !(nodeTypes.AstBlock) then
			local block = statement.what
			file:write(indentStr, "do\n")
			writeImperativeBlock(state, file, block, indent+1, nextLocalN)
			file:write(indentStr, "end\n")

		elseif nodeType == !(nodeTypes.AstIf) then
			-- @Optimize: Don't output empty branches.
			local ifBranch = statement.what
			file:write(indentStr, "if ")
			writeExpression(state, file, ifBranch.condition)
			file:write(" then\n")

			writeImperativeBlock(state, file, ifBranch.branchTrue, indent+1, nextLocalN)

			if ifBranch.branchFalse then
				file:write(indentStr, "else\n")
				writeImperativeBlock(state, file, ifBranch.branchFalse, indent+1, nextLocalN)
			end

			file:write(indentStr, "end\n")

		elseif nodeType == !(nodeTypes.AstWhile) then
			-- @Optimize: Don't output an empty body.
			local whileLoop = statement.what
			file:write(indentStr, "while ")
			writeExpression(state, file, whileLoop.condition)
			file:write(" do\n")

			writeImperativeBlock(state, file, whileLoop.body, indent+1, nextLocalN)

			file:write(indentStr, "end\n")

		elseif isAny(nodeType, !(nodeTypes.AstImport),!(nodeTypes.AstUsing)) then
			-- void  (Ignore these statements.)

		else
			-- Assume the statement is an expression at this point and let writeExpression() deal with any errors.
			file:write(indentStr)
			writeExpression(state, file, statement.what)
			file:write(";\n") -- The ';' removes ambiguity is some cases.
		end
	end
end

function _G.writeFunction(state, file, lambda)
	if lambda.bodyIsForeign then
		if lambda.foreignSource == "lua" then
			assert(lambda.foreignSourceName ~= "")
			file:write("(", lambda.foreignSourceName, ")") -- Too straightforward?
		else
			errorInternal(lambda.foreignSource)
		end
		return
	end

	file:write("function(")

	if lambda.argumentsIn then
		for i, arg in ipairs(lambda.argumentsIn) do
			if i > 1 then  file:write(", ")  end

			local decl = arg.declaration

			if decl.name.nodeType == !(nodeTypes.AstVararg) then
				decl.localName = "..."
			else
				decl.localName = state.settings.outputDebugInfo and "A"..i.."_"..unicodeToLuaIdentifier(decl.name.name) or "A"..i
			end

			file:write(decl.localName)
		end
	end

	file:write(")\n")

	if lambda.body[1] then
		writeImperativeBlock(state, file, lambda.body, 1, 1)
	elseif state.settings.outputDebugInfo then
		file:write("\t-- Empty function.\n")
	end

	file:write("end")
end

function _G.writeConstantValue(state, file, const)
	local tag = const.valueType.tag

	if tag == !(typeTags.TypeInfoBool) then
		file:write(const.value and "true" or "false")

	elseif tag == !(typeTags.TypeInfoInt) then
		-- %.0f handles larger values than %d and with no wrapping. (I think the former is 64-bit
		-- float and the latter 32-bit int.) %d would not work if trying to write the size of a
		-- large file, for example.
		local nStr = F("%.0f", const.value)

		if not nStr:find"^%-?%d+$" then
			errorLine("ProgramWriter", "Cannot write value as integer: %s", tostring(const.value))
		end
		file:write(nStr)

	elseif tag == !(typeTags.TypeInfoNil) then
		file:write("nil")

	elseif tag == !(typeTags.TypeInfoFloat) then
		local floatStr = tostring(const.value) -- @Robustness: Preserve precision as well as possible.
		if not floatStr:find(".", 1, true) then  floatStr = floatStr..".0"  end
		file:write(floatStr)

	elseif tag == !(typeTags.TypeInfoString) then
		file:write(F("%q", const.value))

	elseif tag == !(typeTags.TypeInfoType) then
		local typeInfo = const.value
		file:write(F("%d", typeInfo.id))
		if state.settings.outputDebugInfo then
			file:write("--[[", getFriendlyTypeInfoName(typeInfo):gsub("%]", "%0 "), "]]")
		end

	elseif tag == !(typeTags.TypeInfoTable) then
		errorInternal("@Incomplete: Write table.")

	elseif tag == !(typeTags.TypeInfoArray) then
		errorInternal("@Incomplete: Write array.")

	elseif tag == !(typeTags.TypeInfoFunction) then
		local lambda = const.value
		writeFunction(state, file, lambda)

	elseif tag == !(typeTags.TypeInfoStruct) then
		errorInternal("@Incomplete: Write struct.")

	elseif tag == !(typeTags.TypeInfoEnum) then
		errorInternal("@Incomplete: Write enum.")

	elseif isAny(tag, !(typeTags.TypeInfoAny),!(typeTags.TypeInfoNamespace),!(typeTags.TypeInfoVoid),!(typeTags.TypeInfoCompound),!(typeTags.TypeInfoList)) then
		errorInternal("Cannot write invalid value type '%s'.", TYPE_TAG_NAMES[tag])
	else
		errorInternal("Incomplete: Handle constant value of type '%s'.", (TYPE_TAG_NAMES[tag] or "?"))
	end
end

function _G.writeConstantValueOrReference(state, file, const)
	if const.isObject then
		file:write(const.name)
	else
		return writeConstantValue(state, file, const)
	end
end

function _G.writeProgram(state)
	if not state.settings.doOutputFile then  return  end

	local path = state.settings.outputFilePath
	local file = assert(io.open(path, "w"))

	--
	-- Forward declarations.
	--

	-- @Polish: Treat function constants pointing to the same foreign function as the same constant.

	-- Constants, non-functions.
	for _, const in ipairs(state.constants) do
		if const.isObject and const.valueType.tag ~= !(typeTags.TypeInfoFunction) then
			file:write("local ", const.name, " = ")
			writeConstantValue(state, file, const) -- Only functions need everything to be forward declared.
			file:write("\n")
		end
	end

	if state.constants[1] or state.topScopeNames[1] then
		local first = true
		file:write("local ")

		-- Constants, functions.
		for _, const in ipairs(state.constants) do
			if const.valueType.tag == !(typeTags.TypeInfoFunction) then
				if not first then  file:write(", ")  end
				first = false
				file:write(const.name)
			end
		end

		-- Top-level declarations. (Note: Glóa globals are not Lua globals.)
		for _, topScopeName in ipairs(state.topScopeNames) do
			if not first then  file:write(", ")  end
			first = false
			file:write(topScopeName)
		end

		file:write("\n")
	end

	--
	-- Definitions.
	--

	-- Function definitions.
	for _, const in ipairs(state.constants) do
		if const.valueType.tag == !(typeTags.TypeInfoFunction) then
			file:write(const.name, " = ")
			writeConstantValue(state, file, const)
			file:write("\n")
		end
	end

	!local ENTRY_POINT_NAME = "main" -- @Incomplete: Configurable entry point name.
	local mainFuncDecl      = nil

	-- Global assignments.
	for _, decl in ipairs(state.globalScope.declarations) do
		if decl.topScopeName ~= "" then
			file:write(decl.topScopeName, " = ")
			writeConstantValueOrReference(state, file, decl.valueConstant)
			file:write("\n")
		end
		if decl.name.name == !(ENTRY_POINT_NAME) then  mainFuncDecl = decl  end
	end
	-- File-scope assignments.
	for _, fileScope in ipairs(state.globalScope.fileScopes) do
		for _, decl in ipairs(fileScope.declarations) do
			if decl.topScopeName ~= "" then
				file:write(decl.topScopeName, " = ")
				writeConstantValueOrReference(state, file, decl.valueConstant)
				file:write("\n")
			end
			if decl.name.name == !(ENTRY_POINT_NAME) then  mainFuncDecl = decl  end
		end
	end

	--
	-- Program entry point.
	--

	if not mainFuncDecl then
		local filePaths = {}
		for i, fileScope in ipairs(state.globalScope.fileScopes) do
			filePaths[i] = fileScope.path
		end
		errorLine(
			"ProgramWriter",
			!("Missing program entry point ('"..ENTRY_POINT_NAME.."' function) in top-level scope in loaded files:\n- %s"),
			table.concat(filePaths, "\n- ")
		)

	elseif not mainFuncDecl.isConstant then
		nodeError(
			state, mainFuncDecl.name, "ProgramWriter",
			!("Declared name '"..ENTRY_POINT_NAME.."' must be a constant.")
		)

	elseif mainFuncDecl.name.inferredType.tag ~= !(typeTags.TypeInfoFunction) then
		nodeError(
			state, mainFuncDecl.assignment.values[mainFuncDecl.assignmentIndex], "ProgramWriter",
			!("Declared name '"..ENTRY_POINT_NAME.."' must be a function to represent the entry point of the program.")
		)

	elseif mainFuncDecl.name.inferredType.argumentTypesIn[1] then
		local lambda = getAssignmentValue(state, mainFuncDecl.name, mainFuncDecl.assignment.values, mainFuncDecl.assignmentIndex)
		nodeError(state, lambda.argumentsIn, "ProgramWriter", "Program entry point function must not take any arguments.")

	elseif mainFuncDecl.name.inferredType.argumentTypesOut[1] then
		local lambda = getAssignmentValue(state, mainFuncDecl.name, mainFuncDecl.assignment.values, mainFuncDecl.assignmentIndex)
		nodeError(state, lambda.argumentsOut, "ProgramWriter", "Program entry point function must not return any values.")
	end

	writeConstantValueOrReference(state, file, mainFuncDecl.valueConstant)
	file:write("()\n")

	file:close()
end



local UNICODE_TO_ASCII = @insert "unicodeConversions.luapart"

function _G.unicodeToLuaIdentifier(name)
	name = name:gsub(!(UTF8_CHARACTER_PATTERN), function(c)
		return (#c == 1 and c) or UNICODE_TO_ASCII[c] or "_"
	end)
	return name
end


