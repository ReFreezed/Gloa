--[[============================================================
--=
--=  Program Writer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	doesTypeHaveAnyDefaultValue
	unicodeToLuaIdentifier, isExpressionLiteralStringAndValidLuaIdentifier
	validateForeignSource
	writeProgram, write*

----------------------------------------------------------------

	Format for written programs:
	- Foreign imports.
	- Constants.
	- Forward declarations.
	- Functions.
	- Global/file-scope variables.
	- Program entry point.

	Notes:
	- No Lua globals are read from or written to. (Glóa globals are not Lua globals.)
	- All functions are top-level in Lua no matter where they were defined in Glóa.
	- Local variables in Lua are uniquely named and thus never shadow anything (which might help with debugging).

	@Incomplete:
	- Handle the limited amount of locals Lua allows (200). (Maybe we'll have to use Lua globals to some extent after all.)

--============================================================]]



local FOREIGN_API_COMPILER_SYMBOLS = {
	-- APP_PATH
	-- Get the path to the application file. The path may be relative to the current working directory.
	APP_PATH = `(debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get application path.")) :gsub("\\", "/")`,

	-- APP_DIRECTORY
	-- Get the path to the directory the application is located in. The path may be relative to the current working directory.
	APP_DIRECTORY = `(debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get application path.")) :gsub("\\", "/"):gsub("/?[^/]+$", ""):gsub("^$", ".")`,

	-- COMPILER_PATH
	-- Get the path to the compiler. This will be a hardcoded value in the compiled program.
	COMPILER_PATH = F("%q", COMPILER_PATH),

	-- COMPILER_DIRECTORY
	-- Get the path to the directory the compiler is located in. This will be a hardcoded value in the compiled program.
	COMPILER_DIRECTORY = F("%q", COMPILER_DIRECTORY),

	-- wrapFunctionInGloaErrorHandler()
	-- Make Glóa handle errors triggered by a function.
	--
	-- This is useful if an external library or framework tries to handle an error
	-- triggered by a callback provided by you, but you instead want to trigger a
	-- normal Glóa error before the library knows what happened.
	--
	-- wrappedFunction = wrapFunctionInGloaErrorHandler( function )
	--
	wrapFunctionInGloaErrorHandler = `function(cb)
		return function(...)
			local args = {n=select("#", ...), ...}

			if not xpcall(
				function()
					cb(unpack(args, 1, args.n))
				end,
				gloaErrorHandler
			) then
				os.exit(1) -- In case there was an error in gloaErrorHandler() for some reason.
			end
		end
	end`,
}

local LUA_KEYWORDS = !(Set{"and","break","do","else","elseif","end","false","for","function","goto","if","in","local","nil","not","or","repeat","return","then","true","until","while"})



function _G.writeIdentifierName(state, file, ident)
	local decl = ident.declaration
	local name = decl.topScopeName

	if name == "" then  name = decl.localName  end

	if name == "" then
		astPrint(ident)
		printTraceback(io.stderr)
		nodeError(state, ident, "ProgramWriter", "Internal compiler error: Missing name to write for '%s'.", ident.name)
	end

	file:write(name)
end

function _G.writeStringLiteral(file, name)
	local s = F("%q", name):gsub("\\\n", "\\n")
	file:write(s)
end

function _G.writeStringConcatenation(state, file, binary)
	if binary.left.nodeType == !(nodeTypes.AstBinary) and binary.left.operation == ".." then
		writeStringConcatenation(state, file, binary.left)
	else
		writeExpression(state, file, binary.left)
	end
	file:write(" .. ")
	if binary.right.nodeType == !(nodeTypes.AstBinary) and binary.right.operation == ".." then
		writeStringConcatenation(state, file, binary.right)
	else
		writeExpression(state, file, binary.right)
	end
end

function _G.writeAccess(state, file, access)
	if isAny(access.object.inferredType.tag, !(typeTags.TypeInfoStruct),!(typeTags.TypeInfoTable),!(typeTags.TypeInfoArray)) then
		-- @Incomplete: Compiler setting for runtime checks of array bounds.
		writeExpression(state, file, access.object)

		if access.parent.nodeType == !(nodeTypes.AstCall) and access.parent.isMethod then
			local stringLiteral = access.member
			assert(stringLiteral.nodeType == !(nodeTypes.AstLiteral) and stringLiteral.literalType == !(LITERAL_STRING))

			if not stringLiteral.value:find"^[%a_][%w_]*$" then
				errorInternal("@Incomplete: Support method calls using names containing non-ASCII characters.")
			elseif LUA_KEYWORDS[stringLiteral.value] then
				errorInternal("@Incomplete: Support method calls using names that are keywords in Lua.")
			end

			file:write(":", stringLiteral.value)

		elseif isExpressionLiteralStringAndValidLuaIdentifier(access.member) then
			local stringLiteral = access.member
			file:write(".", stringLiteral.value)

		else
			file:write("[")
			writeExpression(state, file, access.member)
			file:write("]")
		end

	elseif access.object.inferredType.tag == !(typeTags.TypeInfoEnum) then
		errorInternal() -- Enum accesses should have been simplified away.

	else
		errorUnhandledNodeType(state, access.object)
	end
end

-- writeCast( state, file, cast [, nameToCast ] )
-- nameToCast is only used by AstConditional.
function _G.writeCast(state, file, cast, nameToCast)
	!local WRITE_EXPRESSION = trimTemplate`
		if nameToCast then
			file:write(nameToCast)
		else
			writeExpression(state, file, cast.expression)
		end
	`

	local typeInfoSource = adjustTypeToOne(state, cast.expression.inferredType, true)
	local typeInfoTarget = cast.inferredType

	file:write("(") -- In case the written expression is a list of some kind.

	if
		typeInfoSource == typeInfoTarget
		or typeInfoSource.tag == !(typeTags.TypeInfoCompound)
		or typeInfoTarget.tag == !(typeTags.TypeInfoCompound)
	then
		!!(WRITE_EXPRESSION)

	-- int -> float
	elseif typeInfoSource.tag == !(typeTags.TypeInfoInt) and typeInfoTarget.tag == !(typeTags.TypeInfoFloat) then
		!!(WRITE_EXPRESSION)

	-- float -> int
	elseif typeInfoSource.tag == !(typeTags.TypeInfoFloat) and typeInfoTarget.tag == !(typeTags.TypeInfoInt) then
		file:write("(_MATH_MODF(")
		!!(WRITE_EXPRESSION)
		file:write("))")

	-- (numeric) -> bool
	elseif isTypeNumeric(typeInfoSource) and typeInfoTarget.tag == !(typeTags.TypeInfoBool) then
		!!(WRITE_EXPRESSION)
		file:write(" ~= 0")

	-- string -> bool
	elseif typeInfoSource.tag == !(typeTags.TypeInfoString) and typeInfoTarget.tag == !(typeTags.TypeInfoBool) then
		!!(WRITE_EXPRESSION)
		file:write(' ~= ""')

	-- array -> bool
	elseif typeInfoSource.tag == !(typeTags.TypeInfoArray) and typeInfoTarget.tag == !(typeTags.TypeInfoBool) then
		!!(WRITE_EXPRESSION)
		file:write("[1] ~= nil")

	-- (whatever) -> any
	-- any -> (whatever)
	elseif typeInfoSource.tag == !(typeTags.TypeInfoAny) or typeInfoTarget.tag == !(typeTags.TypeInfoAny) then
		-- The user better know what they're doing!
		-- @Incomplete: Compiler setting for runtime checks of 'any' and 'compound' casts.
		!!(WRITE_EXPRESSION)

	-- enum -> (real enum member type)
	elseif typeInfoSource.tag == !(typeTags.TypeInfoEnum) and typeInfoTarget == typeInfoSource.memberTypeInfo then
		!!(WRITE_EXPRESSION)

	else
		errorInternal(state, cast, "Incomplete: Handle casting from %s to %s.", getFriendlyTypeInfoName(typeInfoSource), getFriendlyTypeInfoName(typeInfoTarget))
	end

	file:write(")")
end

function _G.writeTableConstructorKeyName(file, name)
	if name:find"^[%a_][%w_]*$" and not LUA_KEYWORDS[name] then
		file:write(name)
	else
		file:write("[")
		writeStringLiteral(file, name)
		file:write("]")
	end
end

function _G.writeDefaultValueForStructMember(state, file, structInfo, member, nodeForError)
	local decl = findMemberDeclaration(state, structInfo.astNode, member.name) or errorInternal("Did not find member '%s'", member.name)
	if decl.assignment then
		local valueExpr = decl.assignment.values[1] or errorInternal()
		writeExpression(state, file, valueExpr)
	else
		writeDefaultValueForType(state, file, member.typeInfo, nodeForError)
	end
end

local function findTableFieldInStructInitializer(tableNode, memberName)
	for _, tableField in ipairs(tableNode.fields) do
		!ASSERT("tableField.key.nodeType == "..nodeTypes.AstLiteral)

		if tableField.key.value == memberName then
			return tableField
		end
	end

	return nil
end

local function doesTypeContainBoolOrNone(typeInfo)
	if isAny(typeInfo.tag, !(typeTags.TypeInfoBool),!(typeTags.TypeInfoNone),!(typeTags.TypeInfoAny)) then  return true  end

	if typeInfo.tag ~= !(typeTags.TypeInfoCompound) then  return false  end
	local compound = typeInfo

	for _, compoundItem in ipairs(compound) do
		if isAny(compoundItem.tag, !(typeTags.TypeInfoBool),!(typeTags.TypeInfoNone)) then  return true  end
	end
	return false
end

function _G.writeExpression(state, file, expr)
	if expr.nodeType == !(nodeTypes.AstCall) then
		local call   = expr
		local callee = call.callee

		if call.surroundedByParenthesis then  file:write("(")  end

		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			assert(callee.declaration.valueConstant)
			writeConstantValueOrReference(state, file, callee.declaration.valueConstant)
		else
			writeExpression(state, file, callee)
		end

		local argsNeedParenthesis = true
		--[[ @Incomplete: Consider optional arguments if omitting parenthesis.
		local argsNeedParenthesis = not (
			#call.arguments == 1 and (
				call.arguments[1].nodeType == !(nodeTypes.AstTable)
				or (
					call.arguments[1].nodeType == !(nodeTypes.AstLiteral)
					and call.arguments[1].literalType == !(LITERAL_STRING)
				)
			)
		)
		]]

		if argsNeedParenthesis then  file:write("(")  end

		local first = true

		-- Write given arguments.
		for _, argExpr in ipairs(call.arguments) do
			if not first then  file:write(", ")  end
			first = false
			writeExpression(state, file, argExpr)
		end

		-- Write default values for arguments.
		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			local calleeDecl = callee.declaration

			if calleeDecl.isConstant then
				local assignment = calleeDecl.assignment
				local lambda     = assignment.values[calleeDecl.assignmentIndex] or errorInternal()
				!ASSERT("lambda.nodeType == "..nodeTypes.AstLambda)

				-- Only write a value if the last non-vararg argument is optional.
				local argLast = lambda.argumentsIn and getLast(lambda.argumentsIn.arguments)
				if argLast and argLast.declaration.name.nodeType == !(nodeTypes.AstVararg) then
					argLast = getLast(lambda.argumentsIn.arguments, 2)
				end

				if argLast and not argLast.isRequired then
					local argExprLast = getLast(call.arguments)
					if
						argExprLast and (
							(
								argExprLast.inferredType.tag == !(typeTags.TypeInfoVararg)
								and not argExprLast.surroundedByParenthesis
							)
							or (
								argExprLast.inferredType.tag == !(typeTags.TypeInfoList)
								and not argExprLast.surroundedByParenthesis
								and argExprLast.inferredType[2]
							)
						)
					then
						-- :DisallowListAsLastValueToFunctionWithOptionalArguments
						nodeError(state, callee, "ProgramWriter", "@Incomplete: Handle optional arguments if the last value in a call is a list of things.")
					end

					for i = #call.arguments+1, #lambda.argumentsIn.arguments do
						if not first then  file:write(", ")  end
						first = false

						local arg = lambda.argumentsIn.arguments[i]

						if arg.assignment then -- Varargs are optional but have no default value (or zero default values, since it's a list).
							writeExpression(state, file, arg.assignment.values[1])
						end
					end
				end
			end
		end

		if argsNeedParenthesis then  file:write(")")  end

		if call.surroundedByParenthesis then  file:write(")")  end

	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		local unary = expr
		if unary.operation == "+" then
			writeExpression(state, file, unary.expression)
		else
			file:write("(", unary.operation, " ")
			writeExpression(state, file, unary.expression)
			file:write(")")
		end

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr

		if binary.operation == ".." then
			file:write("(")
			writeStringConcatenation(state, file, binary) -- This makes sure consecutive string concatenations appear as one operation without any parenthesis.
			file:write(")")

		elseif binary.operation == "//" then
			file:write("_MATH_FLOOR(")
			writeExpression(state, file, binary.left)
			file:write(" / ")
			writeExpression(state, file, binary.right)
			file:write(")")

		else
			file:write("(")
			writeExpression(state, file, binary.left)
			file:write(" ", binary.operation, " ")
			writeExpression(state, file, binary.right)
			file:write(")")
		end

	elseif expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		writeConstantValue(state, file, literal.valueConstant)

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr

		if ident.declaration.isConstant then
			if ident.inferredType.tag == !(typeTags.TypeInfoEnum) and not isPartOfAnyDeclaration(ident) then -- @Cleanup: This detection seem bit misplaced.
				local valueExpr = ident.declaration.assignment.values[1] or errorInternal()
				writeExpression(state, file, valueExpr)
			else
				writeConstantValueOrReference(state, file, ident.declaration.valueConstant)
			end

		else
			writeIdentifierName(state, file, ident)
		end

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		file:write(F("%d", typeNode.representedType.id)) -- @Cleanup: We probably have a constant for the type ID to use with writeConstantValue() here, but who cares...
		if state.settings.outputDebugInfo then
			file:write("--[[", getFriendlyTypeInfoName(typeNode.representedType):gsub("%]", "%0 "), "]]")
		end

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda   = expr
		local constant = itemWith1(state.constants, "valueType", lambda.inferredType) or errorInternal()
		writeConstantValueOrReference(state, file, constant)

	elseif expr.nodeType == !(nodeTypes.AstVararg) then
		local vararg = expr
		file:write(vararg.surroundedByParenthesis and "(...)" or "...")

	elseif expr.nodeType == !(nodeTypes.AstAccess) then
		local access = expr
		writeAccess(state, file, access)

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		writeCast(state, file, cast)

	elseif expr.nodeType == !(nodeTypes.AstTable) then
		local tableNode = expr
		file:write("{")

		if tableNode.inferredType.tag == !(typeTags.TypeInfoTable) then
			for i, tableField in ipairs(tableNode.fields) do
				if i > 1 then  file:write(", ")  end

				if isExpressionLiteralStringAndValidLuaIdentifier(tableField.key) then
					local stringLiteral = tableField.key
					file:write(stringLiteral.value)
				else
					-- @Polish: Output sequence values without key in 'table' type tables.
					file:write("[")
					writeExpression(state, file, tableField.key)
					file:write("]")
				end
				file:write("=")
				writeExpression(state, file, tableField.value)
			end

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoArray) then
			local items = {}

			for _, tableField in ipairs(tableNode.fields) do
				!ASSERT("tableField.key.nodeType == "..nodeTypes.AstLiteral)

				local literal     = tableField.key
				local arrayIndex  = literal.value
				items[arrayIndex] = tableField.value
			end

			for arrayIndex, expr in ipairs(items) do
				if arrayIndex > 1 then  file:write(", ")  end
				writeExpression(state, file, expr)
			end

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = tableNode.inferredType

			for i, member in ipairs(structInfo.members) do
				if i > 1 then  file:write(", ")  end

				local tableField = findTableFieldInStructInitializer(tableNode, member.name)

				writeTableConstructorKeyName(file, member.name)
				file:write("=")

				if tableField then
					writeExpression(state, file, tableField.value)
				else
					writeDefaultValueForStructMember(state, file, structInfo, member, tableNode) -- @UX: Maybe use a better nodeForError.
				end
			end

		else
			errorUnhandledNodeType(state, tableNode)
		end

		file:write("}")

	elseif expr.nodeType == !(nodeTypes.AstForeign) then
		local foreign = expr
		writeConstantValueOrReference(state, file, foreign.valueConstant)

	elseif expr.nodeType == !(nodeTypes.AstConditional) then
		local conditional = expr
		local hasVararg   = false

		astVisitAllNodes(conditional, function(node)
			if node.nodeType == !(nodeTypes.AstVararg) then
				hasVararg = true
				return !(VISIT_BREAK)
			elseif isScope(node) then
				return !(VISIT_IGNORE_CHILDREN)
			end
		end)

		-- Ternary.
		if not conditional.conditionAndBranchTrue then
			if doesTypeContainBoolOrNone(adjustTypeToOne(state, conditional.branchTrue.inferredType, true)) then
				-- (function(x) if x then return a else return b end end)(x)
				file:write("(function(_CONDITION")
				if hasVararg then  file:write(", ...")  end
				file:write(") if _CONDITION then return ")
				writeExpression(state, file, conditional.branchTrue)
				file:write(" else return ")
				writeExpression(state, file, conditional.branchFalse)
				file:write(" end end)(")
				writeExpression(state, file, conditional.condition)
				if hasVararg then  file:write(", ...")  end
				file:write(")")
			else
				-- x and a or b
				file:write("(")
				writeExpression(state, file, conditional.condition)
				file:write(" and ")
				writeExpression(state, file, conditional.branchTrue)
				file:write(" or ")
				writeExpression(state, file, conditional.branchFalse)
				file:write(")")
			end

		-- Binary (with implicit cast).
		-- @Optimize: Output 'a or b' whenever possible.
		elseif conditional.conditionAndBranchTrue ~= conditional.condition then
			-- (function(x) if x then return x else return y end end)(x)
			local cast = conditional.condition
			assert(cast.nodeType   == !(nodeTypes.AstCast))
			assert(cast.expression == conditional.conditionAndBranchTrue)
			assert(cast.isImplicit)

			file:write("(function(_CONDITION")
			if hasVararg then  file:write(", ...")  end
			file:write(") if ")
			writeCast(state, file, cast, "_CONDITION")
			file:write(" then return _CONDITION else return ")
			writeExpression(state, file, conditional.branchFalse)
			file:write(" end end)(")
			writeExpression(state, file, cast.expression)
			if hasVararg then  file:write(", ...")  end
			file:write(")")

		-- Binary (without implicit cast).
		-- @Optimize: Output 'a or b' whenever possible.
		else
			-- (function(x) if x then return x else return y end end)(x)
			file:write("(function(_CONDITION")
			if hasVararg then  file:write(", ...")  end
			file:write(") if _CONDITION then return _CONDITION else return ")
			writeExpression(state, file, conditional.branchFalse)
			file:write(" end end)(")
			writeExpression(state, file, conditional.condition)
			if hasVararg then  file:write(", ...")  end
			file:write(")")
		end

	else
		errorUnhandledNodeType(state, expr)
	end
end

function _G.writeDefaultValueForType(state, file, typeInfo, nodeForError)
	local tag = typeInfo.tag

	if tag == !(typeTags.TypeInfoBool) then
		file:write("false")
	elseif tag == !(typeTags.TypeInfoInt) then
		file:write("0")
	elseif tag == !(typeTags.TypeInfoNone) then
		file:write("nil")
	elseif tag == !(typeTags.TypeInfoFloat) then
		file:write("0.0")
	elseif tag == !(typeTags.TypeInfoString) then
		file:write('""')
	elseif tag == !(typeTags.TypeInfoType) then
		file:write("0") -- @Robustness: Maybe 'type' variables should have no defult value and this should be an error. :DefaultValueForTypes
	elseif tag == !(typeTags.TypeInfoArray) or tag == !(typeTags.TypeInfoTable) then
		file:write("{}")

	elseif tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		file:write("{")

		for i, member in ipairs(structInfo.members) do
			if i > 1 then  file:write(", ")  end
			writeTableConstructorKeyName(file, member.name)
			file:write("=")
			writeDefaultValueForStructMember(state, file, structInfo, member, nodeForError)
		end

		file:write("}")

	elseif doesTypeHaveAnyDefaultValue(typeInfo) then
		errorInternal("Incomplete: Write default value for type group '%s'.", TYPE_TAG_NAMES[typeInfo.tag])
	else
		nodeError(state, nodeForError, "ProgramWriter", "There is no default value for %s.", getFriendlyTypeInfoName(typeInfo))
	end
end

local function isNameAllocated(state, localsStack, localName)
	if state.topScopeNames[localName] then  return true  end

	for _, locals in ipairs(localsStack) do
		if locals[localName] then  return true  end
	end

	return false
end

local function allocateName(state, localsStack, name, n, shortPrefix, longInfix)
	if name == "_" then  return name  end -- @Incomplete: Make "_" a write-only name.

	local localName

	if state.settings.outputDebugInfo then
		localName = unicodeToLuaIdentifier(name)
		if isNameAllocated(state, localsStack, localName) then
			localName = localName..longInfix..n
		end
	else
		localName = shortPrefix..n
	end

	localsStack[1][localName] = true

	return localName, n+1
end
local function allocateLocalName(state, localsStack, name, n)
	return allocateName(state, localsStack, name, n, "L", "_L")
end
local function allocateArgumentName(state, localsStack, name, n)
	return allocateName(state, localsStack, name, n, "A", "_A")
end

local function writeLoopBodyAndFooter(state, file, loop, indent, nextLocalN, localsStack)
	local indentStr = ("\t"):rep(indent)

	if not (loop.hasNamedBreaks or state.loopStack[1]) then
		writeBlock(state, file, loop.body, indent+1, nextLocalN, localsStack)
		file:write(indentStr, "end\n")
		return
	end

	if not state.loopStack[1] then
		file:write(indentStr, "\tlocal _BREAK = 0\n")
	end

	table.insert(state.loopStack, loop)
	writeBlock(state, file, loop.body, indent+1, nextLocalN, localsStack)
	file:write(indentStr, "end\n")
	table.remove(state.loopStack)

	if state.loopStack[2] then
		file:write(indentStr, "if _BREAK > 0 then  _BREAK = _BREAK-1 ; break  end\n")
	elseif state.loopStack[1] then
		file:write(indentStr, "if _BREAK > 0 then  break  end\n")
	end
end

-- writeBlock( state, file, block, indent, nextLocalN, localsStack [, isElseif=false ] )
function _G.writeBlock(state, file, block, indent, nextLocalN, localsStack, isElseif)
	!ASSERT `not block[1]`

	local outputDebugInfo = state.settings.outputDebugInfo
	local indentStr       = ("\t"):rep(indent)

	if not block.statements[1] then
		if outputDebugInfo then
			file:write(indentStr, "-- Empty block.\n")
		end
		return
	end

	localsStack  = {{}, unpack(localsStack)}
	local inDecl = false

	for _, statement in ipairs(block.statements) do
		local nodeType = statement.nodeType

		if nodeType == !(nodeTypes.AstDeclaration) then
			local decl = statement

			if decl.isConstant then
				skipNextAssignment = true

			else
				decl.localName, nextLocalN = allocateLocalName(state, localsStack, decl.name.name, nextLocalN)

				if decl.assignment then
					inDecl = true
					if decl.assignmentIndex == 1 then
						file:write(indentStr, "local ")
					end

				else
					local tag = decl.name.inferredType.tag
					file:write(indentStr, "local ", decl.localName, " = ")
					writeDefaultValueForType(state, file, decl.name.inferredType, decl.name)
					file:write(";\n")
				end

				-- The initial assignment, if there is one, should be written as the next statement (or after several declarations).
			end

		elseif nodeType == !(nodeTypes.AstAssignment) then
			if not skipNextAssignment then
				local assignment = statement
				assert(assignment.operation == "=", "@Incomplete: Support more than '='.")

				if not inDecl then
					file:write(indentStr)
				end
				for i, targetExpr in ipairs(assignment.targets) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, file, targetExpr)
				end
				file:write(" ", assignment.operation, " ")
				for i, expr in ipairs(assignment.values) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, file, expr)
				end
				file:write(";\n") -- The ';' removes ambiguity is some cases.
			end

			inDecl             = false
			skipNextAssignment = false

		elseif nodeType == !(nodeTypes.AstReturn) then
			local returnNode = statement

			if block.parent.nodeType == !(nodeTypes.AstLambda) and not returnNode.values[1] then
				if outputDebugInfo then
					file:write(indentStr, "-- return\n")
				end

			else
				file:write(indentStr, "return")
				for i, expr in ipairs(returnNode.values) do
					if i > 1 then  file:write(",")  end
					file:write(" ")
					writeExpression(state, file, expr)
				end
				file:write("\n")
			end

		elseif nodeType == !(nodeTypes.AstBlock) then
			local block = statement
			file:write(indentStr, "do\n")
			writeBlock(state, file, block, indent+1, nextLocalN, localsStack)
			file:write(indentStr, "end\n")

		elseif nodeType == !(nodeTypes.AstIf) then
			-- @Optimize: Don't output empty branches.
			local ifBranch = statement

			if not isElseif then  file:write(indentStr)  end

			file:write("if ")
			writeExpression(state, file, ifBranch.condition)
			file:write(" then\n")

			writeBlock(state, file, ifBranch.branchTrue, indent+1, nextLocalN, localsStack)

			if not (ifBranch.branchFalse and ifBranch.branchFalse.statements[1]) then
				-- void

			elseif not ifBranch.branchFalse.statements[2] and ifBranch.branchFalse.statements[1].nodeType == !(nodeTypes.AstIf) then
				file:write(indentStr, "else") -- This will be followed by "if"
				writeBlock(state, file, ifBranch.branchFalse, indent, nextLocalN, localsStack, true)

			else
				file:write(indentStr, "else\n")
				writeBlock(state, file, ifBranch.branchFalse, indent+1, nextLocalN, localsStack)
			end

			if not isElseif then  file:write(indentStr, "end\n")  end

		elseif nodeType == !(nodeTypes.AstWhile) then
			-- @Optimize: Don't output an empty body.
			local whileLoop = statement

			file:write(indentStr, "while ")
			writeExpression(state, file, whileLoop.condition)
			file:write(" do\n")
			writeLoopBodyAndFooter(state, file, whileLoop, indent, nextLocalN, localsStack)

		elseif nodeType == !(nodeTypes.AstFor) then
			-- @Optimize: Don't output an empty body.
			local forLoop     = statement
			local localsStack = {{}, unpack(localsStack)}

			for _, decl in ipairs(forLoop.declarations) do
				decl.localName, nextLocalN = allocateLocalName(state, localsStack, decl.name.name, nextLocalN)
			end

			if forLoop.forType == !(FOR_NUMERIC) then
				local decl   = forLoop.declarations[1]
				local values = forLoop.expressions

				file:write(indentStr, "for ")
				writeIdentifierName(state, file, decl.name)
				file:write(" = ")
				writeExpression(state, file, values[1])
				file:write(", ")
				writeExpression(state, file, values[2])
				if values[3] then
					file:write(", ")
					writeExpression(state, file, values[3])
				end
				file:write(" do\n")
				writeLoopBodyAndFooter(state, file, forLoop, indent, nextLocalN, localsStack)

			elseif forLoop.forType == !(FOR_SHORT) then
				local objExpr = forLoop.expressions[1]

				file:write(indentStr, "for ")

				for i, decl in ipairs(forLoop.declarations) do
					if i > 1 then  file:write(", ")  end
					writeIdentifierName(state, file, decl.name)
				end

				file:write(" in ")

				if objExpr.inferredType.tag == !(typeTags.TypeInfoArray) then
					file:write("_IPAIRS")
				elseif objExpr.inferredType.tag == !(typeTags.TypeInfoTable) then
					file:write("_PAIRS")
				elseif objExpr.inferredType.tag == !(typeTags.TypeInfoStruct) then
					errorUnhandledNodeType(state, objExpr)
					-- writeConstantValueOrReference(state, file, interatorFuncConst?) -- @Incomplete: Output default iterator for the struct.
				else
					errorInternal()
				end

				file:write("(")
				writeExpression(state, file, objExpr)
				file:write(") do\n")
				writeLoopBodyAndFooter(state, file, forLoop, indent, nextLocalN, localsStack)

			else--if forLoop.forType == !(FOR_ITERATOR) then
				file:write(indentStr, "for ")

				for i, decl in ipairs(forLoop.declarations) do
					if i > 1 then  file:write(", ")  end
					writeIdentifierName(state, file, decl.name)
				end
				file:write(" in ")
				for i, valueExpr in ipairs(forLoop.expressions) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, file, valueExpr)
				end
				file:write(" do\n")
				writeLoopBodyAndFooter(state, file, forLoop, indent, nextLocalN, localsStack)
			end

		elseif nodeType == !(nodeTypes.AstBreak) then
			local breakNode = statement

			if breakNode.loop then
				local i                 = indexOf(state.loopStack, breakNode.loop) or errorInternal(state, breakNode)
				local outerLoopsToBreak = #state.loopStack-i
				file:write(indentStr, "_BREAK = ",outerLoopsToBreak," ; break\n")
			else
				file:write(indentStr, "break\n")
			end

		elseif isAny(nodeType, !(nodeTypes.AstImport),!(nodeTypes.AstUsing)) then
			-- void  (Ignore these statements.)

		else
			-- Assume the statement is an expression at this point and let writeExpression() deal with any errors.
			file:write(indentStr)
			writeExpression(state, file, statement)
			file:write(";\n") -- The ';' removes ambiguity is some cases.
		end
	end
end

function _G.writeFunction(state, file, lambda)
	!ASSERT `not lambda.body[1]`

	if lambda.bodyIsForeign then
		file:write(state.foreignReferences[lambda.foreignSourceId])
		return
	end

	local localsStack = {{}}

	file:write("function(")

	if lambda.argumentsIn then
		for i, arg in ipairs(lambda.argumentsIn.arguments) do
			if i > 1 then  file:write(", ")  end

			local decl = arg.declaration

			if decl.name.nodeType == !(nodeTypes.AstVararg) then
				decl.localName = "..."
			else
				decl.localName = allocateArgumentName(state, localsStack, decl.name.name, i)
			end

			file:write(decl.localName)
		end
	end

	file:write(")\n")

	if lambda.body.statements[1] then
		writeBlock(state, file, lambda.body, 1, 1, localsStack)
	elseif state.settings.outputDebugInfo then
		file:write("\t-- Empty function.\n")
	end

	file:write("end")
end

function _G.writeForeignImportIfNew(state, file, typeInfo, foreignSource, foreignSourceName, foreignSourceId)
	assert(foreignSourceId ~= "")

	if state.foreignReferences[foreignSourceId] then  return  end

	-- @Incomplete: Compiler setting for runtime checks of anything originating from foreign sources.
	-- (We can probably wrap foreign the code in something here using typeInfo.)

	local foreignN = state.foreignN+1
	state.foreignN = foreignN

	if foreignN == 1 then
		file:write("local _FOREIGN = {}\n")
	end

	if foreignSource == "lua" then
		if outputDebugInfo then
			state.foreignReferences[foreignSourceId] = F("_FOREIGN[%d--[[%s]]]", foreignN, (foreignSourceId:gsub("[%[%]]", "%0 ")))
			file:write("_FOREIGN[", F("%d", foreignN), "]")
		else
			local foreignRef                         = F("_FOREIGN[%d]", foreignN)
			state.foreignReferences[foreignSourceId] = foreignRef
			file:write(foreignRef)
		end

		file:write(" = (", foreignSourceName, ")\n") -- @Robustness: Is this too straightforward?

	elseif foreignSource == "compiler" then
		if outputDebugInfo then
			state.foreignReferences[foreignSourceId] = F("_FOREIGN[%d--[[%s]]]", foreignN, (foreignSourceId:gsub("[%[%]]", "%0 ")))
			file:write("_FOREIGN[", F("%d", foreignN), "]")
		else
			local foreignRef                         = F("_FOREIGN[%d]", foreignN)
			state.foreignReferences[foreignSourceId] = foreignRef
			file:write(foreignRef)
		end

		file:write(" = ", FOREIGN_API_COMPILER_SYMBOLS[foreignSourceName], "\n")

	else
		errorInternal("Incomplete: Handle foreignSource=%s", foreignSource)
	end
end

function _G.writeConstantValue(state, file, const)
	local tag = const.valueType.tag

	if tag == !(typeTags.TypeInfoBool) then
		file:write(const.value and "true" or "false")

	elseif tag == !(typeTags.TypeInfoInt) then
		-- %.0f handles larger values than %d and with no wrapping. (I think the former is 64-bit
		-- float and the latter 32-bit int.) %d would not work if trying to write the size of a
		-- large file, for example.
		local nStr = F("%.0f", const.value)

		if not nStr:find"^%-?%d+$" then
			errorLine("ProgramWriter", "Cannot write value as integer: %s", tostring(const.value))
		end
		file:write(nStr)

	elseif tag == !(typeTags.TypeInfoNone) then
		file:write("nil")

	elseif tag == !(typeTags.TypeInfoFloat) then
		local floatStr = tostring(const.value) -- @Robustness: Preserve precision as well as possible.
		if not floatStr:find(".", 1, true) then  floatStr = floatStr..".0"  end
		file:write(floatStr)

	elseif tag == !(typeTags.TypeInfoString) then
		writeStringLiteral(file, const.value)

	elseif tag == !(typeTags.TypeInfoType) then
		local typeInfo = const.value
		file:write(F("%d", typeInfo.id))
		if state.settings.outputDebugInfo then
			file:write("--[[", getFriendlyTypeInfoName(typeInfo):gsub("%]", "%0 "), "]]")
		end

	elseif tag == !(typeTags.TypeInfoFunction) then
		local lambda = const.value
		writeFunction(state, file, lambda)

	elseif tag == !(typeTags.TypeInfoStruct) then
		errorInternal("@Incomplete: Write struct instance constant.")

	elseif tag == !(typeTags.TypeInfoArray) then
		local arraySig      = const.valueType
		local tableNode     = const.value
		local indexedValues = {}

		for _, tableField in ipairs(tableNode.fields) do
			indexedValues[tableField.key.value] = tableField.value
		end

		file:write("{")
		for i, valueExpr in ipairs(indexedValues) do
			if i > 1 then  file:write(", ")  end
			writeExpression(state, file, valueExpr)
		end
		file:write("}")

	elseif tag == !(typeTags.TypeInfoTable) then
		errorInternal("@Incomplete: Write table constant.")

	elseif tag == !(typeTags.TypeInfoEnum) then
		errorInternal("@Incomplete: Write enum constant.") -- Do we ever get here? I think not.

	elseif tag == !(typeTags.TypeInfoForeignDummy) then
		local foreign = const.value
		file:write(state.foreignReferences[foreign.sourceId])

	elseif isAny(tag, !(typeTags.TypeInfoAny),!(typeTags.TypeInfoNamespace),!(typeTags.TypeInfoCompound),!(typeTags.TypeInfoList)) then
		errorInternal("Cannot write invalid value type '%s'.", TYPE_TAG_NAMES[tag])
	else
		errorInternal("Incomplete: Handle constant value of type '%s'.", (TYPE_TAG_NAMES[tag] or "?"))
	end
end

function _G.writeConstantValueOrReference(state, file, const)
	if const.isObject then
		file:write(const.name)
	else
		return writeConstantValue(state, file, const)
	end
end

function _G.writeProgram(state)
	if not state.settings.doOutputFile then  return  end

	local path = state.settings.outputFilePath
	local file = assert(io.open(path, "w"))

	local outputDebugInfo = state.settings.outputDebugInfo

	-- @Incomplete: Setting to specify the prefix for the written file (shebang and maybe a comment with copyright info, library documentation etc.).
	file:write('#!/bin/sh\n_=[[\nexec lua "$0" "$@"\n]] and nil\n')

	--
	-- Compiler symbols.
	--

	-- @Incomplete: Convert file paths and line numbers to the Glóa source files.
	-- @Polish: Nicer traceback format.
	!(
	local TEMPLATE_ERROR_HANDLER = `
		local function gloaErrorHandler(err)
			local errStr    = tostring(err)
			local traceback = debug.traceback(errStr, 2)
			$tracebackEdits

			$outputFile:write(traceback, "\n")

			os.exit(1)
		end
	`
	local TEMPLATE_TRACEBACK_EDITS = `
		traceback = traceback:gsub("%w[-%w_/]*%.lua:%d+", $filePathPrefix.."%0")
	`
	local TRACEBACK_EDITS = templateToLua(TEMPLATE_TRACEBACK_EDITS, {
		filePathPrefix = toLua(RUNTIME_ERROR_PREFIX:gsub("%%", "%%%%")),
	})
	local ERROR_HANDLER = templateToLua(TEMPLATE_ERROR_HANDLER, {
		tracebackEdits = DEBUG and TRACEBACK_EDITS or ``,
		outputFile     = DEBUG and `io.stdout` or `io.stderr`, -- :SublimeText2Desync
	})
	)
	file:write(!(ERROR_HANDLER))

	file:write("local _MATH_MODF  = math.modf\n")  -- Used when casting float to int.
	file:write("local _MATH_FLOOR = math.floor\n") -- Used for integer division.
	file:write("local _IPAIRS     = ipairs\n")     -- Used for short-form array loops.
	file:write("local _PAIRS      = pairs\n")      -- Used for short-form table loops.

	-- Start of protected call around all user code.
	file:write("local ok = xpcall(function()\n")

	--
	-- Foreign imports.
	--

	for _, const in ipairs(state.constants) do
		if const.valueType.tag == !(typeTags.TypeInfoFunction) and const.value.bodyIsForeign then
			local lambda = const.value
			writeForeignImportIfNew(state, file, const.valueType, lambda.foreignSource, lambda.foreignSourceName, lambda.foreignSourceId)
		elseif const.valueType.tag == !(typeTags.TypeInfoForeignDummy) then
			local foreign = const.value
			writeForeignImportIfNew(state, file, foreign.inferredType, foreign.source, foreign.sourceName, foreign.sourceId)
		end
	end

	--
	-- Forward declarations.
	--

	-- @Polish: Treat function constants pointing to the same foreign function as the same constant.

	-- Constants, non-functions.
	for _, const in ipairs(state.constants) do
		if const.isObject and const.valueType.tag ~= !(typeTags.TypeInfoFunction) then
			file:write("local ", const.name, " = ")
			writeConstantValue(state, file, const) -- Only functions need everything to be forward declared.
			file:write("\n")
		end
	end

	if state.constants[1] or state.topScopeNames[1] then
		local first = true
		file:write("local ")

		-- Constants, functions.
		for _, const in ipairs(state.constants) do
			if const.valueType.tag == !(typeTags.TypeInfoFunction) then
				if not first then  file:write(", ")  end
				first = false
				file:write(const.name)
			end
		end

		-- Top-level declarations. (Note: Glóa globals are not Lua globals.)
		for _, topScopeName in ipairs(state.topScopeNames) do
			if not first then  file:write(", ")  end
			first = false
			file:write(topScopeName)
		end

		file:write("\n")
	end

	--
	-- Definitions.
	--

	-- Function definitions.
	local functionConstants = {}

	for _, const in ipairs(state.constants) do
		if const.valueType.tag == !(typeTags.TypeInfoFunction) then
			table.insert(functionConstants, const)
		end
	end

	table.sort(functionConstants, function(a, b)
		a = a.value
		b = b.value
		if a.bodyIsForeign ~= b.bodyIsForeign then  return a.bodyIsForeign  end
		return a.token < b.token
	end)

	for _, const in ipairs(functionConstants) do
		local lambda = const.value
		file:write(const.name, " = ")
		writeFunction(state, file, lambda)
		file:write("\n")
	end

	!local ENTRY_POINT_NAME = "main" -- @Incomplete: Configurable entry point name.
	local mainFuncDecl      = nil

	-- Global & file-scope assignments.
	local function handleTopScopeDeclaration(decl)
		if decl.topScopeName ~= "" then
			file:write(decl.topScopeName, " = ")
			if decl.valueConstant then
				writeConstantValueOrReference(state, file, decl.valueConstant)
			else
				-- We should have a declared struct instance or something similar here (I think) that doesn't have a specified initial value.
				writeDefaultValueForType(state, file, decl.name.inferredType, decl.name)
			end
			file:write("\n")
		end
		if decl.name.name == !(ENTRY_POINT_NAME) then  mainFuncDecl = decl  end
	end

	for _, decl in ipairs(state.globalScope.declarations) do
		handleTopScopeDeclaration(decl)
	end
	for _, fileScope in ipairs(state.globalScope.fileScopes) do
		for _, decl in ipairs(fileScope.declarations) do
			handleTopScopeDeclaration(decl)
		end
	end

	--
	-- Program entry point.
	--

	if not mainFuncDecl then
		local filePaths = {}
		for i, fileScope in ipairs(state.globalScope.fileScopes) do
			filePaths[i] = fileScope.path
		end
		errorLine(
			"ProgramWriter",
			!("Missing program entry point ('"..ENTRY_POINT_NAME.."' function) in top-level scope in loaded files:\n- %s"),
			table.concat(filePaths, "\n- ")
		)

	elseif not mainFuncDecl.isConstant then
		nodeError(
			state, mainFuncDecl.name, "ProgramWriter",
			!("Declared name '"..ENTRY_POINT_NAME.."' must be a constant.")
		)

	elseif mainFuncDecl.name.inferredType.tag ~= !(typeTags.TypeInfoFunction) then
		nodeError(
			state, mainFuncDecl.assignment.values[mainFuncDecl.assignmentIndex], "ProgramWriter",
			!("Declared name '"..ENTRY_POINT_NAME.."' must be a function to represent the entry point of the program.")
		)

	elseif mainFuncDecl.name.inferredType.argumentTypesIn[1] then
		local lambda = getAssignmentValue(state, mainFuncDecl.name, mainFuncDecl.assignment.values, mainFuncDecl.assignmentIndex)
		nodeError(state, lambda.argumentsIn, "ProgramWriter", "Program entry point function must not take any arguments.")

	elseif mainFuncDecl.name.inferredType.argumentTypesOut[1] then
		local lambda = getAssignmentValue(state, mainFuncDecl.name, mainFuncDecl.assignment.values, mainFuncDecl.assignmentIndex)
		nodeError(state, lambda.argumentsOut, "ProgramWriter", "Program entry point function must not return any values.")
	end

	writeConstantValueOrReference(state, file, mainFuncDecl.valueConstant)
	file:write("()\n")

	-- End of protected call.
	file:write("end, gloaErrorHandler)\n")
	file:write("if not ok then  os.exit(1)  end\n") -- In case there was an error in gloaErrorHandler() for some reason.

	file:close()
end



local UNICODE_TO_ASCII = @insert "unicodeConversions.luapart"

function _G.unicodeToLuaIdentifier(name)
	if name:find"[\128-\255]" then
		name = name:gsub(!(UTF8_CHARACTER_PATTERN), function(c)
			return (#c == 1 and c) or UNICODE_TO_ASCII[c] or "_"
		end)
	elseif LUA_KEYWORDS[name] then
		name = name.."_"
	end
	return name
end

function _G.isExpressionLiteralStringAndValidLuaIdentifier(expr)
	return
		expr.nodeType == !(nodeTypes.AstLiteral)
		and expr.literalType == !(LITERAL_STRING)
		and expr.value:find"^[%a_][%w_]*$" ~= nil
		and not LUA_KEYWORDS[expr.value]
end



function _G.doesTypeHaveAnyDefaultValue(typeInfo)
	return isAny(
		typeInfo.tag,
		!(typeTags.TypeInfoBool),
		!(typeTags.TypeInfoInt),
		!(typeTags.TypeInfoNone),
		!(typeTags.TypeInfoFloat),
		!(typeTags.TypeInfoString),
		!(typeTags.TypeInfoType), -- Not sure about this one. Should zero represent no type or must a value always be specified? @Robustness :DefaultValueForTypes
		!(typeTags.TypeInfoArray),
		!(typeTags.TypeInfoTable),
		!(typeTags.TypeInfoStruct),
		!(typeTags.TypeInfoVararg) -- Varargs never have any default value(s), but because it's a list we can just say that the default value is "nothing".
	)
end



function _G.validateForeignSource(state, foreignSource, foreignSourceName, nodeForError)
	-- @UX: Make error arrow always point at the !foreign token.

	if foreignSource == "lua" then
		if not loadstring(F("return(%s)", foreignSourceName)) then
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid Lua symbol: '%s'", foreignSourceName)
		end

	elseif foreignSource == "compiler" then
		if not FOREIGN_API_COMPILER_SYMBOLS[foreignSourceName] then
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid compiler symbol: '%s'", foreignSourceName)
		end

	else
		errorInternal("Incomplete: Handle foreignSource=%s", foreignSource)
	end
end


