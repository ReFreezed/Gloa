--[[============================================================
--=
--=  Program Writer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	doesTypeHaveAnyDefaultValue
	unicodeToLuaIdentifier
	validateForeignSource
	writeProgram, write*

----------------------------------------------------------------

	Format for written programs:
	1. Glóa header.
	2. Foreign imports.
	3. Constants.
	4. Forward declarations.
	5. Functions.
	6. Global/file-scope variables.
	7. Program entry point.

	Notes:
	- Usage of Lua globals is minimized. (Glóa globals are not Lua globals.)
	- All functions (with no captures/upvalues) are top-level in Lua no matter where they were defined in Glóa.
	- Local variables in Lua are uniquely named and thus never shadow anything (which might help with debugging).

	@Incomplete:
	- Handle the limited amount of locals Lua allows (200). (Maybe we'll have to use Lua globals to some extent after all.)

--============================================================]]



!(
-- info.what     = "Lua"|"C"|"main"|"tail"
-- info.namewhat = "global"|"local"|"method"|"field"|"upvalue"|""

-- @Incomplete: Handle errors better in compiled Lua modules. :LuaModuleErrors
local ERROR_HANDLER = templateToLua(
	trimTemplate`
		(function(lineMappings, getinfo, tonumber, outputFile, type, exit)
			return function(err)
				local mainSource = (getinfo(1, "S") or {}).source or "<UNKNOWN_SOURCE>"

				if type(err) == "string" then
					local pathHere = mainSource:match"^@(.+)"
					local pathLen  = pathHere and #pathHere
					local ln       = pathHere and err:sub(1, pathLen) == pathHere and tonumber(err:match("^:(%d+): ", pathLen+1))

					if lineMappings.lines[ln] then
						err = (
							lineMappings.paths[lineMappings.files[ln]]..":"
							..lineMappings.lines[ln]..": "
							..err:sub(pathLen+1):gsub("^:%d+: ", "")
						)
					end
				end

				outputFile:write("\n")
				if type(err) == "string" then
					outputFile:write("Error: ", err, "\n")
				else
					outputFile:write("Error!\n")
				end
				outputFile:write("stack traceback:\n")

				for level = 2, 1000 do
					local info = getinfo(level, "nSl")
					if not info then  break  end

					outputFile:write("\t")

					if info.what == "C" then
						outputFile:write("[ C ]: ")
						if (info.name or "") ~= "" then
							outputFile:write("'", info.name, "'")
						else
							outputFile:write("?")
						end

					else
						if info.source == mainSource and (lineMappings.lines[info.currentline] or 0) > 0 then
							outputFile:write(lineMappings.paths[lineMappings.files[info.currentline]], ":", lineMappings.lines[info.currentline])
						else
							outputFile:write("[Lua]")
						end

						outputFile:write(":")

						if info.what == "tail" then
							outputFile:write(" tail call")
						elseif info.what == "main" then
							outputFile:write(" main chunk")
						elseif (info.name or "") ~= "" then
							outputFile:write(" ")
							if info.namewhat == "method" or info.namewhat == "field" then  outputFile:write(info.namewhat, " ")  end
							outputFile:write("'", info.name, "'")
						elseif info.source == mainSource and (lineMappings.lines[info.linedefined] or 0) > 0 and info.linedefined ~= info.currentline then
							outputFile:write(" (linedefined:", lineMappings.lines[info.linedefined], ")")
						end

						local source = nil

						if info.source:find"^@" then
							source = $errorPrefix..info.source:sub(2)
						elseif info.source:find"%.lua$" then
							source = info.source
						end

						source = source and source..":"..info.currentline

						if source then
							outputFile:write(" (", source)
							if info.linedefined > 0 and info.linedefined ~= info.currentline then
								outputFile:write(", linedefined:", info.linedefined)
							end
							outputFile:write(")")
						end
					end

					outputFile:write("\n")
				end

				exit(1)
			end
		end)(lineMappings, debug.getinfo, tonumber, io.stderr, type, os.exit)
	`,
	{ errorPrefix=toLua(RUNTIME_ERROR_PREFIX) }
)

local COMPILER_SYMBOL_PAIRS = {
	`_HUGE`,   `math.huge`,
	`_MODF`,   `math.modf`,  -- Used when casting float to int.
	`_FLOOR`,  `math.floor`, -- Used for integer division.
	`_IPAIRS`, `ipairs`,     -- Used for short-form array loops.
	`_PAIRS`,  `pairs`,      -- Used for short-form table loops.
	`_SELECT`, `select`,     -- Used for short-form vararg loops.
	`_REP`,    `string.rep`, -- Used for string repetition (duh).
	`_REP2`,   `function(n,s)return(s:rep(n))end`,
	`_SUB`,    `function(s,n)return(s:sub(n,n))end`, -- Used for string subscripting.

	-- Used for short-form array loops in reverse.
	`_IPAIRSR`, trimTemplate`
		(function()
			local function iprev(arr, i)
				i = i-1
				if i > 0 then  return i, arr[i]  end
			end
			return function(arr)
				return iprev, arr, #arr+1
			end
		end)()
	`,
}
local COMPILER_SYMBOL_COUNT = #COMPILER_SYMBOL_PAIRS/2
)

local foreignApiCompilerSymbols = {
	-- These can be used in user code through !foreign compiler "symbolName".
	-- (See utils.gloa, io.gloa and other modules for declarations.)
	-- (See compiler.gloa for things only available during compile-time.)

	appPath           = `(debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get application path.")) :gsub("\\", "/")`,
	appDirectory      = `(debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get application path.")) :gsub("\\", "/"):gsub("/?[^/]+$", ""):gsub("^$", ".")`,
	compilerPath      = F("%q", COMPILER_PATH),
	compilerDirectory = F("%q", COMPILER_DIRECTORY),

	ipairsr = `_IPAIRSR`,

	wrapFunctionInGloaErrorHandler = !(trimTemplate`
		(function(select, xpcall, unpack, exit, gloaErrorHandler)
			return function(cb)
				return function(...)
					local args = {n=select("#", ...), ...}

					if not xpcall(
						function()
							cb(unpack(args, 1, args.n))
						end,
						gloaErrorHandler
					) then
						exit(1)
					end
				end
			end
		end)(select, xpcall, unpack, os.exit, gloaErrorHandler)
	`),

	getProgramArguments = !(trimTemplate`
		(function(programArguments)
			return function()
				return {unpack(programArguments)}
			end
		end)(programArguments)
	`),

	getAllTypes = !(trimTemplate`
		function(T)
			if not _TYPES[1000] then
				return {unpack(_TYPES)}
			end

			local types = {unpack(_TYPES, 1, 1000)}
			for i = 1001, #_TYPES do
				types[i] = _TYPES[i]
			end

			return types
		end
	`),

	getTypeInfo = !(trimTemplate`
		function(T)
			return _TYPE_INFO[T]
		end
	`),
}

local foreignApiCompilerSymbolsDuringCompilation = {}

for k in pairs(compilerApi) do
	foreignApiCompilerSymbols[k]                  = `function() error("Function not available during runtime.") end` -- This should only ever get written if keepDeadCode is set.
	foreignApiCompilerSymbolsDuringCompilation[k] = "_COMPILER."..k
end

local LUA_KEYWORDS = !(Set{"and","break","do","else","elseif","end","false","for","function","goto","if","in","local","nil","not","or","repeat","return","then","true","until","while"})

_G.!struct"WriterState"{
	{`file`,              nil}, -- Real or virtual file.
	{`outputRuntime`,     false},

	{`foreignN`,          0},
	{`foreignReferences`, {}},
	{`foreignOnlyAvailableDuringCompilation`, {}},

	{`loopDepth`,         0},
	{`loopStack`,         {}},  -- [](AstFor|AstWhile)  (Only used for loops with named breaks inside.)
	{`deferStack`,        {}},  -- []AstDefer
	{`loopDeferIndices`,  {}},

	{`currentOutputLine`, 1},
	{`lineMappingFiles`,  {}},
	{`lineMappingLines`,  {}},
}



local function addLineMapping(state, writer, token)
	local ln = writer.currentOutputLine
	if (writer.lineMappingLines[ln] or 0) > 0 then  return  end
	writer.lineMappingFiles[ln] = state.tokens.file [token] or errorInternal()
	writer.lineMappingLines[ln] = state.tokens.line1[token] or errorInternal()
end
-- addLineMappingDummy( state, writer [, path ] )
local function addLineMappingDummy(state, writer, path)
	local ln = writer.currentOutputLine
	if writer.lineMappingLines[ln] then  return  end
	writer.lineMappingFiles[ln] = path or state.pathToFirstFile
	writer.lineMappingLines[ln] = 0
end

local function writeEol(state, writer)
	writer.file:write("\n")
	writer.currentOutputLine = writer.currentOutputLine+1
end

function _G.writeIdentifierName(state, writer, ident)
	local decl = ident.declaration
	local name = decl.topScopeName

	addLineMapping(state, writer, ident.token)

	if name == "" then  name = decl.localName  end

	if name == "" then
		astPrint(ident)
		nodeError(state, ident, "ProgramWriter", "Internal compiler error: Missing name to write for '%s'.", ident.name)
	end

	writer.file:write(name)
end

function _G.writeStringLiteral(writer, s)
	local lua = F("%q", s):gsub("\\\n", "\\n")
	writer.file:write(lua)
end

-- writeStringConcatenation( state, writer, indent, nextLocalN, localsStack, left:AstNode|string, right:AstNode|string )
function _G.writeStringConcatenation(state, writer, indent, nextLocalN, localsStack, left, right)
	if type(left) == "string" then
		writer.file:write(left)
	elseif left.nodeType == !(nodeTypes.AstBinary) and left.operation == ".." then
		writeStringConcatenation(state, writer, indent, nextLocalN, localsStack, left.left, left.right)
	else
		writeExpression(state, writer, indent, nextLocalN, localsStack, left)
	end

	writer.file:write(" .. ")

	if type(right) == "string" then
		writer.file:write(right)
	elseif right.nodeType == !(nodeTypes.AstBinary) and right.operation == ".." then
		writeStringConcatenation(state, writer, indent, nextLocalN, localsStack, right.left, right.right)
	else
		writeExpression(state, writer, indent, nextLocalN, localsStack, right)
	end
end

function _G.shouldOperationHaveSurroundingParentheses(node)
	local parent         = node.parent
	local parentNodeType = parent.nodeType
	return not (
		!!(CONST_SET{
			nodeTypes.AstCast, -- Casts should always add their own parentheses.
			nodeTypes.AstAssignment,
			nodeTypes.AstCall, -- Both callee and arguments.
			nodeTypes.AstReturn,
			nodeTypes.AstIf,
			nodeTypes.AstFor,
			nodeTypes.AstWhile
		})[parentNodeType]
		or parent.nodeType == !(nodeTypes.AstAccess) and node == parent.member -- The member should be inside [].
	)
end

-- writeBinaryOperation( state, writer, indent, nextLocalN, localsStack, left:AstNode|string, right:AstNode|string, binaryOperation, leftType, rightType, resultingType, token, binary=nil )
function _G.writeBinaryOperation(state, writer, indent, nextLocalN, localsStack, l, r, binOp, lType, rType, resultingType, token, binary)
	!(
	local function WRITE_OPERAND(sideCode)
		__LUA(templateToLua(
			trimTemplate`
				if type($sideCode) == "string" then
					file:write($sideCode)
				else
					writeExpression(state, writer, indent, nextLocalN, localsStack, $sideCode)
				end
			`,
			{sideCode=sideCode}
		))
	end
	)

	local file      = writer.file
	local addParens = binary and shouldOperationHaveSurroundingParentheses(binary)

	addLineMapping(state, writer, token)

	if binOp == ".." then
		if addParens then  file:write("(")  end
		writeStringConcatenation(state, writer, indent, nextLocalN, localsStack, l, r) -- This makes sure consecutive string concatenations appear as one operation without any parentheses.
		if addParens then  file:write(")")  end

	elseif binOp == "//" then
		file:write("_FLOOR(")
		!WRITE_OPERAND `l`
		file:write(" / ")
		!WRITE_OPERAND `r`
		file:write(")")

	elseif binOp == "*" and resultingType.tag == !(TYPE_STRING) then
		-- Just a quick note:
		--   str *= 3  -- OK
		--   num *= "" -- Illegal (as the result is a string, which is a type mismatch with 'num')
		if lType.tag == !(TYPE_STRING) then
			file:write("_REP(")
		else
			file:write("_REP2(")
		end
		!WRITE_OPERAND `l`
		file:write(", ")
		!WRITE_OPERAND `r`
		file:write(")")

	else
		if addParens then  file:write("(")  end
		!WRITE_OPERAND `l`
		file:write(" ", binOp, " ")
		!WRITE_OPERAND `r`
		if addParens then  file:write(")")  end
	end
end

local function isExpressionLiteralStringAndValidLuaIdentifier(expr)
	return
		expr.nodeType == !(nodeTypes.AstLiteral)
		and expr.literalType == !(LITERAL_STRING)
		and expr.value:find"^[%a_][%w_]*$" ~= nil
		and not LUA_KEYWORDS[expr.value]
end

function _G.writeAccess(state, writer, indent, nextLocalN, localsStack, access)
	local typeInfo = adjustTypeToOne(state, access.object, access.object.inferredType, true)

	if isTypeTableLike(typeInfo) then
		-- @Incomplete: Compiler setting for runtime checks of array bounds.
		writeExpression(state, writer, indent, nextLocalN, localsStack, access.object)

		if access.parent.nodeType == !(nodeTypes.AstCall) and access.parent.isMethod then
			local stringLiteral = access.member
			assert(stringLiteral.nodeType == !(nodeTypes.AstLiteral) and stringLiteral.literalType == !(LITERAL_STRING))

			if not stringLiteral.value:find"^[%a_][%w_]*$" then
				errorInternal("@Incomplete: Support method calls using names containing non-ASCII characters.")
			elseif LUA_KEYWORDS[stringLiteral.value] then
				errorInternal("@Incomplete: Support method calls using names that are keywords in Lua.")
			end

			writer.file:write(":", stringLiteral.value)

		elseif isExpressionLiteralStringAndValidLuaIdentifier(access.member) then
			local stringLiteral = access.member
			writer.file:write(".", stringLiteral.value)

		else
			writer.file:write("[")
			writeExpression(state, writer, indent, nextLocalN, localsStack, access.member)
			writer.file:write("]")
		end

	elseif typeInfo.tag == !(TYPE_STRING) then
		writer.file:write("_SUB(")
		writeExpression(state, writer, indent, nextLocalN, localsStack, access.object)
		writer.file:write(", ")
		writeExpression(state, writer, indent, nextLocalN, localsStack, access.member)
		writer.file:write(")")

	elseif typeInfo.tag == !(TYPE_ENUM) then
		errorInternal(state, access) -- Enum accesses should have been simplified away.

	else
		errorUnhandledType(state, access.object, typeInfo)
	end
end

-- writeCast( state, writer, indent, nextLocalN, localsStack, cast [, nameToCast ] )
-- nameToCast is only used by AstConditional.
function _G.writeCast(state, writer, indent, nextLocalN, localsStack, cast, nameToCast)
	!local WRITE_EXPRESSION = trimTemplate`
		if nameToCast then
			writer.file:write(nameToCast)
		else
			writeExpression(state, writer, indent, nextLocalN, localsStack, cast.expression)
		end
	`

	local typeInfoSource = adjustTypeToOne(state, cast.expression, cast.expression.inferredType, true)
	local typeInfoTarget = cast.inferredType

	addLineMapping(state, writer, cast.token)

	writer.file:write("(") -- In case the written expression is a list of some kind.

	if
		typeInfoSource == typeInfoTarget
		or typeInfoSource.tag == !(TYPE_COMPOUND)
		or typeInfoTarget.tag == !(TYPE_COMPOUND)
	then
		!!(WRITE_EXPRESSION)

	-- int -> float
	elseif typeInfoSource.tag == !(TYPE_INT) and typeInfoTarget.tag == !(TYPE_FLOAT) then
		!!(WRITE_EXPRESSION)
	-- float -> int
	elseif typeInfoSource.tag == !(TYPE_FLOAT) and typeInfoTarget.tag == !(TYPE_INT) then
		writer.file:write("_MODF(") -- Note: math.modf() returns two values.
		!!(WRITE_EXPRESSION)
		writer.file:write(")")

	-- (numeric) -> bool
	elseif isTypeNumeric(typeInfoSource) and typeInfoTarget.tag == !(TYPE_BOOL) then
		!!(WRITE_EXPRESSION)
		writer.file:write(" ~= 0")
	-- string -> bool
	elseif typeInfoSource.tag == !(TYPE_STRING) and typeInfoTarget.tag == !(TYPE_BOOL) then
		!!(WRITE_EXPRESSION)
		writer.file:write(' ~= ""')
	-- array -> bool
	elseif typeInfoSource.tag == !(TYPE_ARRAY) and typeInfoTarget.tag == !(TYPE_BOOL) then
		!!(WRITE_EXPRESSION)
		writer.file:write("[1] ~= nil")
	-- (array-like struct) -> bool
	elseif typeInfoSource.tag == !(TYPE_STRUCT) and typeInfoSource.kind == !(STRUCT_KIND_ARRAY) and typeInfoTarget.tag == !(TYPE_BOOL) then
		!!(WRITE_EXPRESSION)
		writer.file:write("[1] ~= nil")

	-- enum -> (real enum member type)
	elseif typeInfoSource.tag == !(TYPE_ENUM) and typeInfoTarget == typeInfoSource.memberTypeInfo then
		!!(WRITE_EXPRESSION)

	-- (base struct) -> (substruct)
	elseif typeInfoSource.tag == !(TYPE_STRUCT) and typeInfoTarget.tag == !(TYPE_STRUCT) then
		!!(WRITE_EXPRESSION)
	-- (table-like) -> table
	elseif isTypeTableLike(typeInfoSource) and typeInfoTarget.tag == !(TYPE_TABLE) then
		!!(WRITE_EXPRESSION)
	-- (array-like struct) -> array
	elseif typeInfoSource.tag == !(TYPE_STRUCT) and typeInfoSource.kind == !(STRUCT_KIND_ARRAY) and typeInfoTarget.tag == !(TYPE_ARRAY) then
		!!(WRITE_EXPRESSION)

	-- (whatever) -> any
	-- any -> (whatever)
	elseif typeInfoSource.tag == !(TYPE_ANY) or typeInfoTarget.tag == !(TYPE_ANY) then
		-- The user better know what they're doing!
		-- @Incomplete: Compiler setting for runtime checks of 'any' and 'compound' casts.
		!!(WRITE_EXPRESSION)

	else
		errorInternal(state, cast, "Incomplete: Handle casting from %s to %s.", getFriendlyTypeInfoName(typeInfoSource), getFriendlyTypeInfoName(typeInfoTarget))
	end

	writer.file:write(")")
end

function _G.writeTableConstructorKeyName(writer, name)
	if name:find"^[%a_][%w_]*$" and not LUA_KEYWORDS[name] then
		writer.file:write(name)
	else
		writer.file:write("[")
		writeStringLiteral(writer, name)
		writer.file:write("]")
	end
end
function _G.writeTableConstructorKey(state, writer, indent, nextLocalN, localsStack, keyExpr)
	if keyExpr.nodeType == !(nodeTypes.AstLiteral) and keyExpr.literalType == !(LITERAL_STRING) then
		local stringLiteral = keyExpr
		writeTableConstructorKeyName(writer, stringLiteral.value)
	else
		writer.file:write("[")
		writeExpression(state, writer, indent, nextLocalN, localsStack, keyExpr)
		writer.file:write("]")
	end
end

function _G.writeDefaultValueForStructMember(state, writer, indent, nextLocalN, localsStack, structInfo, member, nodeForError)
	local decl = findDynamicMemberDeclaration(state, structInfo.astNode, member.name) or errorInternal(state, structInfo.astNode, "Did not find member '%s'.", member.name)
	if decl.value then
		writeExpression(state, writer, indent, nextLocalN, localsStack, decl.value)
	else
		writeDefaultValueForType(state, writer, indent, nextLocalN, localsStack, member.typeInfo, nodeForError)
	end
end

local function findTableFieldByNameInStructConstructor(state, tableNode, memberName)
	for _, tableField in ipairs(tableNode.fields) do
		local keyExpr = tableField.key
		if keyExpr.nodeType == !(nodeTypes.AstLiteral) and keyExpr.literalType == !(LITERAL_STRING) and keyExpr.value == memberName then
			return tableField
		end
	end

	return nil
end

local function doesTypeContainBoolOrNone(typeInfo)
	if !!(CONST_SET{ TYPE_BOOL, TYPE_NONE, TYPE_ANY })[typeInfo.tag] then  return true  end

	if typeInfo.tag ~= !(TYPE_COMPOUND) then  return false  end
	local compound = typeInfo

	for _, compoundItem in ipairs(compound) do
		if !!(CONST_SET{ TYPE_BOOL, TYPE_NONE })[compoundItem.tag] then  return true  end
	end
	return false
end

function _G.writeExpression(state, writer, indent, nextLocalN, localsStack, expr)
	!ASSERT(`expr.inferredType`, nil, `expr`)
	local file = writer.file

	if expr.nodeType == !(nodeTypes.AstCall) then
		local call   = expr
		local callee = call.callee

		local callingForeignMethod = false

		addLineMapping(state, writer, call.token)

		if call.surroundedByParentheses then  file:write("(")  end

		if callee.nodeType == !(nodeTypes.AstIdentifier) and isDeclarationConstant(callee.declaration) then
			local ident = callee
			local decl  = ident.declaration
			local const = decl.valueConstant

			!if DEBUG then
				if not const then
					if decl.value then  astPrintTree(decl.value)  end
					errorInternal(state, decl, "Missing constant object.")
				end
			!end

			if const.valueType.tag == !(TYPE_FUNCTION) and const.value.bodyIsForeign and const.value.foreignSource == "method" then
				callingForeignMethod = true
				local argExpr        = call.arguments[1] or errorInternal(state, call)

				if argExpr.nodeType == !(nodeTypes.AstIdentifier) then
					-- Note: It doesn't matter if argExpr a reference to a constant or not since it's be an object reference
					-- either way (unless the type inference borked and argExpr somehow isn't a struct instance).
					writeExpression(state, writer, indent, nextLocalN, localsStack, argExpr)

				elseif argExpr.nodeType == !(nodeTypes.AstAccess) then
					-- Table lookups have precedence over method calls in Lua.
					writeExpression(state, writer, indent, nextLocalN, localsStack, argExpr)

				else
					-- I think the parenthesis here is needed since argExpr (or shouldOperationHaveSurroundingParentheses())
					-- will think it's part of a comma-separated list between the parenthesis of the call.
					file:write("(")
					writeExpression(state, writer, indent, nextLocalN, localsStack, argExpr)
					file:write(")")
				end

				local lambda = const.value
				file:write(":", lambda.foreignSourceName.value)
				if outputDebugInfo and lambda.foreignSourceName.value ~= ident.name then
					file:write(formatInfoComment(ident.name)) -- Not sure this is that helpful...
				end

			else
				writeConstantValueOrReference(state, writer, const, ident)
			end

		else
			writeExpression(state, writer, indent, nextLocalN, localsStack, callee)
		end

		file:write("(")
		local first = true

		-- Write given arguments.
		for i = (callingForeignMethod and 2 or 1), #call.arguments do
			if not first then  file:write(", ")  end
			first = false
			writeExpression(state, writer, indent, nextLocalN, localsStack, call.arguments[i])
		end

		-- Write default values for arguments (if the function isn't foreign).
		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			local calleeDecl = callee.declaration

			if isDeclarationConstant(calleeDecl) then
				local lambda = calleeDecl.value or errorInternal(state, calleeDecl)
				lambda       = followIdentifiersToConstantValue(lambda)

				!ASSERT("lambda.nodeType == "..nodeTypes.AstLambda, nil, `lambda`)

				if not lambda.bodyIsForeign then
					-- Only write a value if the last non-vararg argument is optional.
					local argLast = lambda.argumentsIn and getLast(lambda.argumentsIn.arguments)
					if argLast and argLast.declaration.name.nodeType == !(nodeTypes.AstVararg) then
						argLast = getLast(lambda.argumentsIn.arguments, 2)
					end

					if argLast and not argLast.isRequired then
						local argExprLast = getLast(call.arguments)

						if argExprLast and (
							(
								argExprLast.inferredType.tag == !(TYPE_VARARG)
								and not argExprLast.surroundedByParentheses
							)
							or (
								argExprLast.inferredType.tag == !(TYPE_LIST)
								and not argExprLast.surroundedByParentheses
								and argExprLast.inferredType[2]
							)
						) then
							-- :DisallowListAsLastValueToFunctionWithOptionalArguments
							nodeError(state, callee, "ProgramWriter", "@Incomplete: Handle optional arguments if the last value in a call is a list of things.")
						end

						local argsInList = lambda.argumentsIn.arguments

						for i = #call.arguments+1, #argsInList do
							if not first then  file:write(", ")  end
							first = false

							local valueExpr = argsInList[i].declaration.value

							if not valueExpr then
								-- void  Varargs are optional but have no default value (or zero default values, since it's a list).
							elseif valueExpr.nodeType == !(nodeTypes.AstLocation) and valueExpr.ofCaller then
								local const = call.locationConstant or errorInternal(state, call, "Missing caller location data.")
								writeConstantValueOrReference(state, writer, const, valueExpr)
							else
								writeExpression(state, writer, indent, nextLocalN, localsStack, valueExpr)
							end
						end
					end
				end
			end
		end

		file:write(")")

		if call.surroundedByParentheses then  file:write(")")  end

	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		local unary = expr

		if unary.operation == "+" then
			writeExpression(state, writer, indent, nextLocalN, localsStack, unary.expression)

		else
			local addParens = shouldOperationHaveSurroundingParentheses(unary)

			addLineMapping(state, writer, unary.token)

			if addParens then  file:write("(")  end
			file:write(unary.operation)
			if unary.operation:find"%w" then  file:write(" ")  end
			writeExpression(state, writer, indent, nextLocalN, localsStack, unary.expression)
			if addParens then  file:write(")")  end
		end

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr
		writeBinaryOperation(
			state, writer, indent, nextLocalN, localsStack,
			binary.left, binary.right,
			binary.operation,
			binary.left.inferredType, binary.right.inferredType, binary.inferredType,
			binary.token, binary
		)

	elseif expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		!ASSERT(`literal.valueConstant`, nil, `literal`)
		writeConstantValue(state, writer, literal.valueConstant, literal)

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration
		!ASSERT `ident.inferredType`
		!ASSERT `decl`

		if isDeclarationConstant(decl) then
			writeConstantValueOrReference(state, writer, decl.valueConstant, ident)
		else
			writeIdentifierName(state, writer, ident)
		end

	elseif expr.nodeType == !(nodeTypes.AstVararg) then
		local vararg = expr
		file:write(vararg.surroundedByParentheses and "(...)" or "...")

	elseif expr.nodeType == !(nodeTypes.AstBlank) then
		file:write("_")

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		file:write(F("%d", typeNode.representedType.id)) -- @Cleanup: We probably have a constant for the type ID to use with writeConstantValue() here who cares...
		if outputDebugInfo then
			file:write(formatInfoComment(getFriendlyTypeInfoName(typeNode.representedType)))
		end

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda = expr
		if lambda.captures[1] then
			writeFunction(state, writer, indent, nextLocalN, localsStack, lambda)
		else
			local const = lambda.valueConstant or errorInternal(state, lambda)
			writeConstantValueOrReference(state, writer, const, lambda)
		end

	elseif expr.nodeType == !(nodeTypes.AstAccess) then
		local access = expr
		writeAccess(state, writer, indent, nextLocalN, localsStack, access)

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		writeCast(state, writer, indent, nextLocalN, localsStack, cast)

	elseif expr.nodeType == !(nodeTypes.AstTable) then
		local tableNode = expr
		local first     = true
		file:write("{")

		local function writeGenericTableFieldIfValueIsNotNil(tableField)
			local valueExpr = tableField.value
			if valueExpr.nodeType == !(nodeTypes.AstNull) then  return  end
			if valueExpr.nodeType == !(nodeTypes.AstLiteral) and valueExpr.literalType == !(LITERAL_NIL) then  return  end

			if not first then  file:write(", ")  end
			first = false

			-- @Polish: Output sequence values without key in 'table' type tables.
			writeTableConstructorKey(state, writer, indent, nextLocalN, localsStack, tableField.key)
			file:write("=")
			writeExpression(state, writer, indent, nextLocalN, localsStack, valueExpr)
		end

		if tableNode.inferredType.tag == !(TYPE_TABLE) then
			for _, tableField in ipairs(tableNode.fields) do
				writeGenericTableFieldIfValueIsNotNil(tableField)
			end

		elseif tableNode.inferredType.tag == !(TYPE_ARRAY) then
			local items = {}

			for _, tableField in ipairs(tableNode.fields) do
				!ASSERT("tableField.key.nodeType == "..nodeTypes.AstLiteral) -- :VariableArrayIndices

				local literal     = tableField.key
				local arrayIndex  = literal.value
				items[arrayIndex] = tableField.value
			end

			for _, expr in ipairs(items) do
				if not first then  file:write(", ")  end
				first = false
				writeExpression(state, writer, indent, nextLocalN, localsStack, expr)
			end

		elseif tableNode.inferredType.tag == !(TYPE_STRUCT) then
			local structInfo    = tableNode.inferredType
			local writtenFields = {}
			!ASSERT `not structInfo.isPolymorphic`

			for _, member in ipairs(structInfo.members) do
				local tableField = findTableFieldByNameInStructConstructor(state, tableNode, member.name)
				if tableField then  writtenFields[tableField] = true  end

				if not (
					tableField and (
						tableField.value.nodeType == !(nodeTypes.AstNull)
						or (tableField.value.nodeType == !(nodeTypes.AstLiteral) and tableField.value.literalType == !(LITERAL_NIL))
					)
					-- or (default value is NULL/nil) -- @Polish
				) then
					if not first then  file:write(", ")  end
					first = false

					if tableField then
						writeTableConstructorKey(state, writer, indent, nextLocalN, localsStack, tableField.key)
						file:write("=")
						writeExpression(state, writer, indent, nextLocalN, localsStack, tableField.value)
					else
						writeTableConstructorKeyName(writer, member.name)
						file:write("=")
						writeDefaultValueForStructMember(state, writer, indent, nextLocalN, localsStack, structInfo, member, tableNode) -- @UX: Maybe use a better nodeForError.
					end
				end
			end

			if structInfo.kind ~= !(STRUCT_KIND_NORMAL) then
				for _, tableField in ipairs(tableNode.fields) do
					if not writtenFields[tableField] then
						writeGenericTableFieldIfValueIsNotNil(tableField)
					end
				end
			end

		else
			errorUnhandledType(state, tableNode, tableNode.inferredType)
		end

		if tableNode.trailingExpression then
			if not first then  file:write(", ")  end
			writeExpression(state, writer, indent, nextLocalN, localsStack, tableNode.trailingExpression)
		end

		file:write("}")

	elseif expr.nodeType == !(nodeTypes.AstForeign) then
		local foreign = expr
		writeConstantValueOrReference(state, writer, foreign.valueConstant, foreign)

	elseif expr.nodeType == !(nodeTypes.AstTypeInfo) then
		local typeInfoNode = expr
		writeConstantValueOrReference(state, writer, typeInfoNode.valueConstant, typeInfoNode)

	elseif expr.nodeType == !(nodeTypes.AstLocation) then
		local loc = expr
		writeConstantValueOrReference(state, writer, loc.valueConstant, loc)

	elseif expr.nodeType == !(nodeTypes.AstConditional) then
		local conditional = expr
		local hasVararg   = false

		astVisitAllNodes(conditional, function(node)
			if node.nodeType == !(nodeTypes.AstVararg) then
				hasVararg = true
				return !(VISIT_BREAK)
			elseif isScope(node) then
				return !(VISIT_IGNORE_CHILDREN)
			end
		end)

		-- Ternary.
		if not conditional.conditionAndBranchTrue then
			if doesTypeContainBoolOrNone(adjustTypeToOne(state, conditional.branchTrue, conditional.branchTrue.inferredType, true)) then
				-- (function(x) if x then return a else return b end end)(x)
				file:write("(function(_CONDITION")
				if hasVararg then  file:write(", ...")  end
				file:write(") if _CONDITION then return ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchTrue)
				file:write(" else return ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchFalse)
				file:write(" end end)(")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.condition)
				if hasVararg then  file:write(", ...")  end
				file:write(")")
			else
				-- x and a or b
				file:write("(")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.condition)
				file:write(" and ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchTrue)
				file:write(" or ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchFalse)
				file:write(")")
			end

		-- Binary (with implicit cast).
		-- @Optimize: Output 'a or b' whenever possible.
		elseif conditional.conditionAndBranchTrue ~= conditional.condition then
			-- (function(x) if x then return x else return y end end)(x)
			local cast = conditional.condition
			assert(cast.nodeType   == !(nodeTypes.AstCast))
			assert(cast.expression == conditional.conditionAndBranchTrue)
			assert(cast.isImplicit)

			file:write("(function(_CONDITION")
			if hasVararg then  file:write(", ...")  end
			file:write(") if ")
			writeCast(state, writer, indent, nextLocalN, localsStack, cast, "_CONDITION")
			file:write(" then return _CONDITION else return ")
			writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchFalse)
			file:write(" end end)(")
			writeExpression(state, writer, indent, nextLocalN, localsStack, cast.expression)
			if hasVararg then  file:write(", ...")  end
			file:write(")")

		-- Binary (without implicit cast).
		-- @Optimize: Output 'a or b' whenever possible.
		else
			-- (function(x) if x then return x else return y end end)(x)
			file:write("(function(_CONDITION")
			if hasVararg then  file:write(", ...")  end
			file:write(") if _CONDITION then return _CONDITION else return ")
			writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchFalse)
			file:write(" end end)(")
			writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.condition)
			if hasVararg then  file:write(", ...")  end
			file:write(")")
		end

	elseif expr.nodeType == !(nodeTypes.AstNull) then
		file:write("nil")

	elseif expr.inferredType.tag == !(TYPE_NAMESPACE) then
		nodeError(state, expr, "ProgramWriter", "Invalid place for a namespace.")
	else
		errorUnhandledNodeType(state, expr)
	end
end

function _G.writeDefaultValueForType(state, writer, indent, nextLocalN, localsStack, typeInfo, nodeForError)
	local file = writer.file
	local tag  = typeInfo.tag

	if tag == !(TYPE_BOOL) then
		file:write("false")
	elseif tag == !(TYPE_INT) then
		file:write("0")
	elseif tag == !(TYPE_NONE) then
		file:write("nil")
	elseif tag == !(TYPE_FLOAT) then
		file:write("0.0")
	elseif tag == !(TYPE_STRING) then
		file:write('""')
	elseif tag == !(TYPE_ARRAY) or tag == !(TYPE_TABLE) then
		file:write("{}")

	elseif tag == !(TYPE_STRUCT) then
		local structInfo = typeInfo
		!ASSERT `not structInfo.isPolymorphic`

		if structInfo.astNode.isForeign then
			-- @Speed: Detect this sooner (probably when inferring AstDeclaration).
			!TRACE()
			printerr()
			nodeMessage(io.stderr, state, nodeForError, "Error", "Typer", "Cannot instantiate foreign struct '%s'.", getFriendlyTypeInfoName(structInfo))
			if structInfo.astNode.foreignThroughNode then
				nodeMessage(io.stderr, state, structInfo.astNode.foreignThroughNode, "Info", "Typer", "...the struct got its foreign state through this.")
			end
			exitFailure()
		end

		local first = true
		file:write("{")

		for i, member in ipairs(structInfo.members) do
			if not first then  file:write(", ")  end
			first = false

			-- if not (default_value_for_struct_member is AstNull) then -- @Incomplete
				writeTableConstructorKeyName(writer, member.name)
				file:write("=")
				writeDefaultValueForStructMember(state, writer, indent, nextLocalN, localsStack, structInfo, member, nodeForError)
			-- end
		end

		file:write("}")

	elseif doesTypeHaveAnyDefaultValue(typeInfo) then
		errorInternal("Incomplete: Write default value for type group '%s'.", TYPE_NAMES[typeInfo.tag])
	else
		nodeError(state, nodeForError, "ProgramWriter", "There is no default value for %s.", getFriendlyTypeInfoName(typeInfo))
	end
end

local function isNameAllocated(state, writer, localsStack, localName)
	if state.topScopeNames[localName] then  return true  end

	for _, locals in ipairs(localsStack) do
		if locals[localName] then  return true  end
	end

	return false
end

local function allocateName(state, writer, localsStack, name, n, shortPrefix, longInfix)
	local localName

	if name == "_" then
		localName = "_"
	elseif outputDebugInfo then
		localName = unicodeToLuaIdentifier(name)
		if isNameAllocated(state, writer, localsStack, localName) then
			localName = localName..longInfix..n
		end
	else
		localName = shortPrefix..n
	end

	localsStack[1][localName] = true

	return localName, n+1
end
local function allocateLocalName(state, writer, localsStack, name, n)
	return allocateName(state, writer, localsStack, name, n, "L", "_L")
end
local function allocateArgumentName(state, writer, localsStack, name, n)
	return allocateName(state, writer, localsStack, name, n, "A", "_A")
end

local function writeDefers(state, writer, indent, nextLocalN, localsStack, indentStr, defers)
	for i = #defers, 1, -1 do
		local block = defers[i].body
		if
			itemWith1(block.declarations, `kind`, !(DECL_KIND_LOCAL_VAR))
			-- or itemWith1(block.declarations, `kind`, !(DECL_KIND_READ_ONLY))
		then
			writer.file:write(indentStr, "do")
			writeEol(state, writer)
			writeBlock(state, writer, indent+1, nextLocalN, localsStack, block)
			writer.file:write(indentStr, "end")
			writeEol(state, writer)
		else
			writeBlock(state, writer, indent, nextLocalN, localsStack, block)
		end
	end
end

local function writeLoopBodyAndFooter(state, writer, loop, indent, nextLocalN, localsStack, deferStartIndex)
	local file      = writer.file
	local loopStack = writer.loopStack
	local indentStr = ("\t"):rep(indent)

	writer.loopDepth                          = writer.loopDepth+1
	writer.loopDeferIndices[writer.loopDepth] = #writer.deferStack+1

	if not (loop.hasNamedBreaks or loopStack[1]) then
		writeBlock(state, writer, indent+1, nextLocalN, localsStack, loop.body)
		file:write(indentStr, "end") ; writeEol(state, writer)

		writer.loopDeferIndices[writer.loopDepth] = nil
		writer.loopDepth                          = writer.loopDepth-1
		return
	end

	if not loopStack[1] then
		file:write(indentStr, "\tlocal _BREAK = 0") ; writeEol(state, writer)
	end

	table.insert(loopStack, loop)
	writeBlock(state, writer, indent+1, nextLocalN, localsStack, loop.body)
	file:write(indentStr, "end") ; writeEol(state, writer)
	table.remove(loopStack)

	if loopStack[1] then
		file:write(indentStr, "if _BREAK > 0 then") ; writeEol(state, writer)

		local deferStartIndexBreak = writer.loopDeferIndices[writer.loopDepth-1] or deferStartIndex
		local defers               = writer.deferStack[deferStartIndexBreak] and {unpack(writer.deferStack, deferStartIndexBreak)} or EMPTY_TABLE
		writeDefers(state, writer, indent+1, nextLocalN, localsStack, indentStr.."\t", defers)

		file:write(indentStr, "\t")
		if loopStack[2] then
			file:write("_BREAK = _BREAK-1 ; ")
		end
		file:write("break") ; writeEol(state, writer)

		file:write(indentStr, "end") ; writeEol(state, writer)
	end

	writer.loopDeferIndices[writer.loopDepth] = nil
	writer.loopDepth                          = writer.loopDepth-1
end

-- writeBlock( state, writer, indent, nextLocalN, localsStack, block [, isElseif=false ] )
function _G.writeBlock(state, writer, indent, nextLocalN, localsStack, block, isElseif)
	!ASSERT `not block[1]`

	local file      = writer.file
	local indentStr = ("\t"):rep(indent)

	if not block.statementsDynamic[1] then
		if outputDebugInfo then
			file:write(indentStr, "-- Empty block.")
			writeEol(state, writer)
		end
		return
	end

	local deferStartIndex = #writer.deferStack+1

	localsStack  = {{}, unpack(localsStack)} -- @Speed: We can probably handle locals like defers.
	local inDecl = false

	for _, statement in ipairs(block.statementsDynamic) do
		local nodeType = statement.nodeType

		if nodeType == !(nodeTypes.AstDeclaration) then
			local decl = statement
			assert(decl.kind == !(DECL_KIND_LOCAL_VAR) --[[or decl.kind == !(DECL_KIND_READ_ONLY)]])

			decl.localName, nextLocalN = allocateLocalName(state, writer, localsStack, decl.name.name, nextLocalN)

			if decl.assignment then
				-- The (initial) assignment should be written as the next statement (or after several consecutive declarations).
				inDecl = true

			else
				local tag = decl.name.inferredType.tag
				file:write(indentStr, "local ", decl.localName, " = ")
				if decl.value then
					writeExpression(state, writer, indent, nextLocalN, localsStack, decl.value)
				else
					writeDefaultValueForType(state, writer, indent, nextLocalN, localsStack, decl.name.inferredType, decl.name)
				end
				file:write(";")
				writeEol(state, writer)
			end

		elseif nodeType == !(nodeTypes.AstAssignment) then
			local assignment = statement

			-- Plain assignment.
			if assignment.binaryOperation == "" then
				-- @Optimize: Output '_ = func()' as 'func()'.
				-- @Optimize: Output 'x, _ = func()' as 'x = func()'.
				local hasBlank = false

				file:write(indentStr)
				if inDecl then  file:write("local ")  end

				for i, targetExpr in ipairs(assignment.targets) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, writer, indent, nextLocalN, localsStack, targetExpr)
					hasBlank = (hasBlank or targetExpr.nodeType == !(nodeTypes.AstBlank))
				end

				file:write(" = ")

				for i, valueExpr in ipairs(assignment.values) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, writer, indent, nextLocalN, localsStack, valueExpr)
				end

				file:write(";") -- This removes ambiguity is some cases.
				if hasBlank and not isNameAllocated(state, writer, localsStack, "_") then
					file:write(" _=nil;") -- We don't want to accidentally store an object that is subject to garbage collection as a global.
				end
				writeEol(state, writer)

			-- Assignment with binary operation.
			else
				!ASSERT `not inDecl`

				file:write(indentStr, "do")
				writeEol(state, writer)

				-- Get target objects and values.
				file:write(indentStr, "\tlocal ")
				local first   = true
				local accessN = 0

				for _, targetExpr in ipairs(assignment.targets) do
					if targetExpr.nodeType == !(nodeTypes.AstAccess) then
						local access = targetExpr

						if not first then  file:write(", ")  end
						first = false

						-- @Optimize: Don't store the object and/or member like this if it's unnecessary.
						accessN = accessN+1
						file:write("_OBJECT", accessN, ", _MEMBER", accessN) -- @Robustness: Ensure unique names.
					end
				end

				for i, targetExpr in ipairs(assignment.targets) do
					if not first then  file:write(", ")  end
					first = false

					file:write("_VALUE", i) -- @Robustness: Ensure unique names.
				end

				file:write(" = ")
				first = true

				for _, targetExpr in ipairs(assignment.targets) do
					if targetExpr.nodeType == !(nodeTypes.AstAccess) then
						local access = targetExpr

						if not first then  file:write(", ")  end
						first = false

						writeExpression(state, writer, indent, nextLocalN, localsStack, access.object)
						file:write(", ")
						writeExpression(state, writer, indent, nextLocalN, localsStack, access.member)
					end
				end

				for _, valueExpr in ipairs(assignment.values) do
					if not first then  file:write(", ")  end
					first = false

					writeExpression(state, writer, indent, nextLocalN, localsStack, valueExpr)
				end

				writeEol(state, writer)

				-- Assign to targets.
				local targetsToWrite = {}
				file:write(indentStr, "\t")
				first   = true
				accessN = 0

				for i, target in ipairs(assignment.targets) do
					if not first then  file:write(", ")  end
					first = false

					if target.nodeType == !(nodeTypes.AstAccess) then
						accessN = accessN+1
						target  = F("_OBJECT%d[_MEMBER%d]", accessN, accessN)
						file:write(target)
					else
						writeExpression(state, writer, indent, nextLocalN, localsStack, target)
					end

					targetsToWrite[i] = target
				end

				file:write(" = ")
				first   = true
				accessN = 0

				for i, targetExpr in ipairs(assignment.targets) do
					if not first then  file:write(", ")  end
					first = false

					local _, valueType = getAssignmentValue(state, targetExpr, assignment.values, i, nil, nil, nil)
					!ASSERT(`valueType`, `tostring(i)`, `assignment.values[i] or assignment`)

					writeBinaryOperation(
						state, writer, indent, nextLocalN, localsStack,
						targetsToWrite[i], "_VALUE"..i,
						assignment.binaryOperation,
						targetExpr.inferredType, valueType, targetExpr.inferredType,
						targetExpr.token, nil
					)
				end

				writeEol(state, writer)
				file:write(indentStr, "end")
				writeEol(state, writer)
			end

			inDecl = false

		elseif nodeType == !(nodeTypes.AstReturn) then
			local returnNode = statement

			-- @Incomplete: Evaluate return values before running defers (right?).
			writeDefers(state, writer, indent, nextLocalN, localsStack, indentStr, writer.deferStack)

			if block.parent.nodeType == !(nodeTypes.AstLambda) and not returnNode.values[1] then
				if outputDebugInfo then
					file:write(indentStr, "-- return")
					writeEol(state, writer)
				end

			else
				file:write(indentStr, "return")
				for i, expr in ipairs(returnNode.values) do
					if i > 1 then  file:write(",")  end
					file:write(" ")
					writeExpression(state, writer, indent, nextLocalN, localsStack, expr)
				end
				writeEol(state, writer)
			end

		elseif nodeType == !(nodeTypes.AstBlock) then
			local block = statement

			file:write(indentStr, "do")
			writeEol(state, writer)

			writeBlock(state, writer, indent+1, nextLocalN, localsStack, block)

			file:write(indentStr, "end")
			writeEol(state, writer)

		elseif nodeType == !(nodeTypes.AstIf) then
			-- @Optimize: Don't output empty branches.
			local ifBranch = statement

			if not isElseif then  file:write(indentStr)  end

			file:write("if ")
			writeExpression(state, writer, indent, nextLocalN, localsStack, ifBranch.condition)
			file:write(" then")
			writeEol(state, writer)

			writeBlock(state, writer, indent+1, nextLocalN, localsStack, ifBranch.branchTrue)

			if not (ifBranch.branchFalse and ifBranch.branchFalse.statementsDynamic[1]) then
				-- void

			elseif not ifBranch.branchFalse.statementsDynamic[2] and ifBranch.branchFalse.statementsDynamic[1].nodeType == !(nodeTypes.AstIf) then
				file:write(indentStr, "else") -- This will be followed by "if"
				writeBlock(state, writer, indent, nextLocalN, localsStack, ifBranch.branchFalse, true)

			else
				file:write(indentStr, "else")
				writeEol(state, writer)
				writeBlock(state, writer, indent+1, nextLocalN, localsStack, ifBranch.branchFalse)
			end

			if not isElseif then
				file:write(indentStr, "end")
				writeEol(state, writer)
			end

		elseif nodeType == !(nodeTypes.AstWhile) then
			-- @Optimize: Don't output an empty body.
			local whileLoop = statement

			file:write(indentStr, "while ")
			writeExpression(state, writer, indent, nextLocalN, localsStack, whileLoop.condition)
			file:write(" do")
			writeEol(state, writer)

			writeLoopBodyAndFooter(state, writer, whileLoop, indent, nextLocalN, localsStack, deferStartIndex)

		elseif nodeType == !(nodeTypes.AstFor) then
			-- @Optimize: Don't output an empty body.
			local forLoop     = statement
			local localsStack = {{}, unpack(localsStack)}

			for _, decl in ipairs(forLoop.declarations) do
				decl.localName, nextLocalN = allocateLocalName(state, writer, localsStack, decl.name.name, nextLocalN)
			end

			if forLoop.forType == !(FOR_NUMERIC) then
				local decl   = forLoop.declarations[1]
				local values = forLoop.expressions

				file:write(indentStr, "for ")
				writeIdentifierName(state, writer, decl.name)
				file:write(" = ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, values[1])
				file:write(", ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, values[2])
				if values[3] then
					file:write(", ")
					writeExpression(state, writer, indent, nextLocalN, localsStack, values[3])
				end
				file:write(" do")
				writeEol(state, writer)

				writeLoopBodyAndFooter(state, writer, forLoop, indent, nextLocalN, localsStack, deferStartIndex)

			elseif forLoop.forType == !(FOR_SHORT) then
				local objExpr = forLoop.expressions[1]
				local objType = objExpr.inferredType

				file:write(indentStr, "for ")

				if objType.tag == !(TYPE_VARARG) then
					!ASSERT("objExpr.nodeType == "..nodeTypes.AstVararg)

					addLineMapping(state, writer, objExpr.token)
					writeIdentifierName(state, writer, forLoop.declarations[1].name)
					file:write(" = ")

					if forLoop.reverse then
						file:write('_SELECT("#", ...), 1, -1')
					else
						file:write('1, _SELECT("#", ...)')
					end

					file:write(" do")
					writeEol(state, writer)

					file:write(indentStr, "\tlocal ")
					writeIdentifierName(state, writer, forLoop.declarations[2].name)
					file:write(" = _SELECT(")
					writeIdentifierName(state, writer, forLoop.declarations[1].name)
					file:write(", ...);")
					writeEol(state, writer)

				else
					objType = adjustTypeToOne(state, objExpr, objType, true)

					for i, decl in ipairs(forLoop.declarations) do
						if i > 1 then  file:write(", ")  end
						writeIdentifierName(state, writer, decl.name)
					end

					file:write(" in ")

					if objType.tag == !(TYPE_ARRAY) then
						addLineMapping(state, writer, objExpr.token)
						if forLoop.reverse then
							file:write("_IPAIRSR")
						else
							file:write("_IPAIRS")
						end

					elseif objType.tag == !(TYPE_TABLE) then
						assert(not forLoop.reverse)
						addLineMapping(state, writer, objExpr.token)
						file:write("_PAIRS")

					elseif objType.tag == !(TYPE_STRUCT) then
						assert(not forLoop.reverse)
						errorUnhandledNodeType(state, objExpr)
						-- @Incomplete: Output default iterator for the struct. Also handle array-like structs and structured tables.
						-- writeConstantValueOrReference(state, writer, interatorFuncConst?, objExpr)

					else
						errorInternal(state, objExpr)
					end

					file:write("(")
					writeExpression(state, writer, indent, nextLocalN, localsStack, objExpr)
					file:write(") do")
					writeEol(state, writer)
				end

				writeLoopBodyAndFooter(state, writer, forLoop, indent, nextLocalN, localsStack, deferStartIndex)

			else--if forLoop.forType == !(FOR_ITERATOR) then
				file:write(indentStr, "for ")

				for i, decl in ipairs(forLoop.declarations) do
					if i > 1 then  file:write(", ")  end
					writeIdentifierName(state, writer, decl.name)
				end
				file:write(" in ")
				for i, valueExpr in ipairs(forLoop.expressions) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, writer, indent, nextLocalN, localsStack, valueExpr)
				end
				file:write(" do")
				writeEol(state, writer)

				writeLoopBodyAndFooter(state, writer, forLoop, indent, nextLocalN, localsStack, deferStartIndex)
			end

		elseif nodeType == !(nodeTypes.AstBreak) then
			local breakNode = statement

			local deferStartIndexBreak = writer.loopDeferIndices[writer.loopDepth] or errorInternal()
			local defers               = writer.deferStack[deferStartIndexBreak] and {unpack(writer.deferStack, deferStartIndexBreak)} or EMPTY_TABLE
			writeDefers(state, writer, indent, nextLocalN, localsStack, indentStr, defers)

			if breakNode.loop then
				local i                 = indexOf(writer.loopStack, breakNode.loop) or errorInternal(state, breakNode)
				local outerLoopsToBreak = #writer.loopStack-i
				file:write(indentStr, "_BREAK = ",outerLoopsToBreak," ; break")
			else
				file:write(indentStr, "break")
			end

			writeEol(state, writer)

		elseif nodeType == !(nodeTypes.AstDefer) then
			local defer = statement
			table.insert(writer.deferStack, defer)

		elseif nodeType == !(nodeTypes.AstSwitch) then
			local switch = statement

			file:write(indentStr, "local _SWITCH = ")
			writeExpression(state, writer, indent, nextLocalN, localsStack, switch.value)
			writeEol(state, writer)

			if switch.cases[1] then
				local fallingThrough = false

				for i, case in ipairs(switch.cases) do
					if fallingThrough then
						if case.fallThrough or case.value then
							file:write(" or")
						end
					elseif not case.value then
						-- void
					elseif i == 1 then
						file:write(indentStr, "if")
					else
						file:write(indentStr, "elseif")
					end

					if case.value then
						file:write(" _SWITCH == ")
						writeExpression(state, writer, indent, nextLocalN, localsStack, case.value)
					end

					if not case.fallThrough then
						if case.value or fallingThrough then
							file:write(" then")
						elseif i == 1 then
							file:write(indentStr, "do")
						else
							file:write(indentStr, "else")
						end
						writeEol(state, writer)
						writeBlock(state, writer, indent+1, nextLocalN, localsStack, case.body)
					end

					fallingThrough = case.fallThrough
				end

				file:write(indentStr, "end") ; writeEol(state, writer)
			end

		else
			-- Assume the statement is an expression at this point and let writeExpression() deal with any errors.
			file:write(indentStr)
			writeExpression(state, writer, indent, nextLocalN, localsStack, statement)
			file:write(";") -- This removes ambiguity is some cases.
			writeEol(state, writer)
		end
	end

	local doWriteDefers = (
		writer.deferStack[deferStartIndex]
		and not (
			block.statementsDynamic[1]
			and getLast(block.statementsDynamic).nodeType == !(nodeTypes.AstReturn)
		)
	)

	local defers = doWriteDefers and {unpack(writer.deferStack, deferStartIndex)} or EMPTY_TABLE

	for i = deferStartIndex, #writer.deferStack do
		writer.deferStack[i] = nil
	end
	writeDefers(state, writer, indent, nextLocalN, localsStack, indentStr, defers)
end

function _G.writeForeignReference(state, writer, foreignSourceId, nodeForError)
	if writer.foreignOnlyAvailableDuringCompilation[foreignSourceId] and writer.outputRuntime and not keepDeadCode then
		nodeError(state, nodeForError, "ProgramWriter", "Trying to write runtime reference to compile-time-only symbol.")
	end
	writer.file:write(writer.foreignReferences[foreignSourceId])
end

function _G.writeFunction(state, writer, indent, nextLocalN, localsStack, lambda)
	!ASSERT `not lambda.body[1]` -- Statements should be in lambda.body.statements*!
	!ASSERT `not lambda.isPolymorphic`

	local file = writer.file

	addLineMapping(state, writer, lambda.token)

	if lambda.bodyIsForeign then
		writeForeignReference(state, writer, lambda.foreignSourceId, lambda.foreignSourceName)
		return
	end

	local indentStr = ("\t"):rep(indent)
	table.insert(localsStack, {})

	file:write("function(")

	if lambda.argumentsIn then
		for i, arg in ipairs(lambda.argumentsIn.arguments) do
			if i > 1 then  file:write(", ")  end

			local decl = arg.declaration

			if decl.name.nodeType == !(nodeTypes.AstVararg) then
				decl.localName = "..."
			else
				decl.localName = allocateArgumentName(state, writer, localsStack, decl.name.name, i)
			end

			file:write(decl.localName)
		end
	end

	file:write(")")
	writeEol(state, writer)

	if lambda.body.statementsDynamic[1] then
		writeBlock(state, writer, indent+1, nextLocalN, localsStack, lambda.body)
	elseif outputDebugInfo then
		file:write(indentStr, "\t-- Empty function.")
		writeEol(state, writer)
	end

	file:write(indentStr, "end")
	table.remove(localsStack)
end

function _G.writeForeignImportIfNew(state, writer, typeInfo, foreignSource, foreignSourceName, foreignSourceId, token, asGlobal)
	assert(foreignSourceId ~= "")

	if writer.foreignReferences[foreignSourceId] then  return  end
	if foreignSource == "method"                 then  return  end -- Methods are "imported" when they are called.

	-- @Incomplete: Compiler setting for runtime checks of anything originating from foreign sources.
	-- (We can probably wrap the importing code in something here using typeInfo.)

	local file = writer.file

	local foreignN  = writer.foreignN+1
	writer.foreignN = foreignN

	if foreignN == 1 then
		file:write("\t")
		if not asGlobal then  file:write("local ")  end
		file:write("_FOREIGN = {}")
		writeEol(state, writer)
	end

	addLineMapping(state, writer, token) -- Must happen after _FOREIGN is declared.

	if foreignSource == "lua" then
		if outputDebugInfo then
			writer.foreignReferences[foreignSourceId] = F("_FOREIGN[%d%s]", foreignN, formatInfoComment(foreignSourceId))
			file:write("\t_FOREIGN[", F("%d", foreignN), "]")
		else
			local foreignRef                         = F("_FOREIGN[%d]", foreignN)
			writer.foreignReferences[foreignSourceId] = foreignRef
			file:write("\t", foreignRef)
		end

		file:write(" = (", foreignSourceName, ")") -- @Robustness: Is this too straightforward?
		writeEol(state, writer)

		if foreignSourceName:find"\n" then
			local _, nlCount         = foreignSourceName:gsub("\n", "%0")
			writer.currentOutputLine = writer.currentOutputLine + nlCount -- @Incomplete: Call addLineMapping(state,) for every line here.
		end

	elseif foreignSource == "compiler" then
		local lua = nil

		if not writer.outputRuntime then
			lua = foreignApiCompilerSymbolsDuringCompilation[foreignSourceName]
		elseif foreignApiCompilerSymbolsDuringCompilation[foreignSourceName] then
			writer.foreignOnlyAvailableDuringCompilation[foreignSourceId] = true
		end

		if not lua then
			lua = foreignApiCompilerSymbols[foreignSourceName] or errorInternal("%s", foreignSourceName)
		end

		if outputDebugInfo then
			writer.foreignReferences[foreignSourceId] = F("_FOREIGN[%d--[[%s]]]", foreignN, foreignSourceId)
			file:write("\t_FOREIGN[", F("%d", foreignN), "]")
		else
			local foreignRef                          = F("_FOREIGN[%d]", foreignN)
			writer.foreignReferences[foreignSourceId] = foreignRef
			file:write("\t", foreignRef)
		end

		file:write(" = ", lua)
		writeEol(state, writer)

		if lua:find"\n" then
			local _, nlCount         = lua:gsub("\n", "%0")
			writer.currentOutputLine = writer.currentOutputLine + nlCount -- @Incomplete: Call addLineMapping(state,) for every line here.
		end

	else
		errorInternal("Incomplete: Handle foreignSource=%s", foreignSource)
	end
end

local function writeNormalSimpleConstant(state, writer, tag, v, isEnum)
	local file = writer.file

	if tag == !(TYPE_BOOL) then
		file:write(v and "true" or "false")

	elseif tag == !(TYPE_INT) then
		if v == 0 then
			file:write("0") -- Avoid writing '-0'.
		else
			local nStr = tostring(v)
			if not nStr:find"^%-?%d+$" then
				errorLine("ProgramWriter", "Cannot write value as integer: %s", tostring(v))
			end
			if nStr:byte(1) == !(getByte"-") then
				file:write("(", nStr, ")") -- @Incomplete: Use shouldOperationHaveSurroundingParentheses().
			else
				file:write(nStr)
			end
		end

	elseif tag == !(TYPE_FLOAT) then
		-- @Incomplete: Use shouldOperationHaveSurroundingParentheses().
		if v == 0 then
			file:write("0.0") -- Avoid writing '-0.0'.
		elseif v == math.huge then
			file:write("_HUGE")
		elseif v == -math.huge then
			file:write("(-_HUGE)")
		elseif v ~= v then
			file:write("(0/0)")
		else
			local floatStr = tostring(v)
			if not floatStr:find(".", 1, true) then
				floatStr = floatStr..".0"
			end
			if floatStr:byte(1) == !(getByte"-") then
				file:write("(", floatStr, ")")
			else
				file:write(floatStr)
			end
		end

	elseif tag == !(TYPE_NONE) then
		file:write("nil")

	elseif tag == !(TYPE_STRING) then
		writeStringLiteral(writer, v)

	elseif tag == !(TYPE_TYPE) then
		local typeInfo = v
		file:write(F("%d", typeInfo.id))

		if outputDebugInfo and not isEnum then
			file:write(formatInfoComment(getFriendlyTypeInfoName(typeInfo)))
		end

	else
		errorInternal("Incomplete: Handle constant value of type '%s'.", (TYPE_NAMES[tag] or "?"))
	end
end

local TYPE_NAMES_UPPER = {}

local function writeTypeInfo(state, writer, typeInfo)
	local file = writer.file

	!(
	local function END_OF_TYPE_INFO(typeInfoStructName)
		-- @Robustness: Get the name in the comment from the correct TypeInfo* struct declaration.
		return templateToLua(
			trimTemplate`
				file:write("}")
				if outputDebugInfo then  file:write("--[[$typeInfoStructName]]")  end
			`,
			{typeInfoStructName=typeInfoStructName}
		)
	end
	)

	local tag = typeInfo.tag

	-- Note: This table must be synced with preload and messenger!
	file:write("{tag=", tag)
	if outputDebugInfo then
		TYPE_NAMES_UPPER[tag] = TYPE_NAMES_UPPER[tag] or TYPE_NAMES[tag]:upper()
		file:write("--[[TypeTag.", TYPE_NAMES_UPPER[tag], "]]")
	end
	file:write(",id=")
	writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false)

	if tag == !(TYPE_ARRAY) then
		local arraySig = typeInfo

		file:write(",itemType=")
		writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), arraySig.itemType, false)

		!!(END_OF_TYPE_INFO"TypeInfoArray")

	elseif tag == !(TYPE_VARARG) then
		local varargSig = typeInfo

		file:write(",itemType=")
		writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), varargSig.itemType, false)

		!!(END_OF_TYPE_INFO"TypeInfoVararg")

	elseif tag == !(TYPE_FUNCTION) then
		local funcSig = typeInfo

		file:write(",argumentsIn={")
		for i, typeInfo in ipairs(funcSig.argumentTypesIn) do
			if i > 1 then  file:write(",")  end
			file:write("{argumentType=")
			writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false)
			file:write("}")
		end
		file:write("}")

		file:write(",argumentsOut={")
		for i, typeInfo in ipairs(funcSig.argumentTypesOut) do
			if i > 1 then  file:write(",")  end
			file:write("{argumentType=")
			writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false)
			file:write("}")
		end
		file:write("}")

		!!(END_OF_TYPE_INFO"TypeInfoFunction")

	elseif tag == !(TYPE_STRUCT) then
		-- @Incomplete: Output struct kind and key/value types. (Remember to update preload and messenger.)
		local structInfo = typeInfo

		file:write(",members={")
		for i, member in ipairs(structInfo.members) do
			if i > 1 then  file:write(",")  end
			file:write("{name=")
			writeStringLiteral(writer, member.name)
			file:write(",memberType=")
			writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), member.typeInfo, false)
			file:write("}")
		end
		file:write("}")

		!!(END_OF_TYPE_INFO"TypeInfoStruct")

	elseif tag == !(TYPE_ENUM) then
		local enumInfo = typeInfo

		file:write(",memberType=")
		writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), enumInfo.memberTypeInfo, false)

		file:write(",members={")
		for i, member in ipairs(enumInfo.members) do
			if i > 1 then  file:write(",")  end
			file:write("{name=")
			writeStringLiteral(writer, member.name)
			file:write("}")
		end
		file:write("}")

		!!(END_OF_TYPE_INFO"TypeInfoEnum")

	elseif tag == !(TYPE_COMPOUND) then
		local compound = typeInfo

		file:write(",types={")
		for i, compoundItem in ipairs(compound) do
			if i > 1 then  file:write(",")  end
			writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), compoundItem, false)
		end
		file:write("}")

		!!(END_OF_TYPE_INFO"TypeInfoCompound")

	elseif !!(CONST_SET{ -- :SimplePublicTypeInfo
		TYPE_ANY,
		TYPE_BOOL,
		TYPE_FLOAT,
		TYPE_INT,
		TYPE_NONE,
		TYPE_PLACEHOLDER,
		TYPE_STRING,
		TYPE_TABLE,
		TYPE_TYPE,
		TYPE_VOID,
	})[tag] then
		-- void  No more information.
		!!(END_OF_TYPE_INFO"TypeInfo")

	else
		errorInternal("Incomplete: %s", getFriendlyTypeInfoName(typeInfo))
	end
end

function _G.writeConstantValue(state, writer, const, nodeForError)
	local file = writer.file
	local tag  = const.valueType.tag

	if const.kind == !(CONST_KIND_FOREIGN) then
		local foreign = const.value
		writeForeignReference(state, writer, foreign.sourceId, nodeForError)

	elseif const.kind == !(CONST_KIND_TYPE_INFO) then
		local typeInfo = const.value
		file:write("_TYPE_INFO[", typeInfo.id, "]")
		-- writeTypeInfo(state, writer, const.value)

	elseif const.kind == !(CONST_KIND_LOCATION) then
		local target = const.value
		local tokens = state.tokens
		local token  = target.token

		-- Note: This table must be synced with the preload module!
		file:write("{filePath=")
		writeStringLiteral(writer, tokens.file[token])
		file:write(", lineNumber=", tokens.line1[token], ", position=", tokens.position1[token], "}")

	elseif const.kind == !(CONST_KIND_NULL) then
		file:write("nil")

	elseif const.kind == !(CONST_KIND_VIEW) then
		-- Note: The constants must be written in the same order as they were allocated for these
		-- views to work (which is what should happen naturally because of how dependencies work).
		writeAccess(state, writer, 1, 1, {}, const.value)

	--------------------------------

	elseif const.kind ~= !(CONST_KIND_NORMAL) then
		errorInternal(state, nodeForError, "Incomplete: Handle constant kind '%s'.", (CONST_KIND_TITLES[const.kind] or "?"))

	elseif not const.isObject then
		if tag ~= !(TYPE_ENUM) then
			writeNormalSimpleConstant(state, writer, tag, const.value, false)
			return
		end

		local enumInfo   = const.valueType
		local memberName = const.value
		local decl       = findMemberDeclaration(state, enumInfo.astNode, memberName) or errorInternal(state, enumInfo.astNode, "Did not find member '%s'.", memberName)
		local valueExpr  = decl.value

		if enumInfo.memberTypeInfo.tag == !(TYPE_TYPE) then
			local typeNode = valueExpr
			!ASSERT("typeNode.nodeType == "..nodeTypes.AstType)
			writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeNode.representedType, true)
		else
			local literal = valueExpr
			!ASSERT("literal.nodeType == "..nodeTypes.AstLiteral)
			writeNormalSimpleConstant(state, writer, enumInfo.memberTypeInfo.tag, literal.value, true)
		end

		if outputDebugInfo then
			file:write("--[[", enumInfo.name, ".", memberName, "]]")
		end

	elseif tag == !(TYPE_FUNCTION) then
		local lambda = const.value
		writeFunction(state, writer, 1, 1, {}, lambda)

	elseif !!(CONST_SET{ TYPE_TABLE, TYPE_ARRAY, TYPE_STRUCT })[tag] then
		local tableNode = const.value
		writeExpression(state, writer, 1, 1, {}, tableNode)

	elseif !!(CONST_SET{ TYPE_ANY, TYPE_NAMESPACE, TYPE_COMPOUND, TYPE_LIST })[tag] then
		errorInternal(state, nodeForError, "Cannot write invalid value type '%s'.", TYPE_NAMES[tag])
	else
		errorInternal(state, nodeForError, "Incomplete: Handle constant value of type '%s'.", (TYPE_NAMES[tag] or "?"))
	end
end

function _G.writeConstantValueOrReference(state, writer, const, nodeForError)
	if not const.isObject then
		writeConstantValue(state, writer, const, nodeForError)
		return
	end

	if const.valueType.tag == !(TYPE_FUNCTION) then
		local lambda = const.value

		if lambda.bodyIsForeign and lambda.foreignSource == "method" then
			!TRACE()
			printerr()
			nodeMessage(io.stderr, state, nodeForError, "Error", "ProgramWriter", "Cannot output references to foreign methods.")
			if nodeForError ~= lambda then
				nodeMessage(io.stderr, state, lambda, "Info", "ProgramWriter", "...here is the method.")
			end
			exitFailure()
		end
	end

	writer.file:write(const.name)
end



function _G.writeLuaPreloads(state, writer, fromIndex)
	local file = writer.file

	for i = fromIndex, #state.luaPreloads do
		local luaPreload = state.luaPreloads[i]

		file:write("do\n", luaPreload.lua, "\nend\n")

		local _, nlCount = luaPreload.lua:gsub("\n", "%0")

		local trimmedInitialNewline = state.tokens.extra[luaPreload.token]
		local stringTokenFile       = state.tokens.file [luaPreload.token] or errorInternal()
		local stringTokenLn         = state.tokens.line1[luaPreload.token] + luaPreload.lineOffset - 2 + (trimmedInitialNewline and 1 or 0)

		local outputOffsetLn = writer.currentOutputLine-1

		for ln = 2, nlCount+2 do
			writer.lineMappingFiles[outputOffsetLn+ln] = stringTokenFile
			writer.lineMappingLines[outputOffsetLn+ln] = stringTokenLn+ln
		end

		writer.currentOutputLine = writer.currentOutputLine+nlCount+3
	end
end

function _G.writeCompilerSymbols(state, writer)
	local file = writer.file

	if writer.outputRuntime then
		file:write("local lineMappings      = {paths={},files={},lines={}}") ; writeEol(state, writer)
		file:write("local programArguments  = {...}") ; writeEol(state, writer) -- Should we use 'arg' here? It has additional stuff in index 0 and below. metaprogramArguments needs to be updated too.
		file:write!("local gloaErrorHandler = "..ERROR_HANDLER) ; writeEol(state, writer)

		-- @Incomplete: Option for excluding type information from the program as it takes up a lot of space.
		-- @Polish: Also maybe don't write this if no type info is accessed in the written program?

		local first = true

		file:write("local _TYPES = {")
		for _, typeInfo in ipairs(state.allTypeInfos) do
			if isTypePublic(typeInfo) then
				if not typeInfo.isReady then
					errorInternal("Type info is not ready for '%s'.", getFriendlyTypeInfoName(typeInfo))
				end

				if not first then  file:write(",")  end
				first = false

				file:write(typeInfo.id)
			end
		end
		file:write("}") ; writeEol(state, writer)

		local first       = true
		local sequenceGap = 0

		-- @Incomplete: Option for excluding this. @Polish: Also maybe don't write this if no type info is accessed in the written program?
		file:write("local _ = nil") ; writeEol(state, writer)
		file:write("local _TYPE_INFO = {")
		for typeId, typeInfo in ipairs(state.allTypeInfos) do
			if isTypePublic(typeInfo) then
				if not first then  file:write(",")  end
				first = false

				-- Note: Type index and type ID are the same.
				if sequenceGap == 0 then
					-- void
				elseif sequenceGap < 30 then
					file:write(("nil,"):rep(sequenceGap))
					sequenceGap = 0
				else
					file:write("[", typeId, "]=")
				end

				writeTypeInfo(state, writer, typeInfo)

			else
				sequenceGap = sequenceGap+1
			end
		end
		file:write("}") ; writeEol(state, writer)

	else
		-- Note: lineMappings is not used in metaprograms because gloaErrorHandler() is different.
		file:write("local programArguments = metaprogramArguments") ; writeEol(state, writer)
		file:write("local gloaErrorHandler = compilerErrorHandler") ; writeEol(state, writer)

		file:write("local _TYPES     = metaprogramTypeIds")   ; writeEol(state, writer)
		file:write("local _TYPE_INFO = metaprogramTypeTable") ; writeEol(state, writer)
	end

	-- @Polish: Only output symbols actually used in the program.
	!for i = 1, #COMPILER_SYMBOL_PAIRS, 2 do
		file:write!("local "..COMPILER_SYMBOL_PAIRS[i].." = "..COMPILER_SYMBOL_PAIRS[i+1])
		writeEol(state, writer)
	!end
end

-- writeForeignImports(state, writer, constants, asGlobals [, relevantObjects=all ] )
function _G.writeForeignImports(state, writer, constants, asGlobals, relevantObjects)
	for _, const in ipairs(constants) do
		if relevantObjects and not relevantObjects[const] then
			-- void

		elseif const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION) and const.value.bodyIsForeign then
			-- @Polish: Treat function constants pointing to the same foreign function as the same constant.
			local lambda = const.value
			writeForeignImportIfNew(state, writer, const.valueType, lambda.foreignSource, lambda.foreignSourceName.value, lambda.foreignSourceId, lambda.token, asGlobals)

		elseif const.kind == !(CONST_KIND_FOREIGN) then
			local foreign = const.value
			writeForeignImportIfNew(state, writer, foreign.inferredType, foreign.source, foreign.sourceName.value, foreign.sourceId, foreign.token, asGlobals)
		end
	end
end

-- writeConstantObjectsExceptFunctions( state, writer, constants, asGlobals [, relevantObjects=all ] )
function _G.writeConstantObjectsExceptFunctions(state, writer, constants, asGlobals, relevantObjects)
	local file = writer.file

	for _, const in ipairs(constants) do
		if relevantObjects and not relevantObjects[const] then
			-- void

		elseif const.isObject and not (const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION)) then
			file:write("\t")
			if not asGlobals then  file:write("local ")  end
			file:write(const.name, " = ")
			writeConstantValue(state, writer, const, const.value)
			writeEol(state, writer)
		end
	end
end

-- writeFunctionObjects( state, writer, constants [, relevantObjects=all ] )
function _G.writeFunctionObjects(state, writer, constants, relevantObjects)
	local functionConstants = {}

	for _, const in ipairs(constants) do
		if relevantObjects and not relevantObjects[const] then
			--void
		elseif const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION) then
			local lambda = const.value
			-- @Cleanup: Don't generate constants for polymorphic functions. (It's probably declarations doing this.) (I guess don't generate constants for foreign methods either.)
			if not (lambda.isPolymorphic or (lambda.bodyIsForeign and lambda.foreignSource == "method")) then
				table.insert(functionConstants, const)
			end
		end
	end

	table.sort(functionConstants, function(a, b)
		a = a.value
		b = b.value
		if a.bodyIsForeign ~= b.bodyIsForeign then  return a.bodyIsForeign    end
		if a.token         ~= b.token         then  return a.token < b.token  end
		return a.s < b.s
	end)

	local file = writer.file

	for _, const in ipairs(functionConstants) do
		local lambda = const.value
		file:write("\t", const.name, " = ")
		writeFunction(state, writer, 1, 1, {}, lambda)
		writeEol(state, writer)
	end
end

-- writeTopScopeDeclarations( state, writer, declarations [, relevantObjects=all ] )
function _G.writeTopScopeDeclarations(state, writer, declarations, relevantObjects)
	local file = writer.file

	for _, decl in ipairs(declarations) do
		if relevantObjects and not relevantObjects[decl] then
			-- void

		elseif decl.topScopeName ~= "" then -- Constant declarations of non-objects (e.g. ints) should have an empty topScopeName.
			file:write("\t", decl.topScopeName, " = ")
			if decl.valueConstant then
				writeConstantValueOrReference(state, writer, decl.valueConstant, decl.name)
			else
				-- We should have a declared struct instance or something similar here (I think) that doesn't have a specified initial value.
				writeDefaultValueForType(state, writer, 1, 1, {}, decl.name.inferredType, decl.name)
			end
			writeEol(state, writer)
		end
	end
end

function _G.writeProgram(state, writer)

	-- Gather info.
	local globalScope          = state.globalScope
	local topScopeDeclarations = copyArray(globalScope.declarations)

	for _, fileScope in ipairs(globalScope.fileScopes) do
		insertArrayItems(topScopeDeclarations, fileScope.declarations)
	end

	local outputType = state.settings.outputType

	if outputType == !(OUTPUT_TYPE_LUA_MODULE) and not globalScope.fileScopeWithValueToExport then
		local filePaths = {}
		for _, fileScope in ipairs(globalScope.fileScopes) do
			if not fileScope.isModule then  table.insert(filePaths, fileScope.path)  end
		end
		errorLine(
			"ProgramWriter",
			"Missing value to export as the Lua module in top-level scope in loaded files:\n- %s",
			table.concat(filePaths, "\n- ")
		)
	end

	local mainFuncDecl, mainLambda = nil

	if outputType == !(OUTPUT_TYPE_LUA_APP) then
		local entryPointName = state.settings.entryPointName

		for _, decl in ipairs(topScopeDeclarations) do -- Note: topScopeDeclarations does not include static declarations or declarations in namespaces yet.
			if decl.name.name == entryPointName then
				mainFuncDecl = decl
				break
			end
		end

		if not mainFuncDecl then
			local filePaths = {}
			for _, fileScope in ipairs(globalScope.fileScopes) do
				if not fileScope.isModule then  table.insert(filePaths, fileScope.path)  end
			end
			errorLine(
				"ProgramWriter",
				"Missing program entry point ('%s' function) in top-level scope in loaded files:\n- %s",
				entryPointName, table.concat(filePaths, "\n- ")
			)

		elseif not isDeclarationConstant(mainFuncDecl) then
			nodeError(state, mainFuncDecl.name, "ProgramWriter", "Declared name '%s' must be a constant.", entryPointName)
		end

		mainLambda = mainFuncDecl.valueConstant.value

		if mainLambda.inferredType.tag ~= !(TYPE_FUNCTION) then
			nodeError(
				state, mainFuncDecl.value, "ProgramWriter",
				"Declared name '%s' must be a function to represent the entry point of the program.",
				entryPointName
			)
		end
		!ASSERT("mainLambda.nodeType == "..nodeTypes.AstLambda)

		if mainFuncDecl.overloadOf then
			nodeError(state, mainFuncDecl.name, "ProgramWriter", "Program entry point name must not be overloaded.")
		elseif mainLambda.inferredType.argumentTypesIn[1] then
			nodeError(state, mainLambda.argumentsIn, "ProgramWriter", "Program entry point function must not take any arguments.")
		elseif mainLambda.inferredType.argumentTypesOut[1] then
			nodeError(state, mainLambda.argumentsOut, "ProgramWriter", "Program entry point function must not return any values.")
		end
	end

	astVisitAllNodes(globalScope, function(node)
		if node.nodeType == !(nodeTypes.AstDeclaration) then
			local decl = node
			if decl.kind == !(DECL_KIND_STATIC) then
				table.insert(topScopeDeclarations, decl)
			end

		elseif node.nodeType == !(nodeTypes.AstNamespace) then
			local namespace = node
			insertArrayItems(topScopeDeclarations, namespace.declarations)
		end
	end)

	local relevantObjects = nil

	if not keepDeadCode then
		relevantObjects = {}

		if outputType == !(OUTPUT_TYPE_LUA_APP) then
			crawl(state, mainLambda, relevantObjects, false)
		elseif outputType == !(OUTPUT_TYPE_LUA_MODULE) then
			crawl(state, globalScope.fileScopeWithValueToExport.valueToExport, relevantObjects, false)
		else
			errorInternal("outputType==%d", outputType)
		end
	end

	--
	-- Write program.
	--
	local file               = writer.file
	writer.currentOutputLine = 1 -- @Cleanup: Not sure we need to reset this. The runner uses its own writer, right?

	if outputType == !(OUTPUT_TYPE_LUA_APP) then
		-- @Incomplete: Setting to specify the prefix for the written file (shebang and maybe a comment with copyright info, library documentation etc.).
		file:write('#!/bin/sh\n_=[[\nexec lua "$0" "$@"\n]] and nil\n')
		writer.currentOutputLine = 5
	end

	writeLuaPreloads(state, writer, 1)
	writeCompilerSymbols(state, writer)

	-- Start of user code.
	addLineMappingDummy(state, writer)
	file:write("local function runProgram()") ; writeEol(state, writer)

	writeForeignImports(state, writer, state.constants, false, relevantObjects)
	writeConstantObjectsExceptFunctions(state, writer, state.constants, false, relevantObjects)

	if state.constants[1] or state.topScopeNames[1] then
		-- @Incomplete @Robustness: A nicer/better way of supporting more upvalues than Lua. Right now we just limit forward declarations of Glóa globals.
		!local MAX_UPVALUES = 60
		!local MAX_NAMES    = MAX_UPVALUES - COMPILER_SYMBOL_COUNT
		local declCount     = 0

		-- Forward declarations.
		local first = true
		file:write("\tlocal ")

		-- Constants, functions.
		for _, const in ipairs(state.constants) do
			if relevantObjects and not relevantObjects[const] then
				-- void

			elseif const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION) then
				local lambda = const.value

				if not (lambda.isPolymorphic or (lambda.bodyIsForeign and lambda.foreignSource == "method")) then
					declCount = declCount+1
					if declCount > !(MAX_NAMES) then  break  end

					if not first then  file:write(", ")  end
					first = false
					file:write(const.name)
				end
			end
		end

		-- Top-level declarations. (Note: Glóa globals are not Lua globals.)
		for _, topScopeName in ipairs(state.topScopeNames) do
			declCount = declCount+1
			if declCount > !(MAX_NAMES) then  break  end

			if not first then  file:write(", ")  end
			first = false
			file:write(topScopeName)
		end

		writeEol(state, writer)
	end

	writeFunctionObjects(state, writer, state.constants, relevantObjects) -- Must be after forward declarations!
	writeTopScopeDeclarations(state, writer, topScopeDeclarations, relevantObjects)

	-- Write program entry point.

	if outputType == !(OUTPUT_TYPE_LUA_APP) then
		addLineMappingDummy(state, writer)
		file:write("\t", mainFuncDecl.valueConstant.name, "()")
		writeEol(state, writer)

	elseif outputType == !(OUTPUT_TYPE_LUA_MODULE) then
		addLineMappingDummy(state, writer)
		file:write("\treturn ")
		writeExpression(state, writer, 2, 1, {}, globalScope.fileScopeWithValueToExport.valueToExport)
		writeEol(state, writer)

	else
		errorInternal("outputType==%d", outputType)
	end

	-- End of user code.
	file:write("end") ; writeEol(state, writer)

	if outputDebugInfo then
		!(
		-- Size of line mapping information in bytes in a small test program:
		--
		--            pad   exact indices
		--     files  1700  3500
		--     lines  2400  4300
		--
		local USE_PADDING = true -- Enabling this seem better.
		)

		writer.currentOutputLine = writer.currentOutputLine+5
		addLineMappingDummy(state, writer) -- For the xpcall() here below.

		local MODULE_DIR_PREFIX = COMPILER_DIRECTORY.."/modules/"

		local pathIndices = {}
		local pathIndex   = 0
		local first       = true

		file:write("local _ = nil\n") -- Takes up less space than 'nil'.

		file:write("lineMappings.paths = {")
		for ln = 1, writer.currentOutputLine do
			local path = writer.lineMappingFiles[ln]

			if writer.lineMappingLines[ln] and not pathIndices[path] then
				if not first then  file:write(",")  end
				first = false

				pathIndex         = pathIndex+1
				pathIndices[path] = pathIndex

				!if DEBUG then
					path = path:gsub("^%./(.*/)", "%1")
				!else
					if path:sub(1, #MODULE_DIR_PREFIX) == MODULE_DIR_PREFIX then
						path = "module:"..path:sub(#MODULE_DIR_PREFIX+1):gsub("%.gloa$", "")
					end
				!end

				file:write(F("%q", path))
			end
		end
		file:write("}\n")

		file:write("lineMappings.files = {")
		!if USE_PADDING then
			for ln = 1, writer.currentOutputLine do
				if ln > 1 then  file:write(",")  end
				file:write(pathIndices[writer.lineMappingFiles[ln]] or "_")
			end
		!else
			first = true
			for ln = 1, writer.currentOutputLine do
				if writer.lineMappingLines[ln] then
					if not first then  file:write(",")  end
					first = false
					file:write(F("[%d]=%d", ln, pathIndices[writer.lineMappingFiles[ln]]))
				end
			end
		!end
		file:write("}\n")

		file:write("lineMappings.lines = {")
		!if USE_PADDING then
			for ln = 1, writer.currentOutputLine do
				if ln > 1 then  file:write(",")  end
				file:write(writer.lineMappingLines[ln] or "_")
			end
		!else
			first = true
			for ln = 1, writer.currentOutputLine do
				if writer.lineMappingLines[ln] then
					if not first then  file:write(",")  end
					first = false
					file:write(F("[%d]=%d", ln, writer.lineMappingLines[ln]))
				end
			end
		!end
		file:write("}\n")
	end

	local moduleVariableCode = (outputType == !(OUTPUT_TYPE_LUA_MODULE) and ", module" or "")

	file:write("local os, ok"..moduleVariableCode.." = os, xpcall(runProgram, gloaErrorHandler)\n")
	file:write("if not ok then  os.exit(1)  end\n") -- In case there was an error in gloaErrorHandler() for some reason.  :LuaModuleErrors

	if outputType == !(OUTPUT_TYPE_LUA_MODULE) then
		file:write("return module\n")
	end

	file:close()
end



local UNICODE_TO_ASCII = @insert "unicodeConversions.luapart"

function _G.unicodeToLuaIdentifier(name)
	if name:find"[\128-\255]" then
		name = name:gsub(!(UTF8_CHARACTER_PATTERN), function(c)
			return (#c == 1 and c) or UNICODE_TO_ASCII[c] or "_"
		end)
	elseif LUA_KEYWORDS[name] then
		name = name.."_"
	end
	return name
end



local HAS_DEFAULT_VALUE = !(Set{
	TYPE_BOOL,
	TYPE_INT,
	TYPE_NONE,
	TYPE_FLOAT,
	TYPE_STRING,
	TYPE_ARRAY,
	TYPE_TABLE,
	TYPE_STRUCT,
	TYPE_VARARG, -- Varargs never have any default value(s), but because it's a list we can just say that the default value is "nothing".
})
function _G.doesTypeHaveAnyDefaultValue(typeInfo)
	return HAS_DEFAULT_VALUE[typeInfo.tag] or false
end



function _G.validateForeignSource(state, foreignSource, foreignSourceName, nodeForError)
	if foreignSource == "lua" then
		if not (foreignSourceName:find"^[%w_]+$" or foreignSourceName:find"^[%a_][%w_]*%.[%a_][%w_]*$" or loadstring(F("return(%s)", foreignSourceName))) then
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid Lua symbol.")
		end

	elseif foreignSource == "compiler" then
		if not foreignApiCompilerSymbols[foreignSourceName] then
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid compiler symbol.")
		end

	elseif foreignSource == "method" then
		--[[ Hmm, I think we *will* support keywords and weird names as method names actually.
		if not (foreignSourceName:find"^[%a_][%w_]*$" ~= nil and not LUA_KEYWORDS[foreignSourceName]) then
			-- @UX: The error arrow is way off!
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid Lua identifier to use as method name: '%s'", foreignSourceName)
		end
		--]]

	else
		errorInternal(state, nodeForError, "Incomplete: Handle foreignSource=%s", foreignSource)
	end
end



function _G.formatInfoComment(info)
	return "--[[" .. info:gsub("[%[%]]", "%0 ") .. "]]"
end


