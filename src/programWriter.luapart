--[[============================================================
--=
--=  Program Writer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	unicodeToLuaIdentifier
	writeProgram, write*

--============================================================]]



function _G.writeIdentifierName(state, file, ident)
	local decl = ident.declaration
	local name = decl.topScopeName

	if name == "" then  name = decl.localName  end

	if name == "" then
		nodeError(state, ident, "ProgramWriter", "Internal compiler error: Missing name to write for '%s'.", ident.name)
	end

	file:write(name)
end

function _G.writeExpression(state, file, expr, indent, nextLocalN)
	if expr.nodeType == !(nodeTypes.AstCall) then
		local call   = expr
		local callee = call.callee

		if call.surroundedByParenthesis then  file:write("(")  end

		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			assert(callee.declaration.valueConstant)
			writeConstantValueOrReference(state, file, callee.declaration.valueConstant)
		else
			writeExpression(state, file, callee, indent, nextLocalN)
		end

		file:write("(")
		for i, argExpr in ipairs(call.arguments) do
			if i > 1 then  file:write(", ")  end
			writeExpression(state, file, argExpr, indent, nextLocalN)
		end
		file:write(")")

		if call.surroundedByParenthesis then  file:write(")")  end

	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		local unary = expr
		file:write("(", unary.operation)
		writeExpression(state, file, unary.expression, indent, nextLocalN)
		file:write(")")

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr
		file:write("(")
		writeExpression(state, file, binary.left, indent, nextLocalN)
		file:write(" ", binary.operation, " ")
		writeExpression(state, file, binary.right, indent, nextLocalN)
		file:write(")")

	elseif expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		writeConstantValue(state, file, literal.valueConstant)

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		writeIdentifierName(state, file, ident)

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		file:write(F("%d", typeNode.representedType.id)) -- @Cleanup: We probably have a constant for the type ID to use with writeConstantValue() here, but who cares...
		if state.settings.outputDebugInfo then
			file:write("--[[", getFriendlyTypeInfoName(typeNode.representedType):gsub("%]", "%0 "), "]]")
		end

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda   = expr
		local constant = itemWith1(state.constants, "valueType", lambda.inferredType) or errorInternal()
		writeConstantValueOrReference(state, file, constant)

	elseif expr.nodeType == !(nodeTypes.AstBlock) then
		local block     = expr
		local indentStr = ("\t"):rep(indent)
		file:write("do\n")
		writeImperativeBlock(state, file, block, indent+1, nextLocalN)
		file:write(indentStr, "end")

	else
		errorUnhandledNodeType(expr)
	end
end

-- writeImperativeBlock( state, file, block, indentation, nextLocalNumber )
function _G.writeImperativeBlock(state, file, block, indent, nextLocalN)
	local outputDebugInfo = state.settings.outputDebugInfo
	local indentStr       = ("\t"):rep(indent)

	if not block[1] then
		if state.settings.outputDebugInfo then
			file:write(indentStr, "-- Empty block.\n")
		end
		return
	end

	for _, statement in ipairs(block) do
		local nodeType = statement.what.nodeType

		if nodeType == !(nodeTypes.AstDeclaration) then
			local decl = statement.what

			if decl.isConstant then
				skipNextAssignment = true

			else
				decl.localName = outputDebugInfo and "L"..nextLocalN.."_"..unicodeToLuaIdentifier(decl.name.name) or "L"..nextLocalN
				nextLocalN     = nextLocalN+1

				if decl.assignment then
					inDecl = true
					if decl.assignmentIndex == 1 then
						file:write(indentStr, "local ")
					end

				else
					local tag = decl.name.inferredType.tag
					file:write(indentStr, "local ", decl.localName, " = ")

					if tag == !(typeTags.TypeInfoBool) then
						file:write("false")

					elseif tag == !(typeTags.TypeInfoInt) then
						file:write("0")

					elseif tag == !(typeTags.TypeInfoNil) then
						file:write("nil")

					elseif tag == !(typeTags.TypeInfoFloat) then
						file:write("0.0")

					elseif tag == !(typeTags.TypeInfoString) then
						file:write('""')

					elseif tag == !(typeTags.TypeInfoType) then
						file:write("0")

					else
						errorInternal("Incomplete: Default initial value for type '%s'.", (TYPE_TAG_NAMES[tag] or "?"))
					end

					file:write("\n")
				end

				-- The initial assignment, if there is one, should be written as the next statement (or after several declarations).
			end

		elseif nodeType == !(nodeTypes.AstAssignment) then
			if not skipNextAssignment then
				local assignment = statement.what
				assert(assignment.operation == "=", "@Incomplete: Support more than '='.")

				if not inDecl then
					file:write(indentStr)
				end
				for i, ident in ipairs(assignment.targets) do
					if i > 1 then  file:write(", ")  end
					writeIdentifierName(state, file, ident)
				end
				file:write(" ", assignment.operation, " ")
				for i, expr in ipairs(assignment.values) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, file, expr, indent, nextLocalN)
				end
				file:write("\n")
			end

			inDecl             = false
			skipNextAssignment = false

		elseif nodeType == !(nodeTypes.AstReturn) then
			local returnNode = statement.what

			file:write(indentStr, "return")
			for i, expr in ipairs(returnNode.values) do
				if i > 1 then  file:write(",")  end
				file:write(" ")
				writeExpression(state, file, expr, indent, nextLocalN)
			end
			file:write("\n")

		elseif nodeType == !(nodeTypes.AstImport) then
			-- void  (Ignore import statements.)

		else
			-- Assume the statement is an expression at this point and let writeExpression() deal with any errors.
			file:write(indentStr)
			writeExpression(state, file, statement.what, indent, nextLocalN)
			file:write("\n")
		end
	end
end

function _G.writeFunction(state, file, lambda)
	local inDecl = false

	file:write("function(")

	if lambda.argumentsIn then
		for i, arg in ipairs(lambda.argumentsIn) do
			if i > 1 then  file:write(", ")  end

			local decl     = arg.declaration
			decl.localName = state.settings.outputDebugInfo and "A"..i.."_"..unicodeToLuaIdentifier(decl.name.name) or "A"..i

			file:write(decl.localName)
		end
	end

	file:write(")\n")

	if lambda.body[1] then
		writeImperativeBlock(state, file, lambda.body, 1, 1)
	elseif state.settings.outputDebugInfo then
		file:write("\t-- Empty function.\n")
	end

	file:write("end")
end

function _G.writeConstantValue(state, file, const)
	local tag = const.valueType.tag

	if tag == !(typeTags.TypeInfoBool) then
		file:write(const.value and "true" or "false")

	elseif tag == !(typeTags.TypeInfoInt) then
		file:write(F("%d", const.value))

	elseif tag == !(typeTags.TypeInfoNil) then
		file:write("nil")

	elseif tag == !(typeTags.TypeInfoFloat) then
		local floatStr = tostring(const.value) -- @Robustness: Preserve precision as well as possible.
		if not floatStr:find(".", 1, true) then  floatStr = floatStr..".0"  end
		file:write(floatStr)

	elseif tag == !(typeTags.TypeInfoString) then
		file:write(F("%q", const.value))

	elseif tag == !(typeTags.TypeInfoType) then
		local typeInfo = const.value
		file:write(F("%d", typeInfo.id))
		if state.settings.outputDebugInfo then
			file:write("--[[", getFriendlyTypeInfoName(typeInfo):gsub("%]", "%0 "), "]]")
		end

	elseif tag == !(typeTags.TypeInfoTable) then
		errorInternal("@Incomplete: Write table.")

	elseif tag == !(typeTags.TypeInfoArray) then
		errorInternal("@Incomplete: Write array.")

	elseif tag == !(typeTags.TypeInfoFunction) then
		local lambda = const.value
		writeFunction(state, file, lambda)

	elseif tag == !(typeTags.TypeInfoStruct) then
		errorInternal("@Incomplete: Write struct.")

	elseif tag == !(typeTags.TypeInfoEnum) then
		errorInternal("@Incomplete: Write enum.")

	elseif isAny(tag, !(typeTags.TypeInfoAny),!(typeTags.TypeInfoNamespace),!(typeTags.TypeInfoVoid),!(typeTags.TypeInfoCompound),!(typeTags.TypeInfoList)) then
		errorInternal("Cannot write invalid value type '%s'.", TYPE_TAG_NAMES[tag])
	else
		errorInternal("Incomplete: Handle constant value of type '%s'.", (TYPE_TAG_NAMES[tag] or "?"))
	end
end

function _G.writeConstantValueOrReference(state, file, const)
	if const.isObject then
		file:write(const.name)
	else
		return writeConstantValue(state, file, const)
	end
end

function _G.writeProgram(state)
	if not state.settings.doOutputFile then  return  end

	local path = state.settings.outputFilePath
	local file = assert(io.open(path, "w"))

	--
	-- Forward declarations.
	--

	-- Constants, non-functions.
	for _, const in ipairs(state.constants) do
		if const.isObject and const.valueType.tag ~= !(typeTags.TypeInfoFunction) then
			file:write("local ", const.name, " = ")
			writeConstantValue(state, file, const) -- Only functions need everything to be forward declared.
			file:write("\n")
		end
	end

	if state.constants[1] or state.topScopeNames[1] then
		local first = true
		file:write("local ")

		-- Constants, functions.
		for _, const in ipairs(state.constants) do
			if const.valueType.tag == !(typeTags.TypeInfoFunction) then
				if not first then  file:write(", ")  end
				first = false
				file:write(const.name)
			end
		end

		-- Top-level declarations. (Note: Glóa globals are not Lua globals.)
		for _, topScopeName in ipairs(state.topScopeNames) do
			if not first then  file:write(", ")  end
			first = false
			file:write(topScopeName)
		end

		file:write("\n")
	end

	--
	-- Definitions.
	--

	-- Function definitions.
	for _, const in ipairs(state.constants) do
		if const.valueType.tag == !(typeTags.TypeInfoFunction) then
			file:write(const.name, " = ")
			writeConstantValue(state, file, const)
			file:write("\n")
		end
	end

	!local ENTRY_POINT_NAME = "main" -- @Incomplete: Configurable entry point name.
	local mainFuncDecl      = nil

	-- Global assignments.
	for _, decl in ipairs(state.globalScope.declarations) do
		if decl.topScopeName ~= "" then
			file:write(decl.topScopeName, " = ")
			writeConstantValueOrReference(state, file, decl.valueConstant)
			file:write("\n")
		end
		if decl.name.name == !(ENTRY_POINT_NAME) then  mainFuncDecl = decl  end
	end
	-- File-scope assignments.
	for _, fileScope in ipairs(state.globalScope.fileScopes) do
		for _, decl in ipairs(fileScope.declarations) do
			if decl.topScopeName ~= "" then
				file:write(decl.topScopeName, " = ")
				writeConstantValueOrReference(state, file, decl.valueConstant)
				file:write("\n")
			end
			if decl.name.name == !(ENTRY_POINT_NAME) then  mainFuncDecl = decl  end
		end
	end

	--
	-- Program entry point.
	--

	if not mainFuncDecl then
		local filePaths = {}
		for i, fileScope in ipairs(state.globalScope.fileScopes) do
			filePaths[i] = fileScope.path
		end
		errorLine(
			"ProgramWriter",
			!("Missing program entry point ('"..ENTRY_POINT_NAME.."' function) in top-level scope in loaded files:\n- %s"),
			table.concat(filePaths, "\n- ")
		)

	elseif not mainFuncDecl.isConstant then
		nodeError(
			state, mainFuncDecl.name, "ProgramWriter",
			!("Declared name '"..ENTRY_POINT_NAME.."' must be a constant.")
		)

	elseif mainFuncDecl.name.inferredType.tag ~= !(typeTags.TypeInfoFunction) then
		nodeError(
			state, mainFuncDecl.assignment.values[mainFuncDecl.assignmentIndex], "ProgramWriter",
			!("Declared name '"..ENTRY_POINT_NAME.."' must be a function to represent the entry point of the program.")
		)

	elseif mainFuncDecl.name.inferredType.argumentTypesIn[1] then
		local lambda = getAssignmentValue(state, mainFuncDecl.name, mainFuncDecl.assignment.values, mainFuncDecl.assignmentIndex)
		nodeError(state, lambda.argumentsIn, "ProgramWriter", "Program entry point function must not take any arguments.")

	elseif mainFuncDecl.name.inferredType.argumentTypesOut[1] then
		local lambda = getAssignmentValue(state, mainFuncDecl.name, mainFuncDecl.assignment.values, mainFuncDecl.assignmentIndex)
		nodeError(state, lambda.argumentsOut, "ProgramWriter", "Program entry point function must not return any values.")
	end

	writeConstantValueOrReference(state, file, mainFuncDecl.valueConstant)
	file:write("()\n")

	file:close()
end



local UNICODE_TO_ASCII = @insert "unicodeConversions.luapart"

function _G.unicodeToLuaIdentifier(name)
	name = name:gsub(!(UTF8_CHARACTER_PATTERN), function(c)
		return (#c == 1 and c) or UNICODE_TO_ASCII[c] or "_"
	end)
	return name
end


