--[[============================================================
--=
--=  Program Writer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	doesTypeHaveAnyDefaultValue
	unicodeToLuaIdentifier, isExpressionLiteralStringAndValidLuaIdentifier
	validateForeignSource
	writeProgram, write*

----------------------------------------------------------------

	Format for written programs:
	- Foreign imports.
	- Constants.
	- Forward declarations.
	- Functions.
	- Global/file-scope variables.
	- Program entry point.

	Notes:
	- No Lua globals are read from or written to. (Glóa globals are not Lua globals.)
	- All functions are top-level in Lua no matter where they were defined in Glóa.
	- Local variables in Lua are uniquely named and thus never shadow anything (which might help with debugging).

	@Incomplete:
	- Handle the limited amount of locals Lua allows (200). (Maybe we'll have to use Lua globals to some extent after all.)

--============================================================]]



local FOREIGN_API_COMPILER_SYMBOLS = {
	-- APP_PATH
	-- Get the path to the application file. The path may be relative to the current working directory.
	APP_PATH = `(debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get application path.")) :gsub("\\", "/")`,

	-- APP_DIRECTORY
	-- Get the path to the directory the application is located in. The path may be relative to the current working directory.
	APP_DIRECTORY = `(debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get application path.")) :gsub("\\", "/"):gsub("/?[^/]+$", ""):gsub("^$", ".")`,

	-- COMPILER_PATH
	-- Get the path to the compiler. This will be a hardcoded value in the compiled program.
	COMPILER_PATH = F("%q", COMPILER_PATH),

	-- COMPILER_DIRECTORY
	-- Get the path to the directory the compiler is located in. This will be a hardcoded value in the compiled program.
	COMPILER_DIRECTORY = F("%q", COMPILER_DIRECTORY),

	-- wrapFunctionInGloaErrorHandler()
	-- Make Glóa handle errors triggered by a function.
	--
	-- This is useful if an external library or framework tries to handle an error
	-- triggered by a callback provided by you, but you instead want to trigger a
	-- normal Glóa error before the library knows what happened.
	--
	-- wrappedFunction = wrapFunctionInGloaErrorHandler( function )
	--
	wrapFunctionInGloaErrorHandler = `function(cb)
		return function(...)
			local args = {n=select("#", ...), ...}

			if not xpcall(
				function()
					cb(unpack(args, 1, args.n))
				end,
				gloaErrorHandler
			) then
				os.exit(1) -- In case there was an error in gloaErrorHandler() for some reason.
			end
		end
	end`,
}

local LUA_KEYWORDS = !(Set{"and","break","do","else","elseif","end","false","for","function","goto","if","in","local","nil","not","or","repeat","return","then","true","until","while"})

_G.!struct"WriterState"{
	{`c`,                 nil}, -- CompilationState

	{`foreignN`,          0},
	{`foreignReferences`, {}},

	{`loopStack`,         {}},  -- [](AstFor|AstWhile)  (Only used for loops with named breaks inside.)

	{`currentOutputLine`, 1},
	{`lineMappingFiles`,  {}},
	{`lineMappingLines`,  {}},
}



local function addLineMapping(state, writer, token)
	local ln = writer.currentOutputLine
	if (writer.lineMappingLines[ln] or 0) > 0 then  return  end
	writer.lineMappingFiles[ln] = state.tokens.file [token] or errorInternal()
	writer.lineMappingLines[ln] = state.tokens.line1[token] or errorInternal()
end
-- addLineMappingDummy( state, writer [, path ] )
local function addLineMappingDummy(state, writer, path)
	local ln = writer.currentOutputLine
	if writer.lineMappingLines[ln] then  return  end
	writer.lineMappingFiles[ln] = path or state.globalScope.fileScopes[1].path
	writer.lineMappingLines[ln] = 0
end

local function writeEol(state, writer)
	writer.file:write("\n")
	writer.currentOutputLine = writer.currentOutputLine+1
end

function _G.writeIdentifierName(state, writer, ident)
	local decl = ident.declaration
	local name = decl.topScopeName

	addLineMapping(state, writer, ident.token)

	if name == "" then  name = decl.localName  end

	if name == "" then
		astPrint(ident)
		printTraceback(io.stderr)
		nodeError(state, ident, "ProgramWriter", "Internal compiler error: Missing name to write for '%s'.", ident.name)
	end

	writer.file:write(name)
end

function _G.writeStringLiteral(writer, name)
	local s = F("%q", name):gsub("\\\n", "\\n")
	writer.file:write(s)
end

-- writeStringConcatenation( state, writer, left:AstNode|string, right:AstNode|string )
function _G.writeStringConcatenation(state, writer, left, right)
	if type(left) == "string" then
		writer.file:write(left)
	elseif left.nodeType == !(nodeTypes.AstBinary) and left.operation == ".." then
		writeStringConcatenation(state, writer, left.left, left.right)
	else
		writeExpression(state, writer, left)
	end

	writer.file:write(" .. ")

	if type(right) == "string" then
		writer.file:write(right)
	elseif right.nodeType == !(nodeTypes.AstBinary) and right.operation == ".." then
		writeStringConcatenation(state, writer, right.left, right.right)
	else
		writeExpression(state, writer, right)
	end
end

function _G.shouldOperationHaveSurroundingParentheses(node)
	local parent = node.parent
	return not (
		isAny(
			parent.nodeType,
			!(nodeTypes.AstCast), -- Casts should always add their own parentheses.
			!(nodeTypes.AstAssignment),
			!(nodeTypes.AstCall), -- Both callee and arguments.
			!(nodeTypes.AstReturn),
			!(nodeTypes.AstIf),
			!(nodeTypes.AstFor),
			!(nodeTypes.AstWhile)
		)
		or parent.nodeType == !(nodeTypes.AstAccess) and node == parent.member -- The member should be inside [].
	)
end

-- writeBinaryOperation( state, writer, left:AstNode|string, right:AstNode|string, binaryOperation, token [, binary ] )
function _G.writeBinaryOperation(state, writer, left, right, binOp, token, binary)
	!(
	local function WRITE_OPERAND(sideCode)
		__LUA("if type(",sideCode,") == 'string' then  file:write(",sideCode,")  else  writeExpression(state, writer, ",sideCode,")  end")
	end
	)

	local file      = writer.file
	local addParens = binary and shouldOperationHaveSurroundingParentheses(binary)

	addLineMapping(state, writer, token)

	if binOp == ".." then
		if addParens then  file:write("(")  end
		writeStringConcatenation(state, writer, left, right) -- This makes sure consecutive string concatenations appear as one operation without any parentheses.
		if addParens then  file:write(")")  end

	elseif binOp == "//" then
		file:write("_MATH_FLOOR(")
		!WRITE_OPERAND `left`
		file:write(" / ")
		!WRITE_OPERAND `right`
		file:write(")")

	else
		if addParens then  file:write("(")  end
		!WRITE_OPERAND `left`
		file:write(" ", binOp, " ")
		!WRITE_OPERAND `right`
		if addParens then  file:write(")")  end
	end
end

function _G.writeAccess(state, writer, access)
	if isTypeTableLike(access.object.inferredType) then
		-- @Incomplete: Compiler setting for runtime checks of array bounds.
		writeExpression(state, writer, access.object)

		if access.parent.nodeType == !(nodeTypes.AstCall) and access.parent.isMethod then
			local stringLiteral = access.member
			assert(stringLiteral.nodeType == !(nodeTypes.AstLiteral) and stringLiteral.literalType == !(LITERAL_STRING))

			if not stringLiteral.value:find"^[%a_][%w_]*$" then
				errorInternal("@Incomplete: Support method calls using names containing non-ASCII characters.")
			elseif LUA_KEYWORDS[stringLiteral.value] then
				errorInternal("@Incomplete: Support method calls using names that are keywords in Lua.")
			end

			writer.file:write(":", stringLiteral.value)

		elseif isExpressionLiteralStringAndValidLuaIdentifier(access.member) then
			local stringLiteral = access.member
			writer.file:write(".", stringLiteral.value)

		else
			writer.file:write("[")
			writeExpression(state, writer, access.member)
			writer.file:write("]")
		end

	elseif access.object.inferredType.tag == !(typeTags.TypeInfoEnum) then
		errorInternal(state, access) -- Enum accesses should have been simplified away.

	else
		errorUnhandledNodeType(state, access.object)
	end
end

-- writeCast( state, writer, cast [, nameToCast ] )
-- nameToCast is only used by AstConditional.
function _G.writeCast(state, writer, cast, nameToCast)
	!local WRITE_EXPRESSION = trimTemplate`
		if nameToCast then
			writer.file:write(nameToCast)
		else
			writeExpression(state, writer, cast.expression)
		end
	`

	local typeInfoSource = adjustTypeToOne(state, cast.expression, cast.expression.inferredType, true)
	local typeInfoTarget = cast.inferredType

	addLineMapping(state, writer, cast.token)

	writer.file:write("(") -- In case the written expression is a list of some kind.

	if
		typeInfoSource == typeInfoTarget
		or typeInfoSource.tag == !(typeTags.TypeInfoCompound)
		or typeInfoTarget.tag == !(typeTags.TypeInfoCompound)
	then
		!!(WRITE_EXPRESSION)

	-- int -> float
	elseif typeInfoSource.tag == !(typeTags.TypeInfoInt) and typeInfoTarget.tag == !(typeTags.TypeInfoFloat) then
		!!(WRITE_EXPRESSION)

	-- float -> int
	elseif typeInfoSource.tag == !(typeTags.TypeInfoFloat) and typeInfoTarget.tag == !(typeTags.TypeInfoInt) then
		writer.file:write("_MATH_MODF(") -- Note: math.modf() returns two values.
		!!(WRITE_EXPRESSION)
		writer.file:write(")")

	-- (numeric) -> bool
	elseif isTypeNumeric(typeInfoSource) and typeInfoTarget.tag == !(typeTags.TypeInfoBool) then
		!!(WRITE_EXPRESSION)
		writer.file:write(" ~= 0")

	-- string -> bool
	elseif typeInfoSource.tag == !(typeTags.TypeInfoString) and typeInfoTarget.tag == !(typeTags.TypeInfoBool) then
		!!(WRITE_EXPRESSION)
		writer.file:write(' ~= ""')

	-- array -> bool
	elseif typeInfoSource.tag == !(typeTags.TypeInfoArray) and typeInfoTarget.tag == !(typeTags.TypeInfoBool) then
		!!(WRITE_EXPRESSION)
		writer.file:write("[1] ~= nil")

	-- (whatever) -> any
	-- any -> (whatever)
	elseif typeInfoSource.tag == !(typeTags.TypeInfoAny) or typeInfoTarget.tag == !(typeTags.TypeInfoAny) then
		-- The user better know what they're doing!
		-- @Incomplete: Compiler setting for runtime checks of 'any' and 'compound' casts.
		!!(WRITE_EXPRESSION)

	-- enum -> (real enum member type)
	elseif typeInfoSource.tag == !(typeTags.TypeInfoEnum) and typeInfoTarget == typeInfoSource.memberTypeInfo then
		!!(WRITE_EXPRESSION)

	else
		errorInternal(state, cast, "Incomplete: Handle casting from %s to %s.", getFriendlyTypeInfoName(typeInfoSource), getFriendlyTypeInfoName(typeInfoTarget))
	end

	writer.file:write(")")
end

function _G.writeTableConstructorKeyName(writer, name)
	if name:find"^[%a_][%w_]*$" and not LUA_KEYWORDS[name] then
		writer.file:write(name)
	else
		writer.file:write("[")
		writeStringLiteral(writer, name)
		writer.file:write("]")
	end
end

function _G.writeDefaultValueForStructMember(state, writer, structInfo, member, nodeForError)
	local decl = findDynamicMemberDeclaration(state, structInfo.astNode, member.name) or errorInternal(state, structInfo.astNode, "Did not find member '%s'.", member.name)
	if decl.value then
		writeExpression(state, writer, decl.value)
	else
		writeDefaultValueForType(state, writer, member.typeInfo, nodeForError)
	end
end

local function findTableFieldInStructConstructor(tableNode, memberName)
	for _, tableField in ipairs(tableNode.fields) do
		!ASSERT("tableField.key.nodeType == "..nodeTypes.AstLiteral)

		if tableField.key.value == memberName then
			return tableField
		end
	end

	return nil
end

local function doesTypeContainBoolOrNone(typeInfo)
	if isAny(typeInfo.tag, !(typeTags.TypeInfoBool),!(typeTags.TypeInfoNone),!(typeTags.TypeInfoAny)) then  return true  end

	if typeInfo.tag ~= !(typeTags.TypeInfoCompound) then  return false  end
	local compound = typeInfo

	for _, compoundItem in ipairs(compound) do
		if isAny(compoundItem.tag, !(typeTags.TypeInfoBool),!(typeTags.TypeInfoNone)) then  return true  end
	end
	return false
end

function _G.writeExpression(state, writer, expr)
	local file = writer.file

	if expr.nodeType == !(nodeTypes.AstCall) then
		local call   = expr
		local callee = call.callee

		addLineMapping(state, writer, call.token)

		if call.surroundedByParentheses then  file:write("(")  end

		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			local ident = callee
			!if DEBUG then
				if not ident.declaration.valueConstant then
					if ident.declaration.value then  astPrintTree(ident.declaration.value)  end
					errorInternal(state, ident.declaration)
				end
			!end
			writeConstantValueOrReference(state, writer, ident.declaration.valueConstant)
		else
			writeExpression(state, writer, callee)
		end

		local argsNeedParentheses = true
		--[[ @Incomplete: Consider optional arguments if omitting parentheses.
		local argsNeedParentheses = not (
			#call.arguments == 1 and (
				call.arguments[1].nodeType == !(nodeTypes.AstTable)
				or (
					call.arguments[1].nodeType == !(nodeTypes.AstLiteral)
					and call.arguments[1].literalType == !(LITERAL_STRING)
				)
			)
		)
		]]

		if argsNeedParentheses then  file:write("(")  end

		local first = true

		-- Write given arguments.
		for _, argExpr in ipairs(call.arguments) do
			if not first then  file:write(", ")  end
			first = false
			writeExpression(state, writer, argExpr)
		end

		-- Write default values for arguments.
		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			local calleeDecl = callee.declaration

			if calleeDecl.isConstant then
				local lambda = calleeDecl.value or errorInternal()
				!ASSERT("lambda.nodeType == "..nodeTypes.AstLambda)

				-- Only write a value if the last non-vararg argument is optional.
				local argLast = lambda.argumentsIn and getLast(lambda.argumentsIn.arguments)
				if argLast and argLast.declaration.name.nodeType == !(nodeTypes.AstVararg) then
					argLast = getLast(lambda.argumentsIn.arguments, 2)
				end

				if argLast and not argLast.isRequired then
					local argExprLast = getLast(call.arguments)
					if
						argExprLast and (
							(
								argExprLast.inferredType.tag == !(typeTags.TypeInfoVararg)
								and not argExprLast.surroundedByParentheses
							)
							or (
								argExprLast.inferredType.tag == !(typeTags.TypeInfoList)
								and not argExprLast.surroundedByParentheses
								and argExprLast.inferredType[2]
							)
						)
					then
						-- :DisallowListAsLastValueToFunctionWithOptionalArguments
						nodeError(state, callee, "ProgramWriter", "@Incomplete: Handle optional arguments if the last value in a call is a list of things.")
					end

					for i = #call.arguments+1, #lambda.argumentsIn.arguments do
						if not first then  file:write(", ")  end
						first = false

						local arg = lambda.argumentsIn.arguments[i]

						if arg.declaration.value then -- Varargs are optional but have no default value (or zero default values, since it's a list).
							writeExpression(state, writer, arg.declaration.value)
						end
					end
				end
			end
		end

		if argsNeedParentheses then  file:write(")")  end

		if call.surroundedByParentheses then  file:write(")")  end

	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		local unary = expr

		if unary.operation == "+" then
			writeExpression(state, writer, unary.expression)

		else
			local addParens = shouldOperationHaveSurroundingParentheses(unary)

			addLineMapping(state, writer, unary.token)

			if addParens then  file:write("(")  end
			file:write(unary.operation)
			if unary.operation:find"%w" then  file:write(" ")  end
			writeExpression(state, writer, unary.expression)
			if addParens then  file:write(")")  end
		end

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr
		writeBinaryOperation(state, writer, binary.left, binary.right, binary.operation, binary.token, binary)

	elseif expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		writeConstantValue(state, writer, literal.valueConstant)

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration
		!ASSERT `ident.inferredType`
		!ASSERT `decl`

		if not decl.isConstant then
			writeIdentifierName(state, writer, ident)
		else
			writeConstantValueOrReference(state, writer, decl.valueConstant)
		end

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		file:write(F("%d", typeNode.representedType.id)) -- @Cleanup: We probably have a constant for the type ID to use with writeConstantValue(state,) here who cares...
		if state.settings.outputDebugInfo then
			file:write("--[[", getFriendlyTypeInfoName(typeNode.representedType):gsub("%]", "%0 "), "]]")
		end

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda = expr
		local const  = lambda.valueConstant or errorInternal(state, lambda)
		writeConstantValueOrReference(state, writer, const)

	elseif expr.nodeType == !(nodeTypes.AstVararg) then
		local vararg = expr
		file:write(vararg.surroundedByParentheses and "(...)" or "...")

	elseif expr.nodeType == !(nodeTypes.AstAccess) then
		local access = expr
		writeAccess(state, writer, access)

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		writeCast(state, writer, cast)

	elseif expr.nodeType == !(nodeTypes.AstTable) then
		local tableNode = expr
		file:write("{")

		if tableNode.inferredType.tag == !(typeTags.TypeInfoTable) then
			for i, tableField in ipairs(tableNode.fields) do
				if i > 1 then  file:write(", ")  end

				if isExpressionLiteralStringAndValidLuaIdentifier(tableField.key) then
					local stringLiteral = tableField.key
					file:write(stringLiteral.value)
				else
					-- @Polish: Output sequence values without key in 'table' type tables.
					file:write("[")
					writeExpression(state, writer, tableField.key)
					file:write("]")
				end
				file:write("=")
				writeExpression(state, writer, tableField.value)
			end

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoArray) then
			local items = {}

			for _, tableField in ipairs(tableNode.fields) do
				!ASSERT("tableField.key.nodeType == "..nodeTypes.AstLiteral)

				local literal     = tableField.key
				local arrayIndex  = literal.value
				items[arrayIndex] = tableField.value
			end

			for arrayIndex, expr in ipairs(items) do
				if arrayIndex > 1 then  file:write(", ")  end
				writeExpression(state, writer, expr)
			end

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = tableNode.inferredType
			!ASSERT `not structInfo.isPolymorphic`

			for i, member in ipairs(structInfo.members) do
				if i > 1 then  file:write(", ")  end

				local tableField = findTableFieldInStructConstructor(tableNode, member.name)

				writeTableConstructorKeyName(writer, member.name)
				file:write("=")

				if tableField then
					writeExpression(state, writer, tableField.value)
				else
					writeDefaultValueForStructMember(state, writer, structInfo, member, tableNode) -- @UX: Maybe use a better nodeForError.
				end
			end

		else
			errorUnhandledNodeType(state, tableNode)
		end

		file:write("}")

	elseif expr.nodeType == !(nodeTypes.AstForeign) then
		local foreign = expr
		writeConstantValueOrReference(state, writer, foreign.valueConstant)

	elseif expr.nodeType == !(nodeTypes.AstConditional) then
		local conditional = expr
		local hasVararg   = false

		astVisitAllNodes(conditional, function(node)
			if node.nodeType == !(nodeTypes.AstVararg) then
				hasVararg = true
				return !(VISIT_BREAK)
			elseif isScope(node) then
				return !(VISIT_IGNORE_CHILDREN)
			end
		end)

		-- Ternary.
		if not conditional.conditionAndBranchTrue then
			if doesTypeContainBoolOrNone(adjustTypeToOne(state, conditional.branchTrue, conditional.branchTrue.inferredType, true)) then
				-- (function(x) if x then return a else return b end end)(x)
				file:write("(function(_CONDITION")
				if hasVararg then  file:write(", ...")  end
				file:write(") if _CONDITION then return ")
				writeExpression(state, writer, conditional.branchTrue)
				file:write(" else return ")
				writeExpression(state, writer, conditional.branchFalse)
				file:write(" end end)(")
				writeExpression(state, writer, conditional.condition)
				if hasVararg then  file:write(", ...")  end
				file:write(")")
			else
				-- x and a or b
				file:write("(")
				writeExpression(state, writer, conditional.condition)
				file:write(" and ")
				writeExpression(state, writer, conditional.branchTrue)
				file:write(" or ")
				writeExpression(state, writer, conditional.branchFalse)
				file:write(")")
			end

		-- Binary (with implicit cast).
		-- @Optimize: Output 'a or b' whenever possible.
		elseif conditional.conditionAndBranchTrue ~= conditional.condition then
			-- (function(x) if x then return x else return y end end)(x)
			local cast = conditional.condition
			assert(cast.nodeType   == !(nodeTypes.AstCast))
			assert(cast.expression == conditional.conditionAndBranchTrue)
			assert(cast.isImplicit)

			file:write("(function(_CONDITION")
			if hasVararg then  file:write(", ...")  end
			file:write(") if ")
			writeCast(state, writer, cast, "_CONDITION")
			file:write(" then return _CONDITION else return ")
			writeExpression(state, writer, conditional.branchFalse)
			file:write(" end end)(")
			writeExpression(state, writer, cast.expression)
			if hasVararg then  file:write(", ...")  end
			file:write(")")

		-- Binary (without implicit cast).
		-- @Optimize: Output 'a or b' whenever possible.
		else
			-- (function(x) if x then return x else return y end end)(x)
			file:write("(function(_CONDITION")
			if hasVararg then  file:write(", ...")  end
			file:write(") if _CONDITION then return _CONDITION else return ")
			writeExpression(state, writer, conditional.branchFalse)
			file:write(" end end)(")
			writeExpression(state, writer, conditional.condition)
			if hasVararg then  file:write(", ...")  end
			file:write(")")
		end

	elseif expr.inferredType.tag == !(typeTags.TypeInfoNamespace) then
		nodeError(state, expr, "ProgramWriter", "Invalid place for a namespace.")
	else
		errorUnhandledNodeType(state, expr)
	end
end

function _G.writeDefaultValueForType(state, writer, typeInfo, nodeForError)
	local file = writer.file
	local tag  = typeInfo.tag

	if tag == !(typeTags.TypeInfoBool) then
		file:write("false")
	elseif tag == !(typeTags.TypeInfoInt) then
		file:write("0")
	elseif tag == !(typeTags.TypeInfoNone) then
		file:write("nil")
	elseif tag == !(typeTags.TypeInfoFloat) then
		file:write("0.0")
	elseif tag == !(typeTags.TypeInfoString) then
		file:write('""')
	elseif tag == !(typeTags.TypeInfoType) then
		file:write("0") -- @Robustness: Maybe 'type' variables should have no defult value and this should be an error. :DefaultValueForTypes
	elseif tag == !(typeTags.TypeInfoArray) or tag == !(typeTags.TypeInfoTable) then
		file:write("{}")

	elseif tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		!ASSERT `not structInfo.isPolymorphic`

		file:write("{")

		for i, member in ipairs(structInfo.members) do
			if i > 1 then  file:write(", ")  end
			writeTableConstructorKeyName(writer, member.name)
			file:write("=")
			writeDefaultValueForStructMember(state, writer, structInfo, member, nodeForError)
		end

		file:write("}")

	elseif doesTypeHaveAnyDefaultValue(typeInfo) then
		errorInternal("Incomplete: Write default value for type group '%s'.", TYPE_TAG_NAMES[typeInfo.tag])
	else
		nodeError(state, nodeForError, "ProgramWriter", "There is no default value for %s.", getFriendlyTypeInfoName(typeInfo))
	end
end

local function isNameAllocated(state, writer, localsStack, localName)
	if state.topScopeNames[localName] then  return true  end

	for _, locals in ipairs(localsStack) do
		if locals[localName] then  return true  end
	end

	return false
end

local function allocateName(state, writer, localsStack, name, n, shortPrefix, longInfix)
	if name == "_" then  return name  end -- @Incomplete: Make "_" a write-only name.

	local localName

	if state.settings.outputDebugInfo then
		localName = unicodeToLuaIdentifier(name)
		if isNameAllocated(state, writer, localsStack, localName) then
			localName = localName..longInfix..n
		end
	else
		localName = shortPrefix..n
	end

	localsStack[1][localName] = true

	return localName, n+1
end
local function allocateLocalName(state, writer, localsStack, name, n)
	return allocateName(state, writer, localsStack, name, n, "L", "_L")
end
local function allocateArgumentName(state, writer, localsStack, name, n)
	return allocateName(state, writer, localsStack, name, n, "A", "_A")
end

local function writeLoopBodyAndFooter(state, writer, loop, indent, nextLocalN, localsStack)
	local file      = writer.file
	local loopStack = writer.loopStack
	local indentStr = ("\t"):rep(indent)

	if not (loop.hasNamedBreaks or loopStack[1]) then
		writeBlock(state, writer, loop.body, indent+1, nextLocalN, localsStack)
		file:write(indentStr, "end")
		writeEol(state, writer)
		return
	end

	if not loopStack[1] then
		file:write(indentStr, "\tlocal _BREAK = 0")
		writeEol(state, writer)
	end

	table.insert(loopStack, loop)
	writeBlock(state, writer, loop.body, indent+1, nextLocalN, localsStack)
	file:write(indentStr, "end")
	writeEol(state, writer)
	table.remove(loopStack)

	if loopStack[2] then
		file:write(indentStr, "if _BREAK > 0 then  _BREAK = _BREAK-1 ; break  end")
	elseif loopStack[1] then
		file:write(indentStr, "if _BREAK > 0 then  break  end")
	end
	writeEol(state, writer)
end

-- writeBlock( state, writer, block, indent, nextLocalN, localsStack [, isElseif=false ] )
function _G.writeBlock(state, writer, block, indent, nextLocalN, localsStack, isElseif)
	!ASSERT `not block[1]`

	local file            = writer.file
	local outputDebugInfo = state.settings.outputDebugInfo
	local indentStr       = ("\t"):rep(indent)

	if not block.statements[1] then
		if outputDebugInfo then
			file:write(indentStr, "-- Empty block.")
			writeEol(state, writer)
		end
		return
	end

	localsStack  = {{}, unpack(localsStack)}
	local inDecl = false

	for _, statement in ipairs(block.statements) do
		local nodeType = statement.nodeType

		if nodeType == !(nodeTypes.AstDeclaration) then
			local decl = statement

			if not decl.isConstant then
				decl.localName, nextLocalN = allocateLocalName(state, writer, localsStack, decl.name.name, nextLocalN)

				if decl.assignment then
					-- The (initial) assignment should be written as the next statement (or after several declarations).
					inDecl = true

				else
					local tag = decl.name.inferredType.tag
					file:write(indentStr, "local ", decl.localName, " = ")
					if decl.value then
						writeExpression(state, writer, decl.value)
					else
						writeDefaultValueForType(state, writer, decl.name.inferredType, decl.name)
					end
					file:write(";")
					writeEol(state, writer)
				end
			end

		elseif nodeType == !(nodeTypes.AstAssignment) then
			local assignment = statement

			if assignment.operation == "=" then
				file:write(indentStr)
				if inDecl then  file:write("local ")  end

				for i, targetExpr in ipairs(assignment.targets) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, writer, targetExpr)
				end

				file:write(" ", assignment.operation, " ")

				for i, valueExpr in ipairs(assignment.values) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, writer, valueExpr)
				end

				file:write(";") -- This removes ambiguity is some cases.
				writeEol(state, writer)

			else
				!ASSERT `not inDecl`

				file:write(indentStr, "do")
				writeEol(state, writer)

				-- Get target objects and values.
				file:write(indentStr, "\tlocal ")
				local first   = true
				local accessN = 0

				for _, targetExpr in ipairs(assignment.targets) do
					if targetExpr.nodeType == !(nodeTypes.AstAccess) then
						local access = targetExpr

						if not first then  file:write(", ")  end
						first = false

						-- @Optimize: Don't store the object and/or member like this if it's unnecessary.
						accessN = accessN+1
						file:write("_OBJECT", accessN, ", _MEMBER", accessN) -- @Robustness: Ensure unique names.
					end
				end

				for i, targetExpr in ipairs(assignment.targets) do
					if not first then  file:write(", ")  end
					first = false

					file:write("_VALUE", i) -- @Robustness: Ensure unique names.
				end

				file:write(" = ")
				first = true

				for _, targetExpr in ipairs(assignment.targets) do
					if targetExpr.nodeType == !(nodeTypes.AstAccess) then
						local access = targetExpr

						if not first then  file:write(", ")  end
						first = false

						writeExpression(state, writer, access.object)
						file:write(", ")
						writeExpression(state, writer, access.member)
					end
				end

				for _, valueExpr in ipairs(assignment.values) do
					if not first then  file:write(", ")  end
					first = false

					writeExpression(state, writer, valueExpr)
				end

				writeEol(state, writer)

				-- Assign to targets.
				local targetsToWrite = {}
				file:write(indentStr, "\t")
				first   = true
				accessN = 0

				for i, target in ipairs(assignment.targets) do
					if not first then  file:write(", ")  end
					first = false

					if target.nodeType == !(nodeTypes.AstAccess) then
						accessN = accessN+1
						target  = F("_OBJECT%d[_MEMBER%d]", accessN, accessN)
						file:write(target)
					else
						writeExpression(state, writer, target)
					end

					targetsToWrite[i] = target
				end

				file:write(" = ")
				first   = true
				accessN = 0

				for i, targetExpr in ipairs(assignment.targets) do
					if not first then  file:write(", ")  end
					first = false

					writeBinaryOperation(state, writer, targetsToWrite[i], "_VALUE"..i, assignment.binaryOperation, targetExpr.token)
				end

				writeEol(state, writer)
				file:write(indentStr, "end")
				writeEol(state, writer)
			end

			inDecl = false

		elseif nodeType == !(nodeTypes.AstReturn) then
			local returnNode = statement

			if block.parent.nodeType == !(nodeTypes.AstLambda) and not returnNode.values[1] then
				if outputDebugInfo then
					file:write(indentStr, "-- return")
					writeEol(state, writer)
				end

			else
				file:write(indentStr, "return")
				for i, expr in ipairs(returnNode.values) do
					if i > 1 then  file:write(",")  end
					file:write(" ")
					writeExpression(state, writer, expr)
				end
				writeEol(state, writer)
			end

		elseif nodeType == !(nodeTypes.AstBlock) then
			local block = statement

			file:write(indentStr, "do")
			writeEol(state, writer)

			writeBlock(state, writer, block, indent+1, nextLocalN, localsStack)

			file:write(indentStr, "end")
			writeEol(state, writer)

		elseif nodeType == !(nodeTypes.AstIf) then
			-- @Optimize: Don't output empty branches.
			local ifBranch = statement

			if not isElseif then  file:write(indentStr)  end

			file:write("if ")
			writeExpression(state, writer, ifBranch.condition)
			file:write(" then")
			writeEol(state, writer)

			writeBlock(state, writer, ifBranch.branchTrue, indent+1, nextLocalN, localsStack)

			if not (ifBranch.branchFalse and ifBranch.branchFalse.statements[1]) then
				-- void

			elseif not ifBranch.branchFalse.statements[2] and ifBranch.branchFalse.statements[1].nodeType == !(nodeTypes.AstIf) then
				file:write(indentStr, "else") -- This will be followed by "if"
				writeBlock(state, writer, ifBranch.branchFalse, indent, nextLocalN, localsStack, true)

			else
				file:write(indentStr, "else")
				writeEol(state, writer)
				writeBlock(state, writer, ifBranch.branchFalse, indent+1, nextLocalN, localsStack)
			end

			if not isElseif then
				file:write(indentStr, "end")
				writeEol(state, writer)
			end

		elseif nodeType == !(nodeTypes.AstWhile) then
			-- @Optimize: Don't output an empty body.
			local whileLoop = statement

			file:write(indentStr, "while ")
			writeExpression(state, writer, whileLoop.condition)
			file:write(" do")
			writeEol(state, writer)

			writeLoopBodyAndFooter(state, writer, whileLoop, indent, nextLocalN, localsStack)

		elseif nodeType == !(nodeTypes.AstFor) then
			-- @Optimize: Don't output an empty body.
			local forLoop     = statement
			local localsStack = {{}, unpack(localsStack)}

			for _, decl in ipairs(forLoop.declarations) do
				decl.localName, nextLocalN = allocateLocalName(state, writer, localsStack, decl.name.name, nextLocalN)
			end

			if forLoop.forType == !(FOR_NUMERIC) then
				local decl   = forLoop.declarations[1]
				local values = forLoop.expressions

				file:write(indentStr, "for ")
				writeIdentifierName(state, writer, decl.name)
				file:write(" = ")
				writeExpression(state, writer, values[1])
				file:write(", ")
				writeExpression(state, writer, values[2])
				if values[3] then
					file:write(", ")
					writeExpression(state, writer, values[3])
				end
				file:write(" do")
				writeEol(state, writer)

				writeLoopBodyAndFooter(state, writer, forLoop, indent, nextLocalN, localsStack)

			elseif forLoop.forType == !(FOR_SHORT) then
				local objExpr = forLoop.expressions[1]

				file:write(indentStr, "for ")

				for i, decl in ipairs(forLoop.declarations) do
					if i > 1 then  file:write(", ")  end
					writeIdentifierName(state, writer, decl.name)
				end

				file:write(" in ")

				if objExpr.inferredType.tag == !(typeTags.TypeInfoArray) then
					addLineMapping(state, writer, objExpr.token)
					file:write("_IPAIRS")
				elseif objExpr.inferredType.tag == !(typeTags.TypeInfoTable) then
					addLineMapping(state, writer, objExpr.token)
					file:write("_PAIRS")
				elseif objExpr.inferredType.tag == !(typeTags.TypeInfoStruct) then
					errorUnhandledNodeType(state, objExpr)
					-- writeConstantValueOrReference(state, writer, interatorFuncConst?) -- @Incomplete: Output default iterator for the struct.
				else
					errorInternal(state, objExpr)
				end

				file:write("(")
				writeExpression(state, writer, objExpr)
				file:write(") do")
				writeEol(state, writer)

				writeLoopBodyAndFooter(state, writer, forLoop, indent, nextLocalN, localsStack)

			else--if forLoop.forType == !(FOR_ITERATOR) then
				file:write(indentStr, "for ")

				for i, decl in ipairs(forLoop.declarations) do
					if i > 1 then  file:write(", ")  end
					writeIdentifierName(state, writer, decl.name)
				end
				file:write(" in ")
				for i, valueExpr in ipairs(forLoop.expressions) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, writer, valueExpr)
				end
				file:write(" do")
				writeEol(state, writer)

				writeLoopBodyAndFooter(state, writer, forLoop, indent, nextLocalN, localsStack)
			end

		elseif nodeType == !(nodeTypes.AstBreak) then
			local breakNode = statement

			if breakNode.loop then
				local i                 = indexOf(writer.loopStack, breakNode.loop) or errorInternal(state, breakNode)
				local outerLoopsToBreak = #writer.loopStack-i
				file:write(indentStr, "_BREAK = ",outerLoopsToBreak," ; break")
			else
				file:write(indentStr, "break")
			end
			writeEol(state, writer)

		elseif isAny(nodeType, !(nodeTypes.AstImport),!(nodeTypes.AstUsing),!(nodeTypes.AstDebug),!(nodeTypes.AstRun)) then
			-- void  (Ignore these statements.)

		else
			-- Assume the statement is an expression at this point and let writeExpression(state,) deal errors.
			file:write(indentStr)
			writeExpression(state, writer, statement)
			file:write(";") -- This removes ambiguity is some cases.
			writeEol(state, writer)
		end
	end
end

function _G.writeFunction(state, writer, lambda)
	!ASSERT `not lambda.body[1]`
	!ASSERT `not lambda.isPolymorphic`

	local file = writer.file

	addLineMapping(state, writer, lambda.token)

	if lambda.bodyIsForeign then
		file:write(writer.foreignReferences[lambda.foreignSourceId])
		return
	end

	local localsStack = {{}}

	file:write("function(")

	if lambda.argumentsIn then
		for i, arg in ipairs(lambda.argumentsIn.arguments) do
			if i > 1 then  file:write(", ")  end

			local decl = arg.declaration

			if decl.name.nodeType == !(nodeTypes.AstVararg) then
				decl.localName = "..."
			else
				decl.localName = allocateArgumentName(state, writer, localsStack, decl.name.name, i)
			end

			file:write(decl.localName)
		end
	end

	file:write(")")
	writeEol(state, writer)

	if lambda.body.statements[1] then
		writeBlock(state, writer, lambda.body, 2, 1, localsStack)
	elseif state.settings.outputDebugInfo then
		file:write("\t\t-- Empty function.")
		writeEol(state, writer)
	end

	file:write("\tend") -- (This indent may be wrong.)
end

function _G.writeForeignImportIfNew(state, writer, typeInfo, foreignSource, foreignSourceName, foreignSourceId, token, asGlobal)
	assert(foreignSourceId ~= "")

	if writer.foreignReferences[foreignSourceId] then  return  end

	-- @Incomplete: Compiler setting for runtime checks of anything originating from foreign sources.
	-- (We can probably wrap the importing code in something here using typeInfo.)

	local file = writer.file

	local foreignN  = writer.foreignN+1
	writer.foreignN = foreignN

	if foreignN == 1 then
		file:write("\t")
		if not asGlobal then  file:write("local ")  end
		file:write("_FOREIGN = {}")
		writeEol(state, writer)
	end

	addLineMapping(state, writer, token) -- Must happen after _FOREIGN is declared.

	if foreignSource == "lua" then
		if outputDebugInfo then
			writer.foreignReferences[foreignSourceId] = F("_FOREIGN[%d--[[%s]]]", foreignN, (foreignSourceId:gsub("[%[%]]", "%0 ")))
			file:write("\t_FOREIGN[", F("%d", foreignN), "]")
		else
			local foreignRef                         = F("_FOREIGN[%d]", foreignN)
			writer.foreignReferences[foreignSourceId] = foreignRef
			file:write("\t", foreignRef)
		end

		file:write(" = (", foreignSourceName, ")") -- @Robustness: Is this too straightforward?
		writeEol(state, writer)

		if foreignSourceName:find"\n" then
			local _, nlCount         = foreignSourceName:gsub("\n", "\0")
			writer.currentOutputLine = writer.currentOutputLine + nlCount -- @Incomplete: Call addLineMapping(state,) for every line here.
		end

	elseif foreignSource == "compiler" then
		local lua = FOREIGN_API_COMPILER_SYMBOLS[foreignSourceName]

		if outputDebugInfo then
			writer.foreignReferences[foreignSourceId] = F("_FOREIGN[%d--[[%s]]]", foreignN, (foreignSourceId:gsub("[%[%]]", "%0 ")))
			file:write("_FOREIGN[", F("%d", foreignN), "]")
		else
			local foreignRef                         = F("_FOREIGN[%d]", foreignN)
			writer.foreignReferences[foreignSourceId] = foreignRef
			file:write(foreignRef)
		end

		file:write(" = ", lua)
		writeEol(state, writer)

		if lua:find"\n" then
			local _, nlCount         = lua:gsub("\n", "\0")
			writer.currentOutputLine = writer.currentOutputLine + nlCount -- @Incomplete: Call addLineMapping(state,) for every line here.
		end

	else
		errorInternal("Incomplete: Handle foreignSource=%s", foreignSource)
	end
end

local function writeSimpleConstant(state, writer, typeInfo, v, isEnum)
	local file = writer.file
	local tag  = typeInfo.tag

	if tag == !(typeTags.TypeInfoBool) then
		file:write(v and "true" or "false")

	elseif tag == !(typeTags.TypeInfoInt) then
		-- %.0f handles larger values than %d and with no wrapping. (I think the former is 64-bit
		-- float and the latter 32-bit int.) %d would not work if trying to write the size of a
		-- large file, for example.
		local nStr = F("%.0f", v)

		if not nStr:find"^%-?%d+$" then
			errorLine("ProgramWriter", "Cannot write value as integer: %s", tostring(v))
		end
		file:write(nStr)

	elseif tag == !(typeTags.TypeInfoNone) then
		file:write("nil")

	elseif tag == !(typeTags.TypeInfoFloat) then
		local floatStr = tostring(v) -- @Robustness: Preserve precision as well as possible.
		if not floatStr:find(".", 1, true) then  floatStr = floatStr..".0"  end
		file:write(floatStr)

	elseif tag == !(typeTags.TypeInfoString) then
		writeStringLiteral(writer, v)

	elseif tag == !(typeTags.TypeInfoType) then
		local typeInfo = v
		file:write(F("%d", typeInfo.id))

		if state.settings.outputDebugInfo and not isEnum then
			file:write("--[[", getFriendlyTypeInfoName(typeInfo):gsub("%]", "] "), "]]")
		end

	else
		errorInternal("Incomplete: Handle constant value of type '%s'.", (TYPE_TAG_NAMES[tag] or "?"))
	end
end

function _G.writeConstantValue(state, writer, const)
	local file = writer.file
	local tag  = const.valueType.tag

	if not const.isObject then
		if tag == !(typeTags.TypeInfoEnum) then
			local enumInfo   = const.valueType
			local memberName = const.value
			local decl       = findMemberDeclaration(state, enumInfo.astNode, memberName) or errorInternal(state, enumInfo.astNode, "Did not find member '%s'.", memberName)
			local valueExpr  = decl.value

			if enumInfo.memberTypeInfo.tag == !(typeTags.TypeInfoType) then
				local typeNode = valueExpr
				!ASSERT("typeNode.nodeType == "..nodeTypes.AstType)
				writeSimpleConstant(state, writer, enumInfo.memberTypeInfo, typeNode.representedType, true)
			else
				local literal = valueExpr
				!ASSERT("literal.nodeType == "..nodeTypes.AstLiteral)
				writeSimpleConstant(state, writer, enumInfo.memberTypeInfo, literal.value, true)
			end

			if state.settings.outputDebugInfo then
				file:write("--[[", enumInfo.name, ".", memberName, "]]")
			end

		else
			writeSimpleConstant(state, writer, const.valueType, const.value, false)
		end

	elseif tag == !(typeTags.TypeInfoFunction) then
		local lambda = const.value
		writeFunction(state, writer, lambda)

	elseif tag == !(typeTags.TypeInfoTable) then
		local tableNode = const.value

		file:write("{")
		for i, tableField in ipairs(tableNode.fields) do
			if i > 1 then  file:write(", ")  end
			if isExpressionLiteralStringAndValidLuaIdentifier(tableField.key) then
				local stringLiteral = tableField.key
				file:write(stringLiteral.value)
			else
				file:write("[")
				writeExpression(state, writer, tableField.key)
				file:write("]")
			end
			file:write("=")
			writeExpression(state, writer, tableField.value)
		end
		file:write("}")

	elseif tag == !(typeTags.TypeInfoArray) then
		local arraySig      = const.valueType
		local tableNode     = const.value
		local indexedValues = {}

		for _, tableField in ipairs(tableNode.fields) do
			indexedValues[tableField.key.value] = tableField.value
		end

		file:write("{")
		for i, valueExpr in ipairs(indexedValues) do
			if i > 1 then  file:write(", ")  end
			writeExpression(state, writer, valueExpr)
		end
		file:write("}")

	elseif tag == !(typeTags.TypeInfoStruct) then
		local structInfo = const.valueType
		local tableNode  = const.value
		!ASSERT `not structInfo.isPolymorphic`

		file:write("{")

		for i, member in ipairs(structInfo.members) do
			if i > 1 then  file:write(", ")  end

			local tableField = findTableFieldInStructConstructor(tableNode, member.name)

			writeTableConstructorKeyName(writer, member.name)
			file:write("=")

			if tableField then
				writeExpression(state, writer, tableField.value)
			else
				writeDefaultValueForStructMember(state, writer, structInfo, member, tableNode) -- @UX: Maybe use a better nodeForError.
			end
		end

		file:write("}")

	elseif tag == !(typeTags.TypeInfoForeignDummy) then
		local foreign = const.value
		file:write(writer.foreignReferences[foreign.sourceId])

	elseif isAny(tag, !(typeTags.TypeInfoAny),!(typeTags.TypeInfoNamespace),!(typeTags.TypeInfoCompound),!(typeTags.TypeInfoList)) then
		errorInternal("Cannot write invalid value type '%s'.", TYPE_TAG_NAMES[tag])
	else
		errorInternal("Incomplete: Handle constant value of type '%s'.", (TYPE_TAG_NAMES[tag] or "?"))
	end
end

function _G.writeConstantValueOrReference(state, writer, const)
	if const.isObject then
		writer.file:write(const.name)
	else
		return writeConstantValue(state, writer, const)
	end
end



function _G.writeCompilerSymbols(state, writer, asGlobals)
	local file       = writer.file
	local maybeLocal = asGlobals and "" or "local "

	file:write(maybeLocal, "lineMappingPaths, lineMappingFiles, lineMappingLines = {}, {}, {}")
	writeEol(state, writer)

	!(
	-- info.what     = "Lua"|"C"|"main"|"tail"
	-- info.namewhat = "global"|"local"|"method"|"field"|"upvalue"|""

	local TEMPLATE_ERROR_HANDLER = `
		local function gloaErrorHandler(err)
			local mainSource = (debug.getinfo(1, "S") or {}).source or "<UNKNOWN_SOURCE>"

			if type(err) == "string" then
				local pathHere = mainSource:match("^@(.+)")
				local pathLen  = pathHere and #pathHere
				local ln       = pathHere and err:sub(1, pathLen) == pathHere and tonumber(err:match("^:(%d+): ", pathLen+1))

				if lineMappingLines[ln] then
					err = (
						lineMappingPaths[lineMappingFiles[ln]]..":"
						..lineMappingLines[ln]..": "
						..err:sub(pathLen+1):gsub("^:%d+: ", "")
					)
				end
			end

			$outputFile:write("\n")
			if type(err) == "string" then
				$outputFile:write("Error: ", err, "\n")
			else
				$outputFile:write("Error!\n")
			end
			$outputFile:write("stack traceback:\n")

			for level = 2, math.huge do
				local info = debug.getinfo(level, "nSl")
				if not info then  break  end

				$outputFile:write("\t")

				if info.what == "C" then
					$outputFile:write("[C]: ")
					if (info.name or "") ~= "" then
						$outputFile:write("'", info.name, "'")
					else
						$outputFile:write("?")
					end

				else
					if info.source == mainSource and (lineMappingLines[info.currentline] or 0) > 0 then
						$outputFile:write(lineMappingPaths[lineMappingFiles[info.currentline]], ":", lineMappingLines[info.currentline])
					else
						$outputFile:write("[Lua]")
					end

					$outputFile:write(":")

					if info.what == "tail" then
						$outputFile:write(" tail call")
					elseif info.what == "main" then
						$outputFile:write(" main chunk")
					elseif (info.name or "") ~= "" then
						$outputFile:write(" ")
						if info.namewhat == "method" or info.namewhat == "field" then  $outputFile:write(info.namewhat, " ")  end
						$outputFile:write("'", info.name, "'")
					elseif (lineMappingLines[info.linedefined] or 0) > 0 then
						$outputFile:write(" <", lineMappingPaths[lineMappingFiles[info.linedefined]], ":", lineMappingLines[info.linedefined], ">")
					end

					if info.source:find"^@" then
						$outputFile:write(" (", info.source:sub(2), ":", info.currentline)
						if info.linedefined > 0 and info.linedefined ~= info.currentline then
							$outputFile:write(", defined at line ", info.linedefined)
						end
						$outputFile:write(")")
					end
				end

				$outputFile:write("\n")
			end

			os.exit(1)
		end
	`
	local TEMPLATE_TRACEBACK_EDITS = trimTemplate`
		traceback = traceback:gsub("%w[-%w_/]*%.lua:%d+", $filePathPrefix.."%0")
	`
	local TRACEBACK_EDITS = templateToLua(TEMPLATE_TRACEBACK_EDITS, {
		filePathPrefix = toLua(RUNTIME_ERROR_PREFIX:gsub("%%", "%%%%")),
	})
	local ERROR_HANDLER = templateToLua(TEMPLATE_ERROR_HANDLER, {
		tracebackEdits = DEBUG and TRACEBACK_EDITS or ``,
		outputFile     = DEBUG and `io.stdout` or `io.stderr`, -- :SublimeText2Desync
	}, -2, -2)
	)
	file:write(!(ERROR_HANDLER))

	!local _, nlCount        = ERROR_HANDLER:gsub("\n", "\0")
	writer.currentOutputLine = writer.currentOutputLine + !(nlCount)

	file:write(maybeLocal, "_MATH_MODF  = math.modf")  ; writeEol(state, writer) -- Used when casting float to int.
	file:write(maybeLocal, "_MATH_FLOOR = math.floor") ; writeEol(state, writer) -- Used for integer division.
	file:write(maybeLocal, "_IPAIRS     = ipairs")     ; writeEol(state, writer) -- Used for short-form array loops.
	file:write(maybeLocal, "_PAIRS      = pairs")      ; writeEol(state, writer) -- Used for short-form table loops.
end

function _G.writeForeignImports(state, writer, constants, asGlobals)
	for _, const in ipairs(constants) do
		if const.valueType.tag == !(typeTags.TypeInfoFunction) and const.value.bodyIsForeign then
			-- @Polish: Treat function constants pointing to the same foreign function as the same constant.
			local lambda = const.value
			writeForeignImportIfNew(state, writer, const.valueType, lambda.foreignSource, lambda.foreignSourceName, lambda.foreignSourceId, lambda.token, asGlobals)

		elseif const.valueType.tag == !(typeTags.TypeInfoForeignDummy) then
			local foreign = const.value
			writeForeignImportIfNew(state, writer, foreign.inferredType, foreign.source, foreign.sourceName, foreign.sourceId, foreign.token, asGlobals)
		end
	end
end

function _G.writeConstantObjectsExceptFunctions(state, writer, constants, asGlobals)
	local file = writer.file

	for _, const in ipairs(constants) do
		if const.isObject and const.valueType.tag ~= !(typeTags.TypeInfoFunction) then
			file:write("\t")
			if not asGlobals then  file:write("local ")  end
			file:write(const.name, " = ")
			writeConstantValue(state, writer, const)
			writeEol(state, writer)
		end
	end
end

function _G.writeFunctionObjects(state, writer, constants)
	local functionConstants = {}

	for _, const in ipairs(constants) do
		-- @Cleanup: Don't generate constants for polymorphic functions. (It's probably declarations doing this.)
		if const.valueType.tag == !(typeTags.TypeInfoFunction) and not const.value.isPolymorphic then
			table.insert(functionConstants, const)
		end
	end

	table.sort(functionConstants, function(a, b)
		a = a.value
		b = b.value
		if a.bodyIsForeign ~= b.bodyIsForeign then  return a.bodyIsForeign    end
		if a.token         ~= b.token         then  return a.token < b.token  end
		return a.s < b.s
	end)

	local file = writer.file

	for _, const in ipairs(functionConstants) do
		local lambda = const.value
		file:write("\t", const.name, " = ")
		writeFunction(state, writer, lambda)
		writeEol(state, writer)
	end
end

function _G.writeTopScopeDeclarations(state, writer, declarations)
	local file = writer.file

	for _, decl in ipairs(declarations) do
		if decl.topScopeName ~= "" then -- Constant declarations of non-objects (e.g. ints) should have an empty topScopeName.
			file:write("\t", decl.topScopeName, " = ")
			if decl.valueConstant then
				writeConstantValueOrReference(state, writer, decl.valueConstant)
			else
				-- We should have a declared struct instance or something similar here (I think) that doesn't have a specified initial value.
				writeDefaultValueForType(state, writer, decl.name.inferredType, decl.name)
			end
			writeEol(state, writer)
		end
	end
end

function _G.writeProgram(state, writer)
	local file = writer.file

	-- @Incomplete: Setting to specify the prefix for the written file (shebang and maybe a comment with copyright info, library documentation etc.).
	file:write('#!/bin/sh\n_=[[\nexec lua "$0" "$@"\n]] and nil\n')
	writer.currentOutputLine = 5

	writeCompilerSymbols(state, writer, false)

	-- Start of user code.
	addLineMappingDummy(state, writer)
	file:write("local function runProgram()")
	writeEol(state, writer)

	writeForeignImports(state, writer, state.constants, false)
	writeConstantObjectsExceptFunctions(state, writer, state.constants, false)

	if state.constants[1] or state.topScopeNames[1] then
		-- Forward declarations.
		local first = true
		file:write("\tlocal ")

		-- Constants, functions.
		for _, const in ipairs(state.constants) do
			if const.valueType.tag == !(typeTags.TypeInfoFunction) then
				if not first then  file:write(", ")  end
				first = false
				file:write(const.name)
			end
		end

		-- Top-level declarations. (Note: Glóa globals are not Lua globals.)
		for _, topScopeName in ipairs(state.topScopeNames) do
			if not first then  file:write(", ")  end
			first = false
			file:write(topScopeName)
		end

		writeEol(state, writer)
	end

	writeFunctionObjects(state, writer, state.constants) -- Must be after forward declarations!

	local globalScope          = state.globalScope
	local topScopeDeclarations = copyArray(globalScope.declarations)

	for _, fileScope in ipairs(globalScope.fileScopes) do
		insertArrayItems(topScopeDeclarations, fileScope.declarations)
	end

	writeTopScopeDeclarations(state, writer, topScopeDeclarations)

	-- Program entry point.
	local entryPointName = state.settings.entryPointName
	local mainFuncDecl   = nil

	for _, decl in ipairs(topScopeDeclarations) do
		if decl.name.name == entryPointName then
			mainFuncDecl = decl
			break
		end
	end

	if not mainFuncDecl then
		local filePaths = {}
		for i, fileScope in ipairs(globalScope.fileScopes) do
			filePaths[i] = fileScope.path
		end
		errorLine(
			"ProgramWriter",
			"Missing program entry point ('%s' function) in top-level scope in loaded files:\n- %s",
			entryPointName, table.concat(filePaths, "\n- ")
		)

	elseif not mainFuncDecl.isConstant then
		nodeError(state, mainFuncDecl.name, "ProgramWriter", "Declared name '%s' must be a constant.", entryPointName)

	elseif mainFuncDecl.name.inferredType.tag ~= !(typeTags.TypeInfoFunction) then
		nodeError(
			state, mainFuncDecl.value, "ProgramWriter",
			"Declared name '%s' must be a function to represent the entry point of the program.",
			entryPointName
		)

	elseif mainFuncDecl.name.inferredType.argumentTypesIn[1] then
		local lambda = mainFuncDecl.value or errorInternal()
		nodeError(state, lambda.argumentsIn, "ProgramWriter", "Program entry point function must not take any arguments.")

	elseif mainFuncDecl.name.inferredType.argumentTypesOut[1] then
		local lambda = mainFuncDecl.value or errorInternal()
		nodeError(state, lambda.argumentsOut, "ProgramWriter", "Program entry point function must not return any values.")
	end

	addLineMappingDummy(state, writer)
	file:write("\t", mainFuncDecl.valueConstant.name, "()")
	writeEol(state, writer)

	-- End of user code.
	file:write("end")
	writeEol(state, writer)

	if state.settings.outputDebugInfo then
		!(
		-- Size of line mapping information in bytes in a small test program:
		--
		--            pad   exact indices
		--     files  1700  3500
		--     lines  2400  4300
		--
		local USE_PADDING = true -- Enabling this seem better.
		)

		writer.currentOutputLine = writer.currentOutputLine+4
		addLineMappingDummy(state, writer) -- For the xpcall() here below.

		local MODULE_DIR_PREFIX = COMPILER_DIRECTORY.."/modules/"

		local pathIndices = {}
		local pathIndex   = 0
		local first       = true

		file:write("local _ = nil\n") -- Takes up less space than 'nil'.

		file:write("lineMappingPaths = {")
		for ln = 1, writer.currentOutputLine do
			local path = writer.lineMappingFiles[ln]

			if writer.lineMappingLines[ln] and not pathIndices[path] then
				if not first then  file:write(",")  end
				first = false

				pathIndex         = pathIndex+1
				pathIndices[path] = pathIndex

				if path:sub(1, #MODULE_DIR_PREFIX) == MODULE_DIR_PREFIX then
					path = "module:"..path:sub(#MODULE_DIR_PREFIX+1):gsub("%.gloa$", "")
				end

				file:write(F("%q", path))
			end
		end
		file:write("}\n")

		file:write("lineMappingFiles = {")
		!if USE_PADDING then
			for ln = 1, writer.currentOutputLine do
				if ln > 1 then  file:write(",")  end
				file:write(pathIndices[writer.lineMappingFiles[ln]] or "_")
			end
		!else
			first = true
			for ln = 1, writer.currentOutputLine do
				if writer.lineMappingLines[ln] then
					if not first then  file:write(",")  end
					first = false
					file:write(F("[%d]=%d", ln, pathIndices[writer.lineMappingFiles[ln]]))
				end
			end
		!end
		file:write("}\n")

		file:write("lineMappingLines = {")
		!if USE_PADDING then
			for ln = 1, writer.currentOutputLine do
				if ln > 1 then  file:write(",")  end
				file:write(writer.lineMappingLines[ln] or "_")
			end
		!else
			first = true
			for ln = 1, writer.currentOutputLine do
				if writer.lineMappingLines[ln] then
					if not first then  file:write(",")  end
					first = false
					file:write(F("[%d]=%d", ln, writer.lineMappingLines[ln]))
				end
			end
		!end
		file:write("}\n")
	end

	file:write("if not xpcall(runProgram, gloaErrorHandler) then\n")
	file:write("\tos.exit(1)\n") -- In case there was an error in gloaErrorHandler() for some reason.
	file:write("end\n")

	file:close()
end



local UNICODE_TO_ASCII = @insert "unicodeConversions.luapart"

function _G.unicodeToLuaIdentifier(name)
	if name:find"[\128-\255]" then
		name = name:gsub(!(UTF8_CHARACTER_PATTERN), function(c)
			return (#c == 1 and c) or UNICODE_TO_ASCII[c] or "_"
		end)
	elseif LUA_KEYWORDS[name] then
		name = name.."_"
	end
	return name
end

function _G.isExpressionLiteralStringAndValidLuaIdentifier(expr)
	return
		expr.nodeType == !(nodeTypes.AstLiteral)
		and expr.literalType == !(LITERAL_STRING)
		and expr.value:find"^[%a_][%w_]*$" ~= nil
		and not LUA_KEYWORDS[expr.value]
end



function _G.doesTypeHaveAnyDefaultValue(typeInfo)
	return isAny(
		typeInfo.tag,
		!(typeTags.TypeInfoBool),
		!(typeTags.TypeInfoInt),
		!(typeTags.TypeInfoNone),
		!(typeTags.TypeInfoFloat),
		!(typeTags.TypeInfoString),
		!(typeTags.TypeInfoType), -- Not sure about this one. Should zero represent no type or must a value always be specified? @Robustness :DefaultValueForTypes
		!(typeTags.TypeInfoArray),
		!(typeTags.TypeInfoTable),
		!(typeTags.TypeInfoStruct),
		!(typeTags.TypeInfoVararg) -- Varargs never have any default value(s), but because it's a list we can just say that the default value is "nothing".
	)
end



function _G.validateForeignSource(state, foreignSource, foreignSourceName, nodeForError)
	-- @UX: Make error arrow always point at the !foreign token.

	if foreignSource == "lua" then
		if not loadstring(F("return(%s)", foreignSourceName)) then
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid Lua symbol: '%s'", foreignSourceName)
		end

	elseif foreignSource == "compiler" then
		if not FOREIGN_API_COMPILER_SYMBOLS[foreignSourceName] then
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid compiler symbol: '%s'", foreignSourceName)
		end

	else
		errorInternal(state, nodeForError, "Incomplete: Handle foreignSource=%s", foreignSource)
	end
end


