--[[============================================================
--=
--=  Program Writer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	unicodeToLuaIdentifier
	writeProgram, write*

----------------------------------------------------------------

	Format for written programs:
	- Foreign imports.
	- Constants.
	- Forward declarations.
	- Functions.
	- Global/file-scope variables.
	- Program entry point.

	Notes:
	- No Lua globals are read from or written to. (Glóa globals are not Lua globals.)
	- All functions are top-level in Lua no matter where they were defined in Glóa.
	- Local variables in Lua are uniquely named and thus never shadow anything (which might help with debugging).

	@Incomplete:
	- Handle the limited amount of locals Lua allows (200). (Maybe we'll have to use Lua globals to some extent after all.)

--============================================================]]



function _G.writeIdentifierName(state, file, ident)
	local decl = ident.declaration
	local name = decl.topScopeName

	if name == "" then  name = decl.localName  end

	if name == "" then
		astPrint(ident)
		printTraceback(io.stderr)
		nodeError(state, ident, "ProgramWriter", "Internal compiler error: Missing name to write for '%s'.", ident.name)
	end

	file:write(name)
end

function _G.writeStringConcatination(state, file, binary)
	if binary.left.nodeType == !(nodeTypes.AstBinary) and binary.left.operation == ".." then
		writeStringConcatination(state, file, binary.left)
	else
		writeExpression(state, file, binary.left)
	end
	file:write(" .. ")
	if binary.right.nodeType == !(nodeTypes.AstBinary) and binary.right.operation == ".." then
		writeStringConcatination(state, file, binary.right)
	else
		writeExpression(state, file, binary.right)
	end
end

function _G.writeLookup(state, file, lookup)
	if isAny(lookup.object.inferredType.tag, !(typeTags.TypeInfoStruct),!(typeTags.TypeInfoTable),!(typeTags.TypeInfoArray)) then
		-- @Incomplete: Compiler setting for runtime checks of array bounds.
		writeExpression(state, file, lookup.object)

		if isExpressionLiteralStringAndValidLuaIdentifier(lookup.member) then
			local stringLiteral = lookup.member
			file:write(".", stringLiteral.value)
		else
			file:write("[")
			writeExpression(state, file, lookup.member)
			file:write("]")
		end

	elseif lookup.object.inferredType.tag == !(typeTags.TypeInfoEnum) then
		errorInternal() -- Enum lookups should have been simplified away.

	else
		errorUnhandledNodeType(state, lookup.object)
	end
end

function _G.writeCast(state, file, cast)
	local typeInfoSource = cast.expression.inferredType
	local typeInfoTarget = cast.inferredType

	file:write("(") -- In case the written expression is a list of some kind.

	if
		typeInfoSource == typeInfoTarget
		or typeInfoSource.tag == !(typeTags.TypeInfoCompound)
		or typeInfoTarget.tag == !(typeTags.TypeInfoCompound)
		or typeInfoSource.tag == !(typeTags.TypeInfoVararg)
		or typeInfoTarget.tag == !(typeTags.TypeInfoVararg)
	then
		writeExpression(state, file, cast.expression)

	-- int -> float
	elseif typeInfoSource.tag == !(typeTags.TypeInfoInt) and typeInfoTarget.tag == !(typeTags.TypeInfoFloat) then
		writeExpression(state, file, cast.expression)

	-- float -> int
	elseif typeInfoSource.tag == !(typeTags.TypeInfoFloat) and typeInfoTarget.tag == !(typeTags.TypeInfoInt) then
		file:write("math.modf(") -- @Robustness: Store 'math' module in a local. Maybe automatically add a foreign import?
		writeExpression(state, file, cast.expression)
		file:write(")")

	-- (whatever) -> any
	-- any -> (whatever)
	elseif typeInfoSource.tag == !(typeTags.TypeInfoAny) or typeInfoTarget.tag == !(typeTags.TypeInfoAny) then
		-- The user better know what they're doing!
		-- @Incomplete: Compiler setting for runtime checks of 'any' and 'compound' casts.
		writeExpression(state, file, cast.expression)

	else
		errorInternal("@Incomplete: Handle casting from %s to %s.", getFriendlyTypeInfoName(typeInfoSource), getFriendlyTypeInfoName(typeInfoTarget))
	end

	file:write(")")
end

function _G.writeTableConstructorKeyName(file, name)
	if name:find"^[%a_][%w_]*$" then
		file:write(name)
	else
		file:write(F("[%q]", name))
	end
end

function _G.writeDefaultValueForStructMember(state, file, structInfo, member, nodeForError)
	local assignment = findDeclarationInScope(state, structInfo.astNode, member.name, false).assignment
	if assignment then
		local valueExpr = assignment.values[1] or errorInternal()
		writeExpression(state, file, valueExpr)
	else
		writeDefaultValueForType(state, file, member.typeInfo, nodeForError)
	end
end

local function findTableFieldInStructInitializer(tableNode, memberName)
	for _, tableField in ipairs(tableNode) do
		!ASSERT("tableField.key.nodeType == "..nodeTypes.AstLiteral)

		if tableField.key.value == memberName then
			return tableField
		end
	end

	return nil
end

function _G.writeExpression(state, file, expr)
	if expr.nodeType == !(nodeTypes.AstCall) then
		local call   = expr
		local callee = call.callee

		if call.surroundedByParenthesis then  file:write("(")  end

		if callee.nodeType == !(nodeTypes.AstIdentifier) then
			assert(callee.declaration.valueConstant)
			writeConstantValueOrReference(state, file, callee.declaration.valueConstant)
		else
			writeExpression(state, file, callee)
		end

		local argsNeedParenthesis = not (
			#call.arguments == 1 and (
				call.arguments[1].nodeType == !(nodeTypes.AstTable)
				or (
					call.arguments[1].nodeType == !(nodeTypes.AstLiteral)
					and call.arguments[1].literalType == !(LITERAL_STRING)
				)
			)
		)

		if argsNeedParenthesis then  file:write("(")  end

		for i, argExpr in ipairs(call.arguments) do
			if i > 1 then  file:write(", ")  end
			writeExpression(state, file, argExpr)
		end

		if argsNeedParenthesis then  file:write(")")  end

		if call.surroundedByParenthesis then  file:write(")")  end

	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		local unary = expr
		file:write("(", unary.operation)
		writeExpression(state, file, unary.expression)
		file:write(")")

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr
		file:write("(")
		if binary.operation == ".." then
			-- This makes sure consecutive string concatinations appear as one operation without any parenthesis.
			writeStringConcatination(state, file, binary)
		else
			writeExpression(state, file, binary.left)
			file:write(" ", binary.operation, " ")
			writeExpression(state, file, binary.right)
		end
		file:write(")")

	elseif expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		writeConstantValue(state, file, literal.valueConstant)

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr

		if ident.inferredType.tag == !(typeTags.TypeInfoEnum) and not isPartOfAnyDeclaration(ident) then -- @Cleanup: This detection is a bit misplaced, I think.
			local valueExpr = ident.declaration.assignment.values[1] or errorInternal()
			writeExpression(state, file, valueExpr)

		elseif ident.declaration.isConstant then
			writeConstantValueOrReference(state, file, ident.declaration.valueConstant)

		else
			writeIdentifierName(state, file, ident)
		end

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		file:write(F("%d", typeNode.representedType.id)) -- @Cleanup: We probably have a constant for the type ID to use with writeConstantValue() here, but who cares...
		if state.settings.outputDebugInfo then
			file:write("--[[", getFriendlyTypeInfoName(typeNode.representedType):gsub("%]", "%0 "), "]]")
		end

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda   = expr
		local constant = itemWith1(state.constants, "valueType", lambda.inferredType) or errorInternal()
		writeConstantValueOrReference(state, file, constant)

	elseif expr.nodeType == !(nodeTypes.AstVararg) then
		local vararg = expr
		file:write(vararg.surroundedByParenthesis and "(...)" or "...")

	elseif expr.nodeType == !(nodeTypes.AstLookup) then
		local lookup = expr
		writeLookup(state, file, lookup)

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		local cast = expr
		writeCast(state, file, cast)

	elseif expr.nodeType == !(nodeTypes.AstTable) then
		local tableNode = expr
		file:write("{")

		if tableNode.inferredType.tag == !(typeTags.TypeInfoTable) then
			for i, tableField in ipairs(tableNode) do
				if i > 1 then  file:write(", ")  end

				if isExpressionLiteralStringAndValidLuaIdentifier(tableField.key) then
					local stringLiteral = tableField.key
					file:write(stringLiteral.value)
				else
					-- @Polish: Output sequence values without key in 'table' type tables.
					file:write("[")
					writeExpression(state, file, tableField.key)
					file:write("]")
				end
				file:write("=")
				writeExpression(state, file, tableField.value)
			end

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoArray) then
			local items = {}

			for _, tableField in ipairs(tableNode) do
				!ASSERT("tableField.key.nodeType == "..nodeTypes.AstLiteral)

				local literal     = tableField.key
				local arrayIndex  = literal.value
				items[arrayIndex] = tableField.value
			end

			for arrayIndex, expr in ipairs(items) do
				if arrayIndex > 1 then  file:write(", ")  end
				writeExpression(state, file, expr)
			end

		elseif tableNode.inferredType.tag == !(typeTags.TypeInfoStruct) then
			local structInfo = tableNode.inferredType

			for i, member in ipairs(structInfo.members) do
				if i > 1 then  file:write(", ")  end

				local tableField = findTableFieldInStructInitializer(tableNode, member.name)

				writeTableConstructorKeyName(file, member.name)
				file:write("=")

				if tableField then
					writeExpression(state, file, tableField.value)
				else
					writeDefaultValueForStructMember(state, file, structInfo, member, tableNode) -- @UX: Maybe use a better nodeForError.
				end
			end

		else
			errorUnhandledNodeType(state, tableNode)
		end

		file:write("}")

	elseif expr.nodeType == !(nodeTypes.AstForeign) then
		local foreign = expr
		writeConstantValueOrReference(state, file, foreign.valueConstant)

	else
		errorUnhandledNodeType(state, expr)
	end
end

function _G.writeDefaultValueForType(state, file, typeInfo, nodeForError)
	local tag = typeInfo.tag

	if tag == !(typeTags.TypeInfoBool) then
		file:write("false")
	elseif tag == !(typeTags.TypeInfoInt) then
		file:write("0")
	elseif tag == !(typeTags.TypeInfoNil) then
		file:write("nil")
	elseif tag == !(typeTags.TypeInfoFloat) then
		file:write("0.0")
	elseif tag == !(typeTags.TypeInfoString) then
		file:write('""')
	elseif tag == !(typeTags.TypeInfoType) then
		file:write("0") -- @Robustness: Maybe 'type' variables should have no defult value and this should be an error.
	elseif tag == !(typeTags.TypeInfoArray) or tag == !(typeTags.TypeInfoTable) then
		file:write("{}")

	elseif tag == !(typeTags.TypeInfoStruct) then
		local structInfo = typeInfo
		file:write("{")

		for i, member in ipairs(structInfo.members) do
			if i > 1 then  file:write(", ")  end
			writeTableConstructorKeyName(file, member.name)
			file:write("=")
			writeDefaultValueForStructMember(state, file, structInfo, member, nodeForError)
		end

		file:write("}")

	elseif tag == !(typeTags.TypeInfoEnum) then
		nodeError(state, nodeForError, "ProgramWriter", "Enums do not have default values.") -- @Cleanup: This can be detected in the infer pipe.

	else
		nodeError(state, nodeForError, "ProgramWriter", "There is no default value for %s.", getFriendlyTypeInfoName(typeInfo))
	end
end

local function isNameAllocated(state, localsStack, localName)
	if state.topScopeNames[localName] then  return true  end

	for _, locals in ipairs(localsStack) do
		if locals[localName] then  return true  end
	end

	return false
end

local function allocateName(state, localsStack, name, n, shortPrefix, longInfix)
	if name == "_" then  return name  end -- @Incomplete: Make "_" a write-only name.

	local localName

	if state.settings.outputDebugInfo then
		localName = unicodeToLuaIdentifier(name)
		if isNameAllocated(state, localsStack, localName) then
			localName = localName..longInfix..n
		end
	else
		localName = shortPrefix..n
	end

	localsStack[1][localName] = true

	return localName, n+1
end
local function allocateLocalName(state, localsStack, name, n)
	return allocateName(state, localsStack, name, n, "L", "_L")
end
local function allocateArgumentName(state, localsStack, name, n)
	return allocateName(state, localsStack, name, n, "A", "_A")
end

function _G.writeBlock(state, file, block, indent, nextLocalN, localsStack)
	local outputDebugInfo = state.settings.outputDebugInfo
	local indentStr       = ("\t"):rep(indent)

	if not block[1] then
		if outputDebugInfo then
			file:write(indentStr, "-- Empty block.\n")
		end
		return
	end

	localsStack  = {{}, unpack(localsStack)}
	local inDecl = false

	for _, statement in ipairs(block) do
		local nodeType = statement.what.nodeType

		if nodeType == !(nodeTypes.AstDeclaration) then
			local decl = statement.what

			if decl.isConstant then
				skipNextAssignment = true

			else
				decl.localName, nextLocalN = allocateLocalName(state, localsStack, decl.name.name, nextLocalN)

				if decl.assignment then
					inDecl = true
					if decl.assignmentIndex == 1 then
						file:write(indentStr, "local ")
					end

				else
					local tag = decl.name.inferredType.tag
					file:write(indentStr, "local ", decl.localName, " = ")
					writeDefaultValueForType(state, file, decl.name.inferredType, decl.name)
					file:write(";\n")
				end

				-- The initial assignment, if there is one, should be written as the next statement (or after several declarations).
			end

		elseif nodeType == !(nodeTypes.AstAssignment) then
			if not skipNextAssignment then
				local assignment = statement.what
				assert(assignment.operation == "=", "@Incomplete: Support more than '='.")

				if not inDecl then
					file:write(indentStr)
				end
				for i, targetExpr in ipairs(assignment.targets) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, file, targetExpr)
				end
				file:write(" ", assignment.operation, " ")
				for i, expr in ipairs(assignment.values) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, file, expr)
				end
				file:write(";\n") -- The ';' removes ambiguity is some cases.
			end

			inDecl             = false
			skipNextAssignment = false

		elseif nodeType == !(nodeTypes.AstReturn) then
			local returnNode = statement.what
			if
				block.parent.nodeType == !(nodeTypes.AstStatement) -- @Cleanup: Remove AstStatement from the compiler?
				and block.parent.parent.nodeType == !(nodeTypes.AstLambda)
				and not returnNode.values[1]
			then
				if outputDebugInfo then
					file:write(indentStr, "-- return\n")
				end

			else
				file:write(indentStr, "return")
				for i, expr in ipairs(returnNode.values) do
					if i > 1 then  file:write(",")  end
					file:write(" ")
					writeExpression(state, file, expr)
				end
				file:write("\n")
			end

		elseif nodeType == !(nodeTypes.AstBreak) then
			local breakNode = statement.what
			if breakNode.loopName then
				errorUnhandledNodeType(state, breakNode)
			end
			file:write(indentStr, "break\n")

		elseif nodeType == !(nodeTypes.AstBlock) then
			local block = statement.what
			file:write(indentStr, "do\n")
			writeBlock(state, file, block, indent+1, nextLocalN, localsStack)
			file:write(indentStr, "end\n")

		elseif nodeType == !(nodeTypes.AstIf) then
			-- @Optimize: Don't output empty branches.
			local ifBranch = statement.what
			file:write(indentStr, "if ")
			writeExpression(state, file, ifBranch.condition)
			file:write(" then\n")

			writeBlock(state, file, ifBranch.branchTrue, indent+1, nextLocalN, localsStack)

			if ifBranch.branchFalse then
				file:write(indentStr, "else\n")
				writeBlock(state, file, ifBranch.branchFalse, indent+1, nextLocalN, localsStack)
			end

			file:write(indentStr, "end\n")

		elseif nodeType == !(nodeTypes.AstWhile) then
			-- @Optimize: Don't output an empty body.
			local whileLoop = statement.what
			file:write(indentStr, "while ")
			writeExpression(state, file, whileLoop.condition)
			file:write(" do\n")

			writeBlock(state, file, whileLoop.body, indent+1, nextLocalN, localsStack)
			file:write(indentStr, "end\n")

		elseif nodeType == !(nodeTypes.AstFor) then
			-- @Optimize: Don't output an empty body.
			local forLoop     = statement.what
			local localsStack = {{}, unpack(localsStack)}

			for _, decl in ipairs(forLoop.declarations) do
				decl.localName, nextLocalN = allocateLocalName(state, localsStack, decl.name.name, nextLocalN)
			end

			if forLoop.forType == !(FOR_NUMERIC) then
				local decl   = forLoop.declarations[1]
				local values = forLoop.expressions

				file:write(indentStr, "for ")
				writeIdentifierName(state, file, decl.name)
				file:write(" = ")
				writeExpression(state, file, values[1])
				file:write(", ")
				writeExpression(state, file, values[2])
				if values[3] then
					file:write(", ")
					writeExpression(state, file, values[3])
				end

				file:write(" do\n")
				writeBlock(state, file, forLoop.body, indent+1, nextLocalN, localsStack)
				file:write(indentStr, "end\n")

			elseif forLoop.forType == !(FOR_SHORT) then
				local objExpr = forLoop.expressions[1]

				file:write(indentStr, "for ")

				for i, decl in ipairs(forLoop.declarations) do
					if i > 1 then  file:write(", ")  end
					writeIdentifierName(state, file, decl.name)
				end

				file:write(" in ")

				if objExpr.inferredType.tag == !(typeTags.TypeInfoArray) then
					file:write("ipairs")
				elseif objExpr.inferredType.tag == !(typeTags.TypeInfoTable) then
					file:write("pairs")
				elseif objExpr.inferredType.tag == !(typeTags.TypeInfoStruct) then
					errorUnhandledNodeType(state, objExpr)
					-- writeConstantValueOrReference(state, file, interatorFuncConst?) -- @Incomplete: Output default iterator for the struct.
				else
					errorInternal()
				end

				file:write("(")
				writeExpression(state, file, objExpr)
				file:write(") do\n")

				writeBlock(state, file, forLoop.body, indent+1, nextLocalN, localsStack)
				file:write(indentStr, "end\n")

			else--if forLoop.forType == !(FOR_ITERATOR) then
				file:write(indentStr, "for ")

				for i, decl in ipairs(forLoop.declarations) do
					if i > 1 then  file:write(", ")  end
					writeIdentifierName(state, file, decl.name)
				end

				file:write(" in ")

				for i, valueExpr in ipairs(forLoop.expressions) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, file, valueExpr)
				end

				file:write(" do\n")
				writeBlock(state, file, forLoop.body, indent+1, nextLocalN, localsStack)
				file:write(indentStr, "end\n")
			end

		elseif isAny(nodeType, !(nodeTypes.AstImport),!(nodeTypes.AstUsing)) then
			-- void  (Ignore these statements.)

		else
			-- Assume the statement is an expression at this point and let writeExpression() deal with any errors.
			file:write(indentStr)
			writeExpression(state, file, statement.what)
			file:write(";\n") -- The ';' removes ambiguity is some cases.
		end
	end
end

function _G.writeFunction(state, file, lambda)
	if lambda.bodyIsForeign then
		file:write(state.foreignReferences[lambda.foreignSourceId])
		return
	end

	local localsStack = {{}}

	file:write("function(")

	if lambda.argumentsIn then
		for i, arg in ipairs(lambda.argumentsIn) do
			if i > 1 then  file:write(", ")  end

			local decl = arg.declaration

			if decl.name.nodeType == !(nodeTypes.AstVararg) then
				decl.localName = "..."
			else
				decl.localName = allocateArgumentName(state, localsStack, decl.name.name, i)
			end

			file:write(decl.localName)
		end
	end

	file:write(")\n")

	if lambda.body[1] then
		writeBlock(state, file, lambda.body, 1, 1, localsStack)
	elseif state.settings.outputDebugInfo then
		file:write("\t-- Empty function.\n")
	end

	file:write("end")
end

function _G.writeForeignImportIfNew(state, file, typeInfo, foreignSource, foreignSourceName, foreignSourceId)
	assert(foreignSourceId ~= "")

	if state.foreignReferences[foreignSourceId] then  return  end

	-- @Incomplete: Compiler setting for runtime checks of anything originating from foreign sources.
	-- (We can probably wrap foreign the code in something here using typeInfo.)

	local foreignN = state.foreignN+1
	state.foreignN = foreignN

	if foreignN == 1 then
		file:write("local _FOREIGN = {}\n")
	end

	if foreignSource == "lua" then
		if outputDebugInfo then
			state.foreignReferences[foreignSourceId] = F("_FOREIGN[%d--[[%s]]]", foreignN, (foreignSourceId:gsub("[%[%]]", "%0 ")))
			file:write("_FOREIGN[", F("%d", foreignN), "]")
		else
			local foreignRef                                = F("_FOREIGN[%d]", foreignN)
			state.foreignReferences[foreignSourceId] = foreignRef
			file:write(foreignRef)
		end

		file:write(" = (", foreignSourceName, ")\n") -- @Robustness: Is this too straightforward?

	else
		errorInternal("Incomplete: Handle foreignSource=%s", foreignSource)
	end
end

function _G.writeConstantValue(state, file, const)
	local tag = const.valueType.tag

	if tag == !(typeTags.TypeInfoBool) then
		file:write(const.value and "true" or "false")

	elseif tag == !(typeTags.TypeInfoInt) then
		-- %.0f handles larger values than %d and with no wrapping. (I think the former is 64-bit
		-- float and the latter 32-bit int.) %d would not work if trying to write the size of a
		-- large file, for example.
		local nStr = F("%.0f", const.value)

		if not nStr:find"^%-?%d+$" then
			errorLine("ProgramWriter", "Cannot write value as integer: %s", tostring(const.value))
		end
		file:write(nStr)

	elseif tag == !(typeTags.TypeInfoNil) then
		file:write("nil")

	elseif tag == !(typeTags.TypeInfoFloat) then
		local floatStr = tostring(const.value) -- @Robustness: Preserve precision as well as possible.
		if not floatStr:find(".", 1, true) then  floatStr = floatStr..".0"  end
		file:write(floatStr)

	elseif tag == !(typeTags.TypeInfoString) then
		file:write(F("%q", const.value))

	elseif tag == !(typeTags.TypeInfoType) then
		local typeInfo = const.value
		file:write(F("%d", typeInfo.id))
		if state.settings.outputDebugInfo then
			file:write("--[[", getFriendlyTypeInfoName(typeInfo):gsub("%]", "%0 "), "]]")
		end

	elseif tag == !(typeTags.TypeInfoTable) then
		errorInternal("@Incomplete: Write table.")

	elseif tag == !(typeTags.TypeInfoArray) then
		errorInternal("@Incomplete: Write array.")

	elseif tag == !(typeTags.TypeInfoFunction) then
		local lambda = const.value
		writeFunction(state, file, lambda)

	elseif tag == !(typeTags.TypeInfoStruct) then
		errorInternal("@Incomplete: Write struct.")

	elseif tag == !(typeTags.TypeInfoEnum) then
		errorInternal("@Incomplete: Write enum.")

	elseif tag == !(typeTags.TypeInfoForeignDummy) then
		local foreign = const.value
		file:write(state.foreignReferences[foreign.sourceId])

	elseif isAny(tag, !(typeTags.TypeInfoAny),!(typeTags.TypeInfoNamespace),!(typeTags.TypeInfoCompound),!(typeTags.TypeInfoList)) then
		errorInternal("Cannot write invalid value type '%s'.", TYPE_TAG_NAMES[tag])
	else
		errorInternal("Incomplete: Handle constant value of type '%s'.", (TYPE_TAG_NAMES[tag] or "?"))
	end
end

function _G.writeConstantValueOrReference(state, file, const)
	if const.isObject then
		file:write(const.name)
	else
		return writeConstantValue(state, file, const)
	end
end

function _G.writeProgram(state)
	if not state.settings.doOutputFile then  return  end

	local path = state.settings.outputFilePath
	local file = assert(io.open(path, "w"))

	local outputDebugInfo = state.settings.outputDebugInfo

	--
	-- Foreign imports.
	--

	for _, const in ipairs(state.constants) do
		if const.valueType.tag == !(typeTags.TypeInfoFunction) and const.value.bodyIsForeign then
			local lambda = const.value
			writeForeignImportIfNew(state, file, const.valueType, lambda.foreignSource, lambda.foreignSourceName, lambda.foreignSourceId)
		elseif const.valueType.tag == !(typeTags.TypeInfoForeignDummy) then
			local foreign = const.value
			writeForeignImportIfNew(state, file, foreign.inferredType, foreign.source, foreign.sourceName, foreign.sourceId)
		end
	end

	--
	-- Forward declarations.
	--

	-- @Polish: Treat function constants pointing to the same foreign function as the same constant.

	-- Constants, non-functions.
	for _, const in ipairs(state.constants) do
		if const.isObject and const.valueType.tag ~= !(typeTags.TypeInfoFunction) then
			file:write("local ", const.name, " = ")
			writeConstantValue(state, file, const) -- Only functions need everything to be forward declared.
			file:write("\n")
		end
	end

	if state.constants[1] or state.topScopeNames[1] then
		local first = true
		file:write("local ")

		-- Constants, functions.
		for _, const in ipairs(state.constants) do
			if const.valueType.tag == !(typeTags.TypeInfoFunction) then
				if not first then  file:write(", ")  end
				first = false
				file:write(const.name)
			end
		end

		-- Top-level declarations. (Note: Glóa globals are not Lua globals.)
		for _, topScopeName in ipairs(state.topScopeNames) do
			if not first then  file:write(", ")  end
			first = false
			file:write(topScopeName)
		end

		file:write("\n")
	end

	--
	-- Definitions.
	--

	-- Function definitions.
	for _, const in ipairs(state.constants) do
		if const.valueType.tag == !(typeTags.TypeInfoFunction) and const.value.bodyIsForeign then
			local lambda = const.value
			file:write(const.name, " = ")
			writeFunction(state, file, lambda)
			file:write("\n")
		end
	end
	for _, const in ipairs(state.constants) do
		if const.valueType.tag == !(typeTags.TypeInfoFunction) and not const.value.bodyIsForeign then
			local lambda = const.value
			file:write(const.name, " = ")
			writeFunction(state, file, lambda)
			file:write("\n")
		end
	end

	!local ENTRY_POINT_NAME = "main" -- @Incomplete: Configurable entry point name.
	local mainFuncDecl      = nil

	-- Global assignments.
	for _, decl in ipairs(state.globalScope.declarations) do
		if decl.topScopeName ~= "" then
			file:write(decl.topScopeName, " = ")
			writeConstantValueOrReference(state, file, decl.valueConstant)
			file:write("\n")
		end
		if decl.name.name == !(ENTRY_POINT_NAME) then  mainFuncDecl = decl  end
	end
	-- File-scope assignments.
	for _, fileScope in ipairs(state.globalScope.fileScopes) do
		for _, decl in ipairs(fileScope.declarations) do
			if decl.topScopeName ~= "" then
				file:write(decl.topScopeName, " = ")
				writeConstantValueOrReference(state, file, decl.valueConstant)
				file:write("\n")
			end
			if decl.name.name == !(ENTRY_POINT_NAME) then  mainFuncDecl = decl  end
		end
	end

	--
	-- Program entry point.
	--

	if not mainFuncDecl then
		local filePaths = {}
		for i, fileScope in ipairs(state.globalScope.fileScopes) do
			filePaths[i] = fileScope.path
		end
		errorLine(
			"ProgramWriter",
			!("Missing program entry point ('"..ENTRY_POINT_NAME.."' function) in top-level scope in loaded files:\n- %s"),
			table.concat(filePaths, "\n- ")
		)

	elseif not mainFuncDecl.isConstant then
		nodeError(
			state, mainFuncDecl.name, "ProgramWriter",
			!("Declared name '"..ENTRY_POINT_NAME.."' must be a constant.")
		)

	elseif mainFuncDecl.name.inferredType.tag ~= !(typeTags.TypeInfoFunction) then
		nodeError(
			state, mainFuncDecl.assignment.values[mainFuncDecl.assignmentIndex], "ProgramWriter",
			!("Declared name '"..ENTRY_POINT_NAME.."' must be a function to represent the entry point of the program.")
		)

	elseif mainFuncDecl.name.inferredType.argumentTypesIn[1] then
		local lambda = getAssignmentValue(state, mainFuncDecl.name, mainFuncDecl.assignment.values, mainFuncDecl.assignmentIndex)
		nodeError(state, lambda.argumentsIn, "ProgramWriter", "Program entry point function must not take any arguments.")

	elseif mainFuncDecl.name.inferredType.argumentTypesOut[1] then
		local lambda = getAssignmentValue(state, mainFuncDecl.name, mainFuncDecl.assignment.values, mainFuncDecl.assignmentIndex)
		nodeError(state, lambda.argumentsOut, "ProgramWriter", "Program entry point function must not return any values.")
	end

	writeConstantValueOrReference(state, file, mainFuncDecl.valueConstant)
	file:write("()\n")

	file:close()
end



local UNICODE_TO_ASCII = @insert "unicodeConversions.luapart"

function _G.unicodeToLuaIdentifier(name)
	name = name:gsub(!(UTF8_CHARACTER_PATTERN), function(c)
		return (#c == 1 and c) or UNICODE_TO_ASCII[c] or "_"
	end)
	return name
end



function _G.isExpressionLiteralStringAndValidLuaIdentifier(expr)
	return expr.nodeType == !(nodeTypes.AstLiteral) and expr.literalType == !(LITERAL_STRING) and expr.value:find"^[%a_][%w_]*$" ~= nil
end


