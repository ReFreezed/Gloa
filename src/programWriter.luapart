--[[============================================================
--=
--=  Program Writer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	doesTypeHaveAnyDefaultValue
	formatInfoComment
	shouldOperationHaveSurroundingParentheses
	unicodeToLuaIdentifier
	validateForeignSource
	writeProgram, write*

----------------------------------------------------------------

	Format for written programs:
	1. Glóa header.
	2. Foreign imports.
	3. Forward declarations.
	4. Constants (including functions).
	5. Global/file-scope variables.
	6. Program entry point.

	Notes:
	- Usage of Lua globals is minimized. (Glóa globals are not Lua globals.)
	- All functions (with no captures/upvalues) are top-level in Lua no matter where they were defined in Glóa.
	- Local variables in Lua are uniquely named and thus never shadow anything (which might help with debugging).

	@Incomplete:
	- Handle the limited amount of locals Lua allows (200).

--============================================================]]



!(
-- info.what     = "Lua"|"C"|"main"|"tail"
-- info.namewhat = "global"|"local"|"method"|"field"|"upvalue"|""

-- @Incomplete: Handle errors better in compiled Lua modules. :LuaModuleErrors
local ERROR_HANDLER = templateToLua(
	trimTemplate`
		(function(lineMappings, getinfo, tonumber, outputFile, type, exit)
			return function(err, level)
				level            = (level or 1)+1
				local mainSource = (getinfo(1, "S") or {}).source or "<UNKNOWN_SOURCE>"

				if type(err) == "string" then
					local pathHere = mainSource:match"^@(.+)"
					local pathLen  = pathHere and #pathHere
					local ln       = pathHere and err:sub(1, pathLen) == pathHere and tonumber(err:match("^:(%d+): ", pathLen+1))

					if lineMappings.lines[ln] then
						err = (
							lineMappings.paths[lineMappings.files[ln]]..":"
							..lineMappings.lines[ln]..": "
							..err:sub(pathLen+1):gsub("^:%d+: ", "")
						)
					end
				end

				outputFile:write("\n")
				if type(err) == "string" then
					outputFile:write("Error: ", err, "\n")
				else
					outputFile:write("Error!\n")
				end
				outputFile:write("stack traceback:\n")

				for level = level, 1000 do
					local info = getinfo(level, "nSl")
					if not info then  break  end

					outputFile:write("\t")

					if info.what == "C" then
						outputFile:write("[ C ]: ")
						if (info.name or "") ~= "" then
							outputFile:write("'", info.name, "'")
						else
							outputFile:write("?")
						end

					else
						if info.source == mainSource and (lineMappings.lines[info.currentline] or 0) > 0 then
							outputFile:write(lineMappings.paths[lineMappings.files[info.currentline]], ":", lineMappings.lines[info.currentline])
						else
							outputFile:write("[Lua]")
						end

						outputFile:write(":")

						if info.what == "tail" then
							outputFile:write(" tail call")
						elseif info.what == "main" then
							outputFile:write(" main chunk")
						elseif (info.name or "") ~= "" then
							outputFile:write(" ")
							if info.namewhat == "method" or info.namewhat == "field" then  outputFile:write(info.namewhat, " ")  end
							outputFile:write("'", info.name, "'")
						--[[elseif info.source == mainSource and (lineMappings.lines[info.linedefined] or 0) > 0 and info.linedefined ~= info.currentline then
							outputFile:write(" (linedefined:", lineMappings.lines[info.linedefined], ")")]]
						end

						local source = nil

						if info.source:find"^@" then
							source = $errorPrefix..info.source:sub(2)
						elseif info.source:find"%.lua$" then
							source = info.source
						end

						source = source and source..":"..info.currentline

						if source then
							outputFile:write(" (", source)
							--[[if info.linedefined > 0 and info.linedefined ~= info.currentline then
								outputFile:write(", linedefined:", info.linedefined)
							end]]
							outputFile:write(")")
						end
					end

					outputFile:write("\n")
				end

				exit(1)
			end
		end)(lineMappings, debug.getinfo, tonumber, io.stderr, type, os.exit)
	`,
	{ errorPrefix=toLua(RUNTIME_ERROR_PREFIX) }
)

local COMPILER_SYMBOL_PAIRS = {
	`_HUGE`,   `math.huge`,
	`_MODF`,   `math.modf`,  -- Used when casting float to int.
	`_FLOOR`,  `math.floor`, -- Used for integer division.
	`_IPAIRS`, `ipairs`,     -- Used for short-form array loops.
	`_PAIRS`,  `pairs`,      -- Used for short-form table loops.
	`_SELECT`, `select`,     -- Used for short-form vararg loops, lookups and length expressions.
	`_REP`,    `string.rep`, -- Used for string repetition (duh).
	`_REP2`,   `function(n,s)return(s:rep(n))end`,
	`_BYTE`,   `string.byte`,-- Used for string subscripting.

	-- Used for short-form array loops in reverse.
	`_IPAIRSR`, trimTemplate`
		(function()
			local function iprev(arr, i)
				i = i-1
				if i > 0 then  return i, arr[i]  end
			end
			return function(arr)
				return iprev, arr, #arr+1
			end
		end)()
	`,
}
local COMPILER_SYMBOL_COUNT = #COMPILER_SYMBOL_PAIRS/2
)

local foreignApiCompilerSymbols = {
	-- These can be used in user code through !foreign compiler "symbolName".
	-- (See utils.gloa, io.gloa and other modules for declarations.)
	-- (See compiler.gloa for things only available during compile-time.)

	appPath           = `(debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get application path.")) :gsub("\\", "/")`,
	appDirectory      = `(debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get application path.")) :gsub("\\", "/"):gsub("/?[^/]+$", ""):gsub("^$", ".")`,
	compilerPath      = F("%q", COMPILER_PATH),
	compilerDirectory = F("%q", COMPILER_DIRECTORY),

	error   = `error`,
	ipairsr = `_IPAIRSR`,

	wrapFunctionInGloaErrorHandler = !(trimTemplate`
		(function(select, xpcall, unpack, exit, gloaErrorHandler)
			local function pack(...)
				return {n=select("#", ...), ...}
			end

			return function(cb)
				return function(...)
					local args = pack(...)

					args = pack(xpcall(
						function() return cb(unpack(args, 1, args.n)) end,
						gloaErrorHandler
					))
					if not args[1] then  exit(1)  end

					return unpack(args, 2, args.n)
				end
			end
		end)(select, xpcall, unpack, os.exit, gloaErrorHandler)
	`),

	getProgramArguments = !(trimTemplate`
		(function(args, unpack)
			return function()
				return {unpack(args)}
			end
		end)(programArguments, unpack)
	`),

	getCommandLineArguments = !(trimTemplate`
		(function(args, HUGE, unpack)
			return function()
				local argsCopy = {unpack(args)}
				for i = 0, -HUGE, -1 do
					if args[i] == nil then  return argsCopy  end
					argsCopy[i] = args[i]
				end
			end
		end)(luaArguments, math.huge, unpack)
	`),

	getAllTypes = !(trimTemplate`
		(function(unpack)
			return function(T)
				if not _TYPES[1000] then
					return {unpack(_TYPES)}
				end

				local types = {unpack(_TYPES, 1, 1000)}
				for i = 1001, #_TYPES do
					types[i] = _TYPES[i]
				end

				return types
			end
		end)(unpack)
	`),

	getTypeInfo = !(trimTemplate`
		function(T)
			return _TYPE_INFO[T]
		end
	`),
}

local foreignApiCompilerSymbolsDuringCompilation = {
	-- These are different during compilation.

	appPath      = `metaprogramAppPath`,
	appDirectory = `metaprogramAppDirectory`,

	error = `compilerErrorHandler`,
}

for k in pairs(compilerApi) do
	foreignApiCompilerSymbols[k]                  = `function() error("Function not available during runtime.") end` -- This should only ever get written if keepDeadCode is set.
	foreignApiCompilerSymbolsDuringCompilation[k] = "_COMPILER."..k
end

local LUA_KEYWORDS = !(Set{"and","break","do","else","elseif","end","false","for","function","goto","if","in","local","nil","not","or","repeat","return","then","true","until","while"})

_G.!struct"WriterState"{
	{`file`,              nil}, -- Real or virtual file.
	{`outputRuntime`,     false},

	{`foreignN`,          0},
	{`foreignReferences`, {}},
	{`foreignOnlyAvailableDuringCompilation`, {}},

	{`loopDepth`,         0},
	{`loopStack`,         {}},  -- [](AstFor|AstWhile)  Only used for loops with named jumps inside.
	{`continueDepth`,     0},
	{`skipOneJumpCheck`,  false},
	{`deferStack`,        {}},  -- []AstDefer
	{`loopDeferIndices`,  {}},

	{`currentOutputLine`, 1},
	{`lineMappingFiles`,  {}},
	{`lineMappingLines`,  {}},

	{`remainingUpvalues`, 0},
}



local function addLineMapping(state, writer, token)
	local ln = writer.currentOutputLine
	if (writer.lineMappingLines[ln] or 0) > 0 then  return  end
	writer.lineMappingFiles[ln] = state.tokens.file [token] or errorInternal()
	writer.lineMappingLines[ln] = state.tokens.line1[token] or errorInternal()
end
-- addLineMappingDummy( state, writer [, path ] )
local function addLineMappingDummy(state, writer, path)
	local ln = writer.currentOutputLine
	if writer.lineMappingLines[ln] then  return  end
	writer.lineMappingFiles[ln] = path or state.pathToFirstFile
	writer.lineMappingLines[ln] = 0
end

local function writeEol(state, writer)
	writer.file:write("\n")
	writer.currentOutputLine = writer.currentOutputLine+1
end

function _G.writeIdentifierName(state, writer, ident)
	local decl = ident.declaration
	local name = decl.topScopeName

	addLineMapping(state, writer, ident.token)

	if name == "" then  name = decl.localName  end

	if name == "" then
		nodeError(state, ident, "ProgramWriter", "Internal compiler error: Missing name to write for '%s'.", ident.name)
	end

	writer.file:write(name)
end

function _G.writeStringLiteral(writer, s)
	local lua = F("%q", s):gsub("\\\n", "\\n")
	writer.file:write(lua)
end

-- writeBinaryOperatorChain( state, writer, indent, nextLocalN, localsStack, left:AstNode|string, right:AstNode|string, binaryOperation )
function _G.writeBinaryOperatorChain(state, writer, indent, nextLocalN, localsStack, left, right, binOp)
	if type(left) == "string" then
		writer.file:write(left)
	elseif left.nodeType == !(AST_BINARY) and left.operation == binOp then
		writeBinaryOperatorChain(state, writer, indent, nextLocalN, localsStack, left.left, left.right, binOp)
	else
		writeExpression(state, writer, indent, nextLocalN, localsStack, left)
	end

	writer.file:write(" ", binOp, " ")

	if type(right) == "string" then
		writer.file:write(right)
	elseif right.nodeType == !(AST_BINARY) and right.operation == binOp then
		writeBinaryOperatorChain(state, writer, indent, nextLocalN, localsStack, right.left, right.right, binOp)
	else
		writeExpression(state, writer, indent, nextLocalN, localsStack, right)
	end
end

function _G.shouldOperationHaveSurroundingParentheses(node)
	local parent         = node.parent
	local parentNodeType = parent.nodeType
	return not (
		!!(CONST_SET{
			AST_CAST, -- Casts should always add their own parentheses.
			AST_CALL, -- Both callee and arguments.
			AST_RETURN,
			AST_IF,
			AST_FOR,
			AST_WHILE
		})[parentNodeType]
		or parentNodeType == !(AST_ASSIGNMENT) and not (parent.binaryOperation ~= "" and node.queued.container == parent.values)
		or parentNodeType == !(AST_ACCESS) and node == parent.member -- The member should be inside [].
	)
end

-- writeBinaryOperation( state, writer, indent, nextLocalN, localsStack, left:AstNode|string, right:AstNode|string, binaryOperation leftType, rightType, resultingType, token, binary=nil )
function _G.writeBinaryOperation(state, writer, indent, nextLocalN, localsStack, l, r, binOp, lType, rType, resultingType, token, binary)
	!(
	local function WRITE_OPERAND(sideCode)
		__LUA(templateToLua(
			trimTemplate`
				if type($sideCode) == "string" then
					file:write($sideCode)
				else
					writeExpression(state, writer, indent, nextLocalN, localsStack, $sideCode)
				end
			`,
			{sideCode=sideCode}
		))
	end
	)

	local file      = writer.file
	local addParens = binary and shouldOperationHaveSurroundingParentheses(binary)

	addLineMapping(state, writer, token)

	if !!(CONST_SET{"..","and","or"})[binOp] then
		-- @Polish: For the logical operators there is probably more we can do, but we may have to dive deeper in the sub-trees to make some predictions or something...
		if addParens then  file:write("(")  end
		writeBinaryOperatorChain(state, writer, indent, nextLocalN, localsStack, l, r, binOp) -- This makes sure e.g. consecutive string concatenations appear as one operation without any parentheses.
		if addParens then  file:write(")")  end

	elseif binOp == "//" then
		file:write("_FLOOR(")
		!WRITE_OPERAND `l`
		file:write(" / ")
		!WRITE_OPERAND `r`
		file:write(")")

	elseif binOp == "*" and resultingType.tag == !(TYPE_STRING) then
		-- Just a quick note:
		--   str *= 3  -- OK
		--   num *= "" -- Illegal (as the result is a string, which is a type mismatch with 'num')
		if lType.tag == !(TYPE_STRING) then
			file:write("_REP(")
		else
			file:write("_REP2(")
		end
		!WRITE_OPERAND `l`
		file:write(", ")
		!WRITE_OPERAND `r`
		file:write(")")

	else
		if addParens then  file:write("(")  end
		!WRITE_OPERAND `l`
		file:write(" ", binOp, " ")
		!WRITE_OPERAND `r`
		if addParens then  file:write(")")  end
	end
end

local function isExpressionLiteralStringAndValidLuaIdentifier(expr)
	return
		expr.nodeType == !(AST_LITERAL)
		and expr.literalType == !(LITERAL_STRING)
		and expr.value:find"^[%a_][%w_]*$" ~= nil
		and not LUA_KEYWORDS[expr.value]
end

local function writeAccessMemberPart(state, writer, indent, nextLocalN, localsStack, accessMember)
	if isExpressionLiteralStringAndValidLuaIdentifier(accessMember) then
		local stringLiteral = accessMember
		writer.file:write(".", stringLiteral.value)
	else
		writer.file:write("[")
		writeExpression(state, writer, indent, nextLocalN, localsStack, accessMember)
		writer.file:write("]")
	end
end

function _G.writeAccess(state, writer, indent, nextLocalN, localsStack, access)
	if access.XXX_AWBO_HACK then -- @Hack
		-- :AbcCheck
		if type(access.object) == "string" then
			writer.file:write(access.object)
		else
			writeExpression(state, writer, indent, nextLocalN, localsStack, access.object)
		end
		if type(access.member) == "string" then
			writer.file:write("[", access.member, "]")
		else
			writeAccessMemberPart(state, writer, indent, nextLocalN, localsStack, access.member)
		end
		return
	end

	local objType = access.object.inferredType
	if objType.tag == !(TYPE_LIST) then
		objType = adjustTypeToOne(state, access.object, objType, true)
	end

	if isTypeTableLike(objType) then
		-- @Incomplete: Compiler setting for runtime checks of array bounds. :AbcCheck
		writeExpression(state, writer, indent, nextLocalN, localsStack, access.object)

		if access.parent.nodeType == !(AST_CALL) and access.parent.isMethod then
			local stringLiteral = access.member
			assert(stringLiteral.nodeType == !(AST_LITERAL) and stringLiteral.literalType == !(LITERAL_STRING))

			if not stringLiteral.value:find"^[%a_][%w_]*$" then
				errorInternal("@Incomplete: Support method calls using names containing non-ASCII characters.")
			elseif LUA_KEYWORDS[stringLiteral.value] then
				errorInternal("@Incomplete: Support method calls using names that are keywords in Lua.")
			end

			writer.file:write(":", stringLiteral.value)

		else
			writeAccessMemberPart(state, writer, indent, nextLocalN, localsStack, access.member)
		end

	elseif objType.tag == !(TYPE_STRING) then
		writer.file:write("_BYTE(")
		writeExpression(state, writer, indent, nextLocalN, localsStack, access.object)
		writer.file:write(", ")
		writeExpression(state, writer, indent, nextLocalN, localsStack, access.member)
		writer.file:write(")")

	elseif objType.tag == !(TYPE_VARARG) then
		writer.file:write("(_SELECT(")
		writeExpression(state, writer, indent, nextLocalN, localsStack, access.member)
		writer.file:write(", ...))")

	elseif objType.tag == !(TYPE_ENUM) then
		errorInternal(state, access) -- Enum accesses should have been simplified away.

	else
		errorUnhandledType(state, access.object, objType)
	end
end

-- writeCast( state, writer, indent, nextLocalN, localsStack, cast [, nameToCast ] )
-- nameToCast is only used by AstConditional.
function _G.writeCast(state, writer, indent, nextLocalN, localsStack, cast, nameToCast)
	!local WRITE_EXPRESSION = trimTemplate`
		if nameToCast then
			writer.file:write(nameToCast)
		else
			writeExpression(state, writer, indent, nextLocalN, localsStack, cast.expression)
		end
	`

	local typeInfoSource = adjustTypeToOne(state, cast.expression, cast.expression.inferredType, true)
	local typeInfoTarget = cast.inferredType

	addLineMapping(state, writer, cast.token)

	writer.file:write("(") -- In case the written expression is a list of some kind.

	if
		typeInfoSource == typeInfoTarget
		or typeInfoSource.tag == !(TYPE_COMPOUND)
		or typeInfoTarget.tag == !(TYPE_COMPOUND)
	then
		!!(WRITE_EXPRESSION)

	-- int -> float
	elseif typeInfoSource.tag == !(TYPE_INT) and typeInfoTarget.tag == !(TYPE_FLOAT) then
		!!(WRITE_EXPRESSION)
	-- float -> int
	elseif typeInfoSource.tag == !(TYPE_FLOAT) and typeInfoTarget.tag == !(TYPE_INT) then
		writer.file:write("_MODF(") -- Note: math.modf() returns two values.
		!!(WRITE_EXPRESSION)
		writer.file:write(")")

	-- (numeric) -> bool
	elseif isTypeNumeric(typeInfoSource) and typeInfoTarget.tag == !(TYPE_BOOL) then
		!!(WRITE_EXPRESSION)
		writer.file:write(" ~= 0")
	-- string -> bool
	elseif typeInfoSource.tag == !(TYPE_STRING) and typeInfoTarget.tag == !(TYPE_BOOL) then
		!!(WRITE_EXPRESSION)
		writer.file:write(' ~= ""')
	-- array -> bool
	elseif typeInfoSource.tag == !(TYPE_ARRAY) and typeInfoTarget.tag == !(TYPE_BOOL) then
		!!(WRITE_EXPRESSION)
		writer.file:write("[1] ~= nil")
	-- (array-like struct) -> bool
	elseif typeInfoSource.tag == !(TYPE_STRUCT) and typeInfoSource.kind == !(STRUCT_KIND_ARRAY) and typeInfoTarget.tag == !(TYPE_BOOL) then
		!!(WRITE_EXPRESSION)
		writer.file:write("[1] ~= nil")

	-- enum -> (real enum member type)
	elseif typeInfoSource.tag == !(TYPE_ENUM) and typeInfoTarget == typeInfoSource.memberTypeInfo then
		!!(WRITE_EXPRESSION)
	-- (real enum member type) -> enum
	elseif typeInfoTarget.tag == !(TYPE_ENUM) and typeInfoSource == typeInfoTarget.memberTypeInfo then
		!!(WRITE_EXPRESSION)

	-- (base struct) -> (substruct)
	elseif typeInfoSource.tag == !(TYPE_STRUCT) and typeInfoTarget.tag == !(TYPE_STRUCT) then
		!!(WRITE_EXPRESSION)
	-- (table-like) -> table
	elseif isTypeTableLike(typeInfoSource) and typeInfoTarget.tag == !(TYPE_TABLE) then
		!!(WRITE_EXPRESSION)
	-- (array-like struct) -> array
	elseif typeInfoSource.tag == !(TYPE_STRUCT) and typeInfoSource.kind == !(STRUCT_KIND_ARRAY) and typeInfoTarget.tag == !(TYPE_ARRAY) then
		!!(WRITE_EXPRESSION)

	-- (whatever) -> any
	-- any -> (whatever)
	elseif typeInfoSource.tag == !(TYPE_ANY) or typeInfoTarget.tag == !(TYPE_ANY) then
		-- The user better know what they're doing!
		-- @Incomplete: Compiler setting for runtime checks of 'any' and 'compound' casts.
		!!(WRITE_EXPRESSION)

	else
		errorInternal(state, cast, "Incomplete: Handle casting from %s to %s.", getFriendlyTypeInfoName(typeInfoSource), getFriendlyTypeInfoName(typeInfoTarget))
	end

	writer.file:write(")")
end

function _G.writeTableConstructorKeyName(writer, name)
	if name:find"^[%a_][%w_]*$" and not LUA_KEYWORDS[name] then
		writer.file:write(name)
	else
		writer.file:write("[")
		writeStringLiteral(writer, name) -- @Incomplete: Use writeConstantValueOrReference() in case the string is large.
		writer.file:write("]")
	end
end
function _G.writeTableConstructorKey(state, writer, indent, nextLocalN, localsStack, keyExpr)
	if keyExpr.nodeType == !(AST_LITERAL) and keyExpr.literalType == !(LITERAL_STRING) then
		local stringLiteral = keyExpr
		writeTableConstructorKeyName(writer, stringLiteral.value)
	else
		writer.file:write("[")
		writeExpression(state, writer, indent, nextLocalN, localsStack, keyExpr)
		writer.file:write("]")
	end
end

function _G.writeDefaultValueForStructMember(state, writer, indent, nextLocalN, localsStack, structInfo, member, nodeForError)
	local decl = findDynamicMemberDeclaration(state, structInfo.astNode, member.name) or errorInternal(state, structInfo.astNode, "Did not find member '%s'.", member.name)
	if decl.value then
		writeExpression(state, writer, indent, nextLocalN, localsStack, decl.value)
	else
		writeDefaultValueForType(state, writer, indent, nextLocalN, localsStack, member.typeInfo, nodeForError)
	end
end

local function findTableFieldByNameInStructConstructor(state, tableNode, memberName)
	for _, tableField in ipairs(tableNode.fields) do
		local keyExpr = tableField.key
		if keyExpr.nodeType == !(AST_LITERAL) and keyExpr.literalType == !(LITERAL_STRING) and keyExpr.value == memberName then
			return tableField
		end
	end

	return nil
end

local function doesTypeContainBoolOrNone(typeInfo)
	if !!(CONST_SET{ TYPE_BOOL, TYPE_NONE, TYPE_ANY })[typeInfo.tag] then  return true  end

	if typeInfo.tag ~= !(TYPE_COMPOUND) then  return false  end
	local compound = typeInfo

	for _, compoundItem in ipairs(compound) do
		if !!(CONST_SET{ TYPE_BOOL, TYPE_NONE })[compoundItem.tag] then  return true  end
	end
	return false
end

-- lambda = getDataForHandlingMissingArguments( state, callee )
local function getDataForHandlingMissingArguments(state, callee)
	if callee.nodeType ~= !(AST_IDENTIFIER) then  return nil  end

	local ident = callee
	if not isDeclarationConstant(ident.declaration) then  return nil  end

	local const = ident.declaration.valueConstant
	if not const then  return nil  end

	local funcSig = const.valueType
	if funcSig.tag ~= !(TYPE_FUNCTION) then
		errorInternal(state, ident, getFriendlyTypeInfoName(funcSig))
	end

	local argTypesIn = funcSig.argumentTypesIn
	if not argTypesIn[1] or argTypesIn[1].tag == !(TYPE_VARARG) then  return nil  end

	local lambda = const.value
	!ASSERT("lambda.nodeType == "..AST_LAMBDA, nil, `lambda`)

	return lambda
end

local function isExpressionNil(expr)
	return
		expr.nodeType == !(AST_NULL)
		or expr.nodeType == !(AST_LITERAL) and expr.literalType == !(LITERAL_NIL)
end

local function isStructMemberDefaultValueNil(state, struct, memberName, nodeForError)
	local decl      = findDynamicMemberDeclaration(state, struct, memberName) or errorInternal(state, nodeForError, memberName)
	local valueExpr = decl.value

	if valueExpr then
		return isExpressionNil(valueExpr)
	else
		return !!(CONST_SET{ TYPE_NONE, TYPE_ANY })[decl.name.inferredType.tag] or false
	end
end

function _G.writeExpression(state, writer, indent, nextLocalN, localsStack, expr)
	!ASSERT(`expr.inferredType`, nil, `expr`)
	local file = writer.file

	if expr.nodeType == !(AST_CALL) then
		local call   = expr
		local callee = call.callee

		local callingForeignMethod = false

		addLineMapping(state, writer, call.token)

		if call.surroundedByParentheses then  file:write("(")  end

		-- Write callee and handle method calls.
		if callee.nodeType == !(AST_IDENTIFIER) and isDeclarationConstant(callee.declaration) then
			local ident = callee
			local decl  = ident.declaration
			local const = decl.valueConstant

			!if DEBUG then
				if not const then
					if decl.value then  astPrintTree(decl.value)  end
					errorInternal(state, decl, "Missing constant object.")
				end
			!end

			if const.valueType.tag == !(TYPE_FUNCTION) and const.value.bodyIsForeign and const.value.foreignSource == "method" then
				callingForeignMethod = true
				local argExpr        = call.arguments[1] or errorInternal(state, call)

				if argExpr.nodeType == !(AST_IDENTIFIER) then
					-- Note: It doesn't matter if argExpr a reference to a constant or not since it's be an object reference
					-- either way (unless the type inference borked and argExpr somehow isn't a struct instance).
					writeExpression(state, writer, indent, nextLocalN, localsStack, argExpr)

				elseif argExpr.nodeType == !(AST_ACCESS) then
					-- Table lookups have precedence over method calls in Lua.
					writeExpression(state, writer, indent, nextLocalN, localsStack, argExpr)

				else
					-- I think the parenthesis here is needed since argExpr (or shouldOperationHaveSurroundingParentheses())
					-- will think it's part of a comma-separated list between the parenthesis of the call.
					file:write("(")
					writeExpression(state, writer, indent, nextLocalN, localsStack, argExpr)
					file:write(")")
				end

				local lambda = const.value
				file:write(":", lambda.foreignSourceName.value)
				if outputDebugInfo and lambda.foreignSourceName.value ~= ident.name then
					file:write(formatInfoComment(ident.name)) -- Not sure this is that helpful...
				end

			else
				writeConstantValueOrReference(state, writer, const, ident)
			end

		else
			writeExpression(state, writer, indent, nextLocalN, localsStack, callee)
		end

		file:write("(")
		local first = true

		-- Write given sequential arguments.
		!local MAYBE_WRITE_COMMA = trimTemplate`
			if not first then  file:write(", ")  end
			first = false
		`

		for i = (callingForeignMethod and 2 or 1), #call.arguments do
			!!(MAYBE_WRITE_COMMA)
			writeExpression(state, writer, indent, nextLocalN, localsStack, call.arguments[i])
		end

		-- Write given named arguments and handle default values.
		local lambda = getDataForHandlingMissingArguments(state, callee)

		if lambda then
			local lastValue = getLast(call.arguments)

			local lastValueIsList = (lastValue ~= nil and (
				(
					lastValue.inferredType.tag == !(TYPE_VARARG)
					and not lastValue.surroundedByParentheses
				)
				or (
					lastValue.inferredType.tag == !(TYPE_LIST)
					and not lastValue.surroundedByParentheses
					and lastValue.inferredType[2] ~= nil
				)
			))

			if lastValueIsList then
				local argTypesIn         = lambda.inferredType.argumentTypesIn
				local isVararg           = getLast(argTypesIn).tag == !(TYPE_VARARG)
				local lastNonVarargIndex = #argTypesIn - (isVararg and 1 or 0)
				local lastNonVarargType  = argTypesIn[lastNonVarargIndex]

				--[[
				local lastValueListSize = 0
				if not lastValueIsList then
					-- void
				elseif lastValue.inferredType.tag == !(TYPE_VARARG) then
					lastValueListSize    = math.huge
				else
					local lastArgOutType = getLast(lastValue.inferredType) or errorInternal(state, lastValue)
					lastValueListSize    = lastArgOutType.tag == !(TYPE_VARARG) and math.huge or #lastValue.inferredType
				end
				--]]

				if not isVararg and not lastNonVarargType.isRequired --[[and lastNonVarargIndex > #call.arguments-1+lastValueListSize]] then
					-- :DisallowListAsLastValueToFunctionWithOptionalArguments
					nodeError(state, call, "ProgramWriter", "@Incomplete: Handle optional arguments if the last argument in a call is a list of values.")
				end
			end

			local argsIn = lambda.argumentsIn.arguments

			for argIndex = #call.arguments+1, #argsIn do
				local argNamed  = itemWith1(call.argumentsNamed, "argumentIndex", argIndex)
				local valueExpr = argNamed and argNamed.value or argsIn[argIndex].declaration.value

				if not valueExpr then
					-- Varargs are optional but have no default value (or zero default values since it's technically a list).
					-- !ASSERT(`not argsIn[argIndex+1]`, nil, `call`) -- This assert is not correct if the last call argument is another call that returns values before the vararg.
					break

				elseif argNamed then
					!!(MAYBE_WRITE_COMMA)
					writeExpression(state, writer, indent, nextLocalN, localsStack, valueExpr)

				elseif lambda.bodyIsForeign then
					-- Don't write default values for foreign functions. This gives the foreign site control over
					-- what the actual default values should be no matter what the local !foreign declaration says.
					break

				elseif valueExpr.nodeType == !(AST_LOCATION) and valueExpr.ofCaller then
					local const = call.locationConstant or errorInternal(state, call, "Missing caller location data.")
					!!(MAYBE_WRITE_COMMA)
					writeConstantValueOrReference(state, writer, const, valueExpr)

				else
					!!(MAYBE_WRITE_COMMA)
					writeExpression(state, writer, indent, nextLocalN, localsStack, valueExpr)
				end
			end
		end

		file:write(")")

		if call.surroundedByParentheses then  file:write(")")  end

	elseif expr.nodeType == !(AST_UNARY) then
		local unary = expr
		addLineMapping(state, writer, unary.token)

		-- Lua doesn't have unary '+'.
		if unary.operation == "+" then
			writeExpression(state, writer, indent, nextLocalN, localsStack, unary.expression)

		-- Length of vararg.
		elseif unary.operation == "#" and unary.expression.nodeType == !(AST_VARARG) then
			file:write('_SELECT("#", ...)')

		-- For 'if not n', output 'if n==0' instead of 'if not(n~=0)'.
		elseif unary.operation == "not" and unary.expression.nodeType == !(AST_CAST) and !!(CONST_SET{ TYPE_STRING, TYPE_INT, TYPE_FLOAT })[unary.expression.expression.inferredType.tag] then
			local cast = unary.expression

			addLineMapping(state, writer, cast.token)
			addLineMapping(state, writer, cast.expression.token)

			file:write("(")
			writeExpression(state, writer, indent, nextLocalN, localsStack, cast.expression)
			file:write(" == ")
			if cast.expression.inferredType.tag == !(TYPE_STRING) then
				file:write('""')
			else
				file:write("0")
			end
			file:write(")")

		-- Other operations.
		else
			local addParens = shouldOperationHaveSurroundingParentheses(unary)

			if addParens then  file:write("(")  end
			file:write(unary.operation)
			if unary.operation:find"%w" then  file:write(" ")  end
			writeExpression(state, writer, indent, nextLocalN, localsStack, unary.expression)
			if addParens then  file:write(")")  end
		end

	elseif expr.nodeType == !(AST_BINARY) then
		local binary = expr
		writeBinaryOperation(
			state, writer, indent, nextLocalN, localsStack,
			binary.left, binary.right,
			binary.operation,
			binary.left.inferredType, binary.right.inferredType, binary.inferredType,
			binary.token, binary
		)

	elseif expr.nodeType == !(AST_LITERAL) then
		local literal = expr
		!ASSERT(`literal.valueConstant`, nil, `literal`)
		writeConstantValueOrReference(state, writer, literal.valueConstant, literal)

	elseif expr.nodeType == !(AST_IDENTIFIER) then
		local ident = expr
		local decl  = ident.declaration
		!ASSERT `ident.inferredType`
		!ASSERT `decl`

		if isDeclarationConstant(decl) then
			writeConstantValueOrReference(state, writer, decl.valueConstant, ident)
		else
			writeIdentifierName(state, writer, ident)
		end

	elseif expr.nodeType == !(AST_VARARG) then
		local vararg = expr
		file:write(vararg.surroundedByParentheses and "(...)" or "...")

	elseif expr.nodeType == !(AST_BLANK) then
		file:write("_")

	elseif expr.nodeType == !(AST_TYPE) then
		local typeNode = expr
		file:write(F("%d", typeNode.representedType.id)) -- @Cleanup: We probably have a constant for the type ID to use with writeConstantValue() here, but whatever!
		if outputDebugInfo then
			file:write(formatInfoComment(getFriendlyTypeInfoName(typeNode.representedType)))
		end

	elseif expr.nodeType == !(AST_LAMBDA) then
		local lambda = expr
		if lambda.captures[1] then
			writeFunction(state, writer, indent, nextLocalN, localsStack, lambda)
		else
			local const = lambda.valueConstant or errorInternal(state, lambda)
			writeConstantValueOrReference(state, writer, const, lambda)
		end

	elseif expr.nodeType == !(AST_ACCESS) then
		local access = expr
		writeAccess(state, writer, indent, nextLocalN, localsStack, access)

	elseif expr.nodeType == !(AST_CAST) then
		local cast = expr
		writeCast(state, writer, indent, nextLocalN, localsStack, cast)

	elseif expr.nodeType == !(AST_TABLE) then
		local tableNode = expr
		local first     = true
		file:write("{")

		if tableNode.inferredType.tag == !(TYPE_TABLE) then
			for _, tableField in ipairs(tableNode.fields) do
				if not (isExpressionNil(tableField.value) and isExpressionConstant(state, tableField.key, true)) then
					if not first then  file:write(", ")  end
					first = false

					-- @Polish: Output sequence values without key in generic table constructors.
					writeTableConstructorKey(state, writer, indent, nextLocalN, localsStack, tableField.key)
					file:write("=")
					writeExpression(state, writer, indent, nextLocalN, localsStack, tableField.value)
				end
			end

		elseif tableNode.inferredType.tag == !(TYPE_ARRAY) then
			for _, tableField in ipairs(tableNode.fields) do
				!ASSERT("tableField.key.nodeType == "..AST_LITERAL) -- :VariableArrayIndices

				if not first then  file:write(", ")  end
				first = false

				if not tableField.keyIsGenerated then
					writeTableConstructorKey(state, writer, indent, nextLocalN, localsStack, tableField.key)
					file:write("=")
				end
				writeExpression(state, writer, indent, nextLocalN, localsStack, tableField.value)
			end

		elseif tableNode.inferredType.tag == !(TYPE_STRUCT) then
			local structInfo = tableNode.inferredType
			!ASSERT `not structInfo.isPolymorphic`

			for _, member in ipairs(structInfo.members) do
				local tableField = findTableFieldByNameInStructConstructor(state, tableNode, member.name)

				if not (tableField or isStructMemberDefaultValueNil(state, structInfo.astNode, member.name, tableNode)) then
					if not first then  file:write(", ")  end
					first = false

					writeTableConstructorKeyName(writer, member.name)
					file:write("=")
					writeDefaultValueForStructMember(state, writer, indent, nextLocalN, localsStack, structInfo, member, tableNode) -- @UX: Maybe use a better nodeForError.
				end
			end

			for _, tableField in ipairs(tableNode.fields) do
				if tableField.keyIsGenerated or not isExpressionNil(tableField.value) then
					if not first then  file:write(", ")  end
					first = false

					if not tableField.keyIsGenerated then
						writeTableConstructorKey(state, writer, indent, nextLocalN, localsStack, tableField.key)
						file:write("=")
					end
					writeExpression(state, writer, indent, nextLocalN, localsStack, tableField.value)
				end
			end

		else
			errorUnhandledType(state, tableNode, tableNode.inferredType)
		end

		if tableNode.trailingExpression then
			if not first then  file:write(", ")  end
			writeExpression(state, writer, indent, nextLocalN, localsStack, tableNode.trailingExpression)
		end

		file:write("}")

	elseif expr.nodeType == !(AST_FOREIGN) then
		local foreign = expr
		writeConstantValueOrReference(state, writer, foreign.valueConstant, foreign)

	elseif expr.nodeType == !(AST_TYPE_INFO) then
		local typeInfoNode = expr
		writeConstantValueOrReference(state, writer, typeInfoNode.valueConstant, typeInfoNode)

	elseif expr.nodeType == !(AST_LOCATION) then
		local loc = expr
		writeConstantValueOrReference(state, writer, loc.valueConstant, loc)

	elseif expr.nodeType == !(AST_CONDITIONAL) then
		local conditional = expr
		local hasVararg   = false

		astVisitAllNodes(conditional, function(node)
			if node.nodeType == !(AST_VARARG) then
				hasVararg = true
				return !(VISIT_BREAK)
			elseif isScope(node) then
				return !(VISIT_IGNORE_CHILDREN)
			end
		end)

		-- Ternary.
		if not conditional.conditionAndBranchTrue then
			if doesTypeContainBoolOrNone(adjustTypeToOne(state, conditional.branchTrue, conditional.branchTrue.inferredType, true)) then
				-- (function(x) if x then return a else return b end end)(x)
				file:write("(function(_CONDITION")
				if hasVararg then  file:write(", ...")  end
				file:write(") if _CONDITION then return ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchTrue)
				file:write(" else return ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchFalse)
				file:write(" end end)(")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.condition)
				if hasVararg then  file:write(", ...")  end
				file:write(")")
			else
				-- x and a or b
				file:write("(")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.condition)
				file:write(" and ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchTrue)
				file:write(" or ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchFalse)
				file:write(")")
			end

		-- Binary (with implicit cast).
		-- @Optimize: Output 'a or b' whenever possible.
		elseif conditional.conditionAndBranchTrue ~= conditional.condition then
			-- (function(x) if x then return x else return y end end)(x)
			local cast = conditional.condition
			assert(cast.nodeType   == !(AST_CAST))
			assert(cast.expression == conditional.conditionAndBranchTrue)
			assert(cast.isImplicit)

			file:write("(function(_CONDITION")
			if hasVararg then  file:write(", ...")  end
			file:write(") if ")
			writeCast(state, writer, indent, nextLocalN, localsStack, cast, "_CONDITION")
			file:write(" then return _CONDITION else return ")
			writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchFalse)
			file:write(" end end)(")
			writeExpression(state, writer, indent, nextLocalN, localsStack, cast.expression)
			if hasVararg then  file:write(", ...")  end
			file:write(")")

		-- Binary (without implicit cast).
		-- @Optimize: Output 'a or b' whenever possible.
		else
			-- (function(x) if x then return x else return y end end)(x)
			file:write("(function(_CONDITION")
			if hasVararg then  file:write(", ...")  end
			file:write(") if _CONDITION then return _CONDITION else return ")
			writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.branchFalse)
			file:write(" end end)(")
			writeExpression(state, writer, indent, nextLocalN, localsStack, conditional.condition)
			if hasVararg then  file:write(", ...")  end
			file:write(")")
		end

	elseif expr.nodeType == !(AST_NULL) then
		file:write("nil")

	elseif expr.inferredType.tag == !(TYPE_NAMESPACE) then
		nodeError(state, expr, "ProgramWriter", "Invalid place for a namespace.")
	else
		errorUnhandledNodeType(state, expr)
	end
end

function _G.writeDefaultValueForType(state, writer, indent, nextLocalN, localsStack, typeInfo, nodeForError)
	local file = writer.file
	local tag  = typeInfo.tag

	if tag == !(TYPE_ANY) then
		file:write("nil")
	elseif tag == !(TYPE_BOOL) then
		file:write("false")
	elseif tag == !(TYPE_INT) then
		file:write("0")
	elseif tag == !(TYPE_NONE) then
		file:write("nil")
	elseif tag == !(TYPE_FLOAT) then
		file:write("0.0")
	elseif tag == !(TYPE_STRING) then
		file:write('""')
	elseif tag == !(TYPE_ARRAY) or tag == !(TYPE_TABLE) then
		file:write("{}")

	elseif tag == !(TYPE_STRUCT) then
		local structInfo = typeInfo
		!ASSERT `not structInfo.isPolymorphic`

		if structInfo.astNode.isForeign then
			-- @Speed: Detect this sooner (probably when inferring AstDeclaration).
			!TRACE()
			printerr()
			nodeMessage(io.stderr, state, nodeForError, "Error", "Typer", "Cannot instantiate foreign struct '%s'.", getFriendlyTypeInfoName(structInfo))
			-- if structInfo.astNode.foreignThroughNode then
			-- 	nodeMessage(io.stderr, state, structInfo.astNode.foreignThroughNode, "Info", "Typer", "...the struct got its foreign state through this.")
			-- end
			exitFailure()
		end

		local first = true
		file:write("{")

		for i, member in ipairs(structInfo.members) do
			if not first then  file:write(", ")  end
			first = false

			-- if not (default_value_for_struct_member is AstNull) then -- @Incomplete
				writeTableConstructorKeyName(writer, member.name)
				file:write("=")
				writeDefaultValueForStructMember(state, writer, indent, nextLocalN, localsStack, structInfo, member, nodeForError)
			-- end
		end

		file:write("}")

	elseif doesTypeHaveAnyDefaultValue(typeInfo) then
		errorInternal("Incomplete: Write default value for type group '%s'.", TYPE_NAMES[typeInfo.tag])
	else
		nodeError(state, nodeForError, "ProgramWriter", "There is no default value for %s.", getFriendlyTypeInfoName(typeInfo))
	end
end

local function isNameAllocated(state, writer, localsStack, localName)
	if state.topScopeNames[localName] then  return true  end

	for _, locals in ipairs(localsStack) do
		if locals[localName] then  return true  end
	end

	if localName:find"^_AWBO_" then  return true  end -- Assignment with binary operation.

	return false
end

local function allocateName(state, writer, localsStack, name, n, shortPrefix, longInfix)
	local localName

	if name == "_" then
		localName = "_"
	elseif outputDebugInfo then
		localName = unicodeToLuaIdentifier(name)
		if isNameAllocated(state, writer, localsStack, localName) then
			localName = localName..longInfix..n
		end
	else
		localName = shortPrefix..n
	end

	localsStack[1][localName] = true

	return localName, n+1
end
local function allocateLocalName(state, writer, localsStack, name, n)
	return allocateName(state, writer, localsStack, name, n, "L", "_L")
end
local function allocateArgumentName(state, writer, localsStack, name, n)
	return allocateName(state, writer, localsStack, name, n, "A", "_A")
end

local function writeDefers(state, writer, indent, nextLocalN, localsStack, indentStr, defers)
	if not defers[1] then  return  end

	!ifDEBUG `writer.file:write(indentStr, "-- defers") ; writeEol(state, writer)`

	for i = #defers, 1, -1 do
		local block = defers[i].body
		if
			itemWith1(block.declarations, `kind`, !(DECL_KIND_LOCAL_VAR))
			-- or itemWith1(block.declarations, `kind`, !(DECL_KIND_READ_ONLY))
		then
			writer.file:write(indentStr, "do")
			writeEol(state, writer)
			writeBlock(state, writer, indent+1, nextLocalN, localsStack, block, false, nil)
			writer.file:write(indentStr, "end")
			writeEol(state, writer)
		else
			writeBlock(state, writer, indent, nextLocalN, localsStack, block, false, nil)
		end
	end

	!ifDEBUG `writer.file:write(indentStr, "-- /defers") ; writeEol(state, writer)`
end

local function handleContinueAfterBlock(state, writer, parentContinueDepth, prevContinueDepth, siblings, siblingIndex, indent, indentStr)
	-- if writer.continueDepth <= parentContinueDepth then  return indent, indentStr  end
	if writer.continueDepth == 0 then  return indent, indentStr  end

	if writer.continueDepth == prevContinueDepth then
		writer.continueDepth = writer.continueDepth+1
	end

	if not siblings[siblingIndex+1] then
		writer.skipOneJumpCheck = true -- @Cleanup: Kind of ugly flag...
		return indent, indentStr
	end

	if not (writer.continueDepth == 1 and !!(CONST_SET{ AST_FOR, AST_WHILE })[siblings[1].parent.parent.nodeType] and siblings[1].parent.parent.hasContinues) then
		for i = siblingIndex, 1, -1 do
			if i < siblingIndex and !!(CONST_SET{ AST_FOR, AST_WHILE, AST_BLOCK, AST_IF, AST_SWITCH })[siblings[i].nodeType] then
				-- This should be the last time handleContinueAfterBlock() was called in this scope.
				break
			end

			local hasContinue = false

			astVisitAllNodesInUnit(siblings[i], false, function(node)
				-- @Polish: Only look for continues crossing our block.
				if node.nodeType == !(AST_CONTINUE) then
					hasContinue = true
					return !(VISIT_BREAK)
				end
			end)

			if not hasContinue then
				writer.file:write(indentStr, "do") ; writeEol(state, writer) -- @Cleanup: Don't write this unnecessary 'do'.

				indent    = indent+1
				indentStr = indentStr.."\t"

				return indent, indentStr
			end
		end
	end

	-- @Cleanup @Speed: Make 'if _JUMP>0 then...end if _JUMP==0' into 'if _JUMP>0 then...else'.
	writer.file:write(indentStr, "if _JUMP == 0 then") ; writeEol(state, writer)

	indent    = indent+1
	indentStr = indentStr.."\t"

	return indent, indentStr
end

local function writeLoopBodyAndFooter(state, writer, loop, indent, nextLocalN, localsStack, deferStartIndex, siblings, siblingIndex, parentContinueDepth)
	local file      = writer.file
	local loopStack = writer.loopStack
	local indentStr = ("\t"):rep(indent)

	writer.loopDepth                          = writer.loopDepth+1
	writer.loopDeferIndices[writer.loopDepth] = #writer.deferStack+1

	if not (loop.hasNamedJumps or loopStack[1]) then
		writeBlock(state, writer, indent+1, nextLocalN, localsStack, loop.body, false, siblings, siblingIndex)
		file:write(indentStr, "end") ; writeEol(state, writer)

		writer.loopDeferIndices[writer.loopDepth] = nil
		writer.loopDepth                          = writer.loopDepth-1
		return indent, indentStr
	end

	if loopStack[1] then
		file:write(indentStr, "\t_JUMP = 0") ; writeEol(state, writer)
	else
		file:write(indentStr, "\tlocal _JUMP, _BREAK = 0, false") ; writeEol(state, writer)
	end

	table.insert(loopStack, loop)

	local prevContinueDepth = writer.continueDepth
	writeBlock(state, writer, indent+1, nextLocalN, localsStack, loop.body, false, siblings, siblingIndex)

	file:write(indentStr, "end") ; writeEol(state, writer)

	table.remove(loopStack)

	if loopStack[1] then
		local deferStartIndexJump = writer.loopDeferIndices[writer.loopDepth-1] or deferStartIndex
		local defers              = writer.deferStack[deferStartIndexJump] and {unpack(writer.deferStack, deferStartIndexJump)} or EMPTY_TABLE

		file:write(indentStr, "if _JUMP > 0 then") ; writeEol(state, writer)
			writeDefers(state, writer, indent+1, nextLocalN, localsStack, indentStr.."\t", defers)

			if loopStack[2] then
				file:write(indentStr, "\tif _BREAK or _JUMP > 1 then  _JUMP = _JUMP-1 ; break  end") ; writeEol(state, writer)
			else
				file:write(indentStr, "\tif _BREAK or _JUMP > 1 then  break  end") ; writeEol(state, writer)
			end
		file:write(indentStr, "end") ; writeEol(state, writer)
	end

	writer.loopDeferIndices[writer.loopDepth] = nil
	writer.loopDepth                          = writer.loopDepth-1

	indent, indentStr = handleContinueAfterBlock(state, writer, parentContinueDepth, prevContinueDepth, siblings, siblingIndex, indent, indentStr)
	return indent, indentStr
end

local function doesContinueCrossNode(state, node)
	-- @Polish: Check more exactly for an actual crossing.
	while true do
		node = astFindParent(node, !!(CONST_SET{ AST_FOR, AST_WHILE, AST_LAMBDA }))
		if not node or node.nodeType == !(AST_LAMBDA) then  return false  end

		if node.hasContinues then  return true  end
	end
end

function _G.writeBlock(state, writer, indent, nextLocalN, localsStack, block, isElseif, nextStatementInParent)
	!ASSERT `not block[1]`

	local file      = writer.file
	local indentStr = ("\t"):rep(indent)

	if not block.statementsDynamic[1] then
		if outputDebugInfo then
			file:write(indentStr, "-- Empty block.")
			writeEol(state, writer)
		end
		return
	end

	local deferStartIndex     = #writer.deferStack+1
	local parentContinueDepth = writer.continueDepth
	local gotContinue         = false

	localsStack  = {{}, unpack(localsStack)} -- @Speed: We can probably handle locals like defers.
	local inDecl = false

	for statementIndex, statement in ipairs(block.statementsDynamic) do
		local nodeType = statement.nodeType

		----------------------------------------------------------------
		if nodeType == !(AST_DECLARATION) then
			-- @Optimize: Output 'local a = nil' as 'local a'.
			local decl = statement
			assert(decl.kind == !(DECL_KIND_LOCAL_VAR) --[[or decl.kind == !(DECL_KIND_READ_ONLY)]])

			decl.localName, nextLocalN = allocateLocalName(state, writer, localsStack, decl.name.name, nextLocalN)

			if decl.assignment then
				-- The (initial) assignment should be written as the next statement (or after several consecutive declarations).
				inDecl = true

			else
				file:write(indentStr, "local ", decl.localName, " = ")
				if decl.value then
					writeExpression(state, writer, indent, nextLocalN, localsStack, decl.value)
				else
					writeDefaultValueForType(state, writer, indent, nextLocalN, localsStack, decl.name.inferredType, decl.name)
				end
				file:write(";")
				writeEol(state, writer)
			end

		----------------------------------------------------------------
		elseif nodeType == !(AST_ASSIGNMENT) then
			local assignment = statement

			-- Plain assignment.
			if assignment.binaryOperation == "" then
				-- @Optimize: Output '_ = func()' as 'func()'.
				-- @Optimize: Output 'x, _ = func()' as 'x = func()'.
				local hasBlank = false

				if inDecl then
					local hasGaps = false

					for i = 1, #assignment.targets do
						if not assignment.declarations[i] then
							hasGaps = true
							break
						end
					end

					if hasGaps then
						file:write(indentStr)
						file:write("local ")

						local first = true
						for i, ident in ipairs(assignment.targets) do
							if ident.nodeType ~= !(AST_BLANK) and assignment.declarations[i] then
								!ASSERT("ident.nodeType == "..AST_IDENTIFIER)

								if not first then  file:write(",")  end
								first = false

								writeIdentifierName(state, writer, ident)
							end
						end

						file:write("; ")

					else
						file:write(indentStr)
						file:write("local ")
					end

				else
					file:write(indentStr)
				end

				for i, targetExpr in ipairs(assignment.targets) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, writer, indent, nextLocalN, localsStack, targetExpr)
					hasBlank = (hasBlank or targetExpr.nodeType == !(AST_BLANK))
				end

				file:write(" = ")

				for i, valueExpr in ipairs(assignment.values) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, writer, indent, nextLocalN, localsStack, valueExpr)
				end

				file:write(";") -- This removes ambiguity is some cases.
				if hasBlank and not isNameAllocated(state, writer, localsStack, "_") then
					file:write(" _=nil;") -- We don't want to accidentally store an object that is subject to garbage collection as a global.
				end
				writeEol(state, writer)

			-- Assignment with binary operation (AWBO).
			else
				!ASSERT `not inDecl`

				--
				-- To make expressions evaluate the expected way (left to
				-- right with no hidden duplicate evaluations) we prefetch
				-- some values before we start doing operations (and
				-- eventually the assignment).
				--
				-- Constants and right-hand-side values are never prefetched.
				-- These rules apply otherwise:
				--
				--   x        += 1    -- Don't fetch x.
				--   t.k      += 1    -- Don't fetch t. Don't fetch k.
				--   o.t[k]   += 1    -- Fetch o.t.     Don't fetch k.
				--   o.t[t.k] += 1    -- Fetch o.t.     Fetch t.k.
				--
				-- More info:
				--   x, y += 1, z  -- No fetching or preparations needed as all targets are simple variables/identifiers.
				--
				local fetchObj = {}
				local fetchKey = {}
				local fetchVal = {}

				-- Figure out what to fetch.
				for i, targetExpr in ipairs(assignment.targets) do
					if targetExpr.nodeType == !(AST_ACCESS) then
						local access = targetExpr

						if not (access.object.nodeType == !(AST_IDENTIFIER) or isExpressionConstant(state, access.object, true)) then
							fetchObj[i] = true
						end

						if not (access.member.nodeType == !(AST_IDENTIFIER) or isExpressionConstant(state, access.member, true)) then
							fetchKey[i] = true
						end
					end
				end

				if not assignment.values[#assignment.targets] then
					-- The last value ought to be a call! (Note: It shouldn't be vararg as that would've been a type error.)
					for i = #assignment.values, #assignment.targets do
						fetchVal[i] = true
					end
				end

				local fetchingAnything = (next(fetchObj) or next(fetchKey) or next(fetchVal)) ~= nil

				if fetchingAnything then
					file:write(indentStr, "do")
					writeEol(state, writer)

					indent    = indent+1
					indentStr = indentStr.."\t"

					-- Fetch objects and keys.
					if next(fetchObj) or next(fetchKey) then
						file:write(indentStr, "local ")

						local first = true
						for i, targetExpr in ipairs(assignment.targets) do
							if fetchObj[i] then
								if not first then  file:write(", ")  end
								first = false

								file:write("_AWBO_OBJ", i)
							end

							if fetchKey[i] then
								if not first then  file:write(", ")  end
								first = false

								file:write("_AWBO_KEY", i)
							end
						end

						file:write(" = ")

						local first = true
						for i, targetExpr in ipairs(assignment.targets) do
							if fetchObj[i] then
								local access = targetExpr

								if not first then  file:write(", ")  end
								first = false

								writeExpression(state, writer, indent, nextLocalN, localsStack, access.object)
							end

							if fetchKey[i] then
								local access = targetExpr

								if not first then  file:write(", ")  end
								first = false

								writeExpression(state, writer, indent, nextLocalN, localsStack, access.member)
							end
						end

						writeEol(state, writer)
					end

					-- Fetch values.
					if next(fetchVal) then
						file:write(indentStr, "local ")

						local first = true
						for i, targetExpr in ipairs(assignment.targets) do
							if fetchVal[i] then
								if not first then  file:write(", ")  end
								first = false

								file:write("_AWBO_VAL", i)
							end
						end

						file:write(" = ")

						local first = true
						for i, valueExpr in ipairs(assignment.values) do
							if fetchVal[i] then
								if not first then  file:write(", ")  end
								first = false

								writeExpression(state, writer, indent, nextLocalN, localsStack, valueExpr)
							end
						end

						writeEol(state, writer)
					end
				end--if fetchingAnything

				-- Assignment targets.
				file:write(indentStr)

				local first = true
				for i, targetExpr in ipairs(assignment.targets) do
					if not first then  file:write(", ")  end
					first = false

					if fetchObj[i] or fetchKey[i] then
						local access = targetExpr
						if fetchObj[i] then  file:write( "_AWBO_OBJ", i     )  else  writeExpression      (state, writer, indent, nextLocalN, localsStack, access.object)  end
						if fetchKey[i] then  file:write("[_AWBO_KEY", i, "]")  else  writeAccessMemberPart(state, writer, indent, nextLocalN, localsStack, access.member)  end
					else
						writeExpression(state, writer, indent, nextLocalN, localsStack, targetExpr)
					end
				end

				-- Assignment values.
				file:write(" = ")

				local first = true
				for i, targetExpr in ipairs(assignment.targets) do
					if not first then  file:write(", ")  end
					first = false

					if fetchObj[i] or fetchKey[i] then
						local access              = targetExpr
						local accessDummy         = astNewNode(AstAccess, access.token, access.parent)
						accessDummy.XXX_AWBO_HACK = true
						accessDummy.object        = fetchObj[i] and "_AWBO_OBJ"..i or access.object -- @Hack!!!
						accessDummy.member        = fetchKey[i] and "_AWBO_KEY"..i or access.member -- @Hack!!!
						accessDummy.inferredType  = access.inferredType
						targetExpr                = accessDummy
					end

					local _, valueType = getAssignmentValue(state, targetExpr, assignment.values, i, nil, nil, nil)
					!ASSERT(`valueType`, `tostring(i)`, `assignment.values[i] or assignment`)

					writeBinaryOperation(
						state, writer, indent, nextLocalN, localsStack,
						targetExpr, (fetchVal[i] and "_AWBO_VAL"..i or assignment.values[i]),
						assignment.binaryOperation,
						targetExpr.inferredType, valueType, targetExpr.inferredType,
						targetExpr.token, nil
					)
				end

				writeEol(state, writer)

				if fetchingAnything then
					indent    = indent-1
					indentStr = indentStr:sub(2)

					file:write(indentStr, "end")
					writeEol(state, writer)
				end
			end

			inDecl = false

		----------------------------------------------------------------
		elseif nodeType == !(AST_RETURN) then
			local returnNode = statement

			-- @Incomplete: Evaluate return values before running defers (right?).
			writeDefers(state, writer, indent, nextLocalN, localsStack, indentStr, writer.deferStack)

			if block.parent.nodeType == !(AST_LAMBDA) and not returnNode.values[1] then
				if outputDebugInfo then
					file:write(indentStr, "-- return")
					writeEol(state, writer)
				end

			else
				file:write(indentStr, "return")
				for i, expr in ipairs(returnNode.values) do
					if i > 1 then  file:write(",")  end
					file:write(" ")
					writeExpression(state, writer, indent, nextLocalN, localsStack, expr)
				end
				writeEol(state, writer)
			end

		----------------------------------------------------------------
		elseif nodeType == !(AST_BLOCK) then
			local innerBlock = statement

			file:write(indentStr, "do")
			writeEol(state, writer)

			local prevContinueDepth = writer.continueDepth
			writeBlock(state, writer, indent+1, nextLocalN, localsStack, innerBlock, false, block.statementsDynamic, statementIndex)

			file:write(indentStr, "end") ; writeEol(state, writer)
			indent, indentStr = handleContinueAfterBlock(state, writer, parentContinueDepth, prevContinueDepth, block.statementsDynamic, statementIndex, indent, indentStr)

		----------------------------------------------------------------
		elseif nodeType == !(AST_IF) then
			-- @Optimize: Don't output empty branches.
			local ifBranch = statement

			if not isElseif then  file:write(indentStr)  end

			file:write("if ")
			writeExpression(state, writer, indent, nextLocalN, localsStack, ifBranch.condition)
			file:write(" then")
			writeEol(state, writer)

			local prevContinueDepth = writer.continueDepth
			writeBlock(state, writer, indent+1, nextLocalN, localsStack, ifBranch.branchTrue, false, block.statementsDynamic, statementIndex)

			local maxContinue1   = writer.continueDepth
			writer.continueDepth = prevContinueDepth

			if not (ifBranch.branchFalse and ifBranch.branchFalse.statementsDynamic[1]) then
				-- void

			elseif not ifBranch.branchFalse.statementsDynamic[2] and ifBranch.branchFalse.statementsDynamic[1].nodeType == !(AST_IF) and not doesContinueCrossNode(state, ifBranch) then
				file:write(indentStr, "else") -- This will be followed by "if"
				writeBlock(state, writer, indent, nextLocalN, localsStack, ifBranch.branchFalse, true, block.statementsDynamic, statementIndex)

			else
				file:write(indentStr, "else")
				writeEol(state, writer)
				writeBlock(state, writer, indent+1, nextLocalN, localsStack, ifBranch.branchFalse, false, block.statementsDynamic, statementIndex)
			end

			writer.continueDepth = math.max(maxContinue1, writer.continueDepth)

			if not isElseif then
				file:write(indentStr, "end") ; writeEol(state, writer)
				indent, indentStr = handleContinueAfterBlock(state, writer, parentContinueDepth, prevContinueDepth, block.statementsDynamic, statementIndex, indent, indentStr)
			end

		----------------------------------------------------------------
		elseif nodeType == !(AST_WHILE) then
			-- @Optimize: Don't output an empty body.
			local whileLoop = statement

			file:write(indentStr, "while ")
			writeExpression(state, writer, indent, nextLocalN, localsStack, whileLoop.condition)
			file:write(" do")
			writeEol(state, writer)

			indent, indentStr = writeLoopBodyAndFooter(state, writer, whileLoop, indent, nextLocalN, localsStack, deferStartIndex, block.statementsDynamic, statementIndex, parentContinueDepth)

		----------------------------------------------------------------
		elseif nodeType == !(AST_FOR) then
			-- @Optimize: Don't output an empty body.
			local forLoop     = statement
			local localsStack = {{}, unpack(localsStack)}

			for _, decl in ipairs(forLoop.declarations) do
				decl.localName, nextLocalN = allocateLocalName(state, writer, localsStack, decl.name.name, nextLocalN)
			end

			if forLoop.forType == !(FOR_NUMERIC) then
				local decl   = forLoop.declarations[1]
				local values = forLoop.expressions

				file:write(indentStr, "for ")
				writeIdentifierName(state, writer, decl.name)
				file:write(" = ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, values[1])
				file:write(", ")
				writeExpression(state, writer, indent, nextLocalN, localsStack, values[2])
				if values[3] then
					file:write(", ")
					writeExpression(state, writer, indent, nextLocalN, localsStack, values[3])
				end
				file:write(" do")
				writeEol(state, writer)

				indent, indentStr = writeLoopBodyAndFooter(state, writer, forLoop, indent, nextLocalN, localsStack, deferStartIndex, block.statementsDynamic, statementIndex, parentContinueDepth)

			elseif forLoop.forType == !(FOR_SHORT) then
				local objExpr = forLoop.expressions[1]
				local objType = objExpr.inferredType

				file:write(indentStr, "for ")

				if objType.tag == !(TYPE_VARARG) then
					!ASSERT("objExpr.nodeType == "..AST_VARARG)

					addLineMapping(state, writer, objExpr.token)
					writeIdentifierName(state, writer, forLoop.declarations[1].name)
					file:write(" = ")

					if forLoop.reverse then
						file:write('_SELECT("#", ...), 1, -1')
					else
						file:write('1, _SELECT("#", ...)')
					end

					file:write(" do")
					writeEol(state, writer)

					file:write(indentStr, "\tlocal ")
					writeIdentifierName(state, writer, forLoop.declarations[2].name)
					file:write(" = _SELECT(")
					writeIdentifierName(state, writer, forLoop.declarations[1].name)
					file:write(", ...);")
					writeEol(state, writer)

				else
					objType = adjustTypeToOne(state, objExpr, objType, true)

					for i, decl in ipairs(forLoop.declarations) do
						if i > 1 then  file:write(", ")  end
						writeIdentifierName(state, writer, decl.name)
					end

					file:write(" in ")

					if objType.tag == !(TYPE_ARRAY) or (objType.tag == !(TYPE_STRUCT) and objType.kind == !(STRUCT_KIND_ARRAY)) then
						addLineMapping(state, writer, objExpr.token)
						if forLoop.reverse then
							file:write("_IPAIRSR")
						else
							file:write("_IPAIRS")
						end

					elseif objType.tag == !(TYPE_TABLE) then
						assert(not forLoop.reverse)
						addLineMapping(state, writer, objExpr.token)
						file:write("_PAIRS")

					elseif objType.tag == !(TYPE_STRUCT) then
						assert(not forLoop.reverse)
						errorUnhandledNodeType(state, objExpr)
						-- @Incomplete: Output default iterator for the struct. Also handle array-like structs and structured tables.
						-- writeConstantValueOrReference(state, writer, interatorFuncConst?, objExpr)

					else
						errorInternal(state, objExpr)
					end

					file:write("(")
					writeExpression(state, writer, indent, nextLocalN, localsStack, objExpr)
					file:write(") do")
					writeEol(state, writer)
				end

				indent, indentStr = writeLoopBodyAndFooter(state, writer, forLoop, indent, nextLocalN, localsStack, deferStartIndex, block.statementsDynamic, statementIndex, parentContinueDepth)

			else--if forLoop.forType == !(FOR_ITERATOR) then
				file:write(indentStr, "for ")

				for i, decl in ipairs(forLoop.declarations) do
					if i > 1 then  file:write(", ")  end
					writeIdentifierName(state, writer, decl.name)
				end
				file:write(" in ")
				for i, valueExpr in ipairs(forLoop.expressions) do
					if i > 1 then  file:write(", ")  end
					writeExpression(state, writer, indent, nextLocalN, localsStack, valueExpr)
				end
				file:write(" do")
				writeEol(state, writer)

				indent, indentStr = writeLoopBodyAndFooter(state, writer, forLoop, indent, nextLocalN, localsStack, deferStartIndex, block.statementsDynamic, statementIndex, parentContinueDepth)
			end

		----------------------------------------------------------------
		elseif nodeType == !(AST_BREAK) then
			local breakNode = statement

			local deferStartIndexJump = writer.loopDeferIndices[writer.loopDepth] or errorInternal()
			local defers              = writer.deferStack[deferStartIndexJump] and {unpack(writer.deferStack, deferStartIndexJump)} or EMPTY_TABLE
			writeDefers(state, writer, indent, nextLocalN, localsStack, indentStr, defers)

			if breakNode.loop then
				local i                = indexOf(writer.loopStack, breakNode.loop) or errorInternal(state, breakNode)
				local outerLoopsToJump = #writer.loopStack-i
				file:write(indentStr, "_JUMP, _BREAK = ",outerLoopsToJump,", true ; break")
			else
				file:write(indentStr, "break")
			end
			writeEol(state, writer)

		----------------------------------------------------------------
		elseif nodeType == !(AST_CONTINUE) then
			local continue = statement

			local deferStartIndexJump = writer.loopDeferIndices[writer.loopDepth] or errorInternal()
			local defers              = writer.deferStack[deferStartIndexJump] and {unpack(writer.deferStack, deferStartIndexJump)} or EMPTY_TABLE
			writeDefers(state, writer, indent, nextLocalN, localsStack, indentStr, defers)

			local i                = indexOf(writer.loopStack, continue.loop) or errorInternal(state, continue)
			local outerLoopsToJump = #writer.loopStack-i

			if outerLoopsToJump > 0 then
				file:write(indentStr, "_JUMP = ",outerLoopsToJump," ; break") -- Leave _BREAK false.
			else
				file:write(indentStr, "_JUMP = ",outerLoopsToJump+1) -- Leave _BREAK false.
			end
			writeEol(state, writer)

			gotContinue = true

		----------------------------------------------------------------
		elseif nodeType == !(AST_DEFER) then
			local defer = statement
			table.insert(writer.deferStack, defer)

		----------------------------------------------------------------
		elseif nodeType == !(AST_SWITCH) then
			local switch = statement

			file:write(indentStr, "local _SWITCH = ")
			writeExpression(state, writer, indent, nextLocalN, localsStack, switch.value)
			writeEol(state, writer)

			if switch.cases[1] then
				local fallingThrough    = false
				local prevContinueDepth = writer.continueDepth
				local maxContinueDepth  = prevContinueDepth

				for i, case in ipairs(switch.cases) do
					if fallingThrough then
						if case.fallThrough or case.value then
							file:write(" or")
						end
					elseif not case.value then
						-- void
					elseif i == 1 then
						file:write(indentStr, "if")
					else
						file:write(indentStr, "elseif")
					end

					if case.value then
						file:write(" _SWITCH == ")
						writeExpression(state, writer, indent, nextLocalN, localsStack, case.value)
					end

					if not case.fallThrough then
						if case.value or fallingThrough then
							file:write(" then")
						elseif i == 1 then
							file:write(indentStr, "do")
						else
							file:write(indentStr, "else")
						end
						writeEol(state, writer)
						writeBlock(state, writer, indent+1, nextLocalN, localsStack, case.body, false, block.statementsDynamic, statementIndex)

						maxContinueDepth     = math.max(maxContinueDepth, writer.continueDepth)
						writer.continueDepth = prevContinueDepth
					end

					fallingThrough = case.fallThrough
				end

				writer.continueDepth = maxContinueDepth

				file:write(indentStr, "end") ; writeEol(state, writer)
				indent, indentStr = handleContinueAfterBlock(state, writer, parentContinueDepth, prevContinueDepth, block.statementsDynamic, statementIndex, indent, indentStr)
			end

		----------------------------------------------------------------
		else
			-- Assume the statement is an expression at this point and let writeExpression() deal with any errors.
			file:write(indentStr)
			writeExpression(state, writer, indent, nextLocalN, localsStack, statement)
			file:write(";") -- This removes ambiguity is some cases.
			writeEol(state, writer)
		end
		----------------------------------------------------------------
	end

	local doWriteDefers = (
		writer.deferStack[deferStartIndex]
		and not (
			block.statementsDynamic[1] -- Defers will already have been written before these:
			and !!(CONST_SET{ AST_RETURN, AST_BREAK, AST_CONTINUE })[getLast(block.statementsDynamic).nodeType]
		)
	)

	local defers = doWriteDefers and {unpack(writer.deferStack, deferStartIndex)} or EMPTY_TABLE

	for i = deferStartIndex, #writer.deferStack do
		writer.deferStack[i] = nil
	end
	writeDefers(state, writer, indent, nextLocalN, localsStack, indentStr, defers)

	if writer.continueDepth > parentContinueDepth then
		--[[
			-- Implicit 'if not continue' blocks example:
			for {
				do continue -- DEPTH=1
				>>>>
					if {
						do continue -- DEPTH=2
						>>>>
							do continue -- DEPTH=3
							>>>>
							<<<<
						<<<<
					}
					-- DEPTH=1 (reset)
					>>>>
						do continue -- DEPTH=2
						>>>>
						<<<<
					<<<<
				<<<<
			}
		]]
		for i = writer.continueDepth, parentContinueDepth+1+(writer.skipOneJumpCheck and 1 or 0), -1 do
			indentStr = indentStr:sub(2)
			file:write(indentStr, "end")
			!ifDEBUG `file:write("--continue")`
			writeEol(state, writer)
		end
		writer.continueDepth    = parentContinueDepth
		writer.skipOneJumpCheck = false
	end

	if gotContinue then
		writer.continueDepth = writer.continueDepth+1 -- This signals to the parent block that we got a continue.
	end
end

-- writeForeignReference( state, writer, foreignSourceId, nodeForError=nil )
function _G.writeForeignReference(state, writer, foreignSourceId, nodeForError)
	if writer.foreignOnlyAvailableDuringCompilation[foreignSourceId] and writer.outputRuntime and not keepDeadCode then
		if nodeForError then
			nodeError(state, nodeForError, "ProgramWriter", "Trying to write runtime reference to compile-time-only symbol.")
		else
			errorLine("ProgramWriter", "Trying to write runtime reference to compile-time-only symbol.")
		end
	end

	local foreignRef = writer.foreignReferences[foreignSourceId]
	writer.file:write(foreignRef)

	if outputDebugInfo and foreignRef:find"\n" then
		local _, nlCount         = foreignRef:gsub("\n", "%0")
		writer.currentOutputLine = writer.currentOutputLine + nlCount -- @Incomplete: Call addLineMapping() for every line here.
	end
end

function _G.writeFunction(state, writer, indent, nextLocalN, localsStack, lambda)
	!ASSERT `not lambda.body[1]` -- Statements should be in lambda.body.statements*!
	!ASSERT `not lambda.isPolymorphic`

	local file = writer.file

	addLineMapping(state, writer, lambda.token)

	if lambda.bodyIsForeign then
		writeForeignReference(state, writer, lambda.foreignSourceId, lambda.foreignSourceName)
		return
	end

	local indentStr = ("\t"):rep(indent)
	table.insert(localsStack, {})

	file:write("function(")

	if lambda.argumentsIn then
		for i, arg in ipairs(lambda.argumentsIn.arguments) do
			if i > 1 then  file:write(", ")  end

			local decl = arg.declaration

			if decl.name.nodeType == !(AST_VARARG) then
				decl.localName = "..."
			else
				decl.localName = allocateArgumentName(state, writer, localsStack, decl.name.name, i)
			end

			file:write(decl.localName)
		end
	end

	file:write(")")
	writeEol(state, writer)

	if lambda.body.statementsDynamic[1] then
		writeBlock(state, writer, indent+1, nextLocalN, localsStack, lambda.body, false, nil)
	elseif outputDebugInfo then
		file:write(indentStr, "\t-- Empty function.")
		writeEol(state, writer)
	end

	file:write(indentStr, "end")
	table.remove(localsStack)
end

function _G.writeForeignImportIfNew(state, writer, typeInfo, foreignSource, foreignSourceName, foreignSourceId, token, asGlobal)
	assert(foreignSourceId ~= "")

	if writer.foreignReferences[foreignSourceId] then  return  end
	if foreignSource == "method"                 then  return  end -- Methods are "imported" when they are called.

	-- @Incomplete: Compiler setting for runtime checks of anything originating from foreign sources.
	-- (We can probably wrap the importing code in something here using typeInfo.)

	local file = writer.file

	local foreignN  = writer.foreignN+1
	writer.foreignN = foreignN

	if foreignN == 1 then
		file:write("\t")
		if not asGlobal then  file:write("local ")  end
		file:write("_FOREIGN = {}")
		writeEol(state, writer)
	end

	addLineMapping(state, writer, token) -- Must happen after _FOREIGN is declared.

	if foreignSource == "lua" then
		if outputDebugInfo then
			writer.foreignReferences[foreignSourceId] = F("_FOREIGN[%d%s]", foreignN, formatInfoComment(foreignSourceId))
			file:write("\t_FOREIGN[", F("%d", foreignN), "]")
		else
			local foreignRef                         = F("_FOREIGN[%d]", foreignN)
			writer.foreignReferences[foreignSourceId] = foreignRef
			file:write("\t", foreignRef)
		end

		file:write(" = (", foreignSourceName, ")") -- @Robustness: Is this too straightforward?
		writeEol(state, writer)

		if foreignSourceName:find"\n" then
			local _, nlCount         = foreignSourceName:gsub("\n", "%0")
			writer.currentOutputLine = writer.currentOutputLine + nlCount -- @Incomplete: Call addLineMapping() for every line here.
		end

	elseif foreignSource == "compiler" then
		local lua = nil

		if not writer.outputRuntime then
			lua = foreignApiCompilerSymbolsDuringCompilation[foreignSourceName]
		elseif compilerApi[foreignSourceName] then
			writer.foreignOnlyAvailableDuringCompilation[foreignSourceId] = true
		end
		if not lua then
			lua = foreignApiCompilerSymbols[foreignSourceName] or errorInternal("%s", foreignSourceName)
		end

		if outputDebugInfo then
			writer.foreignReferences[foreignSourceId] = F("_FOREIGN[%d--[[%s]]]", foreignN, foreignSourceId)
			file:write("\t_FOREIGN[", F("%d", foreignN), "]")
		else
			local foreignRef                          = F("_FOREIGN[%d]", foreignN)
			writer.foreignReferences[foreignSourceId] = foreignRef
			file:write("\t", foreignRef)
		end

		file:write(" = ", lua)
		writeEol(state, writer)

		if lua:find"\n" then
			local _, nlCount         = lua:gsub("\n", "%0")
			writer.currentOutputLine = writer.currentOutputLine + nlCount -- @Incomplete: Call addLineMapping() for every line here.
		end

	else
		errorInternal("Incomplete: Handle foreignSource=%s", foreignSource)
	end
end

local function writeNormalSimpleConstant(state, writer, tag, v, isEnum)
	local file = writer.file

	if tag == !(TYPE_BOOL) then
		file:write(v and "true" or "false")

	elseif tag == !(TYPE_INT) then
		if v == 0 then
			file:write("0") -- Avoid writing '-0'.
		else
			local nStr = tostring(v)
			if not nStr:find"^%-?%d+$" then
				errorLine("ProgramWriter", "Cannot write value as integer: %s", tostring(v))
			end
			if nStr:byte(1) == !(getByte"-") then
				file:write("(", nStr, ")") -- @Incomplete: Use shouldOperationHaveSurroundingParentheses().
			else
				file:write(nStr)
			end
		end

	elseif tag == !(TYPE_FLOAT) then
		-- @Incomplete: Use shouldOperationHaveSurroundingParentheses().
		if v == 0 then
			file:write("0.0") -- Avoid writing '-0.0'.
		elseif v == math.huge then
			file:write("_HUGE")
		elseif v == -math.huge then
			file:write("(-_HUGE)")
		elseif v ~= v then
			file:write("(0/0)")
		else
			local floatStr = tostring(v)
			if not floatStr:find"[.Ee]" then
				floatStr = floatStr:gsub("^%d+", "%0.0")
			end
			if floatStr:byte(1) == !(getByte"-") then
				file:write("(", floatStr, ")")
			else
				file:write(floatStr)
			end
		end

	elseif tag == !(TYPE_NONE) then
		file:write("nil")

	elseif tag == !(TYPE_STRING) then
		writeStringLiteral(writer, v)

	elseif tag == !(TYPE_TYPE) then
		local typeInfo = v
		file:write(F("%d", typeInfo.id))

		if outputDebugInfo and not isEnum then
			file:write(formatInfoComment(getFriendlyTypeInfoName(typeInfo)))
		end

	else
		errorInternal("Incomplete: Handle constant value of type '%s'.", (TYPE_NAMES[tag] or "?"))
	end
end

local TYPE_NAMES_UPPER = {}

local function writeTypeInfo(state, writer, typeInfo)
	local file = writer.file

	!(
	local function END_OF_TYPE_INFO(typeInfoStructName)
		-- @Robustness: Get the name in the comment from the correct TypeInfo* struct declaration.
		return templateToLua(
			trimTemplate`
				file:write("}")
				if outputDebugInfo then  file:write("--[[$typeInfoStructName]]")  end
			`,
			{typeInfoStructName=typeInfoStructName}
		)
	end
	)

	local tag = typeInfo.tag

	-- Note: This table must be synced with preload and messenger!
	file:write("{tag=", tag)
	if outputDebugInfo then
		TYPE_NAMES_UPPER[tag] = TYPE_NAMES_UPPER[tag] or TYPE_NAMES[tag]:upper()
		file:write("--[[TypeTag.", TYPE_NAMES_UPPER[tag], "]]")
	end
	file:write(",id=")
	writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false)

	if tag == !(TYPE_ARRAY) then
		local arraySig = typeInfo

		file:write(",itemType=")
		writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), arraySig.itemType, false)

		!!(END_OF_TYPE_INFO"TypeInfoArray")

	elseif tag == !(TYPE_VARARG) then
		local varargSig = typeInfo

		file:write(",itemType=")
		writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), varargSig.itemType, false)

		!!(END_OF_TYPE_INFO"TypeInfoVararg")

	elseif tag == !(TYPE_FUNCTION) then
		local funcSig = typeInfo

		file:write(",argumentsIn={")
		for i, typeInfo in ipairs(funcSig.argumentTypesIn) do
			if i > 1 then  file:write(",")  end
			file:write("{argumentType=")
			writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false)
			file:write("}")
		end
		file:write("}")

		file:write(",argumentsOut={")
		for i, typeInfo in ipairs(funcSig.argumentTypesOut) do
			if i > 1 then  file:write(",")  end
			file:write("{argumentType=")
			writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false)
			file:write("}")
		end
		file:write("}")

		!!(END_OF_TYPE_INFO"TypeInfoFunction")

	elseif tag == !(TYPE_STRUCT) then
		local structInfo = typeInfo
		local voidType   = getTypeInfoForBuiltinType(state, "void")

		file:write(",name=")
		writeStringLiteral(writer, structInfo.name)

		file:write(",kind=", structInfo.kind)

		file:write(",valueType=")
		writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), (structInfo.valueType or voidType), false)

		file:write(",keyType=")
		writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), (structInfo.keyType or voidType), false)

		file:write(",members={")
		for i, member in ipairs(structInfo.members) do
			if i > 1 then  file:write(",")  end
			file:write("{name=")
			writeStringLiteral(writer, member.name)
			file:write(",memberType=")
			writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), member.typeInfo, false)
			file:write("}")
		end
		file:write("}")

		!!(END_OF_TYPE_INFO"TypeInfoStruct")

	elseif tag == !(TYPE_ENUM) then
		local enumInfo = typeInfo

		file:write(",name=")
		writeStringLiteral(writer, enumInfo.name)

		file:write(",memberType=")
		writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), enumInfo.memberTypeInfo, false)

		file:write(",members={")
		for i, member in ipairs(enumInfo.members) do
			if i > 1 then  file:write(",")  end
			file:write("{name=")
			writeStringLiteral(writer, member.name)
			file:write("}")
		end
		file:write("}")

		!!(END_OF_TYPE_INFO"TypeInfoEnum")

	elseif tag == !(TYPE_COMPOUND) then
		local compound = typeInfo

		file:write(",types={")
		for i, compoundItem in ipairs(compound) do
			if i > 1 then  file:write(",")  end
			writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), compoundItem, false)
		end
		file:write("}")

		!!(END_OF_TYPE_INFO"TypeInfoCompound")

	elseif !!(CONST_SET{ -- :SimplePublicTypeInfo
		TYPE_ANY,
		TYPE_BOOL,
		TYPE_FLOAT,
		TYPE_INT,
		TYPE_NONE,
		TYPE_PLACEHOLDER,
		TYPE_STRING,
		TYPE_TABLE,
		TYPE_TYPE,
		TYPE_VOID,
	})[tag] then
		-- void  No more information.
		!!(END_OF_TYPE_INFO"TypeInfo")

	else
		errorInternal("Incomplete: %s", getFriendlyTypeInfoName(typeInfo))
	end
end

-- writeConstantValue( state, writer, const, nodeForError=nil )
function _G.writeConstantValue(state, writer, const, nodeForError)
	local file = writer.file
	local tag  = const.valueType.tag

	if const.kind == !(CONST_KIND_FOREIGN) then
		local foreign = const.value
		writeForeignReference(state, writer, foreign.sourceId, nodeForError)

	elseif const.kind == !(CONST_KIND_TYPE_INFO) then
		local typeInfo = const.value
		file:write("_TYPE_INFO[", typeInfo.id, "]")

	elseif const.kind == !(CONST_KIND_LOCATION) then
		local target = const.value
		local tokens = state.tokens
		local token  = target.token

		-- Note: This table must be synced with the preload module!
		file:write("{filePath=")
		writeStringLiteral(writer, tokens.file[token])
		file:write(", lineNumber=", tokens.line1[token], ", position=", tokens.position1[token], "}")

	elseif const.kind == !(CONST_KIND_NULL) then
		file:write("nil")

	elseif const.kind == !(CONST_KIND_VIEW) then
		-- Note: The constants must be written in the same order as they were allocated for these
		-- views to work (which is what should happen naturally because of how dependencies work).
		writeAccess(state, writer, 1, 1, {}, const.value)

	--------------------------------

	elseif const.kind ~= !(CONST_KIND_NORMAL) then
		if nodeForError then
			errorInternal(state, nodeForError, "Incomplete: Handle constant kind '%s'.", (CONST_KIND_TITLES[const.kind] or "?"))
		else
			errorInternal("Incomplete: Handle constant kind '%s'.", (CONST_KIND_TITLES[const.kind] or "?"))
		end

	elseif not const.isObject then
		if tag ~= !(TYPE_ENUM) then
			writeNormalSimpleConstant(state, writer, tag, const.value, false)
			return
		end

		local enumInfo   = const.valueType
		local memberName = const.value
		local decl       = findMemberDeclaration(state, enumInfo.astNode, memberName)

		if not decl then
			if nodeForError then
				typeError2(state,
					enumInfo.astNode, F("Internal compiler error: Did not find member '%s' in enum '%s'.", memberName, getFriendlyTypeInfoName(enumInfo)),
					nodeForError,     F("...current node.")
				)
			else
				typeError("Internal compiler error: Did not find member '%s' in enum '%s'.", memberName, getFriendlyTypeInfoName(enumInfo))
			end
		end

		local valueExpr  = decl.value

		if enumInfo.memberTypeInfo.tag == !(TYPE_TYPE) then
			local typeNode = valueExpr
			!ASSERT("typeNode.nodeType == "..AST_TYPE)
			writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeNode.representedType, true)
		else
			local literal = valueExpr
			!ASSERT("literal.nodeType == "..AST_LITERAL)
			writeNormalSimpleConstant(state, writer, enumInfo.memberTypeInfo.tag, literal.value, true)
		end

		if outputDebugInfo then
			file:write("--[[", enumInfo.name, ".", memberName, "]]")
		end

	elseif tag == !(TYPE_FUNCTION) then
		local lambda = const.value
		writeFunction(state, writer, 1, 1, {}, lambda)

	elseif !!(CONST_SET{ TYPE_TABLE, TYPE_ARRAY, TYPE_STRUCT })[tag] then
		local tableNode = const.value
		writeExpression(state, writer, 1, 1, {}, tableNode)

	elseif tag == !(TYPE_STRING) then -- Large string.
		local s = const.value
		writeStringLiteral(writer, s)

	elseif !!(CONST_SET{ TYPE_ANY, TYPE_NAMESPACE, TYPE_COMPOUND, TYPE_LIST })[tag] then
		if nodeForError then
			errorInternal(state, nodeForError, "Cannot write invalid value type '%s'.", TYPE_NAMES[tag])
		else
			errorInternal("Cannot write invalid value type '%s'.", TYPE_NAMES[tag])
		end
	else
		if nodeForError then
			errorInternal(state, nodeForError, "Incomplete: Handle constant value of type '%s'.", (TYPE_NAMES[tag] or "?"))
		else
			errorInternal("Incomplete: Handle constant value of type '%s'.", (TYPE_NAMES[tag] or "?"))
		end
	end
end

function _G.writeConstantValueOrReference(state, writer, const, nodeForError)
	if not const.isObject then
		writeConstantValue(state, writer, const, nodeForError)
		return
	end

	if const.valueType.tag == !(TYPE_FUNCTION) then
		local lambda = const.value

		if lambda.bodyIsForeign and lambda.foreignSource == "method" then
			!TRACE()
			printerr()
			nodeMessage(io.stderr, state, nodeForError, "Error", "ProgramWriter", "Cannot output references to foreign methods.")
			if nodeForError ~= lambda then
				nodeMessage(io.stderr, state, lambda, "Info", "ProgramWriter", "...here is the method.")
			end
			exitFailure()
		end
	end

	writer.file:write(const.name)
end



function _G.writeLuaPreloads(state, writer, luaPreloads, fromIndex)
	local file = writer.file

	for i = fromIndex, #luaPreloads do
		local luaPreload = luaPreloads[i]

		file:write("do\n", luaPreload.lua, "\nend\n")

		local _, nlCount = luaPreload.lua:gsub("\n", "%0")

		local trimmedInitialNewline = state.tokens.extra[luaPreload.token]
		local stringTokenFile       = state.tokens.file [luaPreload.token] or errorInternal()
		local stringTokenLn         = state.tokens.line1[luaPreload.token] + luaPreload.lineOffset - 2 + (trimmedInitialNewline and 1 or 0)

		local outputOffsetLn = writer.currentOutputLine-1

		for ln = 2, nlCount+2 do
			writer.lineMappingFiles[outputOffsetLn+ln] = stringTokenFile
			writer.lineMappingLines[outputOffsetLn+ln] = stringTokenLn+ln
		end

		writer.currentOutputLine = writer.currentOutputLine+nlCount+3
	end
end

-- writeCompilerSymbols( state, writer, relevantObjects=nil )
function _G.writeCompilerSymbols(state, writer, relevantObjects)
	local file          = writer.file
	local outputRuntime = writer.outputRuntime

	if outputRuntime then
		file:write("local lineMappings      = {paths={},files={},lines={}}") ; writeEol(state, writer)
		file:write("local programArguments  = arg") ; writeEol(state, writer)
		file:write("local luaArguments      = arg") ; writeEol(state, writer)
		file:write!("local gloaErrorHandler = "..ERROR_HANDLER) ; writeEol(state, writer)

		local writeAllTypes = not relevantObjects or relevantObjects.allTypeInfos

		if writeAllTypes or next(relevantObjects.typeInfos) then
			local toWriteTypeIdSet  = {}
			local toWriteLastTypeId = 0

			for typeId, typeInfo in ipairs(state.allTypeInfos) do
				if (writeAllTypes or relevantObjects.typeInfos[typeInfo]) and isTypePublic(typeInfo) then
					if not typeInfo.isReady then
						errorInternal("Type info is not ready for '%s'.", getFriendlyTypeInfoName(typeInfo))
					end

					toWriteTypeIdSet[typeId] = true
					toWriteLastTypeId        = typeId
				end
			end

			-- Write list of types.
			file:write("local _TYPES = {")

			local first = true
			for typeId = 1, toWriteLastTypeId do
				if toWriteTypeIdSet[typeId] then
					if not first then  file:write(",")  end
					first = false

					file:write(typeId)
				end
			end

			file:write("}") ; writeEol(state, writer)

			-- Write type table.
			local sequenceGap       = 0
			local sequenceGapToFill = writeAllTypes and 30 or 10
			local _outputDebugInfo  = outputDebugInfo
			_G.outputDebugInfo      = false -- The type table is big enough already! Let's try making it a bit smaller. (This saves ~50% of the space.)

			file:write("local _ = nil") ; writeEol(state, writer)
			file:write("local _TYPE_INFO = {")

			local first = true
			for typeId = 1, toWriteLastTypeId do
				if toWriteTypeIdSet[typeId] then
					if not first then  file:write(",")  end
					first = false

					-- Note: Type index and type ID are the same.
					if sequenceGap == 0 then
						-- void
					elseif sequenceGap < sequenceGapToFill then
						file:write(("_,"):rep(sequenceGap))
						sequenceGap = 0
					else
						file:write("[", typeId, "]=")
					end

					writeTypeInfo(state, writer, state.allTypeInfos[typeId])

				else
					sequenceGap = sequenceGap+1
				end
			end

			file:write("}") ; writeEol(state, writer)

			_G.outputDebugInfo = _outputDebugInfo
		end

	else
		-- Note: lineMappings is not used in metaprograms because gloaErrorHandler() is different.
		file:write("programArguments = metaprogramArguments") ; writeEol(state, writer)
		file:write("luaArguments     = compilerLuaArguments") ; writeEol(state, writer)
		file:write("gloaErrorHandler = compilerErrorHandler") ; writeEol(state, writer)

		file:write("_TYPES     = metaprogramTypeIds")   ; writeEol(state, writer)
		file:write("_TYPE_INFO = metaprogramTypeTable") ; writeEol(state, writer)
	end

	-- @Polish: Only output symbols actually used in the program.
	!for i = 1, #COMPILER_SYMBOL_PAIRS, 2 do
		if outputRuntime then  file:write("local ")  end
		file:write!(COMPILER_SYMBOL_PAIRS[i].." = "..COMPILER_SYMBOL_PAIRS[i+1])
		writeEol(state, writer)
	!end
end

-- writeForeignImports(state, writer, constants, asGlobals [, relevantObjects=all ] )
function _G.writeForeignImports(state, writer, constants, asGlobals, relevantObjects)
	for _, const in ipairs(constants) do
		if relevantObjects and not relevantObjects[const] then
			-- void

		elseif const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION) and const.value.bodyIsForeign then
			-- @Polish: Treat function constants pointing to the same foreign function as the same constant.
			local lambda = const.value
			writeForeignImportIfNew(state, writer, const.valueType, lambda.foreignSource, lambda.foreignSourceName.value, lambda.foreignSourceId, lambda.token, asGlobals)

		elseif const.kind == !(CONST_KIND_FOREIGN) then
			local foreign = const.value
			writeForeignImportIfNew(state, writer, foreign.inferredType, foreign.source, foreign.sourceName.value, foreign.sourceId, foreign.token, asGlobals)
		end
	end
end

-- writeConstantObjectsAndForwardDeclarations( state, writer, constants, topScopeNames [, relevantObjects=all ] )
function _G.writeConstantObjectsAndForwardDeclarations(state, writer, constants, topScopeNames, relevantObjects)
	local constantNamesToWrite = {}
	local constantFunctions    = {}
	local constantNonFunctions = {}
	local file                 = writer.file

	for _, const in ipairs(constants) do
		if not const.isObject or (relevantObjects and not relevantObjects[const]) then
			-- void

		elseif const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION) then
			local lambda = const.value

			-- @Cleanup: Don't generate constants for polymorphic functions. (It's probably declarations doing this.) (I guess don't generate constants for foreign methods either.)
			if not (lambda.isPolymorphic or (lambda.bodyIsForeign and lambda.foreignSource == "method")) then
				table.insert(constantFunctions,         const)
				table.insert(constantNamesToWrite, const.name)
			end

		else
			table.insert(constantNonFunctions,      const)
			table.insert(constantNamesToWrite, const.name)
		end
	end

	if not (constantNamesToWrite[1] or topScopeNames[1]) then  return  end

	if writer.remainingUpvalues > 0 then
		local first = true
		file:write("\tlocal ")

		for i = 1, math.min(writer.remainingUpvalues, #constantNamesToWrite) do
			if not first then  file:write(", ")  end
			first = false
			file:write(constantNamesToWrite[i])
		end
		writer.remainingUpvalues = writer.remainingUpvalues - #constantNamesToWrite

		for i = 1, math.min(writer.remainingUpvalues, #topScopeNames) do
			if not first then  file:write(", ")  end
			first = false
			file:write(topScopeNames[i])
		end
		writer.remainingUpvalues = writer.remainingUpvalues - #topScopeNames

		writeEol(state, writer)
	end

	table.sort(constantFunctions, function(a, b)
		a = a.value
		b = b.value
		if a.bodyIsForeign ~= b.bodyIsForeign then  return a.bodyIsForeign    end
		if a.token         ~= b.token         then  return a.token < b.token  end
		return a.s < b.s
	end)

	for _, const in ipairs(constantFunctions) do
		local lambda = const.value
		file:write("\t")
		file:write(const.name, " = ")
		writeFunction(state, writer, 1, 1, {}, lambda)
		writeEol(state, writer)
	end

	for _, const in ipairs(constantNonFunctions) do
		local nodeForError = (type(const.value) == "table" and const.value.nodeType and const.value.s and const.value or nil) -- @Hack @Robustness
		file:write("\t")
		file:write(const.name, " = ")
		writeConstantValue(state, writer, const, nodeForError)
		writeEol(state, writer)
	end
end

-- writeTopScopeDeclarations( state, writer, declarations [, relevantObjects=all ] )
function _G.writeTopScopeDeclarations(state, writer, declarations, relevantObjects)
	local file = writer.file

	for _, decl in ipairs(declarations) do
		if relevantObjects and not relevantObjects[decl] then
			-- void

		elseif decl.topScopeName ~= "" then -- Constant declarations of non-objects (e.g. ints) should have an empty topScopeName.
			file:write("\t", decl.topScopeName, " = ")
			if decl.valueConstant then
				writeConstantValueOrReference(state, writer, decl.valueConstant, decl.name)
			else
				-- We should have a declared struct instance or something similar here (I think) that doesn't have a specified initial value.
				writeDefaultValueForType(state, writer, 1, 1, {}, decl.name.inferredType, decl.name)
			end
			writeEol(state, writer)
		end
	end
end

function _G.writeProgram(state, writer)

	-- Gather info.
	local globalScope          = state.globalScope
	local topScopeDeclarations = copyArray(globalScope.declarations)

	for _, fileScope in ipairs(globalScope.fileScopes) do
		insertArrayItems(topScopeDeclarations, fileScope.declarations)
	end

	local outputType = state.settings.outputType

	if outputType == !(OUTPUT_TYPE_LUA_MODULE) and not globalScope.fileScopeWithValueToExport then
		local filePaths = {}
		for _, fileScope in ipairs(globalScope.fileScopes) do
			if not fileScope.isModule then  table.insert(filePaths, fileScope.path)  end
		end
		errorLine(
			"ProgramWriter",
			"Missing value to export as the Lua module in top-level scope in loaded files:\n- %s",
			table.concat(filePaths, "\n- ")
		)
	end

	local mainFuncDecl, mainLambda = nil

	if outputType == !(OUTPUT_TYPE_LUA_APP) then
		local entryPointName = state.settings.entryPointName

		for _, decl in ipairs(topScopeDeclarations) do -- Note: topScopeDeclarations does not include static declarations or declarations in namespaces yet.
			if decl.name.name == entryPointName then
				mainFuncDecl = decl
				break
			end
		end

		if not mainFuncDecl then
			local filePaths = {}
			for _, fileScope in ipairs(globalScope.fileScopes) do
				if not fileScope.isModule then  table.insert(filePaths, fileScope.path)  end
			end
			errorLine(
				"ProgramWriter",
				"Missing program entry point ('%s' function) in top-level scope in loaded files:\n- %s",
				entryPointName, table.concat(filePaths, "\n- ")
			)

		elseif not isDeclarationConstant(mainFuncDecl) then
			nodeError(state, mainFuncDecl.name, "ProgramWriter", "Declared name '%s' must be a constant.", entryPointName)
		end

		mainLambda = mainFuncDecl.valueConstant.value

		if mainLambda.inferredType.tag ~= !(TYPE_FUNCTION) then
			nodeError(
				state, mainFuncDecl.value, "ProgramWriter",
				"Declared name '%s' must be a function to represent the entry point of the program.",
				entryPointName
			)
		end
		!ASSERT("mainLambda.nodeType == "..AST_LAMBDA)

		if mainFuncDecl.overloadOf then
			nodeError(state, mainFuncDecl.name, "ProgramWriter", "Program entry point name must not be overloaded.")
		elseif mainLambda.inferredType.argumentTypesIn[1] then
			nodeError(state, mainLambda.argumentsIn, "ProgramWriter", "Program entry point function must not take any arguments.")
		elseif mainLambda.inferredType.argumentTypesOut[1] then
			nodeError(state, mainLambda.argumentsOut, "ProgramWriter", "Program entry point function must not return any values.")
		end
	end

	astVisitAllNodes(globalScope, function(node)
		if node.nodeType == !(AST_DECLARATION) then
			local decl = node
			if decl.kind == !(DECL_KIND_STATIC) then
				table.insert(topScopeDeclarations, decl)
			end

		elseif node.nodeType == !(AST_NAMESPACE) then
			local namespace = node
			insertArrayItems(topScopeDeclarations, namespace.declarations)
		end
	end)

	local relevantObjects = nil

	if not keepDeadCode then
		local relevantTypes = {--[[ [typeInfo1]=true, ... ]]}
		relevantObjects     = {typeInfos=relevantTypes, allTypeInfos=false--[[, [node1]=true, [const1]=true, ... ]]}

		local function cb(obj, crawlObjKind)
			if crawlObjKind ~= !(CRAWL_CONSTANT) then  return  end

			local const = obj

			if const.kind == !(CONST_KIND_NORMAL) then
				if const.valueType.tag == !(TYPE_FUNCTION) and const.value.bodyIsForeign and const.value.foreignSource == "compiler" and !!(CONST_SET{
					-- These are the only functions that can retrieve type information dynamically at runtime.
					"getAllTypes",
					"getTypeInfo",
				})[const.value.foreignSourceName.value] then
					relevantObjects.allTypeInfos = true
				end

			elseif const.kind == !(CONST_KIND_TYPE_INFO) then
				local typeInfo          = const.value
				relevantTypes[typeInfo] = true
			end
		end

		if outputType == !(OUTPUT_TYPE_LUA_APP) then
			crawl(state, mainLambda, relevantObjects, false, cb)
		elseif outputType == !(OUTPUT_TYPE_LUA_MODULE) then
			crawl(state, globalScope.fileScopeWithValueToExport.valueToExport, relevantObjects, false, cb)
		else
			errorInternal("outputType==%d", outputType)
		end
	end

	--
	-- Write program.
	--
	local file  = assert(io.open(state.settings.outputFilePath, "w"))
	writer.file = file

	!ASSERT `writer.currentOutputLine == 1`

	if outputType == !(OUTPUT_TYPE_LUA_APP) then
		-- @Incomplete: Setting to specify the prefix for the written file (shebang and maybe a comment with copyright info, library documentation etc.).
		file:write('#!/bin/sh\n_=[[\nexec lua "$0" "$@"\n]] and nil\n')
		writer.currentOutputLine = 5
	end

	writeLuaPreloads(state, writer, state.luaPreloads,        1)
	writeLuaPreloads(state, writer, state.luaPreloadsRuntime, 1)
	writeCompilerSymbols(state, writer, relevantObjects)

	-- Start of user code.
	addLineMappingDummy(state, writer)
	file:write("local function runProgram()") ; writeEol(state, writer)

	writeForeignImports(state, writer, state.constants, false, relevantObjects)

	!local MAX_UPVALUES = 60
	writer.remainingUpvalues = !(MAX_UPVALUES - COMPILER_SYMBOL_COUNT) -- @Incomplete: This system for solving the upvalue limit in Lua can be improved. A lot!
	writeConstantObjectsAndForwardDeclarations(state, writer, state.constants, state.topScopeNames, relevantObjects)
	writeTopScopeDeclarations(state, writer, topScopeDeclarations, relevantObjects)

	-- Write program entry point.

	if outputType == !(OUTPUT_TYPE_LUA_APP) then
		addLineMappingDummy(state, writer)
		file:write("\t", mainFuncDecl.valueConstant.name, "()")
		writeEol(state, writer)

	elseif outputType == !(OUTPUT_TYPE_LUA_MODULE) then
		addLineMappingDummy(state, writer)
		file:write("\treturn ")
		writeExpression(state, writer, 2, 1, {}, globalScope.fileScopeWithValueToExport.valueToExport)
		writeEol(state, writer)

	else
		errorInternal("outputType==%d", outputType)
	end

	-- End of user code.
	file:write("end") ; writeEol(state, writer)

	if outputDebugInfo then
		!(
		-- Size of line mapping information in bytes in a small test program:
		--
		--            pad   exact indices
		--     files  1700  3500
		--     lines  2400  4300
		--
		local USE_PADDING = true -- Enabling this seem better.
		)

		writer.currentOutputLine = writer.currentOutputLine+5
		addLineMappingDummy(state, writer) -- For the xpcall() here below.

		local MODULE_DIR_PREFIX = COMPILER_DIRECTORY.."/modules/"

		local pathIndices = {}
		local pathIndex   = 0
		local first       = true

		file:write("local _ = nil\n") -- Takes up less space than 'nil'.

		file:write("lineMappings.paths = {")
		for ln = 1, writer.currentOutputLine do
			local path = writer.lineMappingFiles[ln]

			if writer.lineMappingLines[ln] and not pathIndices[path] then
				if not first then  file:write(",")  end
				first = false

				pathIndex         = pathIndex+1
				pathIndices[path] = pathIndex

				!if DEBUG then
					path = path:gsub("^%./(.*/)", "%1")
				!else
					if path:sub(1, #MODULE_DIR_PREFIX) == MODULE_DIR_PREFIX then
						path = "module:"..path:sub(#MODULE_DIR_PREFIX+1):gsub("%.gloa$", "")
					end
				!end

				file:write(F("%q", path))
			end
		end
		file:write("}\n")

		file:write("lineMappings.files = {")
		!if USE_PADDING then
			for ln = 1, writer.currentOutputLine do
				if ln > 1 then  file:write(",")  end
				file:write(pathIndices[writer.lineMappingFiles[ln]] or "_")
			end
		!else
			first = true
			for ln = 1, writer.currentOutputLine do
				if writer.lineMappingLines[ln] then
					if not first then  file:write(",")  end
					first = false
					file:write(F("[%d]=%d", ln, pathIndices[writer.lineMappingFiles[ln]]))
				end
			end
		!end
		file:write("}\n")

		file:write("lineMappings.lines = {")
		!if USE_PADDING then
			for ln = 1, writer.currentOutputLine do
				if ln > 1 then  file:write(",")  end
				file:write(writer.lineMappingLines[ln] or "_")
			end
		!else
			first = true
			for ln = 1, writer.currentOutputLine do
				if writer.lineMappingLines[ln] then
					if not first then  file:write(",")  end
					first = false
					file:write(F("[%d]=%d", ln, writer.lineMappingLines[ln]))
				end
			end
		!end
		file:write("}\n")
	end

	local moduleVariableCode = (outputType == !(OUTPUT_TYPE_LUA_MODULE) and ", module" or "")

	file:write("local os, ok"..moduleVariableCode.." = os, xpcall(runProgram, gloaErrorHandler)\n")
	file:write("if not ok then  os.exit(1)  end\n") -- In case there was an error in gloaErrorHandler() for some reason.  :LuaModuleErrors

	if outputType == !(OUTPUT_TYPE_LUA_MODULE) then
		file:write("return module\n")
	end

	file:close()

	-- Validate output.
	local chunk, err = loadfile(state.settings.outputFilePath)
	if not chunk then
		errorInternal("Wrote invalid Lua output. (%s)", err)
	end
end



local UNICODE_TO_ASCII = @insert "unicodeConversions.luapart"

function _G.unicodeToLuaIdentifier(name)
	if name:find"[\128-\255]" then
		name = name:gsub(!(UTF8_CHARACTER_PATTERN), function(c)
			return (#c == 1 and c) or UNICODE_TO_ASCII[c] or "_"
		end)
	elseif LUA_KEYWORDS[name] then
		name = name.."_"
	end
	return name
end



local HAS_DEFAULT_VALUE = !(Set{
	TYPE_ANY,
	TYPE_ARRAY,
	TYPE_BOOL,
	TYPE_FLOAT,
	TYPE_INT,
	TYPE_NONE,
	TYPE_STRING,
	TYPE_STRUCT,
	TYPE_TABLE,
	TYPE_VARARG, -- Varargs never have any default value(s), but because it's a list we can just say that the default value is "nothing".
})
function _G.doesTypeHaveAnyDefaultValue(typeInfo)
	return HAS_DEFAULT_VALUE[typeInfo.tag] or false
end



function _G.validateForeignSource(state, foreignSource, foreignSourceName, nodeForError)
	if foreignSource == "lua" then
		if foreignSourceName:find"^[%w_]+$" or foreignSourceName:find"^[%a_][%w_]*%.[%a_][%w_]*$" or loadstring(F("return(%s)", foreignSourceName)) then
			-- void
		elseif foreignSourceName:find"%-%-[^\n]*$" then
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid Lua symbol. (Note that trailing comments in the Lua code may cause problems.)")
		else
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid Lua symbol.")
		end

	elseif foreignSource == "compiler" then
		if not foreignApiCompilerSymbols[foreignSourceName] then
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid compiler symbol.")
		end

	elseif foreignSource == "method" then
		--[[ Hmm, I think we *will* support keywords and weird names as method names actually.
		if not (foreignSourceName:find"^[%a_][%w_]*$" ~= nil and not LUA_KEYWORDS[foreignSourceName]) then
			-- @UX: The error arrow is way off!
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid Lua identifier to use as method name: '%s'", foreignSourceName)
		end
		--]]

	else
		errorInternal(state, nodeForError, "Incomplete: Handle foreignSource=%s", foreignSource)
	end
end



function _G.formatInfoComment(info)
	return "--[[" .. info:gsub("[%[%]]", "%0 ") .. "]]"
end


