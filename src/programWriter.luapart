--[[============================================================
--=
--=  Program Writer
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	createLuaOutput
	doesTypeHaveAnyDefaultValue
	formatInfoComment
	unicodeToLuaIdentifier
	validateForeignSource
	writeProgram, writeLuaPreloads, writeCompilerSymbols, writeForeignImports, writeConstantObjectsAndForwardDeclarations, writeTopScopeDeclarations
	writerError

----------------------------------------------------------------

	Format for written programs:
	1. Glóa header.
	2. Foreign imports.
	3. Forward declarations.
	4. Constants (including functions).
	5. Global/file-scope variables.
	6. Program entry point.

	Notes:
	- Usage of Lua globals is minimized. (Glóa globals are not Lua globals.)
	- All functions (with no captures/upvalues) are top-level in Lua no matter where they were defined in Glóa.
	- Local variables in Lua are uniquely named and thus never shadow anything (which might help with debugging).

	@Incomplete:
	- Handle the limited amount of locals Lua allows (200).
	- Handle the limited amount of upvalues Lua allows (200?).

--============================================================]]
!recordLineNumber(@file, @line)



!(
-- info.what     = "Lua"|"C"|"main"|"tail"
-- info.namewhat = "global"|"local"|"method"|"field"|"upvalue"|""

-- @Incomplete: Handle errors better in compiled Lua modules. :LuaModuleErrors
local ERROR_HANDLER = templateToLua(
	trimTemplate`
		(function(lineMappings, getinfo, tonumber, outputFile, type, exit)
			return function(err, level)
				level            = (level or 1)+1
				local mainSource = (getinfo(1, "S") or {}).source or "<UNKNOWN_SOURCE>"

				if type(err) == "string" then
					local pathHere = mainSource:match"^@(.+)"
					local pathLen  = pathHere and #pathHere
					local ln       = pathHere and err:sub(1, pathLen) == pathHere and tonumber(err:match("^:(%d+): ", pathLen+1))

					if lineMappings.lines[ln] then
						err = (
							lineMappings.paths[lineMappings.files[ln]] .. ":"
							.. lineMappings.lines[ln] .. ": "
							.. err:sub(pathLen+1):gsub("^:%d+: ", "")
						)
					end
				end

				outputFile:write("\n")
				if type(err) == "string" then
					outputFile:write("Error: ", err, "\n")
				else
					outputFile:write("Error!\n")
				end
				outputFile:write("stack traceback:\n")

				for level = level, 1000 do
					local info = getinfo(level, "nSl")
					if not info then  break  end

					outputFile:write("\t")

					if info.what == "C" then
						outputFile:write("[ C ]: ")
						if (info.name or "") ~= "" then
							outputFile:write("'", info.name, "'")
						else
							outputFile:write("?")
						end

					else
						if info.source == mainSource and (lineMappings.lines[info.currentline] or 0) > 0 then
							outputFile:write(lineMappings.paths[lineMappings.files[info.currentline]], ":", lineMappings.lines[info.currentline])
						else
							outputFile:write("[Lua]")
						end

						outputFile:write(":")

						if info.what == "tail" then
							outputFile:write(" tail call")
						elseif info.what == "main" then
							outputFile:write(" main chunk")
						elseif (info.name or "") ~= "" then
							outputFile:write(" ")
							if info.namewhat == "method" or info.namewhat == "field" then  outputFile:write(info.namewhat, " ")  end
							outputFile:write("'", info.name, "'")
						--[[elseif info.source == mainSource and (lineMappings.lines[info.linedefined] or 0) > 0 and info.linedefined ~= info.currentline then
							outputFile:write(" (linedefined:", lineMappings.lines[info.linedefined], ")")]]
						end

						local source = nil

						if info.source:find"^@" then
							source = $errorPrefix .. info.source:sub(2)
						elseif info.source:find"%.lua$" then
							source = info.source
						end

						source = source and source .. ":" .. info.currentline

						if source then
							outputFile:write(" (", source)
							--[[if info.linedefined > 0 and info.linedefined ~= info.currentline then
								outputFile:write(", linedefined:", info.linedefined)
							end]]
							outputFile:write(")")
						end
					end

					outputFile:write("\n")
				end

				exit(1)
			end
		end)(lineMappings, debug.getinfo, tonumber, io.stderr, type, os.exit)
	`,
	{ errorPrefix=toLua(RUNTIME_ERROR_PREFIX) }
)

local COMPILER_SYMBOL_PAIRS = {
	`_MODF`,   `math.modf`,  -- Used when casting float to int.
	`_FLOOR`,  `math.floor`, -- Used for integer division.
	`_IPAIRS`, `ipairs`,     -- Used for short-form array loops.
	`_PAIRS`,  `pairs`,      -- Used for short-form table loops.
	`_SELECT`, `select`,     -- Used for short-form vararg loops, lookups and length expressions.
	`_REP`,    `string.rep`, -- Used for string repetition (duh).
	`_REP2`,   `function(n,s)return(s:rep(n))end`,
	`_BYTE`,   `string.byte`,-- Used for string subscripting.

	-- Used for short-form array loops in reverse.
	`_IPAIRSR`, trimTemplate`
		(function()
			local function iprev(arr, i)
				i = i-1
				if i > 0 then  return i, arr[i]  end
			end
			return function(arr)
				return iprev, arr, #arr+1
			end
		end)()
	`,
}
local COMPILER_SYMBOL_COUNT = #COMPILER_SYMBOL_PAIRS / 2

local function INSERT_TABLE_FIELD(luaTableFieldsCode, keyLiteralCode, valueCode)
	if keyLiteralCode ~= "nil" then
		return F("table.insert(%s, {key=%s, value=%s})", luaTableFieldsCode, LUA_EXPRESSION(keyLiteralCode), valueCode)
	else
		return F("table.insert(%s, {generatedKey=true, value=%s})", luaTableFieldsCode, valueCode)
	end
end
)

local foreignApiCompilerSymbols = {
	-- These can be used in user code through !foreign compiler "symbolName".
	-- (See utils.gloa, io.gloa and other modules for declarations.)
	-- (See compiler.gloa for things only available during compile-time.)

	appPath           = `(debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get application path.")) :gsub("\\", "/")`,
	appDirectory      = `(debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get application path.")) :gsub("\\", "/"):gsub("/?[^/]+$", ""):gsub("^$", ".")`,
	compilerPath      = F("%q", COMPILER_PATH),
	compilerDirectory = F("%q", COMPILER_DIRECTORY),

	error   = `error`,
	ipairsr = `_IPAIRSR`,

	wrapFunctionInGloaErrorHandler = !(trimTemplate`
		(function(select, xpcall, unpack, exit, gloaErrorHandler)
			local function pack(...)
				return {n=select("#", ...), ...}
			end

			return function(cb)
				return function(...)
					local args = pack(...)

					args = pack(xpcall(
						function() return cb(unpack(args, 1, args.n)) end,
						gloaErrorHandler
					))
					if not args[1] then  exit(1)  end

					return unpack(args, 2, args.n)
				end
			end
		end)(select, xpcall, unpack, os.exit, gloaErrorHandler)
	`),

	getProgramArguments = !(trimTemplate`
		(function(args, unpack)
			return function()
				return {unpack(args)}
			end
		end)(programArguments, unpack)
	`),

	getCommandLineArguments = !(trimTemplate`
		(function(args, unpack)
			return function()
				local argsCopy = {unpack(args)}
				for i = 0, -1/0, -1 do
					if args[i] == nil then  return argsCopy  end
					argsCopy[i] = args[i]
				end
			end
		end)(luaArguments, unpack)
	`),

	getAllTypes = !(trimTemplate`
		(function(unpack)
			return function(T)
				if not _TYPES[1000] then
					return {unpack(_TYPES)}
				end

				local types = {unpack(_TYPES, 1, 1000)}
				for i = 1001, #_TYPES do
					types[i] = _TYPES[i]
				end

				return types
			end
		end)(unpack)
	`),

	getTypeInfo = !(trimTemplate`
		function(T)
			return _TYPE_INFO[T]
		end
	`),
}

local foreignApiCompilerSymbolsDuringCompilation = {
	-- These are different during compilation.

	appPath      = `metaprogramAppPath`,
	appDirectory = `metaprogramAppDirectory`,

	error = `compilerErrorHandler`,
}

for k in pairs(compilerApi) do
	foreignApiCompilerSymbols[k]                  = `function() error("Function not available during runtime.") end` -- This should only ever get written if keepDeadCode is set.
	foreignApiCompilerSymbolsDuringCompilation[k] = "_COMPILER." .. k
end

local LUA_KEYWORDS = !(Set{"and","break","do","else","elseif","end","false","for","function","goto","if","in","local","nil","not","or","repeat","return","then","true","until","while"})

_G.!struct"WriterState"{
	{`luaMainChunkBody`,  nil}, -- LuaAstBlock
	{`outputRuntime`,     false},

	{`foreignN`,          0},
	{`foreignReferences`, {}},
	{`foreignOnlyAvailableDuringCompilation`, {}},

	{`loopDepth`,         0},
	{`loopStack`,         {}},  -- [](AstFor|AstWhile)  Only used for loops with named jumps inside.
	{`continueDepth`,     0},
	{`deferStack`,        {}},  -- []AstDefer
	{`loopDeferIndices`,  {}},
	{`argumentN`,         1},
	{`inlineDepth`,       0},
	{`inlineFunctions`,   {--[[ [lambda1]=firstCall, ... ]]}},

	{`lineMappingFiles`,  {}},
	{`lineMappingLines`,  {}},

	{`remainingUpvalues`, 0},
}



local writeBlock, writeExpression, writeFunction, writeDefaultValueForType, writeConstantValueOrReference

-- writtenName = writeIdentifierName( state, writer, identifier ) -- @Cleanup: Return a LuaIdentifier instead of the name.
local function writeIdentifierName(state, writer, ident)
	local decl = ident.declaration
	local name = decl.topScopeName

	if name == "" then  name = decl.localName  end

	if name == "" then
		writerError(state, ident, "Internal compiler error: Missing name to write for '%s'.", ident.name)
	end

	return name
end

-- luaBinary = writeBinaryOperatorChain( state, writer, nextLocalN, localsStack, left:AstNode|string, right:AstNode|string, binaryOperation, sourceNode )
local function writeBinaryOperatorChain(state, writer, nextLocalN, localsStack, left, right, binOp, sourceNode)
	local luaBinary      = luaParser.newNodeFast("binary", binOp)
	luaBinary.sourceNode = sourceNode

	if type(left) == "string" then
		luaBinary.left            = assert(luaParser.parseExpression(left))
		luaBinary.left.sourceNode = sourceNode
	elseif left.nodeType == !(AST_BINARY) and left.operation == binOp then
		luaBinary.left = writeBinaryOperatorChain(state, writer, nextLocalN, localsStack, left.left, left.right, binOp, left)
	else
		luaBinary.left = writeExpression(state, writer, nextLocalN, localsStack, left)
	end

	if type(right) == "string" then
		luaBinary.right            = assert(luaParser.parseExpression(right))
		luaBinary.right.sourceNode = sourceNode
	elseif right.nodeType == !(AST_BINARY) and right.operation == binOp then
		luaBinary.right = writeBinaryOperatorChain(state, writer, nextLocalN, localsStack, right.left, right.right, binOp, right)
	else
		luaBinary.right = writeExpression(state, writer, nextLocalN, localsStack, right)
	end

	return luaBinary
end

-- writeBinaryOperation(
--   state, writer, nextLocalN, localsStack,
--   left:AstNode|string, right:AstNode|string,
--   binaryOperation,
--   leftType, rightType, resultingType,
--   sourceNode
-- )
local function writeBinaryOperation(state, writer, nextLocalN, localsStack, l, r, binOp, lType, rType, resultingType, sourceNode)
	!(
	local function WRITE_OPERAND(sideCode, luaSideCode)
		__LUA(templateToLua(
			trimTemplate`
				if type($side) == "string" then
					$luaSide = assert(luaParser.parseExpression($side))
				else
					$luaSide = writeExpression(state, writer, nextLocalN, localsStack, $side)
				end
			`,
			{side=sideCode, luaSide=luaSideCode}
		))
	end
	)

	local luaExpr

	if !!(CONST_SET{"..","and","or"})[binOp] then
		-- @Polish: For the logical operators there is probably more we can do, but we may have to dive deeper in the sub-trees to make some predictions or something...
		luaExpr = writeBinaryOperatorChain(state, writer, nextLocalN, localsStack, l, r, binOp, sourceNode) -- This makes sure e.g. consecutive string concatenations appear as one operation without any parentheses.

	elseif binOp == "//" then
		luaExpr            = !!(LUA_EXPRESSION([[ _FLOOR(l/r) ]], function(luaCall)luaCall.arguments[1].left=nil;luaCall.arguments[1].right=nil;end))
		luaExpr.sourceNode = sourceNode
		!WRITE_OPERAND(`l`, `luaExpr.arguments[1].left`)
		!WRITE_OPERAND(`r`, `luaExpr.arguments[1].right`)

	elseif binOp == "*" and resultingType.tag == !(TYPE_STRING) then
		-- Just a quick note:
		--   str *= 3  -- OK
		--   num *= "" -- Illegal (as the result is a string, which is a type mismatch with 'num')
		luaExpr            = !!(LUA_EXPRESSION[[ _REP() ]])
		luaExpr.sourceNode = sourceNode
		if lType.tag ~= !(TYPE_STRING) then  luaExpr.callee.name = "_REP2"  end
		!WRITE_OPERAND(`l`, `luaExpr.arguments[1]`)
		!WRITE_OPERAND(`r`, `luaExpr.arguments[2]`)

	else
		luaExpr            = luaParser.newNodeFast("binary", binOp)
		luaExpr.sourceNode = sourceNode
		!WRITE_OPERAND(`l`, `luaExpr.left`)
		!WRITE_OPERAND(`r`, `luaExpr.right`)
	end

	return luaExpr
end

local function isExpressionLiteralStringAndValidLuaIdentifier(expr)
	return
		expr.nodeType == !(AST_LITERAL)
		and expr.literalType == !(LITERAL_STRING)
		and expr.value:find"^[%a_][%w_]*$" ~= nil
		and not LUA_KEYWORDS[expr.value]
end

-- luaExpr = writeAccess( state, writer, nextLocalN, localsStack, access )
local function writeAccess(state, writer, nextLocalN, localsStack, access)
	local luaExpr

	if access.XXX_AWBO_HACK then -- @Hack
		-- :AbcCheck
		luaExpr            = luaParser.newNodeFast("lookup")
		luaExpr.sourceNode = access

		if type(access.object) == "string" then
			luaExpr.object = assert(luaParser.parseExpression(access.object))
		else
			luaExpr.object = writeExpression(state, writer, nextLocalN, localsStack, access.object)
		end
		if type(access.member) == "string" then
			luaExpr.member = assert(luaParser.parseExpression(access.member))
		else
			luaExpr.member = writeExpression(state, writer, nextLocalN, localsStack, access.member)
		end

		return luaExpr
	end

	local objType = access.object.inferredType
	if objType.tag == !(TYPE_LIST) then
		objType = adjustTypeToOne(state, access.object, objType, true)
	end

	if isTypeTableLike(objType) then
		-- @Incomplete: Compiler setting for runtime checks of array bounds. :AbcCheck
		luaExpr            = luaParser.newNodeFast("lookup")
		luaExpr.sourceNode = access
		luaExpr.object     = writeExpression(state, writer, nextLocalN, localsStack, access.object)

		if access.parent.nodeType == !(AST_CALL) and access.parent.isMethod then
			local stringLiteral = access.member
			assert(stringLiteral.nodeType == !(AST_LITERAL) and stringLiteral.literalType == !(LITERAL_STRING))

			local stringValue = stringLiteral.value

			if not stringValue:find"^[%a_][%w_]*$" then
				errorInternal("@Incomplete: Support method calls using names containing non-ASCII characters.")
			elseif LUA_KEYWORDS[stringValue] then
				errorInternal("@Incomplete: Support method calls using names that are keywords in Lua.")
			end

			luaExpr.member = luaParser.newNodeFast("literal", stringValue)

		else
			luaExpr.member = writeExpression(state, writer, nextLocalN, localsStack, access.member)
		end

	elseif objType.tag == !(TYPE_STRING) then
		luaExpr              = !!(LUA_EXPRESSION[[ _BYTE() ]])
		luaExpr.sourceNode   = access
		luaExpr.arguments[1] = writeExpression(state, writer, nextLocalN, localsStack, access.object)
		luaExpr.arguments[2] = writeExpression(state, writer, nextLocalN, localsStack, access.member)

	elseif objType.tag == !(TYPE_VARARG) then
		luaExpr              = !!(LUA_EXPRESSION([[ (_SELECT(x, ...)) ]], function(luaCall)luaCall.arguments[1]=nil;end))
		luaExpr.sourceNode   = access
		luaExpr.arguments[1] = writeExpression(state, writer, nextLocalN, localsStack, access.member)

	elseif objType.tag == !(TYPE_ENUM) then
		errorInternal(state, access) -- Enum accesses should have been simplified away.

	else
		errorUnhandledType(state, access.object, objType)
	end

	return luaExpr
end

-- luaExpression = writeCast( state, writer, nextLocalN, localsStack, cast, nameToCast=nil )
-- nameToCast is only used by AstConditional.
local function writeCast(state, writer, nextLocalN, localsStack, cast, nameToCast)
	local typeInfoSource = adjustTypeToOne(state, cast.expression, cast.expression.inferredType, true)
	local typeInfoTarget = cast.inferredType

	local luaExpr
	if nameToCast then
		luaExpr            = luaParser.newNodeFast("identifier", nameToCast)
		luaExpr.sourceNode = cast.expression
	else
		luaExpr = writeExpression(state, writer, nextLocalN, localsStack, cast.expression)
	end

	if
		typeInfoSource == typeInfoTarget
		or typeInfoSource.tag == !(TYPE_COMPOUND)
		or typeInfoTarget.tag == !(TYPE_COMPOUND)
	then
		-- void

	-- int -> float
	elseif typeInfoSource.tag == !(TYPE_INT) and typeInfoTarget.tag == !(TYPE_FLOAT) then
		-- void
	-- float -> int
	elseif typeInfoSource.tag == !(TYPE_FLOAT) and typeInfoTarget.tag == !(TYPE_INT) then
		local luaCall        = !!(LUA_EXPRESSION[[ (_MODF()) ]]) -- Note: math.modf() returns two values. (Should we actually floor the value instead? I think that might be more "the Lua way".)
		luaCall.sourceNode   = cast
		luaCall.arguments[1] = luaExpr
		luaExpr              = luaCall

	-- (numeric) -> bool
	elseif isTypeNumeric(typeInfoSource) and typeInfoTarget.tag == !(TYPE_BOOL) then
		local luaBinary      = !!(LUA_EXPRESSION([[ x ~= 0 ]], function(luaBinary)luaBinary.left=nil;end))
		luaBinary.sourceNode = cast
		luaBinary.left       = luaExpr
		luaExpr              = luaBinary
	-- string -> bool
	elseif typeInfoSource.tag == !(TYPE_STRING) and typeInfoTarget.tag == !(TYPE_BOOL) then
		local luaBinary      = !!(LUA_EXPRESSION([[ x ~= "" ]], function(luaBinary)luaBinary.left=nil;end))
		luaBinary.sourceNode = cast
		luaBinary.left       = luaExpr
		luaExpr              = luaBinary
	-- array -> bool
	elseif typeInfoSource.tag == !(TYPE_ARRAY) and typeInfoTarget.tag == !(TYPE_BOOL) then
		local luaBinary       = !!(LUA_EXPRESSION([[ x[1] ~= nil ]], function(luaBinary)luaBinary.left.object=nil;end))
		luaBinary.sourceNode  = cast
		luaBinary.left.object = luaExpr
		luaExpr               = luaBinary
	-- (array-like struct) -> bool
	elseif typeInfoSource.tag == !(TYPE_STRUCT) and typeInfoSource.kind == !(STRUCT_KIND_ARRAY) and typeInfoTarget.tag == !(TYPE_BOOL) then
		local luaBinary       = !!(LUA_EXPRESSION([[ x[1] ~= nil ]], function(luaBinary)luaBinary.left.object=nil;end))
		luaBinary.sourceNode  = cast
		luaBinary.left.object = luaExpr
		luaExpr               = luaBinary

	-- enum -> (real enum member type)
	elseif typeInfoSource.tag == !(TYPE_ENUM) and typeInfoTarget == typeInfoSource.memberTypeInfo then
		-- void
	-- (real enum member type) -> enum
	elseif typeInfoTarget.tag == !(TYPE_ENUM) and typeInfoSource == typeInfoTarget.memberTypeInfo then
		-- void

	-- (base struct) -> (substruct)
	elseif typeInfoSource.tag == !(TYPE_STRUCT) and typeInfoTarget.tag == !(TYPE_STRUCT) then
		-- void
	-- (table-like) -> table
	elseif isTypeTableLike(typeInfoSource) and typeInfoTarget.tag == !(TYPE_TABLE) then
		-- void
	-- (array-like struct) -> array
	elseif typeInfoSource.tag == !(TYPE_STRUCT) and typeInfoSource.kind == !(STRUCT_KIND_ARRAY) and typeInfoTarget.tag == !(TYPE_ARRAY) then
		-- void

	-- (whatever) -> any
	-- any -> (whatever)
	elseif typeInfoSource.tag == !(TYPE_ANY) or typeInfoTarget.tag == !(TYPE_ANY) then
		-- void  The user better know what they're doing!
		-- @Incomplete: Compiler setting for runtime checks of 'any' and 'compound' casts.

	else
		errorInternal(state, cast, "Incomplete: Handle casting from %s to %s.", getFriendlyTypeInfoName(typeInfoSource), getFriendlyTypeInfoName(typeInfoTarget))
	end

	if luaExpr.adjustToOne == false then
		-- In case the written expression is a list of some kind.
		-- Not sure if we actually ever get here, but just to be safe. 2021-08-19
		luaExpr.adjustToOne = true
	end

	return luaExpr
end

-- luaExpression = writeTableConstructorKeyName( writer, name, sourceNode ) -- @Cleanup: We maybe don't really need this function.
local function writeTableConstructorKeyName(writer, name, sourceNode)
	local luaLiteral      = luaParser.newNodeFast("literal", name) -- @Incomplete: Use writeConstantValueOrReference() in case the string is large.
	luaLiteral.sourceNode = sourceNode
	return luaLiteral
end

-- luaExpression = writeDefaultValueForStructMember( state, writer, nextLocalN, localsStack, structInfo, member, nodeForError )
local function writeDefaultValueForStructMember(state, writer, nextLocalN, localsStack, structInfo, member, nodeForError)
	local decl = findDynamicMemberDeclaration(state, structInfo.astNode, member.name) or errorInternal(state, structInfo.astNode, "Did not find member '%s'.", member.name)
	local luaExpr
	if decl.value then
		luaExpr = writeExpression(state, writer, nextLocalN, localsStack, decl.value)
	else
		luaExpr = writeDefaultValueForType(state, writer, nextLocalN, localsStack, member.typeInfo, nodeForError)
	end
	return luaExpr
end

local function findTableFieldByNameInStructConstructor(state, tableNode, memberName)
	for _, tableField in ipairs(tableNode.fields) do
		local keyExpr = tableField.key
		if keyExpr.nodeType == !(AST_LITERAL) and keyExpr.literalType == !(LITERAL_STRING) and keyExpr.value == memberName then
			return tableField
		end
	end

	return nil
end

local function doesTypeContainBoolOrNone(typeInfo)
	if !!(CONST_SET{ TYPE_BOOL, TYPE_NONE, TYPE_ANY })[typeInfo.tag] then  return true  end

	if typeInfo.tag ~= !(TYPE_COMPOUND) then  return false  end
	local compound = typeInfo

	for _, compoundItem in ipairs(compound) do
		if !!(CONST_SET{ TYPE_BOOL, TYPE_NONE })[compoundItem.tag] then  return true  end
	end
	return false
end

-- lambda = getDataForHandlingMissingArguments( state, callee )
local function getDataForHandlingMissingArguments(state, callee)
	if callee.nodeType ~= !(AST_IDENTIFIER) then  return nil  end

	local ident = callee
	if not isDeclarationConstant(ident.declaration) then  return nil  end

	local const = ident.declaration.valueConstant
	if not const then  return nil  end

	local funcSig = const.valueType
	if funcSig.tag ~= !(TYPE_FUNCTION) then
		errorInternal(state, ident, getFriendlyTypeInfoName(funcSig))
	end

	local argTypesIn = funcSig.argumentTypesIn
	if not argTypesIn[1] or argTypesIn[1].tag == !(TYPE_VARARG) then  return nil  end

	local lambda = const.value
	!ASSERT("lambda.nodeType == "..AST_LAMBDA, nil, `lambda`)

	return lambda
end

local function isExpressionNil(expr)
	return
		expr.nodeType == !(AST_NULL)
		or expr.nodeType == !(AST_LITERAL) and expr.literalType == !(LITERAL_NIL)
end

local function isStructMemberDefaultValueNil(state, struct, memberName, nodeForError)
	local decl      = findDynamicMemberDeclaration(state, struct, memberName) or errorInternal(state, nodeForError, memberName)
	local valueExpr = decl.value

	if valueExpr then
		return isExpressionNil(valueExpr)
	else
		return !!(CONST_SET{ TYPE_NONE, TYPE_ANY })[decl.inferredType.tag] or false
	end
end

local function isNameAllocated(state, writer, localsStack, localName)
	if state.topScopeNames[localName] then  return true  end

	for _, locals in ipairs(localsStack) do
		if locals[localName] then  return true  end
	end

	if localName:find"^_AWBO_" then  return true  end -- Assignment with binary operation.

	return false
end

local function allocateName(state, writer, localsStack, name, n, shortPrefix, longInfix)
	local localName

	if name == "_" then
		localName = "_"
	elseif outputDebugInfo then
		localName = unicodeToLuaIdentifier(name)
		if isNameAllocated(state, writer, localsStack, localName) then
			localName = localName .. longInfix .. n
		end
	else
		localName = shortPrefix .. n
	end

	localsStack[1][localName] = true

	return localName, n+1
end
local function allocateLocalName(state, writer, localsStack, name, n)
	return allocateName(state, writer, localsStack, name, n, "L", "_L")
end
local function allocateArgumentName(state, writer, localsStack, name, n)
	return allocateName(state, writer, localsStack, name, n, "A", "_A")
end

-- luaCall = writeNormalCall( state, writer, nextLocalN, localsStack, call )
local function writeNormalCall(state, writer, nextLocalN, localsStack, call)
	local callee               = call.callee
	local callingForeignMethod = false
	local luaCall              = luaParser.newNodeFast("call")
	luaCall.sourceNode         = call
	luaCall.adjustToOne        = call.surroundedByParentheses

	-- Write callee and handle method calls.
	if callee.nodeType == !(AST_IDENTIFIER) and isDeclarationConstant(callee.declaration) then
		local ident = callee
		local decl  = ident.declaration
		local const = decl.valueConstant

		!if DEBUG then
			if not const then
				if decl.value then  astPrintTree(decl.value)  end
				errorInternal(state, decl, "Missing constant object.")
			end
		!end

		if const.valueType.tag == !(TYPE_FUNCTION) and const.value.bodyIsForeign and const.value.foreignSource == "method" then
			callingForeignMethod = true
			local argExpr        = call.arguments[1] or errorInternal(state, call)
			luaCall.method       = true
			luaCall.callee       = luaParser.newNodeFast("lookup")
			luaCall.callee.object = writeExpression(state, writer, nextLocalN, localsStack, argExpr)

			local lambda          = const.value
			luaCall.callee.member = luaParser.newNodeFast("literal", lambda.foreignSourceName.value)

			if outputDebugInfo and lambda.foreignSourceName.value ~= ident.name then
				luaCall.callee.member.suffix = formatInfoComment(ident.name) -- Not sure this is that helpful...
			end

		else
			luaCall.callee = writeConstantValueOrReference(state, writer, const, ident)
		end

	else
		luaCall.callee = writeExpression(state, writer, nextLocalN, localsStack, callee)
	end

	-- Write given sequential arguments.
	for i = (callingForeignMethod and 2 or 1), #call.arguments do
		local luaArg = writeExpression(state, writer, nextLocalN, localsStack, call.arguments[i])
		table.insert(luaCall.arguments, luaArg)
	end

	-- Write given named arguments and handle default values.
	local lambda = getDataForHandlingMissingArguments(state, callee)

	if lambda then
		local lastValue = getLast(call.arguments)

		local lastValueIsList = (lastValue ~= nil and (
			(
				lastValue.inferredType.tag == !(TYPE_VARARG)
				and not lastValue.surroundedByParentheses
			)
			or (
				lastValue.inferredType.tag == !(TYPE_LIST)
				and not lastValue.surroundedByParentheses
				and lastValue.inferredType[2] ~= nil
			)
		))

		if lastValueIsList then
			local argTypesIn         = lambda.inferredType.argumentTypesIn
			local isVararg           = getLast(argTypesIn).tag == !(TYPE_VARARG)
			local lastNonVarargIndex = #argTypesIn - (isVararg and 1 or 0)
			local lastNonVarargType  = argTypesIn[lastNonVarargIndex]

			--[[
			local lastValueListSize = 0
			if not lastValueIsList then
				-- void
			elseif lastValue.inferredType.tag == !(TYPE_VARARG) then
				lastValueListSize    = 1/0
			else
				local lastArgOutType = getLast(lastValue.inferredType) or errorInternal(state, lastValue)
				lastValueListSize    = lastArgOutType.tag == !(TYPE_VARARG) and 1/0 or #lastValue.inferredType
			end
			--]]

			if not isVararg and not lastNonVarargType.isRequired --[[and lastNonVarargIndex > #call.arguments-1+lastValueListSize]] then
				-- :DisallowListAsLastValueToFunctionWithOptionalArguments
				writerError(state, call, "@Incomplete: Handle optional arguments if the last argument in a call is a list of values.")
			end
		end

		local argsIn = lambda.argumentsIn.arguments

		for argIndex = #call.arguments+1, #argsIn do
			local argNamed  = itemWith1(call.argumentsNamed, "argumentIndex", argIndex)
			local valueExpr = argNamed and argNamed.value or argsIn[argIndex].declaration.value

			if not valueExpr then
				-- Varargs are optional but have no default value (or zero default values since it's technically a list).
				-- !ASSERT(`not argsIn[argIndex+1]`, nil, `call`) -- This assert is not correct if the last call argument is another call that returns values before the vararg.
				break

			elseif argNamed then
				local luaArg = writeExpression(state, writer, nextLocalN, localsStack, valueExpr)
				table.insert(luaCall.arguments, luaArg)

			elseif lambda.bodyIsForeign then
				-- Don't write default values for foreign functions. This gives the foreign site control over
				-- what the actual default values should be no matter what the local !foreign declaration says.
				break

			elseif valueExpr.nodeType == !(AST_LOCATION) and valueExpr.ofCaller then
				local const = call.locationConstant or errorInternal(state, call, "Missing caller location data.")
				local luaArg = writeConstantValueOrReference(state, writer, const, valueExpr)
				table.insert(luaCall.arguments, luaArg)

			else
				local luaArg = writeExpression(state, writer, nextLocalN, localsStack, valueExpr)
				table.insert(luaCall.arguments, luaArg)
			end
		end
	end

	return luaCall
end

local function writeInlineCallStatement(state, writer, nextLocalN, localsStack, call, luaBlock)
	--[[
		-- Example...

		-- In:
		local func :: inline (x,y:int) -> int, string {
			x *= 2
			return x + y, ""
		}
		local x    = 99
		local y, s = func(x+1, 6)

		-- Out:
		local x = 99
		local y, s
		do
			local x2, y2 = x+1, 6
			x2   = x2 * 2
			y, s = x2 + y2, ""
		end
	]]

	if call.isMethod then  errorInternal(state, call, "@Incomplete: Inline method calls.")  end -- Isn't this for just foreign functions? In that case inlining is not possible.

	if call.parent.nodeType ~= !(AST_BLOCK) then
		-- @UX: Detect this error earlier.
		writerError(state, call, "Inline calls only supported at statement level.") -- :InlineCallsInMorePlaces
	end

	local lambda = call.callee.declaration.valueConstant.value

	if writer.inlineFunctions[lambda] then
		writerError(state, call.callee, "Function is trying to inline itself, directly or indirectly.")
	elseif writer.inlineDepth > 100 then -- @Hardcoded
		writerError(state, call.callee, "Too many recursive function inlines.")
	end
	writer.inlineDepth             = writer.inlineDepth + 1
	writer.inlineFunctions[lambda] = call

	if lambda.argumentsIn or doesImperativeBlockHaveVariableDeclarations(lambda.body) then
		local luaInnerBlock      = !!(LUA_STATEMENT[[ do end ]]) ; table.insert(luaBlock.statements, luaInnerBlock)
		luaInnerBlock.sourceNode = call
		luaBlock                 = luaInnerBlock
	end
	if lambda.argumentsOut then
		errorInternal(state, call, "@Incomplete: Handle return values when inlining.")
	end

	-- Write arguments.
	if lambda.argumentsIn then
		-- @Incomplete: Push localsStack here? It'd be nice to share push with the writeBlock() below.
		local luaDecl = luaParser.newNodeFast("declaration") ; table.insert(luaBlock.statements, luaDecl)

		for i, arg in ipairs(lambda.argumentsIn.arguments) do
			local decl                 = arg.declaration
			local identOrVarargOrBlank = decl.name

			if identOrVarargOrBlank.nodeType == !(AST_VARARG) then
				errorInternal(state, call, "@Incomplete: Inline vararg.")
			end

			decl.localName, nextLocalN = allocateLocalName(state, writer, localsStack, decl.name.name, nextLocalN) -- May overwrite old localName. I think that's OK.

			local name       = writeIdentifierName(state, writer, identOrVarargOrBlank)
			luaDecl.names[i] = luaParser.newNodeFast("identifier", name)
		end

		-- @Incomplete: Optional arguments.
		for i, argExpr in ipairs(call.arguments) do
			luaDecl.values[i] = writeExpression(state, writer, nextLocalN, localsStack, argExpr)
		end
	end

	writeBlock(state, writer, nextLocalN, localsStack, lambda.body, false, luaBlock)

	writer.inlineDepth             = writer.inlineDepth - 1
	writer.inlineFunctions[lambda] = nil
end

-- luaExpr = writeExpression( state, writer, nextLocalN, localsStack, expression )
--[[local ]]function writeExpression(state, writer, nextLocalN, localsStack, expr)
	!ASSERT(`expr.inferredType`, nil, `expr`)
	local nodeType = expr.nodeType
	local luaExpr

	if nodeType == !(AST_CALL) then
		local call = expr
		assert(call.inline ~= !(INLINE_YES)) -- :InlineCallsInMorePlaces
		luaExpr = writeNormalCall(state, writer, nextLocalN, localsStack, call)

	elseif nodeType == !(AST_UNARY) then
		local unary = expr

		-- Lua doesn't have unary '+'.
		if unary.operation == "+" then
			luaExpr = writeExpression(state, writer, nextLocalN, localsStack, unary.expression)

		-- Length of vararg.
		elseif unary.operation == "#" and unary.expression.nodeType == !(AST_VARARG) then
			luaExpr            = !!(LUA_EXPRESSION[[ _SELECT("#", ...) ]])
			luaExpr.sourceNode = unary

		-- For 'if not n', output 'if n==0' instead of 'if not(n~=0)'.
		elseif unary.operation == "not" and unary.expression.nodeType == !(AST_CAST) and !!(CONST_SET{ TYPE_STRING, TYPE_INT, TYPE_FLOAT })[unary.expression.expression.inferredType.tag] then
			local cast = unary.expression
			local expr = cast.expression

			luaExpr            = luaParser.newNodeFast("binary", "==")
			luaExpr.sourceNode = unary
			luaExpr.left       = writeExpression(state, writer, nextLocalN, localsStack, expr)

			if expr.inferredType.tag == !(TYPE_STRING) then
				luaExpr.right = !!(LUA_EXPRESSION[[ "" ]])
			else
				luaExpr.right = !!(LUA_EXPRESSION[[ 0 ]])
			end

		-- Other operations.
		else
			luaExpr            = luaParser.newNodeFast("unary", unary.operation)
			luaExpr.sourceNode = unary
			luaExpr.expression = writeExpression(state, writer, nextLocalN, localsStack, unary.expression)
		end

	elseif nodeType == !(AST_BINARY) then
		local binary = expr
		luaExpr = writeBinaryOperation(
			state, writer, nextLocalN, localsStack,
			binary.left, binary.right,
			binary.operation,
			binary.left.inferredType, binary.right.inferredType, binary.inferredType,
			binary
		)

	elseif nodeType == !(AST_LITERAL) then
		local literal = expr
		!ASSERT(`literal.valueConstant`, nil, `literal`)
		luaExpr = writeConstantValueOrReference(state, writer, literal.valueConstant, literal)

	elseif nodeType == !(AST_IDENTIFIER) then
		local ident = expr
		local decl  = ident.declaration
		!ASSERT `ident.inferredType`
		!ASSERT `decl`

		if isDeclarationConstant(decl) then
			luaExpr = writeConstantValueOrReference(state, writer, decl.valueConstant, ident)
		else
			local name         = writeIdentifierName(state, writer, ident)
			luaExpr            = luaParser.newNodeFast("identifier", name)
			luaExpr.sourceNode = ident
		end

	elseif nodeType == !(AST_VARARG) then
		local vararg        = expr
		luaExpr             = !!(LUA_EXPRESSION[[ ... ]])
		luaExpr.sourceNode  = vararg
		luaExpr.adjustToOne = vararg.surroundedByParentheses

	elseif nodeType == !(AST_BLANK) then
		luaExpr            = !!(LUA_EXPRESSION[[ _ ]])
		luaExpr.sourceNode = expr

	elseif nodeType == !(AST_TYPE) then
		local typeNode = expr

		-- @Cleanup: We probably have a constant for the type ID to use with writeConstantValue() here, but whatever!
		luaExpr            = luaParser.newNodeFast("literal", typeNode.representedType.id)
		luaExpr.sourceNode = typeNode

		if outputDebugInfo then
			luaExpr.suffix = formatInfoComment(getFriendlyTypeInfoName(typeNode.representedType))
		end

	elseif nodeType == !(AST_LAMBDA) then
		local lambda = expr
		if lambda.captures or lambda.captureAll then
			luaExpr     = writeFunction(state, writer, nextLocalN, localsStack, lambda)
		else
			local const = lambda.valueConstant or errorInternal(state, lambda)
			luaExpr     = writeConstantValueOrReference(state, writer, const, lambda)
		end

	elseif nodeType == !(AST_ACCESS) then
		local access = expr
		luaExpr      = writeAccess(state, writer, nextLocalN, localsStack, access)

	elseif nodeType == !(AST_CAST) then
		local cast = expr
		luaExpr    = writeCast(state, writer, nextLocalN, localsStack, cast, nil)

	elseif nodeType == !(AST_TABLE) then
		local tableNode      = expr
		luaExpr              = !!(LUA_EXPRESSION[[ {} ]])
		luaExpr.sourceNode   = tableNode
		local luaTableFields = luaExpr.fields

		if tableNode.inferredType.tag == !(TYPE_TABLE) then
			for _, tableField in ipairs(tableNode.fields) do
				if not (isExpressionNil(tableField.value) and isExpressionConstant(state, tableField.key, true)) then
					-- @Polish: Output sequence values without key in generic table constructors.
					local luaTableField = {
						key   = writeExpression(state, writer, nextLocalN, localsStack, tableField.key),
						value = writeExpression(state, writer, nextLocalN, localsStack, tableField.value),
					}
					table.insert(luaTableFields, luaTableField)
				end
			end

		elseif tableNode.inferredType.tag == !(TYPE_ARRAY) then
			for _, tableField in ipairs(tableNode.fields) do
				!ASSERT("tableField.key.nodeType == "..AST_LITERAL) -- :VariableArrayIndices

				local luaTableField = {key=nil, value=nil}
				table.insert(luaTableFields, luaTableField)

				if tableField.keyIsGenerated then
					luaTableField.generatedKey = true
				else
					luaTableField.key = writeExpression(state, writer, nextLocalN, localsStack, tableField.key)
				end
				luaTableField.value = writeExpression(state, writer, nextLocalN, localsStack, tableField.value)
			end

		elseif tableNode.inferredType.tag == !(TYPE_STRUCT) then
			local structInfo = tableNode.inferredType
			!ASSERT `not structInfo.isPolymorphic`

			for _, member in ipairs(structInfo.members) do
				local tableField = findTableFieldByNameInStructConstructor(state, tableNode, member.name)

				if not (tableField or isStructMemberDefaultValueNil(state, structInfo.astNode, member.name, tableNode)) then
					local luaTableField = {
						key   = writeTableConstructorKeyName(writer, member.name, tableNode), -- @Polish: Better source node (if needed here).
						value = writeDefaultValueForStructMember(state, writer, nextLocalN, localsStack, structInfo, member, tableNode), -- @UX: Maybe use a better nodeForError.
					}
					table.insert(luaTableFields, luaTableField)
				end
			end

			for _, tableField in ipairs(tableNode.fields) do
				if tableField.keyIsGenerated or not isExpressionNil(tableField.value) then
					local luaTableField = {key=nil, value=nil}
					table.insert(luaTableFields, luaTableField)

					if tableField.keyIsGenerated then
						luaTableField.generatedKey = true
					else
						luaTableField.key = writeExpression(state, writer, nextLocalN, localsStack, tableField.key)
					end
					luaTableField.value = writeExpression(state, writer, nextLocalN, localsStack, tableField.value)
				end
			end

		else
			errorUnhandledType(state, tableNode, tableNode.inferredType)
		end

		if tableNode.trailingExpression then
			local luaTableField = {
				generatedKey = true,
				value        = writeExpression(state, writer, nextLocalN, localsStack, tableNode.trailingExpression),
			}
			table.insert(luaTableFields, luaTableField)
		end

	elseif nodeType == !(AST_FOREIGN) then
		local foreign = expr
		luaExpr       = writeConstantValueOrReference(state, writer, foreign.valueConstant, foreign)

	elseif nodeType == !(AST_TYPE_INFO) then
		local typeInfoNode = expr
		luaExpr            = writeConstantValueOrReference(state, writer, typeInfoNode.valueConstant, typeInfoNode)

	elseif nodeType == !(AST_LOCATION) then
		local loc = expr
		luaExpr   = writeConstantValueOrReference(state, writer, loc.valueConstant, loc)

	elseif nodeType == !(AST_CONDITIONAL) then
		local conditional = expr
		local hasVararg   = false

		astVisitAllNodes(conditional, function(node)
			if node.nodeType == !(AST_VARARG) then
				hasVararg = true
				return !(VISIT_BREAK)
			elseif isScope(node) then
				return !(VISIT_IGNORE_CHILDREN)
			end
		end)

		-- Ternary.
		if not conditional.conditionAndBranchTrue then
			if doesTypeContainBoolOrNone(adjustTypeToOne(state, conditional.branchTrue, conditional.branchTrue.inferredType, true)) then
				-- (function(x) if x then return a else return b end end)(x)
				luaExpr = !!(LUA_EXPRESSION[=[
					(function(_CONDITION--[[x]])
						if _CONDITION--[[x]] then
							return -- a
						else
							return -- b
						end
					end)(--[[x]])
				]=])
				luaExpr.sourceNode = conditional
				local luaFunc      = luaExpr.callee
				local luaIfNode    = luaFunc.body.statements[1]

				if hasVararg then  luaFunc.parameters[2] = !!(LUA_EXPRESSION[[ ... ]])  end
				luaIfNode.bodyTrue .statements[1].values[1] = writeExpression(state, writer, nextLocalN, localsStack, conditional.branchTrue)
				luaIfNode.bodyFalse.statements[1].values[1] = writeExpression(state, writer, nextLocalN, localsStack, conditional.branchFalse)
				luaExpr.arguments[1]                        = writeExpression(state, writer, nextLocalN, localsStack, conditional.condition)
				if hasVararg then  luaFunc.parameters[2] = !!(LUA_EXPRESSION[[ ... ]])  end

			else
				-- x and a or b
				luaExpr = !!(LUA_EXPRESSION(
					[=[
						(x and a) or b
					]=],
					function(luaBinary)
						luaBinary.left.left  = nil
						luaBinary.left.right = nil
						luaBinary.right      = nil
					end
				))
				luaExpr.sourceNode = conditional

				luaExpr.left.left  = writeExpression(state, writer, nextLocalN, localsStack, conditional.condition)
				luaExpr.left.right = writeExpression(state, writer, nextLocalN, localsStack, conditional.branchTrue)
				luaExpr.right      = writeExpression(state, writer, nextLocalN, localsStack, conditional.branchFalse)
			end

		-- Binary (with implicit cast).
		-- @Optimize: Output 'a or b' whenever possible.
		elseif conditional.conditionAndBranchTrue ~= conditional.condition then
			-- (function(x) if x then return x else return y end end)(x)
			local cast = conditional.condition
			assert(cast.nodeType   == !(AST_CAST))
			assert(cast.expression == conditional.conditionAndBranchTrue)
			assert(cast.isImplicit)

			luaExpr = !!(LUA_EXPRESSION(
				[=[
					(function(_CONDITION--[[x]])
						if x then
							return _CONDITION -- x
						else
							return -- y
						end
					end)(--[[x]])
				]=],
				function(luaCall)
					luaCall.callee.body.statements[1].condition = nil
				end
			))
			luaExpr.sourceNode = conditional
			local luaFunc      = luaExpr.callee
			local luaIfNode    = luaFunc.body.statements[1]

			if hasVararg then  luaFunc.parameters[2] = !!(LUA_EXPRESSION[[ ... ]])  end
			luaIfNode.condition                         = writeCast      (state, writer, nextLocalN, localsStack, cast, "_CONDITION")
			luaIfNode.bodyFalse.statements[1].values[1] = writeExpression(state, writer, nextLocalN, localsStack, conditional.branchFalse)
			luaExpr.arguments[1]                        = writeExpression(state, writer, nextLocalN, localsStack, cast.expression)
			if hasVararg then  luaExpr.arguments[2] = !!(LUA_EXPRESSION[[ ... ]])  end

		-- Binary (without implicit cast).
		-- @Optimize: Output 'a or b' whenever possible.
		else
			-- (function(x) if x then return x else return y end end)(x)
			luaExpr = !!(LUA_EXPRESSION[=[
				(function(_CONDITION--[[x]])
					if _CONDITION--[[x]] then
						return _CONDITION -- x
					else
						return -- y
					end
				end)(--[[x]])
			]=])
			luaExpr.sourceNode = conditional
			local luaFunc      = luaExpr.callee
			local luaIfNode    = luaFunc.body.statements[1]

			if hasVararg then  luaFunc.parameters[2] = !!(LUA_EXPRESSION[[ ... ]])  end
			luaIfNode.bodyFalse.statements[1].values[1] = writeExpression(state, writer, nextLocalN, localsStack, conditional.branchFalse)
			luaExpr.arguments[1]                        = writeExpression(state, writer, nextLocalN, localsStack, conditional.condition)
			if hasVararg then  luaExpr.arguments[2] = !!(LUA_EXPRESSION[[ ... ]])  end
		end

	elseif nodeType == !(AST_NULL) then
		luaExpr            = !!(LUA_EXPRESSION[[ nil ]])
		luaExpr.sourceNode = expr

	elseif expr.inferredType.tag == !(TYPE_NAMESPACE) then
		writerError(state, expr, "Invalid place for a namespace.")
	else
		errorUnhandledNodeType(state, expr)
	end

	if not luaExpr then
		errorInternal(state, expr)
	end

	return luaExpr
end

-- luaExpression = writeDefaultValueForType( state, writer, nextLocalN, localsStack, typeInfo, nodeForError )
--[[local ]]function writeDefaultValueForType(state, writer, nextLocalN, localsStack, typeInfo, nodeForError)
	local tag = typeInfo.tag
	local luaExpr

	if     tag == !(TYPE_ANY)    then  luaExpr = !!(LUA_EXPRESSION[[ nil   ]])
	elseif tag == !(TYPE_BOOL)   then  luaExpr = !!(LUA_EXPRESSION[[ false ]])
	elseif tag == !(TYPE_INT)    then  luaExpr = !!(LUA_EXPRESSION[[ 0     ]])
	elseif tag == !(TYPE_NONE)   then  luaExpr = !!(LUA_EXPRESSION[[ nil   ]])
	elseif tag == !(TYPE_FLOAT)  then  luaExpr = !!(LUA_EXPRESSION[[ 0.0   ]])
	elseif tag == !(TYPE_STRING) then  luaExpr = !!(LUA_EXPRESSION[[ ""    ]])

	elseif tag == !(TYPE_ARRAY) or tag == !(TYPE_TABLE) then
		luaExpr = !!(LUA_EXPRESSION[[ {} ]])

	elseif tag == !(TYPE_STRUCT) then
		local structInfo = typeInfo
		!ASSERT `not structInfo.isPolymorphic`

		if structInfo.astNode.isForeign then
			-- @Speed: Detect this sooner (probably when inferring AstDeclaration).
			!TRACE()
			printerr()
			nodeMessage(io.stderr, state, nodeForError, "Error", "Typer", "Cannot instantiate foreign struct '%s'.", getFriendlyTypeInfoName(structInfo))
			-- if structInfo.astNode.foreignThroughNode then
			-- 	nodeMessage(io.stderr, state, structInfo.astNode.foreignThroughNode, "Info", "Typer", "...the struct got its foreign state through this.")
			-- end
			exitFailure()
		end

		luaExpr              = !!(LUA_EXPRESSION[[ {} ]])
		local luaTableFields = luaExpr.fields

		for i, member in ipairs(structInfo.members) do
			local luaKeyExpr = writeDefaultValueForStructMember(state, writer, nextLocalN, localsStack, structInfo, member, nodeForError)

			if not (luaKeyExpr.type == "literal" and luaKeyExpr.value == nil) then
				local luaTableField = {
					key   = writeTableConstructorKeyName(writer, member.name, nodeForError), -- @Polish: Better source node?
					value = luaKeyExpr,
				}
				table.insert(luaTableFields, luaTableField)
			end
		end

	else
		if doesTypeHaveAnyDefaultValue(typeInfo) then
			errorInternal("Incomplete: Write default value for type group '%s'.", TYPE_NAMES[typeInfo.tag])
		else
			writerError(state, nodeForError, "There is no default value for %s.", getFriendlyTypeInfoName(typeInfo))
		end
	end

	luaExpr.sourceNode = nodeForError -- @Polish: Better source node?
	return luaExpr
end

local function writeDefers(state, writer, nextLocalN, localsStack, defers, luaBlock)
	if not defers[1] then  return  end

	for i = #defers, 1, -1 do
		local block = defers[i].body

		if doesImperativeBlockHaveVariableDeclarations(block) then
			local luaInnerBlock      = !!(LUA_STATEMENT[[ do end ]]) ; table.insert(luaBlock.statements, luaInnerBlock)
			luaInnerBlock.sourceNode = defers[i]
			writeBlock(state, writer, nextLocalN, localsStack, block, false, luaInnerBlock)
		else
			writeBlock(state, writer, nextLocalN, localsStack, block, false, luaBlock)
		end
	end
end

-- luaBlock = handleContinueAfterBlock( state, writer, parentContinueDepth, prevContinueDepth, siblings, siblingIndex, luaBlock )
local function handleContinueAfterBlock(state, writer, parentContinueDepth, prevContinueDepth, siblings, siblingIndex, luaBlock)
	-- if writer.continueDepth <= parentContinueDepth then  return luaBlock  end
	if writer.continueDepth == 0 then  return luaBlock  end

	if writer.continueDepth == prevContinueDepth then
		writer.continueDepth = writer.continueDepth + 1
	end

	if not siblings[siblingIndex+1] then  return luaBlock  end

	if not (writer.continueDepth == 1 and !!(CONST_SET{ AST_FOR, AST_WHILE })[siblings[1].parent.parent.nodeType] and siblings[1].parent.parent.hasContinues) then
		local hasContinue = false

		for i = siblingIndex, 1, -1 do
			if i < siblingIndex and !!(CONST_SET{ AST_FOR, AST_WHILE, AST_BLOCK, AST_IF, AST_SWITCH })[siblings[i].nodeType] then
				-- This should be the last time handleContinueAfterBlock() was called in this scope.
				break
			end

			astVisitAllNodesInUnit(siblings[i], false, function(node)
				-- @Polish: Only look for continues crossing our block.
				if node.nodeType == !(AST_CONTINUE) then
					hasContinue = true
					return !(VISIT_BREAK)
				end
			end)

			if hasContinue then  break  end
		end

		if not hasContinue then  return luaBlock  end
	end

	-- @Cleanup @Speed: Make 'if _JUMP>0 then...end if _JUMP==0' into 'if _JUMP>0 then...else'.
	local luaIfNode = !!(LUA_STATEMENT[[ if _JUMP == 0 then end ]]) ; table.insert(luaBlock.statements, luaIfNode)
	luaBlock        = luaIfNode.bodyTrue -- Put the rest of the parent block inside this new trailing/indented block.

	return luaBlock
end

-- luaBlock = writeLoopBodyAndFooter( state, writer, loop, nextLocalN, localsStack, deferStartIndex, siblings, siblingIndex, parentContinueDepth, luaUnindentedBlock, luaLoopBody, luaBlock )
local function writeLoopBodyAndFooter(state, writer, loop, nextLocalN, localsStack, deferStartIndex, siblings, siblingIndex, parentContinueDepth, luaUnindentedBlock, luaLoopBody, luaBlock)
	local loopStack = writer.loopStack

	writer.loopDepth                          = writer.loopDepth   + 1
	writer.loopDeferIndices[writer.loopDepth] = #writer.deferStack + 1

	-- No named jump involved.
	if not (loop.hasNamedJumps or loopStack[1]) then
		writeBlock(state, writer, nextLocalN, localsStack, loop.body, false, luaLoopBody)

		writer.loopDeferIndices[writer.loopDepth] = nil
		writer.loopDepth                          = writer.loopDepth - 1

		return luaBlock
	end

	-- Named jumps are involved.

	if loopStack[1] then
		table.insert(luaUnindentedBlock.statements, !!(LUA_STATEMENT[[ _JUMP = 0 ]]))
	else
		table.insert(luaUnindentedBlock.statements, !!(LUA_STATEMENT[[ local _JUMP, _BREAK = 0, false ]]))
	end

	table.insert(loopStack, loop)

	local prevContinueDepth = writer.continueDepth
	writeBlock(state, writer, nextLocalN, localsStack, loop.body, false, luaLoopBody)

	table.remove(loopStack)

	if loopStack[1] then
		local deferStartIndexJump = writer.loopDeferIndices[writer.loopDepth-1] or deferStartIndex
		local defers              = writer.deferStack[deferStartIndexJump] and {unpack(writer.deferStack, deferStartIndexJump)} or EMPTY_TABLE
		local luaIfNode           = !!(LUA_STATEMENT[[ if _JUMP > 0 then end ]]) ; table.insert(luaBlock.statements, luaIfNode)

		writeDefers(state, writer, nextLocalN, localsStack, defers, luaIfNode.bodyTrue)

		if loopStack[2] then
			table.insert(luaIfNode.bodyTrue.statements, !!(LUA_STATEMENT[[ if _BREAK or _JUMP > 1 then  _JUMP = _JUMP-1 ; break  end ]]))
		else
			table.insert(luaIfNode.bodyTrue.statements, !!(LUA_STATEMENT[[ if _BREAK or _JUMP > 1 then  break  end ]]))
		end
	end

	writer.loopDeferIndices[writer.loopDepth] = nil
	writer.loopDepth                          = writer.loopDepth - 1

	luaBlock = handleContinueAfterBlock(state, writer, parentContinueDepth, prevContinueDepth, siblings, siblingIndex, luaBlock)
	return luaBlock
end

local function doesContinueCrossNode(state, node)
	-- @Polish: Check more exactly for an actual crossing.
	while true do
		node = astFindParent(node, !!(CONST_SET{ AST_FOR, AST_WHILE, AST_LAMBDA }))
		if not node or node.nodeType == !(AST_LAMBDA) then  return false  end

		if node.hasContinues then  return true  end
	end
end

--[[local ]]function writeBlock(state, writer, nextLocalN, localsStack, block, isElseif, luaBlock0)
	!ASSERT `not block[1]`
	if not block.statementsDynamic[1] then  return  end

	local deferStartIndex     = #writer.deferStack + 1
	local parentContinueDepth = writer.continueDepth
	local gotContinue         = false

	localsStack    = {{}, unpack(localsStack)} -- @Speed: We can probably handle locals like defers.
	local inDecl   = false
	local luaBlock = luaBlock0

	for statementIndex, statement in ipairs(block.statementsDynamic) do
		!local ASSERT_STATEMENT = DEBUG and 1==0
		!if ASSERT_STATEMENT then
			!ASSERT(`luaBlock`,                 nil,             `statement`)
			!ASSERT(`luaBlock.type == "block"`, `luaBlock.type`, `statement`)
			!ASSERT(`luaBlock.statements`,      nil,             `statement`)
		!end

		local nodeType = statement.nodeType

		----------------------------------------------------------------
		if nodeType == !(AST_DECLARATION) then
			-- @Optimize: Output 'local a = nil' as 'local a'.
			local decl = statement
			assert(decl.kind == !(DECL_KIND_LOCAL_VAR) --[[or decl.kind == !(DECL_KIND_READ_ONLY)]])

			decl.localName, nextLocalN = allocateLocalName(state, writer, localsStack, decl.name.name, nextLocalN)

			if decl.assignment then
				-- The (initial) assignment should be written as the next statement (or after several consecutive declarations).
				inDecl = true

			else
				local luaDecl         = !!(LUA_STATEMENT[[ local x ]]) ; table.insert(luaBlock.statements, luaDecl)
				luaDecl.sourceNode    = decl
				luaDecl.names[1].name = decl.localName

				if decl.value then
					luaDecl.values[1] = writeExpression(state, writer, nextLocalN, localsStack, decl.value)
				else
					luaDecl.values[1] = writeDefaultValueForType(state, writer, nextLocalN, localsStack, decl.inferredType, decl.name)
				end
			end

		----------------------------------------------------------------
		elseif nodeType == !(AST_ASSIGNMENT) then
			local assignment = statement

			-- Plain assignment.
			if assignment.binaryOperation == "" then
				-- @Optimize: Output '_ = func()' as 'func()'.
				-- @Optimize: Output 'x, _ = func()' as 'x = func()'.
				local hasBlank = false
				local luaDeclOrAssignment

				if inDecl then
					local hasGaps = false

					for i = 1, #assignment.targets do
						if not assignment.declarations[i] then
							hasGaps = true
							break
						end
					end

					if hasGaps then
						-- @Robustness: Does this work for e.g. `local ^x, y = y, 0 !shadow`? The name generation hopefully makes the new 'y' not be a shadow.
						local luaDecl = luaParser.newNodeFast("declaration") ; table.insert(luaBlock.statements, luaDecl)

						for i, ident in ipairs(assignment.targets) do
							if ident.nodeType ~= !(AST_BLANK) and assignment.declarations[i] then
								!ASSERT("ident.nodeType == "..AST_IDENTIFIER)

								local name = writeIdentifierName(state, writer, ident)
								table.insert(luaDecl.names, luaParser.newNodeFast("identifier", name))
							end
						end

						luaDeclOrAssignment            = luaParser.newNodeFast("assignment")
						luaDeclOrAssignment.sourceNode = assignment

					else
						luaDeclOrAssignment            = luaParser.newNodeFast("declaration")
						luaDeclOrAssignment.sourceNode = assignment
					end

				else--if not inDecl then
					luaDeclOrAssignment            = luaParser.newNodeFast("assignment")
					luaDeclOrAssignment.sourceNode = assignment
				end

				table.insert(luaBlock.statements, luaDeclOrAssignment)
				local luaTargets = luaDeclOrAssignment.names or luaDeclOrAssignment.targets

				for i, targetExpr in ipairs(assignment.targets) do
					luaTargets[i] = writeExpression(state, writer, nextLocalN, localsStack, targetExpr)
					hasBlank      = hasBlank or targetExpr.nodeType == !(AST_BLANK)
				end

				for i, valueExpr in ipairs(assignment.values) do
					luaDeclOrAssignment.values[i] = writeExpression(state, writer, nextLocalN, localsStack, valueExpr)
				end

				if hasBlank and not isNameAllocated(state, writer, localsStack, "_") then
					-- We don't want to accidentally store an object that is subject to garbage collection as a global.
					table.insert(luaBlock.statements, !!(LUA_STATEMENT[[ _ = nil ]]))
				end

			-- Assignment with binary operation (AWBO).
			else
				!ASSERT `not inDecl`

				--
				-- To make expressions evaluate the expected way (left to
				-- right with no hidden duplicate evaluations) we prefetch
				-- some values before we start doing operations (and
				-- eventually the assignment).
				--
				-- Constants and right-hand-side values are never prefetched.
				-- These rules apply otherwise:
				--
				--   x        += 1    -- Don't fetch x.
				--   t.k      += 1    -- Don't fetch t. Don't fetch k.
				--   o.t[k]   += 1    -- Fetch o.t.     Don't fetch k.
				--   o.t[t.k] += 1    -- Fetch o.t.     Fetch t.k.
				--
				-- More info:
				--   x, y += 1, z  -- No fetching or preparations needed as all targets are simple variables/identifiers.
				--
				local fetchObj = {}
				local fetchKey = {}
				local fetchVal = {}

				-- Figure out what to fetch.
				for i, targetExpr in ipairs(assignment.targets) do
					if targetExpr.nodeType == !(AST_ACCESS) then
						local access = targetExpr

						if not (access.object.nodeType == !(AST_IDENTIFIER) or isExpressionConstant(state, access.object, true)) then
							fetchObj[i] = true
						end
						if not (access.member.nodeType == !(AST_IDENTIFIER) or isExpressionConstant(state, access.member, true)) then
							fetchKey[i] = true
						end
					end
				end

				if not assignment.values[#assignment.targets] then
					-- The last value ought to be a call! (Note: It shouldn't be vararg as that would've been a type error.)
					for i = #assignment.values, #assignment.targets do
						fetchVal[i] = true
					end
				end

				local fetchingAnything   = (next(fetchObj) or next(fetchKey) or next(fetchVal)) ~= nil
				local luaAssignmentBlock = luaBlock

				if fetchingAnything then
					luaAssignmentBlock = !!(LUA_STATEMENT[[ do end ]]) ; table.insert(luaBlock.statements, luaAssignmentBlock)

					-- Fetch objects and keys.
					if next(fetchObj) or next(fetchKey) then
						local luaDecl      = luaParser.newNodeFast("declaration") ; table.insert(luaAssignmentBlock.statements, luaDecl)
						luaDecl.sourceNode = assignment

						for i, targetExpr in ipairs(assignment.targets) do
							if fetchObj[i] then
								table.insert(luaDecl.names, luaParser.newNodeFast("identifier", "_AWBO_OBJ"..i))
							end
							if fetchKey[i] then
								table.insert(luaDecl.names, luaParser.newNodeFast("identifier", "_AWBO_KEY"..i))
							end
						end

						for i, targetExpr in ipairs(assignment.targets) do
							if fetchObj[i] then
								local access  = targetExpr
								local luaExpr = writeExpression(state, writer, nextLocalN, localsStack, access.object)
								table.insert(luaDecl.values, luaExpr)
							end
							if fetchKey[i] then
								local access  = targetExpr
								local luaExpr = writeExpression(state, writer, nextLocalN, localsStack, access.member)
								table.insert(luaDecl.values, luaExpr)
							end
						end
					end

					-- Fetch values.
					if next(fetchVal) then
						local luaDecl      = luaParser.newNodeFast("declaration") ; table.insert(luaAssignmentBlock.statements, luaDecl)
						luaDecl.sourceNode = assignment

						for i, targetExpr in ipairs(assignment.targets) do
							if fetchVal[i] then
								table.insert(luaDecl.names, luaParser.newNodeFast("identifier", "_AWBO_VAL"..i))
							end
						end

						for i, valueExpr in ipairs(assignment.values) do
							if fetchVal[i] then
								local luaExpr = writeExpression(state, writer, nextLocalN, localsStack, valueExpr)
								table.insert(luaDecl.values, luaExpr)
							end
						end
					end
				end--if fetchingAnything

				-- Assignment targets.
				local luaAssignment      = luaParser.newNodeFast("assignment") ; table.insert(luaAssignmentBlock.statements, luaAssignment)
				luaAssignment.sourceNode = assignment

				for i, targetExpr in ipairs(assignment.targets) do
					if fetchObj[i] or fetchKey[i] then
						local access             = targetExpr
						local luaLookup          = luaParser.newNodeFast("lookup")
						luaLookup.sourceNode     = access
						luaAssignment.targets[i] = luaLookup

						if fetchObj[i] then
							luaLookup.object = luaParser.newNodeFast("identifier", "_AWBO_OBJ"..i)
						else
							luaLookup.object = writeExpression(state, writer, nextLocalN, localsStack, access.object)
						end
						if fetchKey[i] then
							luaLookup.member = luaParser.newNodeFast("identifier", "_AWBO_KEY"..i)
						else
							luaLookup.member = writeExpression(state, writer, nextLocalN, localsStack, access.member)
						end

					else
						luaAssignment.targets[i] = writeExpression(state, writer, nextLocalN, localsStack, targetExpr)
					end
				end

				-- Assignment values.
				for i, targetExpr in ipairs(assignment.targets) do
					if fetchObj[i] or fetchKey[i] then
						local access              = targetExpr
						local accessDummy         = astNewNode(AstAccess, access, access.parent)
						accessDummy.XXX_AWBO_HACK = true
						accessDummy.object        = fetchObj[i] and "_AWBO_OBJ"..i or access.object -- @Hack!!!
						accessDummy.member        = fetchKey[i] and "_AWBO_KEY"..i or access.member -- @Hack!!!
						accessDummy.inferredType  = access.inferredType
						targetExpr                = accessDummy
					end

					local _, valueType = getAssignmentValue(state, targetExpr, assignment.values, i, nil, nil, nil, false)
					!ASSERT(`valueType`, `tostring(i)`, `assignment.values[i] or assignment`)

					luaAssignment.values[i] = writeBinaryOperation(
						state, writer, nextLocalN, localsStack,
						targetExpr, (fetchVal[i] and "_AWBO_VAL"..i or assignment.values[i]),
						assignment.binaryOperation,
						targetExpr.inferredType, valueType, targetExpr.inferredType,
						targetExpr
					)
				end
			end

			inDecl = false

		----------------------------------------------------------------
		elseif nodeType == !(AST_RETURN) then
			local returnNode = statement

			-- @Incomplete: Evaluate return values before running defers (right?).
			writeDefers(state, writer, nextLocalN, localsStack, writer.deferStack, luaBlock)

			if block.parent.nodeType == !(AST_LAMBDA) and not returnNode.values[1] then
				-- void  Note: This can only be the last statement in the lambda.

			else
				local luaReturnNode      = !!(LUA_STATEMENT[[ return ]]) ; table.insert(luaBlock.statements, luaReturnNode)
				luaReturnNode.sourceNode = returnNode

				for i, expr in ipairs(returnNode.values) do
					luaReturnNode.values[i] = writeExpression(state, writer, nextLocalN, localsStack, expr)
				end
			end

		----------------------------------------------------------------
		elseif nodeType == !(AST_BLOCK) then
			local innerBlock         = statement
			local luaInnerBlock      = !!(LUA_STATEMENT[[ do end ]]) ; table.insert(luaBlock.statements, luaInnerBlock)
			luaInnerBlock.sourceNode = innerBlock

			local prevContinueDepth = writer.continueDepth
			writeBlock(state, writer, nextLocalN, localsStack, innerBlock, false, luaInnerBlock)

			luaBlock = handleContinueAfterBlock(state, writer, parentContinueDepth, prevContinueDepth, block.statementsDynamic, statementIndex, luaBlock)

		----------------------------------------------------------------
		elseif nodeType == !(AST_IF) then
			-- @Optimize: Don't output empty branches.
			local ifBranch       = statement
			local luaIfNode      = !!(LUA_STATEMENT([[ if x then end ]], function(luaIfNode)luaIfNode.condition=nil;end)) ; table.insert(luaBlock.statements, luaIfNode)
			luaIfNode.sourceNode = ifBranch
			luaIfNode.condition  = writeExpression(state, writer, nextLocalN, localsStack, ifBranch.condition)

			local prevContinueDepth = writer.continueDepth
			writeBlock(state, writer, nextLocalN, localsStack, ifBranch.branchTrue, false, luaIfNode.bodyTrue)

			local maxContinue1   = writer.continueDepth
			writer.continueDepth = prevContinueDepth

			if not (ifBranch.branchFalse and ifBranch.branchFalse.statementsDynamic[1]) then
				-- void

			elseif not ifBranch.branchFalse.statementsDynamic[2] and ifBranch.branchFalse.statementsDynamic[1].nodeType == !(AST_IF) and not doesContinueCrossNode(state, ifBranch) then
				luaIfNode.bodyFalse = !!(LUA_STATEMENT[[ do end ]])
				writeBlock(state, writer, nextLocalN, localsStack, ifBranch.branchFalse, true, luaIfNode.bodyFalse)

			else
				luaIfNode.bodyFalse = !!(LUA_STATEMENT[[ do end ]])
				writeBlock(state, writer, nextLocalN, localsStack, ifBranch.branchFalse, false, luaIfNode.bodyFalse)
			end

			writer.continueDepth = math.max(maxContinue1, writer.continueDepth)

			if not isElseif then
				luaBlock = handleContinueAfterBlock(state, writer, parentContinueDepth, prevContinueDepth, block.statementsDynamic, statementIndex, luaBlock)
			end

		----------------------------------------------------------------
		elseif nodeType == !(AST_WHILE) then
			-- @Optimize: Don't output an empty body.
			local whileLoop         = statement
			local luaWhileLoop      = !!(LUA_STATEMENT([[ while x do end ]], function(luaWhileLoop)luaWhileLoop.condition=nil;end)) ; table.insert(luaBlock.statements, luaWhileLoop)
			luaWhileLoop.sourceNode = whileLoop
			luaWhileLoop.condition  = writeExpression(state, writer, nextLocalN, localsStack, whileLoop.condition)

			luaBlock = writeLoopBodyAndFooter(state, writer, whileLoop, nextLocalN, localsStack, deferStartIndex, block.statementsDynamic, statementIndex, parentContinueDepth, luaBlock0, luaWhileLoop.body, luaBlock)

		----------------------------------------------------------------
		elseif nodeType == !(AST_FOR) then
			-- @Optimize: Don't output an empty body.
			local forLoop         = statement
			local luaForLoop      = luaParser.newNodeFast("for", "numeric") ; table.insert(luaBlock.statements, luaForLoop)
			luaForLoop.sourceNode = forLoop
			luaForLoop.body       = !!(LUA_STATEMENT[[ do end ]])
			local localsStack     = {{}, unpack(localsStack)}

			for _, decl in ipairs(forLoop.declarations) do
				decl.localName, nextLocalN = allocateLocalName(state, writer, localsStack, decl.name.name, nextLocalN)
			end

			-- for i = x, y
			if forLoop.forType == !(FOR_NUMERIC) then
				luaForLoop.kind = "numeric"
				local decl      = forLoop.declarations[1]
				local values    = forLoop.expressions

				do
					luaForLoop.names[1]  = luaParser.newNodeFast("identifier", writeIdentifierName(state, writer, decl.name))
					luaForLoop.values[1] = writeExpression(state, writer, nextLocalN, localsStack, values[1])
					luaForLoop.values[2] = writeExpression(state, writer, nextLocalN, localsStack, values[2])
				end
				if values[3] then
					luaForLoop.values[3] = writeExpression(state, writer, nextLocalN, localsStack, values[3])
				end

				luaBlock = writeLoopBodyAndFooter(state, writer, forLoop, nextLocalN, localsStack, deferStartIndex, block.statementsDynamic, statementIndex, parentContinueDepth, luaBlock0, luaForLoop.body, luaBlock)

			-- for expression
			elseif forLoop.forType == !(FOR_SHORT) then
				local objExpr = forLoop.expressions[1]
				local objType = objExpr.inferredType

				-- for ...
				if objType.tag == !(TYPE_VARARG) then
					luaForLoop.kind = "numeric"
					!ASSERT("objExpr.nodeType == "..AST_VARARG)

					local name          = writeIdentifierName(state, writer, forLoop.declarations[1].name)
					luaForLoop.names[1] = luaParser.newNodeFast("identifier", name)

					if forLoop.reverse then
						luaForLoop.values[1] = !!(LUA_EXPRESSION[[ _SELECT("#", ...) ]])
						luaForLoop.values[2] = !!(LUA_EXPRESSION[[ 1  ]])
						luaForLoop.values[3] = !!(LUA_EXPRESSION[[ -1 ]])
					else
						luaForLoop.values[1] = !!(LUA_EXPRESSION[[ 1 ]])
						luaForLoop.values[2] = !!(LUA_EXPRESSION[[ _SELECT("#", ...) ]])
					end

					local luaDecl                       = !!(LUA_STATEMENT[[ local x = _SELECT(x, ...) ]]) ; table.insert(luaForLoop.body.statements, luaDecl)
					luaDecl.names[1].name               = writeIdentifierName(state, writer, forLoop.declarations[2].name)
					luaDecl.values[1].arguments[1].name = writeIdentifierName(state, writer, forLoop.declarations[1].name)

				-- for object
				else
					luaForLoop.kind = "generic"
					objType         = adjustTypeToOne(state, objExpr, objType, true)

					for i, decl in ipairs(forLoop.declarations) do
						luaForLoop.names[i] = luaParser.newNodeFast("identifier", writeIdentifierName(state, writer, decl.name))
					end

					local luaCall

					if objType.tag == !(TYPE_ARRAY) or (objType.tag == !(TYPE_STRUCT) and objType.kind == !(STRUCT_KIND_ARRAY)) then
						luaCall = (
							forLoop.reverse
							and !!(LUA_EXPRESSION[[ _IPAIRSR() ]])
							or  !!(LUA_EXPRESSION[[ _IPAIRS() ]])
						)

					elseif objType.tag == !(TYPE_TABLE) then
						assert(not forLoop.reverse)
						luaCall = !!(LUA_EXPRESSION[[ _PAIRS() ]])

					elseif objType.tag == !(TYPE_STRUCT) then
						assert(not forLoop.reverse)
						errorUnhandledNodeType(state, objExpr)
						-- @Incomplete: Output default iterator for the struct. Also handle array-like structs and structured tables.
						-- writeConstantValueOrReference(state, writer, interatorFuncConst?, objExpr)

					else
						errorInternal(state, objExpr)
					end

					luaForLoop.values[1] = luaCall
					luaCall.arguments[1] = writeExpression(state, writer, nextLocalN, localsStack, objExpr)
				end

				luaBlock = writeLoopBodyAndFooter(state, writer, forLoop, nextLocalN, localsStack, deferStartIndex, block.statementsDynamic, statementIndex, parentContinueDepth, luaBlock0, luaForLoop.body, luaBlock)

			-- for x in expression
			else--if forLoop.forType == !(FOR_ITERATOR) then
				luaForLoop.kind = "generic"

				for i, decl in ipairs(forLoop.declarations) do
					luaForLoop.names[i] = luaParser.newNodeFast("identifier", writeIdentifierName(state, writer, decl.name))
				end
				for i, valueExpr in ipairs(forLoop.expressions) do
					luaForLoop.values[i] = writeExpression(state, writer, nextLocalN, localsStack, valueExpr)
				end

				luaBlock = writeLoopBodyAndFooter(state, writer, forLoop, nextLocalN, localsStack, deferStartIndex, block.statementsDynamic, statementIndex, parentContinueDepth, luaBlock0, luaForLoop.body, luaBlock)
			end

		----------------------------------------------------------------
		elseif nodeType == !(AST_BREAK) then
			local breakNode = statement

			local deferStartIndexJump = writer.loopDeferIndices[writer.loopDepth] or errorInternal()
			local defers              = writer.deferStack[deferStartIndexJump] and {unpack(writer.deferStack, deferStartIndexJump)} or EMPTY_TABLE
			writeDefers(state, writer, nextLocalN, localsStack, defers, luaBlock)

			if breakNode.loop then
				local i                = indexOf(writer.loopStack, breakNode.loop) or errorInternal(state, breakNode)
				local outerLoopsToJump = #writer.loopStack - i

				local luaAssignment           = !!(LUA_STATEMENT[[ _JUMP, _BREAK = 0, true ]])
				luaAssignment.values[1].value = outerLoopsToJump
				table.insert(luaBlock.statements, luaAssignment)
			end

			table.insert(luaBlock.statements, !!(LUA_STATEMENT[[ break ]]))

		----------------------------------------------------------------
		elseif nodeType == !(AST_CONTINUE) then
			local continue = statement

			local deferStartIndexJump = writer.loopDeferIndices[writer.loopDepth] or errorInternal()
			local defers              = writer.deferStack[deferStartIndexJump] and {unpack(writer.deferStack, deferStartIndexJump)} or EMPTY_TABLE
			writeDefers(state, writer, nextLocalN, localsStack, defers, luaBlock)

			local i                = indexOf(writer.loopStack, continue.loop) or errorInternal(state, continue)
			local outerLoopsToJump = #writer.loopStack - i
			local luaAssignment    = !!(LUA_STATEMENT[[ _JUMP = 0 ]])

			if outerLoopsToJump > 0 then
				luaAssignment.values[1].value = outerLoopsToJump
				table.insert(luaBlock.statements, luaAssignment)
				table.insert(luaBlock.statements, !!(LUA_STATEMENT[[ break ]]))
				-- Leave _BREAK false.
			else
				luaAssignment.values[1].value = outerLoopsToJump + 1
				table.insert(luaBlock.statements, luaAssignment)
				-- Leave _BREAK false.
			end

			gotContinue = true

		----------------------------------------------------------------
		elseif nodeType == !(AST_DEFER) then
			local defer = statement
			table.insert(writer.deferStack, defer)

		----------------------------------------------------------------
		elseif nodeType == !(AST_SWITCH) then
			local switch = statement

			-- @Incomplete: Wrap all this in do...end so _SWITCH doesn't live for too long.
			local luaDecl     = !!(LUA_STATEMENT[[ local _SWITCH ]]) ; table.insert(luaBlock.statements, luaDecl)
			luaDecl.values[1] = writeExpression(state, writer, nextLocalN, localsStack, switch.value)

			if switch.cases[1] then
				local fallingThrough     = false
				local prevContinueDepth  = writer.continueDepth
				local maxContinueDepth   = prevContinueDepth
				local luaCurrentIfNode   = nil
				local luaCurrentBinaryEq = nil
				local luaCurrentBinaryOr = nil
				local luaCurrentBlock    = luaBlock

				for i, case in ipairs(switch.cases) do
					--
					-- Write pre-condition-code followed by condition.
					--
					if fallingThrough then
						if case.fallThrough or case.value then
							-- Add 'or'.

							-- if  x==1 then  ->  if (x==1) or (x==2) then
							if not luaCurrentBinaryOr then
								luaCurrentBinaryOr         = luaParser.newNodeFast("binary", "or")
								luaCurrentBinaryOr.left    = luaCurrentBinaryEq
								luaCurrentBinaryOr.right   = !!(LUA_EXPRESSION([[ _SWITCH == x ]], function(luaBinary)luaBinary.right=nil;end))
								luaCurrentBinaryEq         = luaCurrentBinaryOr.right
								luaCurrentIfNode.condition = luaCurrentBinaryOr
							-- if (x==1) or (x==2) then  ->  if (x==1) or ((x==2) or (x==3)) then
							else
								local luaBinaryOr        = luaParser.newNodeFast("binary", "or")
								luaBinaryOr.left         = luaCurrentBinaryOr.right
								luaBinaryOr.right        = !!(LUA_EXPRESSION([[ _SWITCH == x ]], function(luaBinary)luaBinary.right=nil;end))
								luaCurrentBinaryEq       = luaBinaryOr.right
								luaCurrentBinaryOr.right = luaBinaryOr
							end

						elseif not case.value then
							if luaCurrentBinaryEq then
								luaCurrentIfNode.condition = !!(LUA_EXPRESSION[[ true ]]) -- @Cleanup: Unpack bodyTrue of 'if true'. (Will get solved if/when we use luaParser.optimize().)
							end
						end

					elseif not case.value then
						-- Make sure we don't write the case body into luaBlock.
						if luaCurrentBlock == luaBlock then
							luaCurrentBlock = !!(LUA_STATEMENT[[ do end ]]) ; table.insert(luaBlock.statements, luaCurrentBlock)
						end

					elseif i == 1 then
						-- Add 'if'.
						luaCurrentIfNode   = !!(LUA_STATEMENT([[ if _SWITCH == x then end ]], function(luaIfNode)luaIfNode.condition.right=nil;end)) ; table.insert(luaCurrentBlock.statements, luaCurrentIfNode)
						luaCurrentBinaryEq = luaCurrentIfNode.condition
						luaCurrentBinaryOr = nil
						luaCurrentBlock    = luaCurrentIfNode.bodyTrue

					else
						-- Add 'elseif'.
						luaCurrentBlock            = !!(LUA_STATEMENT[[ do end ]])
						luaCurrentIfNode.bodyFalse = luaCurrentBlock
						luaCurrentIfNode           = !!(LUA_STATEMENT([[ if _SWITCH == x then end ]], function(luaIfNode)luaIfNode.condition.right=nil;end)) ; table.insert(luaCurrentBlock.statements, luaCurrentIfNode)
						luaCurrentBinaryEq         = luaCurrentIfNode.condition
						luaCurrentBinaryOr         = nil
						luaCurrentBlock            = luaCurrentIfNode.bodyTrue
					end

					if case.value then
						luaCurrentBinaryEq.right = writeExpression(state, writer, nextLocalN, localsStack, case.value)
					end

					--
					-- Write body.
					--
					if not case.fallThrough then
						if case.value or fallingThrough then
							-- 'then'
						elseif i == 1 then
							-- 'do'
						else
							-- 'else'
							luaCurrentBlock            = !!(LUA_STATEMENT[[ do end ]])
							luaCurrentIfNode.bodyFalse = luaCurrentBlock
						end

						!ASSERT(`luaCurrentBlock`, nil, `case.value or case.body or switch`)
						writeBlock(state, writer, nextLocalN, localsStack, case.body, false, luaCurrentBlock)

						maxContinueDepth     = math.max(maxContinueDepth, writer.continueDepth)
						writer.continueDepth = prevContinueDepth

						luaCurrentBinaryEq = nil
						luaCurrentBinaryOr = nil
					end

					fallingThrough = case.fallThrough
				end

				writer.continueDepth = maxContinueDepth -- @Robustness: Clarify what's happening here. 2021-08-23

				luaBlock = handleContinueAfterBlock(state, writer, parentContinueDepth, prevContinueDepth, block.statementsDynamic, statementIndex, luaBlock)
			end

		----------------------------------------------------------------
		elseif nodeType == !(AST_CALL) and statement.inline == !(INLINE_YES) then -- @Incomplete: Handle INLINE_MAY in some intelligent way.
			local call = statement
			writeInlineCallStatement(state, writer, nextLocalN, localsStack, call, luaBlock)

		----------------------------------------------------------------
		else
			-- Assume the statement is an expression at this point and let writeExpression() deal with any errors.
			local luaStatement = writeExpression(state, writer, nextLocalN, localsStack, statement) ; table.insert(luaBlock.statements, luaStatement)
		end
		----------------------------------------------------------------

		!if ASSERT_STATEMENT then
			!ASSERT(`luaBlock`,                 nil,             `statement`)
			!ASSERT(`luaBlock.type == "block"`, `luaBlock.type`, `statement`)
			!ASSERT(`luaBlock.statements`,      nil,             `statement`)
		!end
	end

	local doWriteDefers = (
		writer.deferStack[deferStartIndex]
		and not (
			block.statementsDynamic[1] -- Defers will already have been written before these:
			and !!(CONST_SET{ AST_RETURN, AST_BREAK, AST_CONTINUE })[getLast(block.statementsDynamic).nodeType]
		)
	)

	local defers = doWriteDefers and {unpack(writer.deferStack, deferStartIndex)} or EMPTY_TABLE

	for i = deferStartIndex, #writer.deferStack do
		writer.deferStack[i] = nil
	end
	writeDefers(state, writer, nextLocalN, localsStack, defers, luaBlock)

	if writer.continueDepth > parentContinueDepth then
		--[[
			-- Implicit 'if not continue then' blocks (the inside being called trailing/indented) example:
			for {
				do continue -- DEPTH=1
				>>>>
					if {
						do continue -- DEPTH=2
						>>>>
							do continue -- DEPTH=3
							>>>>
							<<<<
						<<<<
					}
					-- DEPTH=1 (reset)
					>>>>
						do continue -- DEPTH=2
						>>>>
						<<<<
					<<<<
				<<<<
			}
		]]
		writer.continueDepth = parentContinueDepth
	end

	if gotContinue then
		writer.continueDepth = writer.continueDepth + 1 -- This signals to the parent block that we got a continue.
	end
end

-- luaExpr = writeForeignReference( state, writer, foreignSourceId, nodeForError=nil )
local function writeForeignReference(state, writer, foreignSourceId, nodeForError)
	if writer.foreignOnlyAvailableDuringCompilation[foreignSourceId] and writer.outputRuntime and not keepDeadCode then
		if nodeForError then
			writerError(state, nodeForError, "Trying to write runtime reference to compile-time-only symbol.")
		else
			errorLine("ProgramWriter", "Trying to write runtime reference to compile-time-only symbol.")
		end
	end

	local foreignRef   = writer.foreignReferences[foreignSourceId]
	local luaExpr      = assert(luaParser.parseExpression(foreignRef)) -- @Speed: Do we need to parse here?
	luaExpr.sourceNode = nodeForError -- May be nil. @Incomplete: Ensure we have a node here.

	return luaExpr
end

-- luaFunction|luaIdentifier = writeFunction( state, writer, nextLocalN, localsStack, lambda )
--[[local ]]function writeFunction(state, writer, nextLocalN, localsStack, lambda)
	!ASSERT `not lambda.body[1]` -- Statements should be in lambda.body.statements*!
	!ASSERT `not lambda.polymorphs`

	if lambda.bodyIsForeign then
		local luaIdent = writeForeignReference(state, writer, lambda.foreignSourceId, lambda.foreignSourceName)
		return luaIdent
	end

	local argumentN = writer.argumentN -- Note: argumentN must be stored on the writer because there may be recursive arguments with shadowing names.
	table.insert(localsStack, {})

	local luaFunc      = !!(LUA_EXPRESSION[[ function()end ]])
	luaFunc.sourceNode = lambda

	if lambda.argumentsIn then
		for i, arg in ipairs(lambda.argumentsIn.arguments) do
			local decl = arg.declaration

			if decl.name.nodeType == !(AST_VARARG) then
				decl.localName        = "..."
				luaFunc.parameters[i] = !!(LUA_EXPRESSION[[ ... ]])
			else
				decl.localName, writer.argumentN = allocateArgumentName(state, writer, localsStack, decl.name.name, writer.argumentN)
				luaFunc.parameters[i]            = luaParser.newNodeFast("identifier", decl.localName)
			end
		end
	end

	if lambda.body.statementsDynamic[1] then
		writeBlock(state, writer, nextLocalN, localsStack, lambda.body, false, luaFunc.body)
	end

	writer.argumentN = argumentN
	table.remove(localsStack)

	return luaFunc
end

local function writeForeignImportIfNew(state, writer, typeInfo, foreignSource, foreignSourceName, foreignSourceId, sourceNode, asGlobal, luaBlock)
	assert(foreignSourceId ~= "")

	if writer.foreignReferences[foreignSourceId] then  return  end
	if foreignSource == "method"                 then  return  end -- Methods are "imported" when they are called.

	-- @Incomplete: Compiler setting for runtime checks of anything originating from foreign sources.
	-- (We can probably wrap the importing code in something here using typeInfo.)

	local foreignN  = writer.foreignN + 1
	writer.foreignN = foreignN

	if foreignN == 1 then
		table.insert(luaBlock.statements, (
			asGlobal
			and !!(LUA_STATEMENT[[       _FOREIGN = {} ]])
			or  !!(LUA_STATEMENT[[ local _FOREIGN = {} ]])
		))
	end

	local lua

	if foreignSource == "lua" then
		lua = foreignSourceName

		if outputDebugInfo then
			writer.foreignReferences[foreignSourceId] = F("_FOREIGN[%d%s]", foreignN, formatInfoComment(foreignSourceId))
		else
			writer.foreignReferences[foreignSourceId] = F("_FOREIGN[%d]", foreignN)
		end

	elseif foreignSource == "compiler" then
		lua = nil

		if not writer.outputRuntime then
			lua = foreignApiCompilerSymbolsDuringCompilation[foreignSourceName]
		elseif compilerApi[foreignSourceName] then
			writer.foreignOnlyAvailableDuringCompilation[foreignSourceId] = true
		end
		if not lua then
			lua = foreignApiCompilerSymbols[foreignSourceName] or errorInternal("%s", foreignSourceName)
		end

		writer.foreignReferences[foreignSourceId] = F("_FOREIGN[%d]", foreignN)

	else
		errorInternal("Incomplete: Handle foreignSource=%s", foreignSource)
	end
	!ASSERT `lua`

	local luaAssignment                   = !!(LUA_STATEMENT([[ _FOREIGN[1] = x ]], function(luaAssignment)luaAssignment.values[1]=nil;end))
	luaAssignment.sourceNode              = sourceNode -- @Incomplete: Line numbers for the contents of 'lua'.
	luaAssignment.targets[1].member.value = foreignN
	luaAssignment.values[1]               = assert(luaParser.parseExpression(lua)) -- @Incomplete: Maybe actually output foreigns as-is instead of part of the Lua AST. Or would that be too straightforward?
	table.insert(luaBlock.statements, luaAssignment)
end

local serializedIntCache = {}

-- luaExpr = writeNormalSimpleConstant( state, writer, tag, v, isEnum, nodeForError=nil )
local function writeNormalSimpleConstant(state, writer, tag, v, isEnum, nodeForError)
	local luaExpr

	if tag == !(TYPE_BOOL) then
		luaExpr = (
			v
			and !!(LUA_EXPRESSION[[ true  ]])
			or  !!(LUA_EXPRESSION[[ false ]])
		)

	elseif tag == !(TYPE_INT) then
		validateIntegerRange(state, v, nodeForError)
		if v == 0 then
			-- void
		else
			local nStr = serializedIntCache[v]
			if not nStr then
				nStr = F("%.0f", v)
				if not nStr:find"^%-?%d+$" then
					-- @Robustness: Ensure luaParser follows this rule. (May be enough to call luaParser.toLua().)
					errorLine("ProgramWriter", "Cannot write value as integer: %s (formatted as '%s')", tostring(v), nStr)
				end
				serializedIntCache[v] = nStr
			end
		end
		luaExpr = luaParser.newNodeFast("literal", v)

	elseif tag == !(TYPE_FLOAT) then
		-- @Polish: Make luaParser always output a decimal point for floats.
		luaExpr = luaParser.newNodeFast("literal", v)

	elseif tag == !(TYPE_NONE) then
		luaExpr = !!(LUA_EXPRESSION[[ nil ]])

	elseif tag == !(TYPE_STRING) then
		luaExpr = luaParser.newNodeFast("literal", v)

	elseif tag == !(TYPE_TYPE) then
		local typeInfo = v
		luaExpr        = luaParser.newNodeFast("literal", typeInfo.id)

		if outputDebugInfo and not isEnum then
			luaExpr.suffix = formatInfoComment(getFriendlyTypeInfoName(typeInfo))
		end

	else
		errorInternal(state, nodeForError, "Incomplete: Handle constant value of type '%s'.", (TYPE_NAMES[tag] or "?"))
	end

	luaExpr.sourceNode = nodeForError -- May be nil.
	return luaExpr
end

local typeInfoCommentCache = {}

-- luaTypeInfoTable = writeTypeInfo( state, writer, typeInfo )
local function writeTypeInfo(state, writer, typeInfo)
	local tag                    = typeInfo.tag
	local luaTypeInfoTable       = !!(LUA_EXPRESSION[[ {} ]])
	local luaTypeInfoTableFields = luaTypeInfoTable.fields

	!(
	local function END_OF_TYPE_INFO(typeInfoStructName)
		-- @Robustness: Get the name in the comment from the correct TypeInfo* struct declaration.
		return templateToLua(
			trimTemplate`
				if outputDebugInfo then
					luaTypeInfoTable.suffix = formatInfoComment($typeInfoStructName)
				end
			`,
			{typeInfoStructName=typeInfoStructName}
		)
	end
	)

	-- Note: This table's fields must be synced with preload and messenger!
	local luaTagLiteral = luaParser.newNodeFast("literal", tag)
	@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "tag", luaTagLiteral)
	if outputDebugInfo then
		typeInfoCommentCache[tag] = typeInfoCommentCache[tag] or formatInfoComment("TypeTag."..TYPE_NAMES[tag]:upper())
		luaTagLiteral.suffix      = typeInfoCommentCache[tag]
	end

	local luaExpr = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false, nil)
	@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "id", luaExpr)

	if tag == !(TYPE_ARRAY) then
		local arraySig = typeInfo
		local luaExpr  = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), arraySig.itemType, false, nil)
		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "itemType", luaExpr)

		!!(END_OF_TYPE_INFO"TypeInfoArray")

	elseif tag == !(TYPE_VARARG) then
		local varargSig = typeInfo
		local luaExpr   = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), varargSig.itemType, false, nil)
		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "itemType", luaExpr)

		!!(END_OF_TYPE_INFO"TypeInfoVararg")

	elseif tag == !(TYPE_FUNCTION) then
		local funcSig = typeInfo

		local luaArgArray       = !!(LUA_EXPRESSION[[ {} ]])
		local luaArgArrayFields = luaArgArray.fields
		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "argumentsIn", luaArgArray)

		for _, typeInfo in ipairs(funcSig.argumentTypesIn) do
			local luaArgTable       = !!(LUA_EXPRESSION[[ {} ]])
			local luaArgTableFields = luaArgTable.fields
			@@INSERT_TABLE_FIELD(luaArgArrayFields, nil, luaArgTable)

			local luaExpr = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false, nil)
			@@INSERT_TABLE_FIELD(luaArgTableFields, "argumentType", luaExpr)
		end

		local luaArgArray       = !!(LUA_EXPRESSION[[ {} ]])
		local luaArgArrayFields = luaArgArray.fields
		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "argumentsOut", luaArgArray)

		for _, typeInfo in ipairs(funcSig.argumentTypesOut) do
			local luaArgTable       = !!(LUA_EXPRESSION[[ {} ]])
			local luaArgTableFields = luaArgTable.fields
			@@INSERT_TABLE_FIELD(luaArgArrayFields, nil, luaArgTable)

			local luaExpr = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false, nil)
			@@INSERT_TABLE_FIELD(luaArgTableFields, "argumentType", luaExpr)
		end

		!!(END_OF_TYPE_INFO"TypeInfoFunction")

	elseif tag == !(TYPE_STRUCT) then
		local structInfo = typeInfo

		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "name", luaParser.newNodeFast("literal", structInfo.name))

		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "kind", luaParser.newNodeFast("literal", structInfo.kind))

		local luaExpr = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), (structInfo.valueType or state.builtinTypeInfos.void), false, nil)
		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "valueType", luaExpr)

		local luaExpr = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), (structInfo.keyType or state.builtinTypeInfos.void), false, nil)
		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "keyType", luaExpr)

		local luaMemberArray       = !!(LUA_EXPRESSION[[ {} ]])
		local luaMemberArrayFields = luaMemberArray.fields
		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "members", luaMemberArray)

		for _, member in ipairs(structInfo.members) do
			local luaMemberTable       = !!(LUA_EXPRESSION[[ {} ]])
			local luaMemberTableFields = luaMemberTable.fields
			@@INSERT_TABLE_FIELD(luaMemberArrayFields, nil, luaMemberTable)

			@@INSERT_TABLE_FIELD(luaMemberTableFields, "name", luaParser.newNodeFast("literal", member.name))

			local luaExpr = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), member.typeInfo, false, nil)
			@@INSERT_TABLE_FIELD(luaMemberTableFields, "memberType", luaExpr)

			local decl               = findMemberDeclaration(state, structInfo.astNode, member.name) or errorInternal(state, structInfo.astNode, "%s", member.name)
			local luaNoteArray       = !!(LUA_EXPRESSION[[ {} ]])
			local luaNoteArrayFields = luaNoteArray.fields
			@@INSERT_TABLE_FIELD(luaMemberTableFields, "notes", luaNoteArray)

			for _, note in ipairs(decl.notes or EMPTY_TABLE) do
				local typeInfo = requireTypeRepresentedByExpression(state, note)
				local luaExpr  = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false, nil)
				@@INSERT_TABLE_FIELD(luaNoteArrayFields, nil, luaExpr)
			end
		end

		!!(END_OF_TYPE_INFO"TypeInfoStruct")

	elseif tag == !(TYPE_ENUM) then
		local enumInfo = typeInfo

		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "name", luaParser.newNodeFast("literal", enumInfo.name))

		local luaExpr = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), enumInfo.memberTypeInfo, false, nil)
		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "memberType", luaExpr)

		local luaMemberArray       = !!(LUA_EXPRESSION[[ {} ]])
		local luaMemberArrayFields = luaMemberArray.fields
		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "members", luaMemberArray)

		for _, member in ipairs(enumInfo.members) do
			local luaMemberTable       = !!(LUA_EXPRESSION[[ {} ]])
			local luaMemberTableFields = luaMemberTable.fields
			@@INSERT_TABLE_FIELD(luaMemberArrayFields, nil, luaMemberTable)

			@@INSERT_TABLE_FIELD(luaMemberTableFields, "name", luaParser.newNodeFast("literal", member.name))

			local decl               = findMemberDeclaration(state, enumInfo.astNode, member.name) or errorInternal(state, enumInfo.astNode, "%s", member.name)
			local luaNoteArray       = !!(LUA_EXPRESSION[[ {} ]])
			local luaNoteArrayFields = luaNoteArray.fields
			@@INSERT_TABLE_FIELD(luaMemberTableFields, "notes", luaNoteArray)

			for _, note in ipairs(decl.notes or EMPTY_TABLE) do
				local typeInfo = requireTypeRepresentedByExpression(state, note)
				local luaExpr  = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeInfo, false, nil)
				@@INSERT_TABLE_FIELD(luaNoteArrayFields, nil, luaExpr)
			end
		end

		!!(END_OF_TYPE_INFO"TypeInfoEnum")

	elseif tag == !(TYPE_COMPOUND) then
		local compound = typeInfo

		local luaTypeArray       = !!(LUA_EXPRESSION[[ {} ]])
		local luaTypeArrayFields = luaTypeArray.fields
		@@INSERT_TABLE_FIELD(luaTypeInfoTableFields, "types", luaTypeArray)

		for _, compoundItem in ipairs(compound) do
			local luaExpr = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), compoundItem, false, nil)
			@@INSERT_TABLE_FIELD(luaTypeArrayFields, nil, luaExpr)
		end

		!!(END_OF_TYPE_INFO"TypeInfoCompound")

	elseif !!(CONST_SET{ -- :SimplePublicTypeInfo
		TYPE_ANY,
		TYPE_BOOL,
		TYPE_FLOAT,
		TYPE_INT,
		TYPE_NONE,
		TYPE_PLACEHOLDER,
		TYPE_STRING,
		TYPE_TABLE,
		TYPE_TYPE,
		TYPE_VOID,
	})[tag] then
		-- void  No more information.
		!!(END_OF_TYPE_INFO"TypeInfo")

	else
		errorInternal("Incomplete: %s", getFriendlyTypeInfoName(typeInfo))
	end

	return luaTypeInfoTable
end

-- luaExpr = writeConstantValue( state, writer, const, nodeForError=nil )
local function writeConstantValue(state, writer, const, nodeForError)
	local tag = const.valueType.tag
	local luaExpr

	if const.kind == !(CONST_KIND_FOREIGN) then
		local foreign = const.value
		luaExpr       = writeForeignReference(state, writer, foreign.foreignSourceId, nodeForError)

	elseif const.kind == !(CONST_KIND_TYPE_INFO) then
		local typeInfo       = const.value
		luaExpr              = !!(LUA_EXPRESSION[[ _TYPE_INFO[0] ]])
		luaExpr.sourceNode   = nodeForError -- May be nil.
		luaExpr.member.value = typeInfo.id

	elseif const.kind == !(CONST_KIND_LOCATION) then
		local target = const.value

		-- Note: This table's fields must be synced with the preload module!
		luaExpr                       = !!(LUA_EXPRESSION[[ {filePath="", lineNumber=0, position=0} ]])
		luaExpr.sourceNode            = nodeForError -- May be nil.
		luaExpr.fields[1].value.value = target.source.path
		luaExpr.fields[2].value.value = target.line
		luaExpr.fields[3].value.value = target.position

	elseif const.kind == !(CONST_KIND_NULL) then
		luaExpr            = !!(LUA_EXPRESSION[[ nil ]])
		luaExpr.sourceNode = nodeForError -- May be nil.

	elseif const.kind == !(CONST_KIND_VIEW) then
		-- Note: The constants must be written in the same order as they were allocated for these
		-- views to work (which is what should happen naturally because of how dependencies work).
		luaExpr = writeAccess(state, writer, 1, {}, const.value)

	--------------------------------

	elseif const.kind ~= !(CONST_KIND_NORMAL) then
		errorInternal(state, nodeForError, "Incomplete: Handle constant kind '%s'.", (CONST_KIND_TITLES[const.kind] or "?"))

	elseif not const.isObject then
		if tag ~= !(TYPE_ENUM) then
			luaExpr = writeNormalSimpleConstant(state, writer, tag, const.value, false, nodeForError)
			return luaExpr
		end

		local enumInfo   = const.valueType
		local memberName = const.value
		local decl       = findMemberDeclaration(state, enumInfo.astNode, memberName)

		if not decl then
			if nodeForError then
				typeError2(state,
					enumInfo.astNode, F("Internal compiler error: Did not find member '%s' in enum '%s'.", memberName, getFriendlyTypeInfoName(enumInfo)),
					nodeForError,     F("...current node.")
				)
			else
				typeError("Internal compiler error: Did not find member '%s' in enum '%s'.", memberName, getFriendlyTypeInfoName(enumInfo))
			end
		end

		local valueExpr = decl.value

		if enumInfo.memberTypeInfo.tag == !(TYPE_TYPE) then
			local typeNode = valueExpr
			!ASSERT("typeNode.nodeType == "..AST_TYPE)
			luaExpr = writeNormalSimpleConstant(state, writer, !(TYPE_TYPE), typeNode.representedType, true, nodeForError)
		else
			local literal = valueExpr
			!ASSERT("literal.nodeType == "..AST_LITERAL)
			luaExpr = writeNormalSimpleConstant(state, writer, enumInfo.memberTypeInfo.tag, literal.value, true, nodeForError)
		end

		if outputDebugInfo then
			luaExpr.suffix = formatInfoComment(enumInfo.name.."."..memberName) -- @Speed: Cache!
		end

	elseif tag == !(TYPE_FUNCTION) then
		local lambda = const.value
		luaExpr      = writeFunction(state, writer, {}, lambda)

	elseif !!(CONST_SET{ TYPE_TABLE, TYPE_ARRAY, TYPE_STRUCT })[tag] then
		local tableNode = const.value
		luaExpr         = writeExpression(state, writer, 1, {}, tableNode)

	elseif tag == !(TYPE_STRING) then -- Large string.
		local s            = const.value
		luaExpr            = luaParser.newNodeFast("literal", s)
		luaExpr.sourceNode = nodeForError -- May be nil.

	else
		if !!(CONST_SET{ TYPE_ANY, TYPE_NAMESPACE, TYPE_COMPOUND, TYPE_LIST })[tag] then
			errorInternal(state, nodeForError, "Cannot write invalid value type '%s'.", TYPE_NAMES[tag])
		else
			errorInternal(state, nodeForError, "Incomplete: Handle constant value of type '%s'.", (TYPE_NAMES[tag] or "?"))
		end
	end

	return luaExpr
end

-- luaExpr = writeConstantValueOrReference( state, writer, constant, nodeForError )
--[[local ]]function writeConstantValueOrReference(state, writer, const, nodeForError)
	if not const.isObject then
		return (writeConstantValue(state, writer, const, nodeForError))
	end

	if const.valueType.tag == !(TYPE_FUNCTION) then
		local lambda = const.value

		if lambda.bodyIsForeign and lambda.foreignSource == "method" then
			!TRACE()
			printerr()
			nodeMessage(io.stderr, state, nodeForError, "Error", "ProgramWriter", "Cannot output references to foreign methods.")
			if nodeForError ~= lambda then
				nodeMessage(io.stderr, state, lambda, "Info", "ProgramWriter", "...here is the method.")
			end
			exitFailure()
		end
	end

	local luaIdent      = luaParser.newNodeFast("identifier", const.name)
	luaIdent.sourceNode = nodeForError
	return luaIdent
end



function _G.writeLuaPreloads(state, writer, luaPreloads, fromIndex, luaBlock)
	for i = fromIndex, #luaPreloads do
		-- @Incomplete: Line numbers for preloads.
		local luaInnerBlock = assert(luaParser.parse(luaPreloads[i].lua)) -- @Incomplete: Maybe actually output preloads as-is instead of part of the Lua AST.
		table.insert(luaBlock.statements, luaInnerBlock)
	end
end

-- writeCompilerSymbols( state, writer, luaBlock, relevantObjects=nil )
function _G.writeCompilerSymbols(state, writer, luaBlock, relevantObjects)
	local outputRuntime = writer.outputRuntime

	if outputRuntime then
		table.insert(luaBlock.statements, !!(LUA_STATEMENT([[ local lineMappings     = {paths={},files={},lines={}} ]])))
		table.insert(luaBlock.statements, !!(LUA_STATEMENT([[ local programArguments = arg ]])))
		table.insert(luaBlock.statements, !!(LUA_STATEMENT([[ local luaArguments     = arg ]])))
		table.insert(luaBlock.statements, !!(LUA_STATEMENT([[ local gloaErrorHandler = ]]..ERROR_HANDLER, function(luaDecl)luaDecl.values[1].pretty=false;end)))

		local writeAllTypes = not relevantObjects or relevantObjects.allTypeInfos

		if writeAllTypes or next(relevantObjects.typeInfos) then
			local toWriteTypeIdSet  = {}
			local toWriteLastTypeId = 0

			for typeId, typeInfo in ipairs(state.allTypeInfos) do
				if (writeAllTypes or relevantObjects.typeInfos[typeInfo]) and isTypePublic(typeInfo) then
					if not typeInfo.isReady then
						errorInternal("Type info is not ready for '%s'.", getFriendlyTypeInfoName(typeInfo))
					end

					toWriteTypeIdSet[typeId] = true
					toWriteLastTypeId        = typeId
				end
			end

			-- Write list of types.
			local luaDecl            = !!(LUA_STATEMENT([[ local _TYPES = {} ]], function(luaDecl)luaDecl.values[1].pretty=false;end))
			local luaTypeArray       = luaDecl.values[1]
			local luaTypeArrayFields = luaTypeArray.fields
			table.insert(luaBlock.statements, luaDecl)

			for typeId = 1, toWriteLastTypeId do
				if toWriteTypeIdSet[typeId] then
					@@INSERT_TABLE_FIELD(luaTypeArrayFields, nil, luaParser.newNodeFast("literal", typeId))
				end
			end

			-- Write type table.
			local sequenceGap       = 0
			local sequenceGapToFill = writeAllTypes and 30 or 10
			local _outputDebugInfo  = outputDebugInfo
			_G.outputDebugInfo      = false -- The type table is big enough already! Let's try making it a bit smaller. (This saves ~50% of the space.)

			table.insert(luaBlock.statements, !!(LUA_STATEMENT[[ local _ = nil ]])) -- '_' is shorter than 'nil'.

			local luaDecl                = !!(LUA_STATEMENT[[ local _TYPE_INFO = {} ]])
			local luaTypeInfoArray       = luaDecl.values[1]
			luaTypeInfoArray.pretty      = false
			local luaTypeInfoArrayFields = luaTypeInfoArray.fields
			table.insert(luaBlock.statements, luaDecl)

			for typeId = 1, toWriteLastTypeId do
				if toWriteTypeIdSet[typeId] then
					local luaTypeArrayField = {generatedKey=true, value=nil}

					-- Note: Type index and type ID are the same.
					if sequenceGap == 0 then
						-- void
					elseif sequenceGap < sequenceGapToFill then
						while sequenceGap > 0 do
							sequenceGap = sequenceGap - 1
							@@INSERT_TABLE_FIELD(luaTypeInfoArrayFields, nil, !!(LUA_EXPRESSION[[ _ ]]))
						end
					else
						luaTypeArrayField.generatedKey = false
						luaTypeArrayField.key          = luaParser.newNodeFast("literal", typeId)
					end

					luaTypeArrayField.value = writeTypeInfo(state, writer, state.allTypeInfos[typeId])
					table.insert(luaTypeInfoArrayFields, luaTypeArrayField)

				else
					sequenceGap = sequenceGap + 1
				end
			end

			_G.outputDebugInfo = _outputDebugInfo
		end

	else
		-- Note: lineMappings is not used in metaprograms because gloaErrorHandler() is different.
		table.insert(luaBlock.statements, !!(LUA_STATEMENT[[ programArguments = metaprogramArguments ]]))
		table.insert(luaBlock.statements, !!(LUA_STATEMENT[[ luaArguments     = compilerLuaArguments ]]))
		table.insert(luaBlock.statements, !!(LUA_STATEMENT[[ gloaErrorHandler = compilerErrorHandler ]]))

		table.insert(luaBlock.statements, !!(LUA_STATEMENT[[ _TYPES     = metaprogramTypeIds ]]))
		table.insert(luaBlock.statements, !!(LUA_STATEMENT[[ _TYPE_INFO = metaprogramTypeTable ]]))
	end

	-- @Polish: Only output symbols actually used in the program.
	!for i = 1, #COMPILER_SYMBOL_PAIRS, 2 do
		table.insert(luaBlock.statements, (
			outputRuntime
			and !!(LUA_STATEMENT("local "..COMPILER_SYMBOL_PAIRS[i].." = "..COMPILER_SYMBOL_PAIRS[i+1], function(luaStatement)luaStatement.values[1].pretty=false;end))
			or  !!(LUA_STATEMENT(          COMPILER_SYMBOL_PAIRS[i].." = "..COMPILER_SYMBOL_PAIRS[i+1], function(luaStatement)luaStatement.values[1].pretty=false;end))
		))
	!end
end

-- writeForeignImports( state, writer, constants, asGlobals, luaBlock, relevantObjects=all )
function _G.writeForeignImports(state, writer, constants, asGlobals, luaBlock, relevantObjects)
	for _, const in ipairs(constants) do
		if relevantObjects and not relevantObjects[const] then
			-- void

		elseif const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION) and const.value.bodyIsForeign then
			-- @Polish: Treat function constants pointing to the same foreign function as the same constant.
			local lambda = const.value
			writeForeignImportIfNew(state, writer, const.valueType, lambda.foreignSource, lambda.foreignSourceName.value, lambda.foreignSourceId, lambda, asGlobals, luaBlock)

		elseif const.kind == !(CONST_KIND_FOREIGN) then
			local foreign = const.value
			writeForeignImportIfNew(state, writer, foreign.inferredType, foreign.foreignSource, foreign.foreignSourceName.value, foreign.foreignSourceId, foreign, asGlobals, luaBlock)
		end
	end
end

-- writeConstantObjectsAndForwardDeclarations( state, writer, constants, topScopeNames, luaBlock, relevantObjects=all )
function _G.writeConstantObjectsAndForwardDeclarations(state, writer, constants, topScopeNames, luaBlock, relevantObjects)
	local constantNamesToWrite = {}
	local constantFunctions    = {}
	local constantNonFunctions = {}

	for _, const in ipairs(constants) do
		if not const.isObject or (relevantObjects and not relevantObjects[const]) then
			-- void

		elseif const.kind == !(CONST_KIND_NORMAL) and const.valueType.tag == !(TYPE_FUNCTION) then
			local lambda = const.value

			-- @Cleanup: Don't generate constants for polymorphic functions. (It's probably declarations doing this.) (I guess don't generate constants for foreign methods either.)
			if not (lambda.polymorphs or (lambda.bodyIsForeign and lambda.foreignSource == "method")) then
				table.insert(constantFunctions,         const)
				table.insert(constantNamesToWrite, const.name)
			end

		else
			table.insert(constantNonFunctions,      const)
			table.insert(constantNamesToWrite, const.name)
		end
	end

	if not (constantNamesToWrite[1] or topScopeNames[1]) then  return  end

	if writer.remainingUpvalues > 0 then
		local luaDecl = !!(LUA_STATEMENT([[ local x ]], function(luaDecl)luaDecl.names[1]=nil;end))
		table.insert(luaBlock.statements, luaDecl)

		for i = 1, math.min(writer.remainingUpvalues, #constantNamesToWrite) do
			table.insert(luaDecl.names, luaParser.newNodeFast("identifier", constantNamesToWrite[i]))
		end
		writer.remainingUpvalues = writer.remainingUpvalues - #constantNamesToWrite

		for i = 1, math.min(writer.remainingUpvalues, #topScopeNames) do
			table.insert(luaDecl.names, luaParser.newNodeFast("identifier", topScopeNames[i]))
		end
		writer.remainingUpvalues = writer.remainingUpvalues - #topScopeNames
	end

	table.sort(constantFunctions, function(a, b)
		a = a.value
		b = b.value
		if a.bodyIsForeign ~= b.bodyIsForeign then  return a.bodyIsForeign                end
		if a.source.path   ~= b.source.path   then  return a.source.path < b.source.path  end
		if a.position      ~= b.position      then  return a.position    < b.position     end
		return a.s < b.s
	end)

	for _, const in ipairs(constantFunctions) do
		local lambda             = const.value
		local luaAssignment      = luaParser.newNodeFast("assignment")
		luaAssignment.sourceNode = lambda
		luaAssignment.targets[1] = luaParser.newNodeFast("identifier", const.name)
		luaAssignment.values[1]  = writeFunction(state, writer, 1, {}, lambda)
		table.insert(luaBlock.statements, luaAssignment)
	end

	for _, const in ipairs(constantNonFunctions) do
		local nodeForError       = (type(const.value) == "table" and const.value.nodeType and const.value.s and const.value or nil) -- @Hack @Robustness!!!
		local luaAssignment      = luaParser.newNodeFast("assignment")
		luaAssignment.targets[1] = luaParser.newNodeFast("identifier", const.name)
		luaAssignment.values[1]  = writeConstantValue(state, writer, const, nodeForError)
		table.insert(luaBlock.statements, luaAssignment)
	end
end

-- writeTopScopeDeclarations( state, writer, declarations, luaBlock, relevantObjects=all )
function _G.writeTopScopeDeclarations(state, writer, declarations, luaBlock, relevantObjects)
	for _, decl in ipairs(declarations) do
		if relevantObjects and not relevantObjects[decl] then
			-- void

		elseif decl.topScopeName ~= "" then -- Constant declarations of non-objects (e.g. ints) should have an empty topScopeName.
			local luaExpr
			if decl.valueConstant then
				luaExpr = writeConstantValueOrReference(state, writer, decl.valueConstant, decl.name)
			else
				-- We should have a declared struct instance or something similar here (I think) that doesn't have a specified initial value.
				luaExpr = writeDefaultValueForType(state, writer, 1, {}, decl.inferredType, decl.name)
			end

			local luaAssignment      = luaParser.newNodeFast("assignment")
			luaAssignment.sourceNode = decl
			luaAssignment.targets[1] = luaParser.newNodeFast("identifier", decl.topScopeName)
			luaAssignment.values[1]  = luaExpr
			table.insert(luaBlock.statements, luaAssignment)
		end
	end
end

function _G.writeProgram(state, writer)
	--
	-- Gather info.
	--
	local globalScope          = state.globalScope
	local topScopeDeclarations = copyArray(globalScope.declarations)

	for _, fileScope in ipairs(globalScope.fileScopes) do
		insertArrayItems(topScopeDeclarations, fileScope.declarations)
	end

	local outputType = state.settings.outputType

	if outputType == !(OUTPUT_TYPE_LUA_MODULE) and not globalScope.fileScopeWithValueToExport then
		local filePaths = {}
		for _, fileScope in ipairs(globalScope.fileScopes) do
			if not fileScope.isModule then  table.insert(filePaths, fileScope.path)  end
		end
		errorLine(
			"ProgramWriter",
			"Missing value to export as the Lua module in top-level scope in loaded files:\n- %s",
			table.concat(filePaths, "\n- ")
		)
	end

	local mainFuncDecl, mainLambda = nil

	if outputType == !(OUTPUT_TYPE_LUA_APP) then
		local entryPointName = state.settings.entryPointName

		for _, decl in ipairs(topScopeDeclarations) do -- Note: topScopeDeclarations does not include static declarations or declarations in namespaces yet.
			if decl.name.name == entryPointName then
				mainFuncDecl = decl
				break
			end
		end

		if not mainFuncDecl then
			local filePaths = {}
			for _, fileScope in ipairs(globalScope.fileScopes) do
				if not fileScope.isModule then  table.insert(filePaths, fileScope.path)  end
			end
			errorLine(
				"ProgramWriter",
				"Missing program entry point ('%s' function) in top-level scope in loaded files:\n- %s",
				entryPointName, table.concat(filePaths, "\n- ")
			)

		elseif not isDeclarationConstant(mainFuncDecl) then
			writerError(state, mainFuncDecl.name, "Declared name '%s' must be a constant.", entryPointName)
		end

		mainLambda = mainFuncDecl.valueConstant.value

		if mainLambda.inferredType.tag ~= !(TYPE_FUNCTION) then
			writerError(
				state, mainFuncDecl.value,
				"Declared name '%s' must be a function to represent the entry point of the program.",
				entryPointName
			)
		end
		!ASSERT("mainLambda.nodeType == "..AST_LAMBDA)

		if mainFuncDecl.overloadOf then
			writerError(state, mainFuncDecl.name, "Program entry point name must not be overloaded.")
		elseif mainLambda.inferredType.argumentTypesIn[1] then
			writerError(state, mainLambda.argumentsIn, "Program entry point function must not take any arguments.")
		elseif mainLambda.inferredType.argumentTypesOut[1] then
			writerError(state, mainLambda.argumentsOut, "Program entry point function must not return any values.")
		end
	end

	astVisitAllNodes(globalScope, function(node)
		if node.nodeType == !(AST_DECLARATION) then
			local decl = node
			if decl.kind == !(DECL_KIND_STATIC) then
				table.insert(topScopeDeclarations, decl)
			end

		elseif node.nodeType == !(AST_NAMESPACE) then
			local namespace = node
			insertArrayItems(topScopeDeclarations, namespace.declarations)
		end
	end)

	local relevantObjects = nil

	if not keepDeadCode then
		local relevantTypes = {--[[ [typeInfo1]=true, ... ]]}
		relevantObjects     = {typeInfos=relevantTypes, allTypeInfos=false--[[, [node1]=true, [const1]=true, ... ]]}

		local function crawlCallback(obj, crawlObjKind)
			if crawlObjKind ~= !(CRAWL_CONSTANT) then  return  end

			local const = obj

			if const.kind == !(CONST_KIND_NORMAL) then
				if const.valueType.tag == !(TYPE_FUNCTION) and const.value.bodyIsForeign and const.value.foreignSource == "compiler" and !!(CONST_SET{
					-- These are the only functions that can retrieve type information dynamically at runtime.
					"getAllTypes", -- @Size: If only this function is used then we don't need to write anything but the type IDs (except for types referenced by type_info()).
					"getTypeInfo",
				})[const.value.foreignSourceName.value] then
					relevantObjects.allTypeInfos = true
				end

			elseif const.kind == !(CONST_KIND_TYPE_INFO) then
				local typeInfo          = const.value
				relevantTypes[typeInfo] = true
			end
		end

		if outputType == !(OUTPUT_TYPE_LUA_APP) then
			crawl(state, mainLambda,    relevantObjects, false, crawlCallback)
		elseif outputType == !(OUTPUT_TYPE_LUA_MODULE) then
			local luaModuleNode = globalScope.fileScopeWithValueToExport.valueToExport
			crawl(state, luaModuleNode, relevantObjects, false, crawlCallback)
		else
			errorInternal("outputType==%d", outputType)
		end
	end

	--
	-- Write program.
	--
	writer.luaMainChunkBody = !!(LUA_STATEMENT[[ do end ]])

	writeLuaPreloads    (state, writer, state.luaPreloads,        1, writer.luaMainChunkBody)
	writeLuaPreloads    (state, writer, state.luaPreloadsRuntime, 1, writer.luaMainChunkBody)
	writeCompilerSymbols(state, writer, writer.luaMainChunkBody,     relevantObjects)

	-- Start of user code.
	local luaProgramBody
	do
		local luaDecl      = !!(LUA_STATEMENT[[ local runProgram = function() end ]])
		luaDecl.sourceNode = mainFuncDecl -- Is nil for Lua modules, which is probably OK.
		luaProgramBody     = luaDecl.values[1].body
		table.insert(writer.luaMainChunkBody.statements, luaDecl)
	end

	writeForeignImports(state, writer, state.constants, false, luaProgramBody, relevantObjects)

	!local MAX_UPVALUES      = 60
	writer.remainingUpvalues = !(MAX_UPVALUES - COMPILER_SYMBOL_COUNT) -- @Incomplete: This system for solving the upvalue limit in Lua can be improved. A lot!
	writeConstantObjectsAndForwardDeclarations(state, writer, state.constants, state.topScopeNames, luaProgramBody, relevantObjects)
	writeTopScopeDeclarations                 (state, writer, topScopeDeclarations,                 luaProgramBody, relevantObjects)

	-- Write program entry point.
	if outputType == !(OUTPUT_TYPE_LUA_APP) then
		local luaCall       = !!(LUA_STATEMENT[[ main() ]])
		luaCall.sourceNode  = mainFuncDecl.name
		luaCall.callee.name = mainFuncDecl.valueConstant.name
		table.insert(luaProgramBody.statements, luaCall)

	elseif outputType == !(OUTPUT_TYPE_LUA_MODULE) then
		local luaModuleNode     = globalScope.fileScopeWithValueToExport.valueToExport
		local luaExpr           = writeExpression(state, writer, 1, {}, luaModuleNode)
		local luaReturnNode     = !!(LUA_STATEMENT[[ return ]])
		luaReturnNode.values[1] = luaExpr
		table.insert(luaProgramBody.statements, luaReturnNode)

	else
		errorInternal("outputType==%d", outputType)
	end

	-- End of user code - start writing to output.
	!local DEFAULT_HEADER       = '#!/bin/sh\n_=[[\nexec lua "$0" "$@"\n]] and nil'
	!local DEFAULT_HEADER_LINES = 1 + countString(DEFAULT_HEADER, "\n", true)

	local lua, luaLastLn, luaLastLnRegistered = createLuaOutput(writer, !(DEFAULT_HEADER_LINES+1))

	local file = assert(io.open(state.settings.outputFilePath, "w"))

	if outputType == !(OUTPUT_TYPE_LUA_APP) then
		file:write!(DEFAULT_HEADER.."\n") -- @Incomplete: Setting to specify the prefix for the written file (shebang and maybe a comment with copyright info, library documentation etc.).
	end
	file:write(lua)

	if outputDebugInfo then
		!(
		-- Size of line mapping information in bytes in a small test program:
		--
		--            pad   exact indices
		--     files  1700  3500
		--     lines  2400  4300
		--
		local USE_PADDING = 1==1 -- Enabling this seem better.
		)

		!local WRAP             = 50
		local MODULE_DIR_PREFIX = (COMPILER_DIRECTORY.."/modules/"):gsub("^%./", "")

		local pathIndices = {}
		local pathIndex   = 0
		local count       = 0

		file:write("local _ = nil\n") -- Takes up less space than 'nil'.

		file:write("lineMappings.paths = {")
		for ln = 1, luaLastLnRegistered do
			local path = writer.lineMappingFiles[ln]

			if writer.lineMappingLines[ln] and not pathIndices[path] then
				count = count + 1
				if count > 1 then  file:write(",")  end -- We don't care about WRAP here as this array will be relatively short.

				pathIndex         = pathIndex + 1
				pathIndices[path] = pathIndex

				path = path:gsub("^%./", "")
				!if not DEBUG then
					if path:find(MODULE_DIR_PREFIX, 1, true) == 1 then
						path = "module:"..path:sub(#MODULE_DIR_PREFIX+1):gsub("%.gloa$", "")
					end
				!end

				file:write(F("%q", path))
			end
		end
		file:write("}\n")

		file:write("lineMappings.files = {")
		!if USE_PADDING then
			for ln = 1, luaLastLnRegistered do
				if ln % !(WRAP) == 0 then  file:write(",\n")
				elseif ln       >  1 then  file:write(",")  end
				file:write(pathIndices[writer.lineMappingFiles[ln]] or "_")
			end
		!else
			count = 0
			for ln = 1, luaLastLnRegistered do
				if writer.lineMappingLines[ln] then
					count = count + 1
					if count % !(WRAP) == 0 then  file:write(",\n")
					elseif count       >  1 then  file:write(",")  end
					file:write("[", ln, "]=", pathIndices[writer.lineMappingFiles[ln]])
				end
			end
		!end
		file:write("}\n")

		file:write("lineMappings.lines = {")
		!if USE_PADDING then
			for ln = 1, luaLastLnRegistered do
				if ln % !(WRAP) == 0 then  file:write(",\n")
				elseif ln       >  1 then  file:write(",")  end
				file:write(writer.lineMappingLines[ln] or "_")
			end
		!else
			count = 0
			for ln = 1, luaLastLnRegistered do
				if writer.lineMappingLines[ln] then
					count = count + 1
					if count % !(WRAP) == 0 then  file:write(",\n")
					elseif count       >  1 then  file:write(",")  end
					file:write("[", ln, "]=", writer.lineMappingLines[ln])
				end
			end
		!end
		file:write("}\n")
	end

	local moduleVariableCode = (outputType == !(OUTPUT_TYPE_LUA_MODULE) and ", module" or "")

	file:write("local os, ok", moduleVariableCode, " = os, xpcall(runProgram, gloaErrorHandler)\n")
	file:write("if not ok then  os.exit(1)  end\n") -- In case there was an error in gloaErrorHandler() for some reason.  :LuaModuleErrors

	if outputType == !(OUTPUT_TYPE_LUA_MODULE) then
		file:write("return module\n")
	end

	file:close()

	-- luaParser.printTree(writer.luaMainChunkBody)

	-- Validate output.
	local chunk, err = loadfile(state.settings.outputFilePath)
	if not chunk then
		errorInternal("Wrote invalid Lua output. (%s)", err)
	end
end

-- lua, lastLineNumber, lastRegisteredLineNumber = createLuaOutput( writer, startingLineNumber )
function _G.createLuaOutput(writer, ln)
	!ifDEBUG `do
		local ok, errs = luaParser.validateTree(writer.luaMainChunkBody)
		if not ok then
			luaParser.printTree(writer.luaMainChunkBody)
			print(errs)
			errorInternal()
		end
	end`

	luaParser.traverseTree(writer.luaMainChunkBody, function(luaNode, parent, container, key)
		luaNode.parent     = parent
		luaNode.container  = container
		luaNode.key        = key
		luaNode.sourceNode = luaNode.sourceNode or (parent and parent.sourceNode)
	end)

	!ifDEBUG`
	local nodeCount     = 0`
	local lnBufferIndex = 0

	local lua = assert(luaParser.toLua(writer.luaMainChunkBody, true, function(luaNode, buffer)
		!ifDEBUG `nodeCount = nodeCount + 1`

		while lnBufferIndex < #buffer do
			lnBufferIndex = lnBufferIndex + 1
			ln            = ln + countString(buffer[lnBufferIndex], "\n", true)
		end

		-- [[ Break long lines. @Speed
		-- if luaNode.parent and luaNode.parent.type == "table" then
			!local MAX_COLUMNS = 200 -- (Not exact.)
			local col          = 1

			for i = #buffer, 1, -1 do
				local s   = buffer[i]
				local pos = s:find"\n[^\n]*$"
				col       = col + #s

				if pos then
					col = col - pos

					if col > !(MAX_COLUMNS) then
						lnBufferIndex         = lnBufferIndex + 1
						buffer[lnBufferIndex] = "\n"
						ln                    = ln + 1
					end
					break
				end
			end
		-- end
		--]]

		if outputDebugInfo then
			local sourceNode = luaNode.sourceNode

			if sourceNode and not writer.lineMappingLines[ln] then
				writer.lineMappingFiles[ln] = sourceNode.source.path
				writer.lineMappingLines[ln] = sourceNode.line
			end
		end
	end))
	-- !ifDEBUG `printf("nodeCount=%d ln=%d bufferIndex=%d", nodeCount, ln, lnBufferIndex)`
	-- !ifDEBUG `os.exit(2)`

	local lnRegistered = ln

	while not writer.lineMappingFiles[lnRegistered] and lnRegistered > 1 do
		lnRegistered = lnRegistered - 1
	end

	return lua, ln, lnRegistered
end



local UNICODE_TO_ASCII = @insert "src/unicodeConversions.luapart"
!recordLineNumber(@file, @line)

function _G.unicodeToLuaIdentifier(name)
	if name:find"[\128-\255]" then
		name = name:gsub(!(UTF8_CHARACTER_PATTERN), function(c)
			return (#c == 1 and c) or UNICODE_TO_ASCII[c] or "_"
		end)
	elseif LUA_KEYWORDS[name] then
		name = name .. "_"
	end
	return name
end



local HAS_DEFAULT_VALUE = !(Set{
	TYPE_ANY,
	TYPE_ARRAY,
	TYPE_BOOL,
	TYPE_FLOAT,
	TYPE_INT,
	TYPE_NONE,
	TYPE_STRING,
	TYPE_STRUCT,
	TYPE_TABLE,
	TYPE_VARARG, -- Varargs never have any default value(s), but because it's a list we can just say that the default value is "nothing".
})
function _G.doesTypeHaveAnyDefaultValue(typeInfo)
	return HAS_DEFAULT_VALUE[typeInfo.tag] or false
end



function _G.validateForeignSource(state, foreignSource, foreignSourceName, nodeForError)
	if foreignSource == "lua" then
		if foreignSourceName:find"^[%w_]+$" or foreignSourceName:find"^[%a_][%w_]*%.[%a_][%w_]*$" or loadstring(F("return(%s)", foreignSourceName)) then
			-- void
		elseif foreignSourceName:find"%-%-[^\n]*$" then
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid Lua symbol. (Note that trailing comments in the Lua code may cause problems.)")
		else
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid Lua symbol.")
		end

	elseif foreignSource == "compiler" then
		if not foreignApiCompilerSymbols[foreignSourceName] then
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid compiler symbol.")
		end

	elseif foreignSource == "method" then
		--[[ Hmm, I think we *will* support keywords and weird names as method names actually.
		if not (foreignSourceName:find"^[%a_][%w_]*$" ~= nil and not LUA_KEYWORDS[foreignSourceName]) then
			-- @UX: The error arrow is way off!
			nodeError(state, nodeForError, "ForeignValidator", "This is not a valid Lua identifier to use as method name: '%s'", foreignSourceName)
		end
		--]]

	else
		errorInternal(state, nodeForError, "Incomplete: Handle foreignSource=%s", foreignSource)
	end
end



function _G.formatInfoComment(info)
	return "--[[" .. info:gsub("[%[%]]", "%0 ") .. "]]"
end



function _G.writerError(state, node, s, ...)
	nodeError(state, node, "ProgramWriter", s, ...)
end


