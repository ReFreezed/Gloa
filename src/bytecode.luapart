--[[============================================================
--=
--=  Bytecode
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	bcAllocate*
	bcEmit*
	bcError, bcMessage

----------------------------------------------------------------

	Lua 5.x opcode info

	Instructions fields:
		'A'   : 8 bits
		'B'   : 9 bits
		'C'   : 9 bits
		'Ax'  : 26 bits ('A', 'B', and 'C' together)
		'Bx'  : 18 bits ('B' and 'C' together)
		'sBx' : signed Bx

	Opcodes:
		R(x) - register
		Kst(x) - constant (in constant table)
		RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)

		name           args    description
		----------------------------------------------------------------
		OP_MOVE        A B     R(A) := R(B)
		OP_LOADK       A Bx    R(A) := Kst(Bx)
		OP_LOADBOOL    A B C   R(A) := (Bool)B; if (C) pc++
		OP_LOADNIL     A B     R(A) := ... := R(B) := nil
		OP_GETUPVAL    A B     R(A) := UpValue[B]

		OP_GETGLOBAL   A Bx    R(A) := Gbl[Kst(Bx)]
		OP_GETTABLE    A B C   R(A) := R(B)[RK(C)]

		OP_SETGLOBAL   A Bx    Gbl[Kst(Bx)] := R(A)
		OP_SETUPVAL    A B     UpValue[B]   := R(A)
		OP_SETTABLE    A B C   R(A)[RK(B)]  := RK(C)

		OP_NEWTABLE    A B C   R(A) := {} (size = B,C)

		OP_SELF        A B C   R(A+1) := R(B); R(A) := R(B)[RK(C)]

		OP_ADD         A B C   R(A) := RK(B) +  RK(C)
		OP_SUB         A B C   R(A) := RK(B) -  RK(C)
		OP_MUL         A B C   R(A) := RK(B) *  RK(C)
		OP_DIV         A B C   R(A) := RK(B) /  RK(C)
		OP_IDIV        A B C   R(A) := RK(B) // RK(C)
		OP_MOD         A B C   R(A) := RK(B) %  RK(C)
		OP_POW         A B C   R(A) := RK(B) ^  RK(C)
		OP_UNM         A B     R(A) := -R(B)
		OP_NOT         A B     R(A) := not R(B)
		OP_LEN         A B     R(A) := length of R(B)

		OP_CONCAT      A B C   R(A) := R(B).. ... ..R(C)

		OP_JMP         A sBx   pc+=sBx; if (A) close all upvalues >= R(A - 1)

		OP_EQ          A B C   if ((RK(B) == RK(C)) ~= A) then pc++
		OP_LT          A B C   if ((RK(B) <  RK(C)) ~= A) then pc++
		OP_LE          A B C   if ((RK(B) <= RK(C)) ~= A) then pc++

		OP_TEST        A C     if not (R(A) <=> C) then pc++
		OP_TESTSET     A B C   if (R(B) <=> C) then R(A) := R(B) else pc++

		OP_CALL        A B C   R(A), ..., R(A+C-2) := R(A)(R(A+1), ..., R(A+B-1))
		OP_TAILCALL    A B C   return R(A)(R(A+1), ..., R(A+B-1))
		OP_RETURN      A B     return R(A), ..., R(A+B-2)  (see note)

		OP_FORLOOP     A sBx   R(A)+=R(A+2); if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }

		OP_FORPREP     A sBx   R(A)-=R(A+2); pc+=sBx

		OP_TFORCALL    A C     R(A+3), ..., R(A+2+C) := R(A)(R(A+1), R(A+2));
		OP_TFORLOOP    A sBx   if R(A+1) ~= nil then { R(A)=R(A+1); pc += sBx }

		OP_SETLIST     A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B

		OP_CLOSURE     A Bx    R(A) := closure(KPROTO[Bx], R(A), ..., R(A+n))

		OP_VARARG      A B     R(A), R(A+1), ..., R(A+B-1) = vararg
		----------------------------------------------------------------

	Notes:
		* In OP_CALL, if (B == 0) then B = top. If (C == 0), then 'top' is
		set to last_result+1, so next open instruction (OP_CALL, OP_RETURN,
		OP_SETLIST) may use 'top'.

		* In OP_VARARG, if (B == 0) then use actual number of varargs and
		set top (like in OP_CALL with C == 0).

		* In OP_RETURN, if (B == 0) then return up to 'top'.

		* In OP_SETLIST, if (B == 0) then B = 'top'; if (C == 0) then next
		'instruction' is real C.

		* For comparisons, A specifies what condition the test should accept
		(true or false).

		* All 'skips' (pc++) assume that next instruction is a jump.

--============================================================]]

!(
local BC_CODES = {
	-- name            args    description

	"BC_MOVE",      -- A B     R(A) := R(B)
	"BC_LOADK",     -- A Bx    R(A) := Kst(Bx)
	"BC_LOADBOOL",  -- A B C   R(A) := (Bool)B; if (C) pc++
	"BC_LOADNIL",   -- A B     R(A) := ... := R(B) := nil
	"BC_GETUPVAL",  -- A B     R(A) := UpValue[B]

	"BC_GETGLOBAL", -- A Bx    R(A) := Gbl[Kst(Bx)]
	"BC_GETTABLE",  -- A B C   R(A) := R(B)[RK(C)]

	"BC_SETGLOBAL", -- A Bx    Gbl[Kst(Bx)] := R(A)
	"BC_SETUPVAL",  -- A B     UpValue[B] := R(A)
	"BC_SETTABLE",  -- A B C   R(A)[RK(B)] := RK(C)

	"BC_NEWTABLE",  -- A B C   R(A) := {} (size = B,C)

	"BC_SELF",      -- A B C   R(A+1) := R(B); R(A) := R(B)[RK(C)]

	"BC_ADD",       -- A B C   R(A) := RK(B) +  RK(C)
	"BC_SUB",       -- A B C   R(A) := RK(B) -  RK(C)
	"BC_MUL",       -- A B C   R(A) := RK(B) *  RK(C)
	"BC_DIV",       -- A B C   R(A) := RK(B) /  RK(C)
	"BC_IDIV",      -- A B C   R(A) := RK(B) // RK(C)
	"BC_MOD",       -- A B C   R(A) := RK(B) %  RK(C)
	"BC_POW",       -- A B C   R(A) := RK(B) ^  RK(C)
	"BC_UNM",       -- A B     R(A) := -R(B)
	"BC_NOT",       -- A B     R(A) := not R(B)
	"BC_LEN",       -- A B     R(A) := length of R(B)

	"BC_CONCAT",    -- A B C   R(A) := R(B).. ... ..R(C)

	"BC_JUMP",      -- A sBx   pc+=sBx; if (A) close all upvalues >= R(A - 1)

	"BC_EQ",        -- A B C   if ((RK(B) == RK(C)) ~= A) then pc++
	"BC_LT",        -- A B C   if ((RK(B) <  RK(C)) ~= A) then pc++
	"BC_LE",        -- A B C   if ((RK(B) <= RK(C)) ~= A) then pc++

	"BC_TEST",      -- A C     if not (R(A) <=> C) then pc++
	"BC_TESTSET",   -- A B C   if (R(B) <=> C) then R(A) := R(B) else pc++

	"BC_CALL",      -- A B C   R(A), ..., R(A+C-1) := R(A)(R(A+1), ..., R(A+B-1))
	"BC_TAILCALL",  -- A B C   return R(A)(R(A+1), ..., R(A+B-1))
	"BC_RETURN",    -- A B     return R(A), ..., R(A+B-1)

	"BC_FORLOOP",   -- A sBx   R(A)+=R(A+2); if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }
	"BC_FORPREP",   -- A sBx   R(A)-=R(A+2); pc+=sBx

	"BC_TFORCALL",  -- A C     R(A+3), ..., R(A+2+C) := R(A)(R(A+1), R(A+2));
	"BC_TFORLOOP",  -- A sBx   if R(A+1) ~= nil then { R(A)=R(A+1); pc += sBx }

	"BC_SETLIST",   -- A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B

	"BC_CLOSURE",   -- A Bx    R(A) := closure(KPROTO[Bx], R(A), ..., R(A+n))

	"BC_VARARG",    -- A B     R(A), R(A+1), ..., R(A+B-1) = vararg
}

for bcode, bcodeName in ipairs(BC_CODES) do
	_G[bcodeName] = bcode
end

-- DEPEND_AND_RETURN( dependentCode, dependType, dependOnCode [, returnValueCode="" ] )
local function DEPEND_AND_RETURN(dependentCode, dependType, dependOnCode, returnValueCode)
	returnValueCode = (returnValueCode or "")
	__LUA("addDependency(state, ",dependentCode,", ",toLua(dependType),", ",dependOnCode,") ; return ",returnValueCode)
end
)



local !struct"Constant"{
	name         = "",  -- Only used for constants that are objects.
	nameTampered = false,
	valueType    = NIL, -- TypeInfo
	value        = NIL,
	isObject     = false,
}

-- constant, isNew = bcAllocateConstantValueIfNew( state, simpleTypeInfo,    literalValue   )
-- constant, isNew = bcAllocateConstantValueIfNew( state, functionSignature, lambdaWithBody )
-- constant, isNew = bcAllocateConstantValueIfNew( state, typeInfo,          value          )
function _G.bcAllocateConstantValueIfNew(state, typeInfo, v)
	local tag      = typeInfo.tag
	local isSimple = isTypeSimple(typeInfo)

	if not isSimple and isAny(tag, !(typeTags.TypeInfoAny),!(typeTags.TypeInfoNamespace),!(typeTags.TypeInfoVoid),!(typeTags.TypeInfoCompound),!(typeTags.TypeInfoList)) then
		errorInternal("Invalid type '%s' for constant.", (TYPE_TAG_NAMES[tag] or "?"))
	end
	local isObject = not isSimple

	for _, const in ipairs(state.constants) do
		if const.valueType ~= typeInfo then
			-- void

		elseif isSimple then
			if const.value == v then  return const, false  end

		elseif tag == !(typeTags.TypeInfoArray) then
			errorInternal("@Incomplete: Handle TypeInfoArray.")

		elseif tag == !(typeTags.TypeInfoFunction) then
			if const.value == v then  return const, false  end -- All functions are unique for now. We may detect duplicates at some point.

		elseif tag == !(typeTags.TypeInfoStruct) then
			if const.value == v then  return const, false  end -- All structs are unique for now. We may detect duplicates at some point.

		elseif tag == !(typeTags.TypeInfoEnum) then
			errorInternal("@Incomplete: Handle TypeInfoEnum.")

		elseif tag == !(typeTags.TypeInfoTable) then
			errorInternal("Incomplete: Handle tables.") -- @Incomplete: Compare tables (or maybe every table is a unique?).

		else
			errorInternal("Incomplete: Unhandled constant value type '%s'.", (TYPE_TAG_NAMES[tag] or "?"))
		end
	end

	local i = #state.constants+1

	local const     = Constant()
	const.valueType = typeInfo
	const.value     = v
	const.isObject  = isObject

	if isObject then
		-- Note: Simple constants (like ints) don't need a referencable name as we write those values directly everywhere.
		if tag == !(typeTags.TypeInfoFunction) then
			state.functionN = state.functionN+1
			const.name      = "F"..state.functionN
		else
			state.constantN = state.constantN+1
			const.name      = "C"..state.constantN
		end
	end

	state.constants[i] = const

	return const, true
end

-- constant, isNew = bcAllocateConstantValueForExpressionIfNew( state, expression, dependent )
-- Returns nil on failure and the dependent is now waiting.
function _G.bcAllocateConstantValueForExpressionIfNew(state, expr, dependent)
	local typeInfo = expr.inferredType

	if expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		local const   = literal.valueConstant

		if not const then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_EMITTED, `literal`, `nil`)
		end

		return const, false

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		local typeInfo = getTypeInfoForBuiltinType(state, "int")
		local typeId   = typeNode.representedType.id
		return bcAllocateConstantValueIfNew(state, typeInfo, typeId) -- Glóa types are represented as ints in Lua.

	elseif expr.nodeType == !(nodeTypes.AstLambda) then
		local lambda = expr
		assert(lambda.body) -- We should never get here for lambdas without bodies as those would have been AstTypes.

		return bcAllocateConstantValueIfNew(state, typeInfo, lambda)

	elseif expr.nodeType == !(nodeTypes.AstStruct) then
		local struct = expr

		-- @Incomplete: Wait for statements to get inferred (when we got struct self-referencing working).

		local const, isNew = bcAllocateConstantValueIfNew(state, typeInfo, struct)

		if isNew and state.settings.outputDebugInfo then
			local structInfo = struct.representedType

			if structInfo.name ~= "" then
				const.name         = const.name.."_"..unicodeToLuaIdentifier(structInfo.name)
				const.nameTampered = true
			end
		end

		return const, isNew

	elseif expr.nodeType == !(nodeTypes.AstEnum) then
		local enum         = expr
		local const, isNew = bcAllocateConstantValueIfNew(state, typeInfo, enum)

		if isNew and state.settings.outputDebugInfo then
			local enumInfo = enum.representedType

			if enumInfo.name ~= "" then
				const.name         = const.name.."_"..unicodeToLuaIdentifier(enumInfo.name)
				const.nameTampered = true
			end
		end

		return const, isNew

	elseif expr.nodeType == !(nodeTypes.AstIdentifier) then
		local ident = expr
		local decl  = ident.declaration

		if decl.queued.pipe <= !(PIPE_BYTECODE) then
			!DEPEND_AND_RETURN(`dependent`, DEPEND_NODE_EMITTED, `decl`, `nil`)
		end

		assert(decl.assignment) -- Should have given an error in the typer.

		local valueExpr = getAssignmentValue(state, decl.name, decl.assignment.values, decl.assignmentIndex)
		return bcAllocateConstantValueForExpressionIfNew(state, valueExpr, dependent)

	elseif expr.nodeType == !(nodeTypes.AstCast) then
		errorInternal() -- Casts of constants should have simplified to something else in the typer.

	else
		errorUnhandledNodeType(expr)
	end
	errorInternal()
end

function _G.bcAllocateTopScopeName(state, name)
	local i = #state.topScopeNames+1

	local topScopeName = state.settings.outputDebugInfo and "G"..i.."_"..unicodeToLuaIdentifier(name) or "G"..i

	state.topScopeNames[i] = topScopeName
	return topScopeName
end



--[[
local function createNodeWithDefaultValueForType(state, parent, typeInfo)
	local tag = typeInfo.tag

	if BUILTIN_TYPE_TAG_TO_LITERAL_TYPE[tag] then
		local literal        = astNewNode(AstLiteral, parent.token, parent)
		literal.literalType  = BUILTIN_TYPE_TAG_TO_LITERAL_TYPE[tag]
		literal.inferredType = typeInfo

		if tag == !(typeTags.TypeInfoBool) then
			literal.value = false
		elseif tag == !(typeTags.TypeInfoInt) then
			literal.value = 0
		elseif tag == !(typeTags.TypeInfoNil) then
			literal.value = nil
		elseif tag == !(typeTags.TypeInfoFloat) then
			literal.value = 0
		elseif tag == !(typeTags.TypeInfoString) then
			literal.value = ""
		else
			errorInternal("%d", tag)
		end

		return literal

	else
		errorInternal("Incomplete: Handle type tag '%s'.", (TYPE_TAG_NAMES[tag] or "?"))
	end
end
--]]

function _G.bcEmitForLambda(state, lambda)
	bcAllocateConstantValueIfNew(state, lambda.inferredType, lambda)

	local body = lambda.body

	if body and body.queued.pipe <= !(PIPE_BYTECODE) then
		!DEPEND_AND_RETURN(`lambda`, DEPEND_NODE_EMITTED, `body`)
	end

	if body and lambda.bodyIsForeign then
		-- @Incomplete: Emit for foreign function.
		moveToPipe(state, lambda, !(PIPE_DONE))
		return
	end

	-- Ensure there's return statements at the end of the lambda body.
	local lastStatement = body[#body]

	if not (lastStatement and lastStatement.what.nodeType == !(nodeTypes.AstReturn)) then
		if lambda.inferredType.argumentTypesOut[1] then
			bcError(state, body, "Expected a return statement at the end of the function body.") -- @Polish: Better error arrow position.
		end

		local statement  = astNewNode(AstStatement, lambda.bodyEndToken, body)
		local returnNode = astNewNode(AstReturn,    statement.token,     statement)
		statement.what   = returnNode

		--[[ We don't have default return values (yet?).
		for i, argTypeInfo in ipairs(lambda.inferredType.argumentTypesOut) do
			local valueExpr = createNodeWithDefaultValueForType(state, returnNode, argTypeInfo)
			returnNode.values[i] = valueExpr
		end
		--]]

		addToQueueRecursively(state, statement, !(PIPE_DONE))
		table.insert(body, statement)
	end

	-- @Incomplete: Insert defer blocks at the end of the block they're in and
	-- before return/continue/break statements. (Probably not needed until we're
	-- actualy generating bytecode.)

	-- @Incomplete: Generate bytecode.
	local bcs = lambda.bytecodes

	-- TEMP:
	local returnValuePosition1 = 0
	local returnValueCount     = 0
	table.insert(bcs, !(BC_RETURN))         -- [A B] return R(A), ..., R(A+B-1)
	table.insert(bcs, returnValuePosition1) -- A
	table.insert(bcs, returnValueCount)     -- B

	moveToPipe(state, lambda, !(PIPE_DONE))
end

function _G.bcEmitForDeclaration(state, decl)
	if decl.isConstant or isScopeDeclarative(getClosestScope(decl)) then
		if decl.assignment then
			local valueExpr = getAssignmentValue(state, decl.name, decl.assignment.values, decl.assignmentIndex)
			local const     = bcAllocateConstantValueForExpressionIfNew(state, valueExpr, decl)
			if not const then  return  end -- A dependency was added and we're now waiting.

			decl.valueConstant = const

			if decl.isConstant then
				if not const.nameTampered and state.settings.outputDebugInfo then
					const.name         = const.name.."_"..unicodeToLuaIdentifier(decl.name.name)
					const.nameTampered = true
				end
			elseif isAny(getClosestScope(decl).nodeType, !(nodeTypes.AstGlobalScope),!(nodeTypes.AstFileScope)) then
				decl.topScopeName = bcAllocateTopScopeName(state, decl.name.name)
			end
		else
			decl.topScopeName = bcAllocateTopScopeName(state, decl.name.name)
		end
	end

	moveToPipe(state, decl, !(PIPE_DONE))
end

function _G.bcEmit(state, node)
	if node.nodeType == !(nodeTypes.AstLiteral) then
		local literal         = node
		literal.valueConstant = bcAllocateConstantValueIfNew(state, literal.inferredType, literal.value)
		moveToPipe(state, literal, !(PIPE_DONE))

	elseif node.nodeType == !(nodeTypes.AstLambda) then
		local lambda = node
		assert(lambda.body)
		bcEmitForLambda(state, lambda)

	elseif node.nodeType == !(nodeTypes.AstDeclaration) then
		local decl = node
		bcEmitForDeclaration(state, decl)

	elseif node.nodeType == !(nodeTypes.AstLookup) then
		local lookup = node
		bcEmitForLookup(state, decl)

	else
		errorUnhandledNodeType(node)
	end
	--[[
	AstIdentifier AstType AstCall AstDeclaration AstVararg AstLiteral AstUnary AstBinary AstTable AstArgument
	AstArguments AstLambda AstTypeOf AstCast AstStatement AstAssignment AstReturn AstBreak AstContinue AstDefer
	AstImport AstIf AstWhile AstFor AstStruct AstEnum AstFileScope AstGlobalScope AstBlock
	]]
end



function _G.bcError(state, node, s, ...)
	return nodeError(state, node, "Bytecode", s, ...)
end

-- bcMessage( [ outputFile=io.stdout, ] compilationState, node, label, formatString, ... )
function _G.bcMessage(file, state, node, label, s, ...)
	return nodeMessage(file, state, node, label, "Bytecode", s, ...)
end


