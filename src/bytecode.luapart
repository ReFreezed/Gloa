--[[============================================================
--=
--=  Bytecode
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	bcEmit*
	bcError, bcMessage

----------------------------------------------------------------

	Lua 5.x opcode info

	Instructions fields:
		'A'   : 8 bits
		'B'   : 9 bits
		'C'   : 9 bits
		'Ax'  : 26 bits ('A', 'B', and 'C' together)
		'Bx'  : 18 bits ('B' and 'C' together)
		'sBx' : signed Bx

	Opcodes:
		R(x) - register
		Kst(x) - constant (in constant table)
		RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)

		name           args    description
		----------------------------------------------------------------
		OP_MOVE        A B     R(A) := R(B)
		OP_LOADK       A Bx    R(A) := Kst(Bx)
		OP_LOADBOOL    A B C   R(A) := (Bool)B; if (C) pc++
		OP_LOADNIL     A B     R(A) := ... := R(B) := nil
		OP_GETUPVAL    A B     R(A) := UpValue[B]

		OP_GETGLOBAL   A Bx    R(A) := Gbl[Kst(Bx)]
		OP_GETTABLE    A B C   R(A) := R(B)[RK(C)]

		OP_SETGLOBAL   A Bx    Gbl[Kst(Bx)] := R(A)
		OP_SETUPVAL    A B     UpValue[B]   := R(A)
		OP_SETTABLE    A B C   R(A)[RK(B)]  := RK(C)

		OP_NEWTABLE    A B C   R(A) := {} (size = B,C)

		OP_SELF        A B C   R(A+1) := R(B); R(A) := R(B)[RK(C)]

		OP_ADD         A B C   R(A) := RK(B) +  RK(C)
		OP_SUB         A B C   R(A) := RK(B) -  RK(C)
		OP_MUL         A B C   R(A) := RK(B) *  RK(C)
		OP_DIV         A B C   R(A) := RK(B) /  RK(C)
		OP_IDIV        A B C   R(A) := RK(B) // RK(C)
		OP_MOD         A B C   R(A) := RK(B) %  RK(C)
		OP_POW         A B C   R(A) := RK(B) ^  RK(C)
		OP_UNM         A B     R(A) := -R(B)
		OP_NOT         A B     R(A) := not R(B)
		OP_LEN         A B     R(A) := length of R(B)

		OP_CONCAT      A B C   R(A) := R(B).. ... ..R(C)

		OP_JMP         A sBx   pc+=sBx; if (A) close all upvalues >= R(A - 1)

		OP_EQ          A B C   if ((RK(B) == RK(C)) ~= A) then pc++
		OP_LT          A B C   if ((RK(B) <  RK(C)) ~= A) then pc++
		OP_LE          A B C   if ((RK(B) <= RK(C)) ~= A) then pc++

		OP_TEST        A C     if not (R(A) <=> C) then pc++
		OP_TESTSET     A B C   if (R(B) <=> C) then R(A) := R(B) else pc++

		OP_CALL        A B C   R(A), ..., R(A+C-2) := R(A)(R(A+1), ..., R(A+B-1))
		OP_TAILCALL    A B C   return R(A)(R(A+1), ..., R(A+B-1))
		OP_RETURN      A B     return R(A), ..., R(A+B-2)  (see note)

		OP_FORLOOP     A sBx   R(A)+=R(A+2); if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }

		OP_FORPREP     A sBx   R(A)-=R(A+2); pc+=sBx

		OP_TFORCALL    A C     R(A+3), ..., R(A+2+C) := R(A)(R(A+1), R(A+2));
		OP_TFORLOOP    A sBx   if R(A+1) ~= nil then { R(A)=R(A+1); pc += sBx }

		OP_SETLIST     A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B

		OP_CLOSURE     A Bx    R(A) := closure(KPROTO[Bx], R(A), ..., R(A+n))

		OP_VARARG      A B     R(A), R(A+1), ..., R(A+B-1) = vararg
		----------------------------------------------------------------

	Notes:
		* In OP_CALL, if (B == 0) then B = top. If (C == 0), then 'top' is
		set to last_result+1, so next open instruction (OP_CALL, OP_RETURN,
		OP_SETLIST) may use 'top'.

		* In OP_VARARG, if (B == 0) then use actual number of varargs and
		set top (like in OP_CALL with C == 0).

		* In OP_RETURN, if (B == 0) then return up to 'top'.

		* In OP_SETLIST, if (B == 0) then B = 'top'; if (C == 0) then next
		'instruction' is real C.

		* For comparisons, A specifies what condition the test should accept
		(true or false).

		* All 'skips' (pc++) assume that next instruction is a jump.

--============================================================ ]]

!(
local BC_CODES = {
	-- name         args    description

	"BC_MOVE",      -- A B     R(A) := R(B)
	"BC_LOADK",     -- A Bx    R(A) := Kst(Bx)
	"BC_LOADBOOL",  -- A B C   R(A) := (Bool)B; if (C) pc++
	"BC_LOADNIL",   -- A B     R(A) := ... := R(B) := nil
	"BC_GETUPVAL",  -- A B     R(A) := UpValue[B]

	"BC_GETGLOBAL", -- A Bx    R(A) := Gbl[Kst(Bx)]
	"BC_GETTABLE",  -- A B C   R(A) := R(B)[RK(C)]

	"BC_SETGLOBAL", -- A Bx    Gbl[Kst(Bx)] := R(A)
	"BC_SETUPVAL",  -- A B     UpValue[B] := R(A)
	"BC_SETTABLE",  -- A B C   R(A)[RK(B)] := RK(C)

	"BC_NEWTABLE",  -- A B C   R(A) := {} (size = B,C)

	"BC_SELF",      -- A B C   R(A+1) := R(B); R(A) := R(B)[RK(C)]

	"BC_ADD",       -- A B C   R(A) := RK(B) +  RK(C)
	"BC_SUB",       -- A B C   R(A) := RK(B) -  RK(C)
	"BC_MUL",       -- A B C   R(A) := RK(B) *  RK(C)
	"BC_DIV",       -- A B C   R(A) := RK(B) /  RK(C)
	"BC_IDIV",      -- A B C   R(A) := RK(B) // RK(C)
	"BC_MOD",       -- A B C   R(A) := RK(B) %  RK(C)
	"BC_POW",       -- A B C   R(A) := RK(B) ^  RK(C)
	"BC_UNM",       -- A B     R(A) := -R(B)
	"BC_NOT",       -- A B     R(A) := not R(B)
	"BC_LEN",       -- A B     R(A) := length of R(B)

	"BC_CONCAT",    -- A B C   R(A) := R(B).. ... ..R(C)

	"BC_JUMP",      -- A sBx   pc+=sBx; if (A) close all upvalues >= R(A - 1)

	"BC_EQ",        -- A B C   if ((RK(B) == RK(C)) ~= A) then pc++
	"BC_LT",        -- A B C   if ((RK(B) <  RK(C)) ~= A) then pc++
	"BC_LE",        -- A B C   if ((RK(B) <= RK(C)) ~= A) then pc++

	"BC_TEST",      -- A C     if not (R(A) <=> C) then pc++
	"BC_TESTSET",   -- A B C   if (R(B) <=> C) then R(A) := R(B) else pc++

	"BC_CALL",      -- A B C   R(A), ..., R(A+C-2) := R(A)(R(A+1), ..., R(A+B-1))
	"BC_TAILCALL",  -- A B C   return R(A)(R(A+1), ..., R(A+B-1))
	"BC_RETURN",    -- A B     return R(A), ..., R(A+B-2)

	"BC_FORLOOP",   -- A sBx   R(A)+=R(A+2); if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }
	"BC_FORPREP",   -- A sBx   R(A)-=R(A+2); pc+=sBx

	"BC_TFORCALL",  -- A C     R(A+3), ..., R(A+2+C) := R(A)(R(A+1), R(A+2));
	"BC_TFORLOOP",  -- A sBx   if R(A+1) ~= nil then { R(A)=R(A+1); pc += sBx }

	"BC_SETLIST",   -- A B C   R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B

	"BC_CLOSURE",   -- A Bx    R(A) := closure(KPROTO[Bx], R(A), ..., R(A+n))

	"BC_VARARG",    -- A B     R(A), R(A+1), ..., R(A+B-1) = vararg
}

for bcode, bcodeName in ipairs(BC_CODES) do
	_G[bcodeName] = bcode
end
)



local !struct"Constant"{
	id        = 0,
	valueType = NIL, -- TypeInfo
	value     = NIL,
}



function _G.evaluateConstantExpression(state, sourceNode, expr)
	if expr.nodeType == !(nodeTypes.AstLiteral) then
		local literal = expr
		return literal.value

	else
		errorUnhandledNodeType(expr)
	end
end

-- constant = bcAllocateConstantIfNew( state, typeInfo, value )
function _G.bcAllocateConstantIfNew(state, typeInfo, v)
	if not isAny(
		typeInfo,
		getTypeInfoForBuiltinType(state, "bool"),
		getTypeInfoForBuiltinType(state, "float"),
		getTypeInfoForBuiltinType(state, "int"),
		getTypeInfoForBuiltinType(state, "nil"),
		getTypeInfoForBuiltinType(state, "string")
	) then
		errorInternal("@Incomplete: Handle '%s'.", getFriendlyTypeInfoName(typeInfo))
	end

	for _, const in ipairs(state.constants) do
		if const.valueType == typeInfo and const.value == v then -- @Incomplete: Comparison for non-primitive values.
			return const.id
		end
	end

	local i = #state.constants+1

	local const     = Constant()
	const.id        = i
	const.valueType = typeInfo
	const.value     = v

	state.constants[i] = const
	return const
end

function _G.bcAllocateGlobalVariable(state, name)
	local i                  = #state.globalVariables+1
	local globalName         = "GLOBAL"..i.."_"..name
	state.globalVariables[i] = globalName
	return globalName
end



!(
local function DEPEND_AND_RETURN(dependentCode, dependType, dependOnCode)
	__LUA("addDependency(state, ",dependentCode,", ",toLua(dependType),", ",dependOnCode,") ; return")
end
local function DEPEND_AND_RETURN_FALSE(dependentCode, dependType, dependOnCode)
	__LUA("addDependency(state, ",dependentCode,", ",toLua(dependType),", ",dependOnCode,") ; return false")
end
)

function _G.bcEmitForDeclarationStatement(state, statement)
	local decl = statement.what

	-- Constant.
	if decl.isConstant then
		assert(decl.assignment) -- Should have given an error during parsing.

		local valueExpr, typeInfo = getAssignmentValue(state, decl.name, decl.assignment.values, decl.assignmentIndex)

		if valueExpr.nodeType == !(nodeTypes.AstLiteral) then
			local literal      = valueExpr
			decl.valueConstant = bcAllocateConstantIfNew(state, typeInfo, literal.value)

		else
			errorUnhandledNodeType(valueExpr)
		end

		moveTreeToNextPipe(state, statement, !(PIPE_BYTECODE+1)) -- Won't include the assignment statement.
		return
	end

	local scope = getClosestScope(statement)

	-- Static variable.
	if isScopeDeclarative(scope) then
		if not decl.assignment then
			errorInternal("@Incomplete: Default values.")
		end

		local valueExpr, typeInfo = getAssignmentValue(state, decl.name, decl.assignment.values, decl.assignmentIndex)
		local initialValueConst

		if valueExpr.nodeType == !(nodeTypes.AstIdentifier) then
			local ident     = valueExpr
			local declOther = ident.declaration

			if declOther.queued.pipe <= !(PIPE_BYTECODE) then
				!DEPEND_AND_RETURN(`statement`, DEPEND_NODE_EMITTED, `declOther`)
			end

			assert(declOther.isConstant) -- Should have given an error in the typer.
			initialValueConst = declOther.valueConstant or errorInternal() -- @Incomplete: valueConstant is nil for non-literals.

		elseif valueExpr.nodeType == !(nodeTypes.AstLiteral) then
			local literal     = valueExpr
			initialValueConst = bcAllocateConstantIfNew(state, typeInfo, literal.value)

		else
			errorUnhandledNodeType(valueExpr)
		end

		decl.valueConstant      = initialValueConst
		decl.globalVariableName = bcAllocateGlobalVariable(state, decl.name.name)
		moveTreeToNextPipe(state, statement, !(PIPE_BYTECODE+1)) -- Won't include the assignment statement.

	-- Dynamic variable.
	else
		-- void  (These will be handled by AstLambda, I think.)
	end
end

function _G.bcEmitForAssignmentStatement(state, statement)
	local assignment = statement.what

	if assignment.forDeclaration then
		for _, decl in ipairs(assignment.declarations) do
			if decl.queued.pipe <= !(PIPE_BYTECODE) then
				!DEPEND_AND_RETURN(`statement`, DEPEND_NODE_EMITTED, `decl`)
			end
		end
	end

	-- @Incomplete: Emit code for assignment.

	moveTreeToNextPipe(state, statement, !(PIPE_BYTECODE+1))
end

function _G.bcEmit(state, node)
	if node.nodeType == !(nodeTypes.AstStatement) then
		local statement = node

		if statement.what.nodeType == !(nodeTypes.AstDeclaration) then
			bcEmitForDeclarationStatement(state, statement)

		elseif statement.what.nodeType == !(nodeTypes.AstAssignment) then
			bcEmitForAssignmentStatement(state, statement)

		elseif statement.what.nodeType == !(nodeTypes.AstFileScope) then
			local fileScope = statement.what

			for _, statementInner in ipairs(fileScope) do
				if statementInner.queued.pipe <= !(PIPE_BYTECODE) then
					!DEPEND_AND_RETURN(`statement`, DEPEND_NODE_EMITTED, `statementInner.what`)
				end
			end

			moveToNextPipe(state, fileScope, !(PIPE_BYTECODE+1))
			moveToNextPipe(state, statement, !(PIPE_BYTECODE+1))

		else
			errorUnhandledNodeType(statement.what)
		end

	elseif node.nodeType == !(nodeTypes.AstGlobalScope) then
		local globalScope = node

		for _, statement in ipairs(globalScope) do
			if statement.queued.pipe <= !(PIPE_BYTECODE) then
				!DEPEND_AND_RETURN(`globalScope`, DEPEND_NODE_EMITTED, `statement.what`)
			end
		end

		moveToNextPipe(state, globalScope, !(PIPE_BYTECODE+1))

	else
		-- void  (Ignore.)
	end

	--[[
	AstIdentifier AstType AstCall AstDeclaration AstVararg AstLiteral AstUnary AstBinary AstTable AstArgument
	AstArguments AstLambda AstTypeOf AstCast AstStatement AstAssignment AstReturn AstBreak AstContinue AstDefer
	AstImport AstIf AstWhile AstFor AstStruct AstEnum AstFileScope AstGlobalScope AstBlock
	]]
end



function _G.bcError(state, node, s, ...)
	return nodeError(state, node, "Bytecode", s, ...)
end

-- bcMessage( [ outputFile=io.stdout, ] compilationState, node, label, formatString, ... )
function _G.bcMessage(file, state, node, label, s, ...)
	return nodeMessage(file, state, node, label, "Bytecode", s, ...)
end


