--[[============================================================
--=
--=  Preprocessor stuff and globals
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	Preprocessor:
	- debugger
	- F
	- getByte
	- ifDEBUG, ifNotDEBUG
	- N, incN
	- struct

--============================================================]]



!(
local n = 0
function _G.incN() n = n + 1   ; return n  end
function _G.N(_n)  n = _n or n ; return n  end

_G.UTF8_CHARACTER_PATTERN = "[%z\1-\127\194-\244][\128-\191]*"

_G.TOKEN_KEYWORD     = 1
_G.TOKEN_IDENTIFIER  = 2
_G.TOKEN_DIRECTIVE   = 3
_G.TOKEN_FLOAT       = 4
_G.TOKEN_INTEGER     = 5
_G.TOKEN_STRING      = 6
_G.TOKEN_PUNCTUATION = 7

local TOKEN_TITLES = {
	[TOKEN_KEYWORD]     = "keyword",
	[TOKEN_IDENTIFIER]  = "identifier",
	[TOKEN_DIRECTIVE]   = "directive",
	[TOKEN_FLOAT]       = "float",
	[TOKEN_INTEGER]     = "integer",
	[TOKEN_STRING]      = "string",
	[TOKEN_PUNCTUATION] = "punctuation",
}

_G.LITERAL_FLOAT   = 1
_G.LITERAL_INTEGER = 2
_G.LITERAL_STRING  = 3
_G.LITERAL_BOOLEAN = 4
_G.LITERAL_NIL     = 5

local LITERAL_TITLES = {
	[LITERAL_FLOAT]   = "float",
	[LITERAL_INTEGER] = "int",
	[LITERAL_STRING]  = "string",
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_NIL]     = "nil",
}

_G.FOR_NUMERIC  = 1 -- for [ i = ] start, end [, step ]
_G.FOR_SHORT    = 2 -- for [ v1, ... : ] obj
_G.FOR_ITERATOR = 3 -- for v1, ... in iter [, state [, init ] ]

local FOR_TITLES = {
	[FOR_NUMERIC]  = "numeric",
	[FOR_SHORT]    = "short",
	[FOR_ITERATOR] = "iterator",
}

_G.DECLARATION_NORMAL = 0
_G.DECLARATION_STRUCT = 1
_G.DECLARATION_ENUM   = 2

_G.VISIT_CONTINUE        = nil
_G.VISIT_BREAK           = 1
_G.VISIT_IGNORE_CHILDREN = 2

_G.PIPE_NONE     = 0
_G.PIPE_INFER    = 1
_G.PIPE_BYTECODE = 2
_G.PIPE_DONE     = 3

local PIPE_TITLES = {
	[PIPE_NONE]     = "none",
	[PIPE_INFER]    = "infer",
	[PIPE_BYTECODE] = "bytecode",
	[PIPE_DONE]     = "done",
}

_G.DEPEND_DECLARATION   = 1
_G.DEPEND_NODE_INFERRED = 2
_G.DEPEND_NODE_EMITTED  = 3

local DEPEND_TITLES = {
	[DEPEND_DECLARATION]   = "declaration",
	[DEPEND_NODE_INFERRED] = "node_inferred",
}

_G.OPERATOR_PRECEDENCE = {
	-- From lower to higher priority.
	["or"]  = N(1),
	["and"] = incN(),
	["<"]   = incN(), [">"] = N(), ["<="] = N(), [">="] = N(), ["~="] = N(), ["=="] = N(),
	[".."]  = incN(),
	["+"]   = incN(), ["-"] = N(),
	["*"]   = incN(), ["/"] = N(), ["//"] = N(), ["%"] = N(),
	unary   = incN(),-- not, #, +(unary), -(unary)
	["^"]   = incN(),
	call    = incN(), -- (Unused)
	lookup  = incN(),
}
--[[
	The concatenation (..) and exponentiation (^) operators are right associative.
	All other binary operators are left associative.

	a+i < b/2+1       <-->  (a+i) < ((b/2)+1)
	5+x^2*8           <-->  5+((x^2)*8)
	a < y and y <= z  <-->  (a < y) and (y <= z)
	-x^2              <-->  -(x^2)
	x^y^z             <-->  x^(y^z)
]]

_G.NIL = {} -- Placeholder value representing nil values in structs in the metaprogram.



_G.F       = string.format
_G.getByte = string.byte



-- !struct       "_Name[:Parent]" { field1=value1, ... }
-- local !struct "Name[:Parent]"  { field1=value1, ... }
-- _G.!struct    "Name[:Parent]"  { field1=value1, ... }
do
	--[[
	local TEMPLATE_STRUCT_PREALLOC_PREPARATION = trimTemplate(`
		local __struct_$structN_preAllocated__ = {}
		local __struct_$structN_index__        = math.huge
	`)
	local TEMPLATE_STRUCT_PREALLOC_FUNCTION = trimTemplate(`
		$structName = function()
			__struct_$structN_index__ = __struct_$structN_index__+1
			if __struct_$structN_index__ > $count then
				__struct_$structN_index__ = 1
				for i = 1, $count do
					__struct_$structN_preAllocated__[i] = $tableConstructor
				end
			end
			return __struct_$structN_preAllocated__[__struct_$structN_index__]
		end
	`)
	]]

	local structs      = {}
	local structNumber = 0

	function _G.struct(nameAndMaybeParent) return function(fields)
		local name, nameParent = nameAndMaybeParent:match"^([%w_]+):([%w_]+)()$"
		name                   = name or nameAndMaybeParent

		if structs[name] then
			error(F("Duplicate struct '%s'.", name), 2)
		end

		local overrides     = fields._overrides
		local preAllocate   = fields._preAllocate
		fields._overrides   = nil
		fields._preAllocate = nil

		if nameParent then
			local fieldsParent = structs[nameParent] or error(F("No struct '%s'.", nameParent), 2)

			for k, v in pairs(fieldsParent) do
				if fields[k] ~= nil then
					error(F("Existing field in parent: %s.%s", nameParent, k), 2)
				end
				fields[k] = v
			end

			if overrides then
				for k, v in pairs(overrides) do
					if fieldsParent[k] == nil then
						error(F("Non-existing field in parent: %s.%s", nameParent, k), 2)
					end
					assert((v ~= NIL),                         k)
					assert((type(fieldsParent[k]) == type(v)), k)
					fields[k] = v
				end
			end

		elseif overrides then
			error(F("No parent whose fields to override."), 2)
		end

		structs[name] = fields

		if not name:find"^_" then
			local fieldsToOutput = {}

			for k, v in pairs(fields) do
				if v ~= NIL then
					fieldsToOutput[k] = v
				end
			end

			if preAllocate then
				error("Pre-allocation of tables doesn't seem any faster...", 2)

				--[[
				structNumber = structNumber+1

				local values = {structN=structNumber, structName=name, count=preAllocate, tableConstructor=toLua(fieldsToOutput)}

				preprocessorOutputAtTopOfFile(templateToLua(TEMPLATE_STRUCT_PREALLOC_PREPARATION, values))
				__LUA(templateToLua(TEMPLATE_STRUCT_PREALLOC_FUNCTION, values))
				]]

			else
				__LUA(name,"=function()")
					__LUA("return")__VAL(fieldsToOutput)
				__LUA("end")
			end
		end
	end end
end



function _G.ifDEBUG(lua)
	if DEBUG then  __LUA(lua)  end
end

function _G.ifNotDEBUG(lua)
	if not DEBUG then  __LUA(lua)  end
end



function _G.debugger()
	if DEBUGGER then
		local lua = @insert "debugger.luapart"
		lua = "--[[ Debugger: ]]"..lua:gsub("%-%-%[%[.-%]%]", ""):gsub("%-%-[^\n]+", ""):gsub("[\n\t]+", " "):gsub("   +", "  ")
		__LUA(lua)
	end
end
)



_G.DIR_HERE            = !!(GLOA_DIR ~= "" and toLua(GLOA_DIR) or `debug.getinfo(1, "S").source:match"@?(.+)":gsub("[/\\]?[^/\\]+$", ""):gsub("^$", ".")`)
_G.EMPTY_TABLE         = {}

_G.OPERATOR_PRECEDENCE = !(OPERATOR_PRECEDENCE)

_G.TOKEN_TITLES        = !(TOKEN_TITLES)
_G.LITERAL_TITLES      = !(LITERAL_TITLES)
_G.FOR_TITLES          = !(FOR_TITLES)
_G.PIPE_TITLES         = !(PIPE_TITLES)
_G.DEPEND_TITLES       = !(DEPEND_TITLES)


