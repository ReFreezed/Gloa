--[[============================================================
--=
--=  Preprocessor stuff and globals
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	Preprocessor:
	- debugger
	- F
	- getByte
	- ifDEBUG, ifNotDEBUG
	- N, incN
	- struct

--============================================================]]



!(
local n = 0
function _G.incN() n = n + 1   ; return n  end
function _G.N(_n)  n = _n or n ; return n  end

_G.UTF8_CHARACTER_PATTERN = "[%z\1-\127\194-\244][\128-\191]*"

_G.TOKEN_KEYWORD     = 1
_G.TOKEN_IDENTIFIER  = 2
_G.TOKEN_DIRECTIVE   = 3
_G.TOKEN_FLOAT       = 4
_G.TOKEN_INTEGER     = 5
_G.TOKEN_STRING      = 6
_G.TOKEN_PUNCTUATION = 7

local TOKEN_TITLES = {
	[TOKEN_KEYWORD]     = "keyword",
	[TOKEN_IDENTIFIER]  = "identifier",
	[TOKEN_DIRECTIVE]   = "directive",
	[TOKEN_FLOAT]       = "float",
	[TOKEN_INTEGER]     = "integer",
	[TOKEN_STRING]      = "string",
	[TOKEN_PUNCTUATION] = "punctuation",
}

_G.LITERAL_FLOAT   = 1
_G.LITERAL_INTEGER = 2
_G.LITERAL_STRING  = 3
_G.LITERAL_BOOLEAN = 4
_G.LITERAL_NIL     = 5

local LITERAL_TITLES = {
	[LITERAL_FLOAT]   = "float",
	[LITERAL_INTEGER] = "int",
	[LITERAL_STRING]  = "string",
	[LITERAL_BOOLEAN] = "bool",
	[LITERAL_NIL]     = "nil",
}

_G.FOR_NUMERIC  = 1 -- for [ i = ] start, end [, step ]
_G.FOR_SHORT    = 2 -- for [ v1, ... : ] obj
_G.FOR_ITERATOR = 3 -- for v1, ... in iter [, state [, init ] ]

local FOR_TITLES = {
	[FOR_NUMERIC]  = "numeric",
	[FOR_SHORT]    = "short",
	[FOR_ITERATOR] = "iterator",
}

_G.DECLARATION_NORMAL = 0
_G.DECLARATION_STRUCT = 1
_G.DECLARATION_ENUM   = 2

_G.VISIT_CONTINUE        = nil
_G.VISIT_BREAK           = 1
_G.VISIT_IGNORE_CHILDREN = 2

_G.PIPE_NONE     = 0
_G.PIPE_INFER    = 1
_G.PIPE_BYTECODE = 2
_G.PIPE_DONE     = 3

local PIPE_TITLES = {
	[PIPE_NONE]     = "none",
	[PIPE_INFER]    = "infer",
	[PIPE_BYTECODE] = "bytecode",
	[PIPE_DONE]     = "done",
}

_G.DEPEND_DECLARATION          = 1
_G.DEPEND_NODE_INFERRED        = 2
_G.DEPEND_NODE_EMITTED         = 3
_G.DEPEND_STRUCT_MEMBERS_READY = 4
_G.DEPEND_CONSTANT_READY       = 5

local DEPEND_TITLES = {
	[DEPEND_DECLARATION]          = "declaration",
	[DEPEND_NODE_INFERRED]        = "nodeInferred",
	[DEPEND_NODE_EMITTED]         = "nodeEmitted",
	[DEPEND_STRUCT_MEMBERS_READY] = "structMembersReady",
	[DEPEND_CONSTANT_READY]       = "constantReady",
}

_G.TYPE_KIND_UNSET          = 0
_G.TYPE_KIND_SIMPLE_BUILTIN = 1
_G.TYPE_KIND_SIMPLE_USER    = 2
_G.TYPE_KIND_FUNCTION       = 3 -- Extra data: Function signature.
_G.TYPE_KIND_ARRAY          = 4 -- Extra data: Item type.
_G.TYPE_KIND_POLY_STRUCT    = 5 -- Extra data: Parameters.
_G.TYPE_KIND_COMPOUND       = 6 -- Extra data: Types.

local TYPE_KIND_TITLES = {
	[TYPE_KIND_UNSET]          = "**unset type kind**",
	[TYPE_KIND_SIMPLE_BUILTIN] = "built-in type",
	[TYPE_KIND_SIMPLE_USER]    = "user type",
	[TYPE_KIND_FUNCTION]       = "function signature",
	[TYPE_KIND_ARRAY]          = "array type",
	[TYPE_KIND_POLY_STRUCT]    = "polymorphic struct type",
	[TYPE_KIND_COMPOUND]       = "compound type",
}

_G.OPERATOR_PRECEDENCE = {
	-- From lower to higher priority.
	["or"]   = N(1),
	["and"]  = incN(),
	["<"]    = incN(), [">"] = N(), ["<="] = N(), [">="] = N(), ["~="] = N(), ["=="] = N(),
	[".."]   = incN(),
	["+"]    = incN(), ["-"] = N(),
	["*"]    = incN(), ["/"] = N(), ["//"] = N(), ["%"] = N(),
	unary    = incN(),-- not, #, +(unary), -(unary)
	["^"]    = incN(),
	cast     = incN(),
	call     = incN(),
	compound = incN(),-- |
	access   = incN(),-- ., [...]
}
--[[
	The concatenation (..) and exponentiation (^) operators are right associative.
	All other binary operators are left associative.

	a+i < b/2+1       <-->  (a+i) < ((b/2)+1)
	5+x^2*8           <-->  5+((x^2)*8)
	a < y and y <= z  <-->  (a < y) and (y <= z)
	-x^2              <-->  -(x^2)
	x^y^z             <-->  x^(y^z)
]]



_G.F       = string.format
_G.getByte = string.byte



-- function _G.preprocessorOutputAtTopOfFile(lua) end -- Defined in build.lua



-- !struct       "_Name[:Parent]" { {[1]=field1, [2]=fieldValue, option1=optionValue, ...}, ... }
-- local !struct "Name[:Parent]"  { {[1]=field1, [2]=fieldValue, option1=optionValue, ...}, ... }
-- _G.!struct    "Name[:Parent]"  { {[1]=field1, [2]=fieldValue, option1=optionValue, ...}, ... }
do
	_G.structs         = {}
	local structNumber = 0

	function _G.struct(nameAndMaybeParent) return function(fields)
		local name, nameParent = nameAndMaybeParent:match"^([%w_]+):([%w_]+)()$"
		name                   = name or nameAndMaybeParent

		if structs[name] then
			error(F("Duplicate struct '%s'.", name), 2)
		end

		local overrides   = fields._overrides
		fields._overrides = nil

		if nameParent then
			local fieldsParent = structs[nameParent] or error(F("No struct '%s'.", nameParent), 2)

			for i, fieldParent in ipairs(fieldsParent) do
				local k = fieldParent[1]
				if itemWith1(fields, 1, k) then
					error(F("Existing field in parent: %s.%s", nameParent, k), 2)
				end
				table.insert(fields, i, fieldParent)
			end

			if overrides then
				for _, field in ipairs(overrides) do
					assert(type(field) == "table")
					assert((field[2] ~= nil), k)

					local k           = field[1]
					local fieldParent = itemWith1(fieldsParent, 1, k)

					if not fieldParent then
						error(F("Non-existing field in parent: %s.%s", nameParent, k), 2)
					end

					assert((type(fieldParent[2]) == type(field[2])), k)

					local i = indexOf(fields, fieldParent) or assert(false)
					fields[i] = field
				end
			end

		elseif overrides then
			error(F("No parent whose fields to override."), 2)
		end

		structs[name] = fields
		-- table.insert(structs, fields)

		if not name:find"^_" then
			local fieldsToOutput = {}

			for _, field in ipairs(fields) do
				assert(type(field) == "table")

				local k           = field[1]
				fieldsToOutput[k] = field[2] -- May be nil.
			end

			__LUA(name,"=function()")
				__LUA("return")__VAL(fieldsToOutput)
			__LUA("end")
		end
	end end
end



function _G.ifDEBUG(lua)
	if DEBUG then  __LUA(lua)  end
end

function _G.ifNotDEBUG(lua)
	if not DEBUG then  __LUA(lua)  end
end

-- Output an assert() only in DEBUG mode.
function _G.ASSERT(valueCode)
	if DEBUG then  __LUA("assert(",valueCode,")")  end
end

function _G.debugger()
	if DEBUGGER then
		local lua = @insert "debugger.luapart"
		lua = "--[[ Debugger: ]]"..lua:gsub("%-%-%[%[.-%]%]", ""):gsub("%-%-[^\n]+", ""):gsub("[\n\t]+", " "):gsub("   +", "  ")
		__LUA(lua)
	end
end



function _G.trimTemplate(lua)
	return (lua:gsub("%s+", " "):gsub("^ ", ""):gsub(" $", ""))
end

-- templateToLua( template, values [, indentFirstLine=0, indentRest=0 ] )
function _G.templateToLua(template, values, indentFirst, indentRest)
	local lua = template:gsub("$(%a%w*)", values)
	lua       = lua:gsub("^%s*\n", ""):gsub("[^%S\n]+$", "")

	if not indentFirst then
		-- void
	elseif indentFirst < 0 then
		lua = lua:sub(1-indentFirst)
	elseif indentRest > 0 then
		lua = ("\t"):rep(indentFirst)..lua
	end

	if not indentRest then
		-- void
	elseif indentRest < 0 then
		lua = lua:gsub("()([^\n]+)", function(ptr, line)
			if ptr > 1 then  return line:sub(1-indentRest)  end
		end)
	elseif indentRest > 0 then
		local indentStr = ("\t"):rep(indentRest)
		lua = lua:gsub("()([^\n]+)", function(ptr, line)
			if ptr > 1 then  return indentStr..line  end
		end)
	end

	return lua
end



function _G.outputCommaSeparatedValues(...)
	for i = 1, select("#", ...) do
		if i > 1 then  __LUA(",")  end
		__VAL((select(i, ...)))
	end
end



-- Convert an array of values to a set (where the table keys are the values and the table values are 'true').
function _G.Set(values)
	local set = {}
	for _, v in ipairs(values) do
		set[v] = true
	end
	return set
end



function _G.indexOf(t, v)
	for i = 1, #t do
		if t[i] == v then  return i  end
	end
	return nil
end

function _G.itemWith1(t, k, v)
	for i = 1, #t do
		if t[i][k] == v then  return t[i], i  end
	end
	return nil, nil
end
)



_G.COMPILER_PATH = (debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get compiler path.")) :gsub("\\", "/")

_G.COMPILER_DIRECTORY = !!(
	GLOA_DIR ~= ""
	and toLua(GLOA_DIR)
	or  `((debug.getinfo(1, "S").source:match"^@(.+)" or error("Could not get compiler path.")) :gsub("\\", "/"):gsub("/?[^/]+$", ""):gsub("^$", "."))`
)

_G.EMPTY_TABLE         = {}

_G.OPERATOR_PRECEDENCE = !(OPERATOR_PRECEDENCE)

_G.TOKEN_TITLES        = !(TOKEN_TITLES)
_G.LITERAL_TITLES      = !(LITERAL_TITLES)
_G.FOR_TITLES          = !(FOR_TITLES)
_G.PIPE_TITLES         = !(PIPE_TITLES)
_G.DEPEND_TITLES       = !(DEPEND_TITLES)
_G.TYPE_KIND_TITLES    = !(TYPE_KIND_TITLES)


