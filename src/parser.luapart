--[[============================================================
--=
--=  Parser
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	astCopy
	astFindParent*, astFindParentScope, astFindCommonParent, astHasParent, astFindInTree
	astGetDepth
	astGetExpressionVisuallyFurthestToThe*, astGetCalleeVisuallyFurthestToTheLeft
	astGetOriginal, astGetReplacement
	astIsOrIsInModule
	astMoveRelevantThingsFromFileScopeToGlobalScope
	astNewNode
	astPrint, astPrintTree
	astVisitAllNodes, astVisitAllNodesLeavesFirst
	eatNextToken, peekNextToken, peekLastToken, putBackLastToken, eatTrailingSemicolon
	errorParsing*, parserMessage*
	errorUnhandledNodeType, errorUnhandledType
	isNodeAt
	nodeError, nodeErrorAfter, nodeMessage, where
	parse*

--============================================================]]

!(
local PRINT_NODE_BRACKETS = false

local function errorOrReturn(errCode, returnValueCode)
	__LUA("if state.soft then return ",returnValueCode," end ")
	__LUA(errCode)
end
local function ERROR_OR_RETURN      (errCode, returnCode)  errorOrReturn(errCode, (returnCode or "nil"))  end
local function ERROR_OR_RETURN_FALSE(errCode            )  errorOrReturn(errCode, ("false"            ))  end

local function setOrReturn(assignmentCode, returnValueCode)
	local preCode, sufCode = assignmentCode:match"^([^=]+)=(.*)$"
	if not preCode then  error(assignmentCode)  end

	-- local x = ...
	if preCode:find"^%s*local%s" then
		local var = preCode:match"^%s*local%s+([%w_]+)" or error(preCode)
		__LUA(assignmentCode)
		__LUA(" if not ",var," then return ",returnValueCode," end ")

	-- x = ...
	elseif preCode:find"^%s*[%w_]+%s*$" then
		local var = preCode:match"[%w_]+" or error(preCode)
		__LUA(assignmentCode)
		__LUA(" if not ",var," then return ",returnValueCode," end ")

	-- x.y = ...
	else
		__LUA("local __value__ =",sufCode)
		__LUA(" if not __value__ then return ",returnValueCode," end ")
		__LUA(preCode,"= __value__")
	end
end
local function SET_OR_RETURN      (assignmentCode)  setOrReturn(assignmentCode, "nil"  )  end
local function SET_OR_RETURN_FALSE(assignmentCode)  setOrReturn(assignmentCode, "false")  end

local function doOrReturn(exprCode, returnValueCode)
	__LUA("if not (",exprCode,") then return ",returnValueCode," end")
end
local function DO_OR_RETURN      (exprCode)  doOrReturn(exprCode, "nil"  )  end
local function DO_OR_RETURN_FALSE(exprCode)  doOrReturn(exprCode, "false")  end
)



!(
local nodeTypeN              = 0
local nodeTypeNames          = {}
_G.nodeTypes                 = {}
_G.scopeNodeTypes            = {}
_G.scopeNodeTypesDeclarative = {}
_G.scopeNodeTypesImperative  = {}

local function structAst(nameAndParent)
	return function(fields)
		local name        = nameAndParent:match"^[%w_]+"

		local scopeType   = fields._scopeType
		fields._scopeType = nil

		if not name:find"^_" then
			local overrides          = fields._overrides or {}
			fields._overrides        = overrides

			nodeTypeN                = nodeTypeN+1
			table.insert(overrides, {`nodeType`, nodeTypeN})

			nodeTypes[name]          = nodeTypeN
			nodeTypeNames[nodeTypeN] = name

			if scopeType then
				local scopesOfType
					=  scopeType == "declarative" and scopeNodeTypesDeclarative
					or scopeType == "imperative"  and scopeNodeTypesImperative
					or error(scopeType)

				table.insert(scopeNodeTypes, nodeTypeN)
				table.insert(scopesOfType,   nodeTypeN)
			end
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_AstNode"{
	{`nodeType`,   0},
	{`s`,          0},   -- Serial number.
	{`parent`,     nil}, -- AstNode
	{`token`,      1},
	{`replacedBy`, nil}, -- AstNode
	{`replacing`,  nil}, -- AstNode
	-- Pipe phases:
	{`queued`,     nil}, -- Queued
}

!structAst"_AstExpression:_AstNode"{
	-- Type phase:
	{`inferredType`, nil}, -- TypeInfo
}
_G.!structAst"AstIdentifier:_AstExpression"{
	{`name`,        ""},
	-- Type phase:
	{`declaration`, nil, astRef="node"}, -- AstDeclaration
	{`fromUsing`,   nil, astRef="node"}, -- AstUsing
}
_G.!structAst"AstVararg:AstIdentifier"{
	_overrides = {{`name`,"..."}},
	{`surroundedByParentheses`, false},
}
_G.!structAst"AstBlank:AstIdentifier"{
	_overrides = {{`name`,"_"}},
}
_G.!structAst"AstLiteral:_AstExpression"{
	{`literalType`,   0},
	{`value`,         nil}, -- The value depends on what literalType is. Could be a number, string or whatever.
	-- Bytecode phase:
	{`valueConstant`, nil}, -- Constant
}
_G.!structAst"AstType:_AstExpression"{
	{`functionHeader`,  nil, ast="node"},    -- AstLambda without a body. This is used to create the actual function type.
	{`arrayItemType`,   nil, ast="node"},    -- AstType
	{`arguments`,       nil, ast="array"},   -- []AstExpression  (Is set for parameterized structs.)
	{`components`,      {},  ast="array"},   -- []AstExpression  (Used if kind is TYPE_KIND_COMPOUND.)
	{`kind`,            TYPE_KIND_UNSET},    -- TYPE_KIND_SIMPLE_BUILTIN|TYPE_KIND_SIMPLE_USER|TYPE_KIND_FUNCTION|TYPE_KIND_ARRAY|TYPE_KIND_POLY_STRUCT|TYPE_KIND_COMPOUND
	{`typeName`,        ""},
	-- Type phase:
	{`representedType`, nil},                -- TypeInfo
	{`declaration`,     nil, astRef="node"}, -- AstDeclaration
}
_G.!structAst"AstUnary:_AstExpression"{
	{`expression`, nil, ast="node"}, -- AstExpression
	{`operation`,  ""},              -- "-" or "not" etc.
}
_G.!structAst"AstBinary:_AstExpression"{
	{`left`,      nil, ast="node"}, -- AstExpression
	{`right`,     nil, ast="node"}, -- AstExpression
	{`operation`, ""},  -- "+" or "-" etc.
}
_G.!structAst"AstAccess:_AstExpression"{
	{`object`,          nil, ast="node"}, -- AstExpression
	{`member`,          nil, ast="node"}, -- AstExpression
	-- Type phase:
	{`representedType`, nil}, -- TypeInfo  (Not used anywhere. 2020-01-02)
}
_G.!struct"TableField"{
	{`key`,            nil}, -- AstExpression
	{`value`,          nil}, -- AstExpression
	{`keyIsGenerated`, false},
}
_G.!structAst"AstTable:_AstExpression"{
	{`fields`,                {},  ast="fields"}, -- []TableField
	{`trailingExpression`,    nil, ast="node"},   -- AstVararg|AstCall  This expression potentially expands to multiple values in any resulting Lua table.
	{`highestGeneratedIndex`, 0},
}
_G.!structAst"AstCall:_AstExpression"{
	{`callee`,                    nil, ast="node"},  -- AstExpression
	{`arguments`,                 {},  ast="array"}, -- []AstExpression
	{`couldBeTypeWithParameters`, false},
	{`isMethod`,                  false},
	{`surroundedByParentheses`,   false},
}
_G.!structAst"AstTypeOf:_AstExpression"{
	{`expression`, nil, ast="node"}, -- AstExpression
	-- Type phase:
	{`representedType`, nil}, -- TypeInfo
}
_G.!structAst"AstTypeInfo:_AstExpression"{
	{`expression`,    nil, ast="node"}, -- AstExpression
	-- Type phase:
	{`declaration`,   nil}, -- AstDeclaration for the TypeInfo* struct in preload.
	{`valueTypeInfo`, nil}, -- TypeInfo
	-- Bytecode phase:
	{`valueConstant`, nil}, -- Constant
}
_G.!structAst"AstCast:_AstExpression"{
	{`targetType`, nil, ast="node"}, -- AstType
	{`expression`, nil, ast="node"}, -- AstExpression
	{`isImplicit`, false},           -- Implicit casts include e.g. 'if "foo" {...}'
}
_G.!structAst"AstImport:_AstExpression"{
	{`isLoad`,     false},
	{`importName`, ""},
	-- Type phase:
	{`fileScope`,  nil, astRef="node"}, -- AstFileScope
}
_G.!structAst"AstForeign:_AstExpression"{
	{`source`,        ""}, -- "compiler"|"lua"|"method"
	{`sourceName`,    ""}, -- May be inferred from declaration.
	-- Type phase:
	{`sourceId`,      ""}, -- Is source and sourceName combined.
	-- Bytecode phase:
	{`valueConstant`, nil}, -- Constant
}
_G.!structAst"AstConditional:_AstExpression"{
	{`condition`,              nil, ast="node"},    -- AstExpression
	{`branchTrue`,             nil, ast="node"},    -- AstExpression  (If this is nil then condition (or rather conditionAndBranchTrue) is used for this branch.)
	{`branchFalse`,            nil, ast="node"},    -- AstExpression
	{`conditionAndBranchTrue`, nil, astRef="node"}, -- AstExpression
}
_G.!structAst"AstBake:_AstExpression"{
	{`name`, nil, ast="node"}, -- AstIdentifier
}
_G.!structAst"AstRun:_AstExpression"{
	{`lambda`, nil, ast="node"}, -- AstLambda
}
_G.!structAst"AstNull:_AstExpression"{}

_G.!structAst"AstUsing:_AstNode"{
	{`expression`,          nil, ast="node"},    -- AstExpression
	-- Type phase:
	{`scope`,               nil, astRef="node"}, -- AstScope
	{`variableDeclaration`, nil, astRef="node"}, -- AstDeclaration
}

_G.!structAst"AstDebug:_AstNode"{
	{`expression`, nil, ast="node"}, -- AstExpression
	{`action`,     ""},              -- "assert"|"print"
}

_G.!structAst"AstArgument:_AstNode"{
	{`declaration`, nil, ast="node"}, -- AstDeclaration
	{`assignment`,  nil, ast="node"}, -- AstAssignment
	{`group`,       1}, -- Arguments in the same group have the same type. This is a small optimization for the typer.
	{`autobake`,    AUTOBAKE_DISABLED},
	{`isUsing`,     false}, -- Is it better to store this on declarations?

	-- For an input argument, this indicates optionality.
	-- For an output argument, if there's a !must then it must not be adjusted away by the caller.
	{`isRequired`,  false},
}
_G.!structAst"AstArguments:_AstNode"{
	{`arguments`, {}, ast="array"}, -- []AstArgument
}

_G.!structAst"AstDeclaration:_AstNode"{
	{`name`,                 nil, ast="node"},  -- AstIdentifier|AstVararg
	{`type`,                 nil, ast="node"},  -- AstType  (If this is nil then the type is inferred from the value.)
	{`value`,                nil, ast="node"},  -- AstExpression  (Either this or assignment should be set, or neither for getting the default value for the type.)
	{`notes`,                {},  ast="array"}, -- []AstNote  @Incomplete: Notes.

	{`kind`,                 DECL_KIND_LOCAL_VAR}, -- DECL_KIND_LOCAL_VAR|DECL_KIND_LOCAL_CONST|DECL_KIND_EXPORT_VAR|DECL_KIND_EXPORT_CONST|DECL_KIND_STATIC  @Incomplete: DECL_KIND_READ_ONLY  Note: Globals are exports.
	{`canShadow`,            false},
	{`addedByPolymorph`,     false},

	{`assignment`,           nil, astRef="node"}, -- AstAssignment
	{`assignmentIndex`,      1},

	-- Type phase:
	{`valueTypeInfo`,        nil}, -- TypeInfo  Type represented by the assigned value if the declaration is constant. If this is set then the declared identifier can be used in places where a type is expected. Can be nil.
	{`checkedRedeclaration`, false},
	{`overloads`,            {}},
	{`overloadOf`,           nil, astRef="node"}, -- AstDeclaration  (If this is self then we're the base declaration for the overloads and the overloads array should be filled.)
	{`overloadsLocked`,      false},

	-- Bytecode phase:
	{`valueConstant`,        nil}, -- Constant
	{`topScopeName`,         ""},
	{`localName`,            ""},
}

_G.!structAst"AstAssignment:_AstNode"{
	{`targets`,          {},  ast="array"},    -- []AstExpression
	{`values`,           {},  ast="array"},    -- []AstExpression

	{`forDeclaration`,   false},
	{`declarations`,     nil, astRef="array"}, -- []AstDeclaration  (Is set if forDeclaration is set.)

	{`binaryOperation`,  ""}, -- Empty means plain assignment.

	{`addedByPolymorph`, false},
}

!structAst"_AstJump:_AstNode"{}
_G.!structAst"AstReturn:_AstJump"{
	{`values`,       {},  ast="array"},   -- []AstExpression
	{`runDirective`, nil, astRef="node"}, -- AstRun
}
_G.!structAst"AstBreak:_AstJump"{
	{`loopName`, nil, ast=nil      }, -- AstIdentifier  (Never inferred.)
	{`loop`,     nil, astRef="node"}, -- AstFor|AstWhile
}
_G.!structAst"AstContinue:_AstJump"{
	{`loopName`, nil, ast=nil      }, -- AstIdentifier  (Never inferred.)
	{`loop`,     nil, astRef="node"}, -- AstFor|AstWhile
}

_G.!structAst"AstDefer:_AstNode"{
	{`body`, nil, ast="node"}, -- AstBlock
}

!structAst"_AstScope:_AstNode"{
	{`statements`,         {}, ast="array"},    -- []AstNode
	{`declarations`,       {}, astRef="array"}, -- []AstDeclaration  (Note that inner blocks have their own declarations.)
	{`imports`,            {}, astRef="array"}, -- []AstImport       (Excluding loads.)
	{`usings`,             {}, astRef="array"}, -- []AstUsing
	-- Type phase:
	{`declarationsInTree`, {}, doNotCopy=true}, -- Includes all child scopes. Does not include shadows.
}
_G.!structAst"AstBlock:_AstScope"{
	_scopeType = "imperative",
}
_G.!structAst"AstFileScope:_AstScope"{
	_scopeType = "declarative",
	{`path`,       ""},
	{`isModule`,   false},
	{`moduleName`, ""},
}
_G.!structAst"AstGlobalScope:_AstScope"{
	_scopeType = "declarative",
	{`fileScopes`,     {},  astRef="array"}, -- []AstFileScope
	{`firstFileScope`, nil, astRef="node"},  -- AstFileScope  (@Cleanup: Remove this in favor of fileScopes[1].)
}
_G.!structAst"AstFor:_AstScope"{
	_scopeType = "imperative",
	{`expressions`,    {},  ast="array"},   -- []AstExpression  @Cleanup: Move these into AstFor.statements?
	{`names`,          {},  ast=nil    },   -- []AstIdentifier  These are never inferred, but instead copied to declarations. @Cleanup: Can we get rid of this in favor of the copy we currently make?
	{`forType`,        FOR_NUMERIC},        -- @Cleanup: Rename to "kind"?
	{`body`,           nil, astRef="node"}, -- AstBlock
	{`reverse`,        false},
	{`hasNamedBreaks`, false},
}
!structAst"_AstScopeExpression:_AstScope"{
	-- Type phase:
	{`inferredType`,    nil}, -- TypeInfo
	{`representedType`, nil}, -- TypeInfoStruct|TypeInfoEnum  (Used for AstEnum and AstStruct. Is nil otherwise.)
}
_G.!structAst"AstStruct:_AstScopeExpression"{
	_scopeType = "declarative",

	{`inherits`,              {},  astRef="array"}, -- []AstExpression

	{`keyType`,               nil, ast="node"},     -- AstExpression
	{`valueType`,             nil, ast="node"},     -- AstExpression

	{`isPolymorphic`,         false},
	{`polymorphs`,            {},  astRef="array"}, -- []AstDeclaration
	{`polymorphSourceStruct`, nil, astRef="node"},  -- AstStruct
	{`bakeDeclarations`,      {},  astRef="array"}, -- []AstDeclaration

	{`isForeign`,             false},               -- Foreign structs cannot be instantiated.
	{`foreignThroughNode`,    nil, astRef="node"},  -- AstNode
}
_G.!structAst"AstEnum:_AstScopeExpression"{
	_scopeType = "declarative",
	{`memberType`, nil, ast="node"}, -- AstType
	{`autoValue`,  0},
}
_G.!structAst"AstLambda:_AstScopeExpression"{
	_scopeType = "imperative",

	{`captures`,          {},  ast="array"},   -- []AstIdentifier
	{`argumentsIn`,       nil, astRef="node"}, -- AstArguments
	{`argumentsOut`,      nil, astRef="node"}, -- AstArguments
	{`takingVararg`,      false},

	{`body`,              nil, astRef="node"}, -- AstBlock  (If this is nil then the lambda is a function signature. If bodyIsForeign is set then this is a dummy block.)
	{`bodyIsForeign`,     false}, -- @Cleanup: Use AstForeign instead of all this stuff.
	{`foreignSource`,     ""},
	{`foreignSourceName`, ""},

	{`bodyEndToken`,      1}, -- For better error messages.

	{`isPolymorphic`,     false},
	{`polymorphs`,        {},  astRef="array"}, -- []AstDeclaration
	{`bakeDeclarations`,  {},  astRef="array"}, -- []AstDeclaration
	{`bakeValues`,        {},  astRef="array"}, -- []AstExpression

	-- Type phase:
	{`foreignSourceId`,   ""}, -- Is foreignSource and foreignSourceName combined.

	-- Bytecode phase:
	{`valueConstant`,     nil}, -- Constant
	{`bytecodes`,         {}, doNotCopy=true}, -- Filled if we're not a function signature.
}
_G.!structAst"AstNamespace:_AstScopeExpression"{
	_scopeType = "declarative",
}

_G.!structAst"AstIf:_AstNode"{
	{`condition`,   nil, ast="node"}, -- AstExpression
	{`branchTrue`,  nil, ast="node"}, -- AstBlock
	{`branchFalse`, nil, ast="node"}, -- AstBlock
}
_G.!structAst"AstStaticIf:AstIf"{}
_G.!structAst"AstWhile:_AstNode"{
	{`condition`,      nil, ast="node"}, -- AstExpression
	{`body`,           nil, ast="node"}, -- AstBlock
	{`hasNamedBreaks`, false},
}
_G.!struct"SwitchCase"{
	{`value`, nil}, -- AstExpression
	{`body`,  nil}, -- AstBlock
}
_G.!structAst"AstSwitch:_AstNode"{
	{`value`,    nil, ast="node"},  -- AstExpression
	{`cases`,    {},  ast="cases"}, -- []SwitchCase
	{`complete`, false},
}

_G.AST_NODE_TYPE_NAMES = !(nodeTypeNames)

_G.SCOPES                = !(scopeNodeTypes)
_G.SCOPES_DECLARATIVE    = !(scopeNodeTypesDeclarative)
_G.SCOPES_IMPERATIVE     = !(scopeNodeTypesImperative)
_G.SCOPE_SET             = !(Set(scopeNodeTypes))
_G.SCOPE_SET_DECLARATIVE = !(Set(scopeNodeTypesDeclarative))
_G.SCOPE_SET_IMPERATIVE  = !(Set(scopeNodeTypesImperative))



local TOKEN_TYPE_TO_LITERAL_TYPE = !({
	[TOKEN_FLOAT]   = LITERAL_FLOAT,
	[TOKEN_INTEGER] = LITERAL_INTEGER,
	[TOKEN_STRING]  = LITERAL_STRING,
})



-- node:AstNodeType = astNewNode( AstNodeType, token [, parentNode ] )
do
	local serialN = 0

	function _G.astNewNode(AstNodeType, token, parentNode)
		if not AstNodeType then  errorInternal(2, "No AstNodeType specified.")  end
		!ifDEBUG`assert(token)`

		if not parentNode and AstNodeType ~= AstGlobalScope then
			errorInternal(2, "No parent.")
		end

		serialN = serialN+1

		local node  = AstNodeType()
		node.s      = serialN
		node.parent = parentNode
		node.token  = token

		--[[
		if
			false
			-- or serialN == 22
			or parentNode and parentNode.s == 21
		then
			errorInternal("DEBUG")
		end
		--]]

		return node
	end
end



function _G.parseIdentifier(state, parentNode)
	local tokType, tokValue, token = eatNextToken(state)
	if tokType ~= !(TOKEN_IDENTIFIER) then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected an identifier.")`
	end

	local ident = astNewNode(AstIdentifier, token, parentNode)
	ident.name  = tokValue

	return ident
end

function _G.parseUsing(state, parentNode)
	local tokType, tokValue, token = eatNextToken(state)
	if not isToken(tokType,tokValue, !(TOKEN_KEYWORD),"using") then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected 'using'.")`
	end

	local using                      = astNewNode(AstUsing, token, parentNode)
	!SET_OR_RETURN `using.expression = parseExpression(state, using)`

	return using
end

function _G.parseForeign(state, parentNode)
	-- Note: We assume the '!foreign' has been eaten already.

	local foreign = astNewNode(AstForeign, state.nextToken-1, parentNode)

	local tokType, tokValue = eatNextToken(state)
	if not isToken(tokType,tokValue, !(TOKEN_IDENTIFIER)) then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected foreign source. (Valid values: lua, method, compiler)")`
	elseif not !!(anyV(`tokValue`, "lua","method","compiler")) then
		!ERROR_OR_RETURN `errorParsingLast(state, "Invalid source '%s'. (Valid values: lua, method, compiler)", tokValue)`
	end
	foreign.source = tokValue

	tokType, tokValue = peekNextToken(state)
	if isToken(tokType,tokValue, !(TOKEN_STRING)) then
		eatNextToken(state)
		foreign.sourceName = tokValue
	else
		-- void  (foreign.sourceName will be the name of whatever declared constant the foreign is attached to.)
		!ERROR_OR_RETURN `errorParsingAfterLast(state, "@Incomplete: Infer foreign.sourceName")` -- TEMP
	end

	return foreign
end

function _G.parseTable(state, parentNode)
	-- Note: We assume the '{' has been eaten already.

	local tableNode      = astNewNode(AstTable, state.nextToken-1, parentNode)
	local fields         = tableNode.fields
	local generatedIndex = 0

	while true do
		local tokType, tokValue, token = peekNextToken(state)

		if not tokType then
			!ERROR_OR_RETURN `errorParsing(state, tableNode.token, "Unfinished table.")`
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			eatNextToken(state)
			break
		end

		local tokType2, tokValue2 = peekNextToken(state, 2)
		local tableField          = TableField()
		local tableKey

		-- [k]=v
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[") then
			eatNextToken(state)

			!SET_OR_RETURN `tableKey = parseExpression(state, tableNode)`

			tokType, tokValue = eatNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"]") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ']'.")`
			end

			tokType, tokValue = eatNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '='.")`
			end

		-- k=v
		elseif
			tokType == !(TOKEN_IDENTIFIER)
			and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"=")
		then
			eatNextToken(state)
			local literal       = astNewNode(AstLiteral, token, tableNode)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = tokValue
			tableKey            = literal
			eatNextToken(state) -- '='

		-- v
		else
			generatedIndex      = generatedIndex+1
			local literal       = astNewNode(AstLiteral, token, tableNode) -- Note: The token position of the key and value will be the same.
			literal.literalType = !(LITERAL_INTEGER)
			literal.value       = generatedIndex
			tableKey            = literal

			tableField.keyIsGenerated = true
		end

		assert(tableKey)

		tableField.key                   = tableKey
		!SET_OR_RETURN `tableField.value = parseExpression(state, tableNode)`

		table.insert(fields, tableField)

		tokType, tokValue = eatNextToken(state)
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			break
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",",";") then
			-- void  (Note: A trailing comma or semicolon at the end of the argument list is permitted.)
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ','.")`
		end
	end

	local lastField = fields[#fields]

	if lastField and lastField.keyIsGenerated and lastField.value.nodeType == !(nodeTypes.AstVararg) and not lastField.value.surroundedByParentheses then
		local vararg    = lastField.value
		vararg.parent   = tableNode
		fields[#fields] = nil
		generatedIndex  = generatedIndex-1
		tableNode.trailingExpression = vararg
	end

	tableNode.highestGeneratedIndex = generatedIndex
	return tableNode
end

-- Parse comma-separated expressions. Used for function calls and struct parameters.
-- success = parseExpressionList( compilationState, parentNode, expressions [, expectLeftValues=false ] )
function _G.parseExpressionList(state, parentNode, expressions, expectLeftValues)
	while true do
		local tokType, tokValue = peekNextToken(state)
		local expr

		if expectLeftValues and isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"_") then
			expr = astNewNode(AstBlank, state.nextToken, parentNode)
			eatNextToken(state)
		else
			!SET_OR_RETURN_FALSE `expr = parseExpression(state, parentNode, nil, expectLeftValues)`
		end
		table.insert(expressions, expr)

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			eatNextToken(state)
			-- Continue the loop.
		else
			break
		end
	end

	return true
end

local function concatNamesInArgumentGroupForError(argsInGroup)
	if not argsInGroup[2] then  return argsInGroup[1].declaration.name.name  end

	local names = {}

	for i, arg in ipairs(argsInGroup) do
		names[i] = arg.declaration.name.name
	end

	return table.concat(names, "', '", 1, #names-1) .. "' and '" .. names[#names]
end

function _G.parseArguments(state, parentNode, isInput)
	local args            = astNewNode(AstArguments, state.nextToken, parentNode)
	local takenNames      = {}
	local gotVararg       = false
	local gotDefaultValue = false
	local tokType, tokValue, token

	for groupN = 1, math.huge do
		-- Argument name(s).
		local argsInGroup = {}
		local isUsing     = false

		local tokType, tokValue, token = peekNextToken(state)
		local argStartToken            = token

		if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"using") then
			eatNextToken(state)
			isUsing = true

			if not isInput then
				-- Maybe we should allow 'using' here, but apply it the types instead of the names in the declarations?
				!ERROR_OR_RETURN `errorParsingLast(state, "Cannot apply 'using' to output arguments.")`
			end
		end

		while true do
			local autobake = !(AUTOBAKE_DISABLED)
			tokType, tokValue, token = eatNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"$") then
				if not isInput then
					!ERROR_OR_RETURN `errorParsing(state, token, "Only input arguments can be auto-baked.")`
				elseif isUsing then
					!ERROR_OR_RETURN `errorParsing(state, argStartToken, "Cannot using auto-baked arguments.")`
				end

				autobake          = !(AUTOBAKE_REQUIRED)
				tokType, tokValue = peekNextToken(state)

				if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"?") then
					eatNextToken(state)
					autobake = !(AUTOBAKE_ENABLED)
					!ERROR_OR_RETURN `errorParsing(state, token+1, "Optional auto-baking of arguments isn't supported yet. Omit '?' to force auto-baking.")` -- @Incomplete
				end

				tokType, tokValue = eatNextToken(state)
			end

			if not (tokType == !(TOKEN_IDENTIFIER) or isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"...")) then
				!ERROR_OR_RETURN `errorParsing(state, token, "Argument list: Expected an identifier.")`
			end

			local arg    = astNewNode(AstArgument, token, args)
			arg.group    = groupN
			arg.autobake = autobake
			arg.isUsing  = isUsing

			table.insert(args.arguments, arg)
			table.insert(argsInGroup,    arg)

			local decl      = astNewNode(AstDeclaration, token, arg)
			arg.declaration = decl

			if tokType == !(TOKEN_IDENTIFIER) then
				local ident       = astNewNode(AstIdentifier, token, decl)
				ident.name        = tokValue
				ident.declaration = decl
				decl.name         = ident

				if takenNames[ident.name] then
					!ERROR_OR_RETURN `errorParsingLast(state, "Duplicate name '%s'.", ident.name)`
				end
				takenNames[ident.name] = true

			else
				gotVararg = true

				if isUsing then
					!ERROR_OR_RETURN `errorParsing(state, argStartToken, "Cannot apply 'using' to varargs.")`
				elseif autobake ~= !(AUTOBAKE_DISABLED) then
					!ERROR_OR_RETURN `errorParsing(state, argStartToken, "Auto-baking of varargs is not supported.")`
				end

				local vararg       = astNewNode(AstVararg, token, decl)
				vararg.declaration = decl
				decl.name          = vararg
			end

			tokType, tokValue = peekNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":","=") then
				break
			elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
				eatNextToken(state)
				-- Continue the loop.
			else
				!ERROR_OR_RETURN `errorParsingAfterLast(state, "Expected ':'.")`
			end

			if gotVararg then
				!ERROR_OR_RETURN `errorParsingLast(state, "Vararg must be the last argument.")`
			end
		end

		-- Type(s).
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
			eatNextToken(state)

			token = state.nextToken
			for i, arg in ipairs(argsInGroup) do
				state.nextToken           = token
				local decl                = arg.declaration
				!SET_OR_RETURN `decl.type = parseExpression(state, decl)` -- @Speed: Parse once then just copy the first one.

				if i > 1 then
					-- Make sure (a,b:$T) works.
					astVisitAllNodes(decl.type, function(node, container, key)
						if node.nodeType ~= !(nodeTypes.AstBake) then  return  end

						if not container then
							container = decl
							key       = "type"
						end

						local bake     = node
						local ident    = bake.name

						ident.parent   = node.parent
						container[key] = ident

						return !(VISIT_IGNORE_CHILDREN)
					end)
				end
			end
		end

		-- Default value.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
			gotDefaultValue = true
			eatNextToken(state)

			if not isInput then
				!ERROR_OR_RETURN `errorParsingLast(state, "Output arguments cannot have default values.")`
			end

			token = state.nextToken

			for i, arg in ipairs(argsInGroup) do
				state.nextToken = token

				if arg.autobake ~= !(AUTOBAKE_DISABLED) then
					!ERROR_OR_RETURN `errorParsingLast(state, "Default values for auto-baked arguments are not supported yet.")`
				end

				local decl = arg.declaration

				if decl.name.nodeType == !(nodeTypes.AstVararg) then
					!ERROR_OR_RETURN `errorParsingNext(state, "Varargs cannot have default values.")`
				else
					assert(decl.name.nodeType == !(nodeTypes.AstIdentifier))
				end

				!SET_OR_RETURN `decl.value = parseExpression(state, decl)` -- @Speed: Parse once then just copy the first one.

				--[[
				-- If the value is nil then we make sure 'nil' is one of the types.
				--
				-- @Robustness: One of the types may be an alias for the nil type, which means this
				-- may cause an error in the typer when we check for duplicate specified types. We
				-- should probably do this in the typer instead. @Incomplete
				--
				if
					i == 1
					and decl.value.nodeType    == !(nodeTypes.AstLiteral)
					and decl.value.literalType == !(LITERAL_NIL)
					and not itemWith1(decl.types, "typeName", "nil")
				then
					local typeNode    = astNewNode(AstType, decl.value.token, decl)
					typeNode.kind     = !(TYPE_KIND_SIMPLE_BUILTIN)
					typeNode.typeName = "none"
					table.insert(decl.types, typeNode)
				end
				--]]
			end

		elseif gotDefaultValue and not gotVararg then
			!ERROR_OR_RETURN `errorParsingAfterLast(
				state,
				"Missing default value for '%s'. All optional arguments must be at the end of the argument list.",
				concatNamesInArgumentGroupForError(argsInGroup)
			)`
		end

		-- Set if shadowing is allowed.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"shadow") then
			eatNextToken(state)
			for _, arg in ipairs(argsInGroup) do
				arg.declaration.canShadow = true
			end
		end

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			eatNextToken(state)
			-- Continue the loop.
		else
			break
		end

		if gotVararg then
			!ERROR_OR_RETURN `errorParsingLast(state, "Vararg must be the last argument.")`
		end
	end

	if isInput then
		for _, arg in ipairs(args.arguments) do
			arg.isRequired = (arg.declaration.value == nil and arg.declaration.name.nodeType ~= !(nodeTypes.AstVararg))
		end
	else
		-- @Incomplete: If a !must was specified, set arg.isRequired from first argument to the last !must.
	end

	return args
end

function _G.parseNamelessArguments(state, parentNode)
	local args = astNewNode(AstArguments, state.nextToken, parentNode)

	for groupN = 1, math.huge do
		local arg = astNewNode(AstArgument, state.nextToken, args)
		arg.group = groupN
		table.insert(args.arguments, arg)

		local decl      = astNewNode(AstDeclaration, arg.token, arg)
		arg.declaration = decl

		local tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"...") then
			eatNextToken(state)

			local vararg       = astNewNode(AstVararg, decl.token, decl)
			vararg.declaration = decl
			decl.name          = vararg

			!SET_OR_RETURN `decl.type = parseExpression(state, decl)`

		else
			!SET_OR_RETURN `decl.type = parseExpression(state, decl)`

			local ident       = astNewNode(AstIdentifier, decl.token, decl)
			ident.name        = "_"..groupN
			ident.declaration = decl
			decl.name         = ident
		end

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			eatNextToken(state)
		else
			break
		end

		if decl.name.nodeType == !(nodeTypes.AstVararg) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Vararg must be the last argument.")`
		end
	end

	return args
end

function _G.parseStruct(state, parentNode)
	local struct            = astNewNode(AstStruct, state.nextToken-1, parentNode) -- The token should be the 'struct' keyword.
	local tokType, tokValue = eatNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
		struct.isPolymorphic       = true
		!SET_OR_RETURN `local args = parseArguments(state, struct, true)`

		local gotError = false

		astVisitAllNodes(args, function(node)
			if node.nodeType == !(nodeTypes.AstVararg) then
				gotError = true
				!ERROR_OR_RETURN(`errorParsing(state, node.token, "Struct arguments cannot be variable.")`, toLua(VISIT_BREAK))

			elseif node.nodeType == !(nodeTypes.AstArgument) then
				if node.autobake ~= !(AUTOBAKE_DISABLED) and not state.soft then
					parserMessageLine(io.stderr, state, node.token, "Warning", "Struct arguments are always auto-baked and thus don't need any $.")
				end

			elseif node.nodeType == !(nodeTypes.AstBake) then
				!ERROR_OR_RETURN(`errorParsing(state, node.token, "Placeholder types are not supported in struct arguments.")`, toLua(VISIT_BREAK))
			end
		end)

		if gotError then  return nil  end

		-- Move declarations from the temporary args node into the struct for later baking.
		for _, arg in ipairs(args.arguments) do
			local decl  = arg.declaration
			decl.parent = struct
			decl.kind   = !(DECL_KIND_LOCAL_CONST)

			table.insert(struct.statements,       decl)
			table.insert(struct.declarations,     decl)
			table.insert(struct.bakeDeclarations, decl)
		end

		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		tokType, tokValue = eatNextToken(state)
	end

	if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '{'.")`
	end

	-- Note: We allow a trailing comma/semicolon after the last member.
	while true do
		tokType, tokValue         = peekNextToken(state, 1)
		local tokType2, tokValue2 = peekNextToken(state, 2)
		local tokType3, tokValue3 = peekNextToken(state, 3)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			eatNextToken(state)
			break

		elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"assert","print") then
			!SET_OR_RETURN `local debugNode = parseDebugNode(state, struct)`
			table.insert(struct.statements, debugNode)

		elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"using") and not (
			tokType2 == !(TOKEN_IDENTIFIER)
			and isToken(tokType3,tokValue3, !(TOKEN_PUNCTUATION),"=",":")
		) then
			eatNextToken(state)
			!SET_OR_RETURN `local expr = parseExpression(state, struct)`
			table.insert(struct.statements, expr)
			table.insert(struct.inherits,   expr)

		elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"key","value") then
			eatNextToken(state)

			local what = tokValue
			local k    = what == "key" and "keyType" or "valueType"

			tokType, tokValue = eatNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ':'.")`
			end

			if struct[k] then
				!ERROR_OR_RETURN `
					printerr()
					parserMessage(io.stderr, state, state.nextToken-2, "Error", "Duplicate !%s in struct.",      what)
					parserMessage(io.stderr, state, struct[k].token-2, "Info",  "...previous !%s defined here.", what)
					exitFailure()
				`
			end

			!SET_OR_RETURN `struct[k] = parseExpression(state, struct)`

		else
			local declType = !(DECLARATION_STRUCT)
			!DO_OR_RETURN `parseDeclarationStatement(state, struct, false, declType)`
		end

		tokType, tokValue = eatNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",",";") then
			-- Continue the loop.
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			break
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '}'.")`
		end
	end

	return struct
end

function _G.parseEnum(state, parentNode)
	local enum              = astNewNode(AstEnum, state.nextToken-1, parentNode) -- The token should be the 'enum' keyword.
	local tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"float","int","string","bool","type") then -- We don't allow 'table', 'any' or anything user-defined.
		!SET_OR_RETURN `enum.memberType = parseExpression(state, enum, math.huge)`
	end

	tokType, tokValue = eatNextToken(state)

	if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		local tokType2, tokValue2 = peekNextToken(state)
		if
			(tokType == !(TOKEN_IDENTIFIER) or isTokenBuiltinType(tokType, tokValue))
			and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"{")
		then
			!ERROR_OR_RETURN `errorParsingLast(state, "Supported enum member types are: int, string, type, bool, float")`
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '{'.")`
		end
	end

	-- Note: We allow a trailing comma/semicolon after the members.
	while true do
		local declType = !(DECLARATION_ENUM)
		!DO_OR_RETURN `parseDeclarationStatement(state, enum, false, declType)`

		tokType, tokValue = eatNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",",";") then
			-- Continue the loop.
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			break
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '}'.")`
		end

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			eatNextToken(state)
			break
		end
	end

	return enum
end

-- success = parseDeclarationStatement( compilationState, parentScope, inImperativeScope [, declarationType=DECLARATION_NORMAL ] )
-- declarationType = DECLARATION_NORMAL|DECLARATION_STRUCT|DECLARATION_ENUM
function _G.parseDeclarationStatement(state, scope, imperative, declType)
	--[[
	local a := 0        -- Variable, inferred type.
	local a  = 0        -- Variable, inferred type (same as the above).
	local b:float = 0   -- Variable, explicit type.
	local c:float       -- Variable, getting the default value for the type.
	local A :: 0        -- Constant, inferred type.
	local B:float : 0   -- Constant, explicit type.
	local a,b,c = 0,f() -- Multiples always have either inferred type...
	local a,b:int : 1,2 -- ...or the same type.
	local A :: struct {}
	local A :: enum   {}
	local a :: !import "lib"
	]]

	declType = declType or !(DECLARATION_NORMAL)

	local declarations = {}
	local declNames    = {}
	local isUsing      = false
	local declKind

	local tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"using") then
		eatNextToken(state)
		isUsing = true
	end

	-- local kindToken = state.nextToken

	if declType == !(DECLARATION_NORMAL) then
		tokType, tokValue = eatNextToken(state)

		if tokType ~= !(TOKEN_KEYWORD) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected 'local'.")`
		elseif tokValue == "local" then
			declKind = !(DECL_KIND_LOCAL_VAR)
		elseif tokValue == "export" then
			declKind = !(DECL_KIND_EXPORT_VAR)
		elseif tokValue == "static" then
			declKind = !(DECL_KIND_STATIC) ; imperative = false
		-- elseif tokValue == "read_only" then
		-- 	declKind = !(DECL_KIND_READ_ONLY)
		else
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected 'local'.")`
		end

	else
		declKind = !(DECL_KIND_LOCAL_VAR)
	end

	local nameListStartToken = state.nextToken
	local takenNames = {}

	if declType == !(DECLARATION_NORMAL) then
		!DO_OR_RETURN `parseNameList(state, scope, declNames, true)` -- Note: We update parent here below.

		for i, ident in ipairs(declNames) do
			local decl        = astNewNode(AstDeclaration, ident.token, scope)
			declarations[i]   = decl

			ident.parent      = decl
			ident.declaration = decl

			decl.name         = ident
		end

	else
		local decl        = astNewNode(AstDeclaration, 1, scope)
		declarations[1]   = decl

		tokType, tokValue = peekNextToken(state)
		local ident

		if declType == !(DECLARATION_STRUCT) and isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"call") then
			eatNextToken(state)
			ident      = astNewNode(AstIdentifier, state.nextToken-1, decl)
			ident.name = "!call"
		else
			!SET_OR_RETURN `ident = parseIdentifier(state, decl)`
		end

		ident.declaration = decl
		decl.token        = ident.token
		decl.name         = ident
		table.insert(declNames, ident)
	end

	!ASSERT `#declarations[1]`
	!ASSERT `#declarations == #declNames`

	local typesStartToken = state.nextToken -- Dummy position, kinda.
	tokType, tokValue     = peekNextToken(state)

	-- local x: someType
	-- local x := value
	-- local x :: value
	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
		eatNextToken(state)

		typesStartToken   = state.nextToken
		tokType, tokValue = peekNextToken(state)

		-- Inferred type.
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":","=") then
			-- void

		-- Specified type.
		else
			if declType == !(DECLARATION_ENUM) then
				!ERROR_OR_RETURN `errorParsingNext(state, "The type of the members must be specified after the 'enum' keyword.")`
			end
			for _, decl in ipairs(declarations) do
				state.nextToken           = typesStartToken
				!SET_OR_RETURN `decl.type = parseExpression(state, decl)` -- @Speed: Parse once then just copy the first one.
			end
		end

	-- local x = value
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
		-- void

	-- enum { NAME1, NAME2 }
	elseif declType == !(DECLARATION_ENUM) and isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",","}") then
		-- void

	else
		!ERROR_OR_RETURN `errorParsingAfterLast(state, "Expected ':' or '='.")`
	end

	tokType, tokValue = peekNextToken(state)

	local assignment  = nil
	local isConst     = false

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=",":") then
		eatNextToken(state)
		isConst = (tokValue == ":")

		if isConst then
			imperative = false
			if     declKind == !(DECL_KIND_LOCAL_VAR)  then  declKind = !(DECL_KIND_LOCAL_CONST)
			elseif declKind == !(DECL_KIND_EXPORT_VAR) then  declKind = !(DECL_KIND_EXPORT_CONST)
			elseif declKind == !(DECL_KIND_STATIC)     then  !ERROR_OR_RETURN `errorParsingLast(state, "Static names cannot be constant.")`
			else                                             errorInternal("%s", declKind)  end
		elseif declType == !(DECLARATION_ENUM) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Enum members must be constant.")`
		end

		if imperative then
			assignment                = astNewNode(AstAssignment, state.nextToken-1, scope)
			assignment.forDeclaration = true
			assignment.declarations   = {}

			for i, decl in ipairs(declarations) do
				local identCopy       = astCopy(declNames[i], nil, assignment)
				assignment.targets[i] = identCopy

				decl.assignment       = assignment
				decl.assignmentIndex  = i

				table.insert(assignment.declarations, decl)
			end

			if declType == !(DECLARATION_NORMAL) then
				!DO_OR_RETURN `parseExpressionList(state, assignment, assignment.values)`
			else
				!SET_OR_RETURN `local expr = parseExpression(state, assignment)`
				table.insert(assignment.values, expr)
			end

		else
			for i, decl in ipairs(declarations) do
				if i > 1 then
					tokType, tokValue = eatNextToken(state)
					if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
						!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Missing a value for '%s'.", decl.name.name)`
					end
				end

				decl.value = parseExpression(state, decl)
			end
		end

	elseif declType == !(DECLARATION_ENUM) then
		local enum = scope
		!ASSERT("enum.nodeType == "..nodeTypes.AstEnum) -- Note: We don't support !if or anything in enums, so the parent scope should always be the enum.

		enum.autoValue        = enum.autoValue+1
		declarations[1].value = newLiteral(declarations[1], nameListStartToken, !(LITERAL_INTEGER), enum.autoValue)

		!ASSERT("declKind == "..DECL_KIND_LOCAL_VAR)

		declKind   = !(DECL_KIND_LOCAL_CONST)
		isConst    = true
		imperative = false
	end

	for _, decl in ipairs(declarations) do
		decl.kind = declKind
	end

	-- Set if shadowing is allowed.
	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"shadow") then
		eatNextToken(state)

		if isConst then
			!ERROR_OR_RETURN `errorParsingLast(state, "Constants cannot be shadows.")`
		elseif declType == !(DECLARATION_STRUCT) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Struct members cannot be marked as shadows.")`
		elseif declType == !(DECLARATION_STRUCT) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Enum members cannot be marked as shadows.")`
		elseif declType ~= !(DECLARATION_NORMAL) then
			errorInternal(declType)
		end

		for _, decl in ipairs(declarations) do
			decl.canShadow = true
		end
	end

	-- Quickly check if the value count is obviously wrong.
	if assignment then
		local valueCount = #assignment.values
		local nameCount  = #declNames

		if valueCount > nameCount then
			!ERROR_OR_RETURN `errorParsing(
				state, assignment.values[nameCount+1].token-1,
				"There are more values than names being declared. (Expected %d value%s, got %d)",
				nameCount, (nameCount == 1 and "" or "s"), valueCount
			)`

		elseif isConst and valueCount < nameCount then
			!ERROR_OR_RETURN `errorParsingAfterLast(
				state,
				"No value for '%s'. Each constant must have it's own value. (Expected %d values, got %d)",
				declNames[valueCount+1].name, nameCount, valueCount
			)`
		end
	end

	if declType == !(DECLARATION_STRUCT) and not isConst and declNames[1].name == "!call" then
		!ERROR_OR_RETURN `errorParsing(state, declNames[1].token, "!call declarations must be constant.")`
	end

	if declType == !(DECLARATION_NORMAL) then  eatTrailingSemicolon(state)  end

	--
	-- Everything's done! Now we can modify the scope.
	--

	for i = 1, #declarations do
		table.insert(scope.statements,   declarations[i])
		table.insert(scope.declarations, declarations[i])
	end

	if assignment then
		table.insert(scope.statements, assignment)
	end

	if isUsing then
		for _, decl in ipairs(declarations) do
			local using       = astNewNode(AstUsing, decl.token, scope)

			local ident       = astNewNode(AstIdentifier, decl.token, using)
			ident.name        = decl.name.name
			ident.declaration = decl
			using.expression  = ident

			table.insert(scope.statements, using)
			table.insert(scope.usings,     using)
		end
	end

	return true
end

function _G.parseAssignment(state, parentNode)
	local assignment          = astNewNode(AstAssignment, 1, parentNode)
	local statementStartToken = state.nextToken

	!DO_OR_RETURN `parseExpressionList(state, assignment, assignment.targets, true)`

	for i, expr in ipairs(assignment.targets) do
		if not !!(anyV(`expr.nodeType`, nodeTypes.AstIdentifier,nodeTypes.AstAccess,nodeTypes.AstBlank)) then
			!ERROR_OR_RETURN `errorParsing(state, expr.token, "Expected assignment target expression to resolve into a variable or namespace access.")`
		end
	end

	local tokType, tokValue = eatNextToken(state)

	if not isTokenAssigning(tokType, tokValue) then
		!TRACE()
		!ERROR_OR_RETURN `
			printerr()
			parserMessageAfter(io.stderr, state, state.nextToken-2,   "Error", "Expected '=' in assignment statement.")
			parserMessage     (io.stderr, state, statementStartToken, "Info",  "...start of statement is here.")
			exitFailure()
		`
	end

	assignment.token           = state.nextToken-1
	assignment.binaryOperation = tokValue:sub(1, -2) -- All assignments with extra operations end with '=' (e.g. '+='). Here we just strip away the '='.

	!DO_OR_RETURN `parseExpressionList(state, assignment, assignment.values)`

	-- Quickly check if there are obviously too many values.
	if #assignment.values > #assignment.targets then
		!ERROR_OR_RETURN `errorParsing(state, assignment.values[#assignment.targets+1].token-1, "There are more values than assignment targets.")`
	end

	return assignment
end

-- Add the names to the 'names' array.
-- success = parseNameList( compilationState, parentNode, names, allowBlanks )
function _G.parseNameList(state, parentNode, names, allowBlanks)
	local takenNames = {}

	while true do
		local tokType, tokValue, token = peekNextToken(state)
		local identOrBlank

		if allowBlanks and isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"_") then
			eatNextToken(state)
			identOrBlank = astNewNode(AstBlank, token, parentNode)
		else
			!SET_OR_RETURN_FALSE `identOrBlank = parseIdentifier(state, parentNode)`
			if takenNames[identOrBlank.name] then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Duplicate name '%s'.", identOrBlank.name)`
			end
			takenNames[identOrBlank.name] = true
		end

		table.insert(names, identOrBlank)
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			eatNextToken(state)
			-- Continue the loop.
		else
			break
		end
	end

	return true
end

function _G.parseDebugNode(state, parentNode)
	local tokType, tokValue, token = eatNextToken(state)
	if tokType ~= !(TOKEN_DIRECTIVE) then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected a directive.")`
	end

	local debugNode  = astNewNode(AstDebug, token, parentNode)
	debugNode.action = tokValue

	!SET_OR_RETURN `debugNode.expression = parseExpression(state, debugNode)`

	return debugNode
end

local function parseIfBranch(state, ifOrStaticIf, isFileScope)
	local block

	if isFileScope then
		!ASSERT("ifOrStaticIf.nodeType == "..nodeTypes.AstStaticIf)

		local tokType, tokValue, token = peekNextToken(state)

		-- This block will never get inferred - it's just for storing statements we
		-- may potentially use. (Should we have a dedicated node type for this?)
		block = astNewNode(AstBlock, token, ifOrStaticIf)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
			eatNextToken(state) -- '{'
			!DO_OR_RETURN `parseFileScopeOrNamespaceStatements(state, block, false, false)` -- @Cleanup: Make a parseBlockOrScopedStatement() equivalent for file scope/namepaces.
		else
			!DO_OR_RETURN `parseFileScopeOrNamespaceStatements(state, block, false, true)`
		end

	else
		!SET_OR_RETURN `block = parseBlockOrScopedStatement(state, ifOrStaticIf)`
	end

	return block
end

function _G.parseIfOrStaticIf(state, parentNode, isFileScope)
	local tokType, tokValue, token = eatNextToken(state)
	!ASSERT(F("isToken(tokType,tokValue, %d,%q) or isToken(tokType,tokValue, %d,%q)", TOKEN_KEYWORD,"if", TOKEN_DIRECTIVE,"if"))

	local AstNodeType                       = tokType == !(TOKEN_KEYWORD) and AstIf or AstStaticIf
	local ifOrStaticIf                      = astNewNode(AstNodeType, token, parentNode)
	!SET_OR_RETURN `ifOrStaticIf.condition  = parseExpression(state, ifOrStaticIf)`
	!SET_OR_RETURN `ifOrStaticIf.branchTrue = parseIfBranch(state, ifOrStaticIf, isFileScope)`

	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"else") then
		eatNextToken(state)

		-- Make !if...elseif work.
		if AstNodeType == AstStaticIf then
			tokType, tokValue, token = peekNextToken(state)
			if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"if") and state.tokens.position1[token] == state.tokens.position1[token-1]+4 then
				state.tokens.type[token] = !(TOKEN_DIRECTIVE) -- Just make the 'if' into '!if'.
			end
		end

		!SET_OR_RETURN `ifOrStaticIf.branchFalse = parseIfBranch(state, ifOrStaticIf, isFileScope)`
	end

	return ifOrStaticIf
end

local function getBreakableNameFromSimpleExpression(expr)
	if expr.nodeType == !(nodeTypes.AstIdentifier) then
		return expr.name

	elseif expr.nodeType == !(nodeTypes.AstUnary) then
		if expr.operation == "not" and expr.expression.nodeType == !(nodeTypes.AstIdentifier) then
			return expr.expression.name
		end

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		if expr.left.nodeType == expr.right.nodeType then
			-- void
		elseif expr.left.nodeType == !(nodeTypes.AstIdentifier) then
			if expr.right.nodeType == !(nodeTypes.AstLiteral) then  return expr.left.name   end
		elseif expr.right.nodeType == !(nodeTypes.AstIdentifier) then
			if expr.left.nodeType  == !(nodeTypes.AstLiteral) then  return expr.right.name  end
		end
	end

	return ""
end

function _G.parseSwitch(state, parentNode, statementStartToken, valueExpr, complete)
	-- Note: We assume '... == {' has been eaten already.
	local switch     = astNewNode(AstSwitch, statementStartToken, parentNode)
	switch.complete  = complete
	switch.value     = valueExpr
	valueExpr.parent = switch

	local gotDefault = false
	local lastCaseToken

	while true do
		local tokType, tokValue = eatNextToken(state)
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			break
		elseif not isToken(tokType,tokValue, !(TOKEN_KEYWORD),"case") then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected 'case'.")`
		elseif gotDefault then
			!ERROR_OR_RETURN `errorParsing(state, lastCaseToken, "The default case must be last.")`
		end

		lastCaseToken = state.nextToken-1

		local case = SwitchCase()
		table.insert(switch.cases, case)

		tokType, tokValue = peekNextToken(state)
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
			gotDefault = true -- Omitted value means the default case.
		else
			!SET_OR_RETURN `case.value = parseExpression(state, switch)`
		end

		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ':'.")`
		end

		!SET_OR_RETURN `local body = astNewNode(AstBlock, state.nextToken, switch)`
		case.body                  = body

		while true do
			tokType, tokValue = peekNextToken(state)
			if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"case") or isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
				break
			end
			!DO_OR_RETURN `parseOneStatementButSometimesMoreAndAddToBlock(state, body)`
		end
	end

	return switch
end

-- success = parseOneStatementButSometimesMoreAndAddToBlock( state, block )
function _G.parseOneStatementButSometimesMoreAndAddToBlock(state, block)
	local tokType,  tokValue  = peekNextToken(state, 1)
	local tokType2, tokValue2 = peekNextToken(state, 2)
	local tokType3, tokValue3 = peekNextToken(state, 3)
	local tokType4, tokValue4 = peekNextToken(state, 4)

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"local","static") or (
		isToken(tokType, tokValue,  !(TOKEN_KEYWORD),"using") and
		isToken(tokType2,tokValue2, !(TOKEN_KEYWORD),"local","static")
	) then
		!DO_OR_RETURN_FALSE `parseDeclarationStatement(state, block, true)`
		return true
	end

	local statementStartToken = state.nextToken
	local statement

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"export") or (
		isToken(tokType, tokValue,  !(TOKEN_KEYWORD),"using") and
		isToken(tokType2,tokValue2, !(TOKEN_KEYWORD),"export")
	) then
		if tokValue == "using" then  eatNextToken(state)  end
		!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Exports can only be declared in file scope or in namespaces.")`

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"return") then
		local returnNode = astNewNode(AstReturn, state.nextToken, block)

		eatNextToken(state)
		tokType, tokValue = peekNextToken(state)

		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			--
			-- Note: Considering this following @Ambigous situation we have to check whether any values should be returned.
			-- As a bonus we also figure if we're even inside a function, though I'm not sure this'll work when we have static code. @Robustness
			--
			--   if x return
			--   func() -- Returned expression, or separate statement after 'if'?
			--
			local lambda = getLambda(returnNode)
			if not lambda then
				-- This shouldn't happen as this function shouldn't be called by anything that does not parse return statements.
				!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Internal compiler error: Not inside a function.")`
			end

			if lambda.argumentsOut and lambda.argumentsOut.arguments[1] then
				!DO_OR_RETURN_FALSE `parseExpressionList(state, returnNode, returnNode.values)`
			end
		end

		statement = returnNode

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"break","continue") then
		local keyword         = tokValue
		local breakOrContinue = astNewNode((keyword == "break" and AstBreak or AstContinue), state.nextToken, block)

		eatNextToken(state)

		!local constName   = CONST_SET{ nodeTypes.AstFor, nodeTypes.AstWhile, nodeTypes.AstLambda }
		local loopOrLambda = astFindParent(breakOrContinue, !!(constName))

		if not loopOrLambda or loopOrLambda.nodeType == !(nodeTypes.AstLambda) then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Not inside a loop.")`
		end

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			eatNextToken(state) -- '('

			!SET_OR_RETURN_FALSE `local loopNameIdent = parseIdentifier(state, breakOrContinue)`

			local loopName    = loopNameIdent.name
			local loopClosest = loopOrLambda

			repeat
				-- We can break from these types of loops:
				--   for i = 1, 2  break(i)
				--   while x       break(x)
				--   while not x   break(x)
				-- We cannot break from these:
				--   for 1, 2   break(it)  -- 'it' is an implicit name. (We could make this work if necessary.)
				--   while x+y  break(x)   -- The condition expression is too complex. (What's "too complex" is debatable. @Revise)
				if
					loopOrLambda.nodeType == !(nodeTypes.AstFor)   and itemWith1(loopOrLambda.names, "name", loopName) or
					loopOrLambda.nodeType == !(nodeTypes.AstWhile) and getBreakableNameFromSimpleExpression(loopOrLambda.condition) == loopName
				then
					if loopOrLambda == loopClosest then
						-- void  We don't need a named break if we're breaking from the closest loop. (Should we save this info anyway for the metaprogram?)
					else
						breakOrContinue.loopName    = loopNameIdent
						breakOrContinue.loop        = loopOrLambda
						loopOrLambda.hasNamedBreaks = true
					end
					break

				elseif loopOrLambda.nodeType == !(nodeTypes.AstLambda) then
					break -- Assume the identifier is part of a different statement.
				end

				!local constName = CONST_SET{ nodeTypes.AstFor, nodeTypes.AstWhile, nodeTypes.AstLambda }
				loopOrLambda     = astFindParent(loopOrLambda, !!(constName))
			until not loopOrLambda

			if not loopOrLambda or loopOrLambda.nodeType == !(nodeTypes.AstLambda) then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Could not find what loop '%s' refers to.", loopName)`
			end

			tokType, tokValue = eatNextToken(state)

			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
				!ERROR_OR_RETURN_FALSE `errorParsingAfterPrevious(state, "Expected ')'.")`
			end
		end

		statement = breakOrContinue

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"do") then
		eatNextToken(state)
		!SET_OR_RETURN_FALSE `statement = parseBlockOrScopedStatement(state, block)`

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"defer") then
		local defer = astNewNode(AstDefer, state.nextToken, block)

		eatNextToken(state)
		!SET_OR_RETURN_FALSE `defer.body = parseBlockOrScopedStatement(state, defer)`

		statement = defer

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"if") and isToken(tokType2,tokValue2, !(TOKEN_DIRECTIVE),"complete") then
		eatNextToken(state) -- 'if'
		eatNextToken(state) -- '!complete'
		!SET_OR_RETURN_FALSE `local expr = parseExpression(state, block)`

		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"==") then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Expected '=='.")`
		end

		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Expected '{'.")`
		end

		!SET_OR_RETURN_FALSE `statement = parseSwitch(state, block, statementStartToken, expr, true)`

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"if") then
		eatNextToken(state) -- 'if'
		!SET_OR_RETURN_FALSE `local expr = parseExpression(state, block)`
		tokType,  tokValue  = peekNextToken(state, 1)
		tokType2, tokValue2 = peekNextToken(state, 2)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"==") and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"{") then
			eatNextToken(state) -- '=='
			eatNextToken(state) -- '{'
			!SET_OR_RETURN_FALSE `statement = parseSwitch(state, block, statementStartToken, expr, false)`

		else
			state.nextToken = statementStartToken
			!SET_OR_RETURN_FALSE `statement = parseIfOrStaticIf(state, block, false)`
		end

	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"if") then
		!SET_OR_RETURN_FALSE `statement = parseIfOrStaticIf(state, block, false)`

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"while") then
		local whileLoop = astNewNode(AstWhile, state.nextToken, block)
		eatNextToken(state)

		!SET_OR_RETURN_FALSE `whileLoop.condition = parseExpression(state, whileLoop)`
		!SET_OR_RETURN_FALSE `whileLoop.body      = parseBlockOrScopedStatement(state, whileLoop)`

		statement = whileLoop

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"for") then
		local forLoop = astNewNode(AstFor, state.nextToken, block)

		eatNextToken(state)
		tokType, tokValue = peekNextToken(state)

		-- FOR_SHORT  for < [ v1, ... : ] obj
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"<") then
			eatNextToken(state)
			forLoop.reverse = true
		end

		local forStartIndex = state.nextToken

		local exprListWeMayOrMayNotUse = {}
		!DO_OR_RETURN_FALSE `parseExpressionList(state, forLoop, exprListWeMayOrMayNotUse)`

		tokType, tokValue = peekNextToken(state)
		local twoParter

		-- FOR_ITERATOR  for v1, ... in iter [, state [, init ] ]
		if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"in") then
			forLoop.forType = !(FOR_ITERATOR)
		-- FOR_SHORT  for [ < ] v1, ... : obj
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
			forLoop.forType = !(FOR_SHORT)
			twoParter       = true
		-- FOR_NUMERIC  for i = start, end [, step ]
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
			forLoop.forType = !(FOR_NUMERIC)
			twoParter       = true
		-- FOR_NUMERIC  for start, end [, step ]
		elseif #exprListWeMayOrMayNotUse >= 2 then -- If more than 3 arguments are specified then we'll get an error later.
			forLoop.forType = !(FOR_NUMERIC)
			twoParter       = false
		-- FOR_SHORT  for [ < ] obj
		elseif #exprListWeMayOrMayNotUse == 1 then
			forLoop.forType = !(FOR_SHORT)
			twoParter       = false
		else
			!ERROR_OR_RETURN_FALSE `errorParsing(state, forLoop.token, "Could not determine what kind of 'for' statement this is.")`
		end

		if forLoop.reverse and forLoop.forType ~= !(FOR_SHORT) then
			!ERROR_OR_RETURN_FALSE `errorParsing(state, forLoop.token+1, "Only short-form 'for' loops support the reverse operator.")`
		end

		if forLoop.forType == !(FOR_NUMERIC) then
			-- for i = start, end [, step ]
			if twoParter then
				state.nextToken = forStartIndex
				!DO_OR_RETURN_FALSE `parseNameList(state, forLoop, forLoop.names, false)`

				if forLoop.names[2] then
					!ERROR_OR_RETURN_FALSE `errorParsing(state, forLoop.names[2].token, "Expected only one name in numeric 'for' loop.")`
				end

				tokType, tokValue = eatNextToken(state)
				assert(isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"="))

				!DO_OR_RETURN_FALSE `parseExpressionList(state, forLoop, forLoop.expressions)`

			-- for start, end [, step ]
			else
				forLoop.expressions = exprListWeMayOrMayNotUse
			end

			if #forLoop.expressions < 2 then
				!ERROR_OR_RETURN_FALSE `errorParsingAfterLast(state, "Expected 2 or 3 parameters for the numeric 'for' loop.")`

			elseif #forLoop.expressions > 3 then
				!ERROR_OR_RETURN_FALSE `errorParsing(state, forLoop.expressions[4].token-1, "Expected 2 or 3 parameters for the numeric 'for' loop.")`
			end

		elseif forLoop.forType == !(FOR_SHORT) then
			-- for [ < ] v1, ... : obj
			if twoParter then
				state.nextToken = forStartIndex
				!DO_OR_RETURN_FALSE `parseNameList(state, forLoop, forLoop.names, false)`

				tokType, tokValue = eatNextToken(state)
				assert(isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":"))

				!DO_OR_RETURN_FALSE `parseExpressionList(state, forLoop, forLoop.expressions)`

				if forLoop.expressions[2] then
					!ERROR_OR_RETURN_FALSE `errorParsing(state, forLoop.expressions[2].token-1, "Expected a single parameter for the short-form 'for' loop.")`
				end

			-- for [ < ] obj
			else
				forLoop.expressions = exprListWeMayOrMayNotUse
				assert(#forLoop.expressions == 1)
			end

		-- for v1, ... in iter [, state [, init ] ]
		else
			state.nextToken = forStartIndex
			!DO_OR_RETURN_FALSE `parseNameList(state, forLoop, forLoop.names, false)`

			tokType, tokValue = eatNextToken(state)
			assert(isToken(tokType,tokValue, !(TOKEN_KEYWORD),"in"))

			!DO_OR_RETURN_FALSE `parseExpressionList(state, forLoop, forLoop.expressions)`
		end

		!SET_OR_RETURN_FALSE `forLoop.body = parseBlockOrScopedStatement(state, forLoop)`
		table.insert(forLoop.statements, forLoop.body)

		statement = forLoop

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"using") then
		!SET_OR_RETURN_FALSE `local using = parseUsing(state, block)`
		statement                         = using

		table.insert(block.usings, using)

	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import","load") then
		!SET_OR_RETURN_FALSE `local import = parseImportOrLoad(state, block)`
		statement                          = import

		if not import.isLoad then
			table.insert(block.imports, import)
		end

	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"assert","print") then
		!SET_OR_RETURN_FALSE `statement = parseDebugNode(state, block)`

	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"_") then
		!SET_OR_RETURN_FALSE `statement = parseAssignment(state, block)`

	else
		state.soft     = true
		local exprTest = parseExpression(state, block)
		state.soft     = false

		if not exprTest then
			-- !TRACE() -- This fixes the position of the traceback in the console, but we don't want the traceback to here!
			!ERROR_OR_RETURN_FALSE `
				printerr()
				parserMessage(io.stderr, state, statementStartToken, "Error", "Could not parse statement starting here.")

				state.nextToken = statementStartToken
				parseExpression(state, block) -- Should call exitFailure() at some point.
				exitFailure() -- Just to be safe.
			`

		elseif exprTest.nodeType == !(nodeTypes.AstCall) then
			local call = exprTest
			--[[ @Incomplete :ParenthesesAmbiguityError
			if
				isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
				and call.callee.nodeType == !(nodeTypes.AstCall)
				and astGetCalleeVisuallyFurthestToTheLeft(call).nodeType == !(nodeTypes.AstIdentifier)
			then
				!ERROR_OR_RETURN_FALSE `errorParsing(state, statementStartToken, "Ambigous expression being called.")`
			end
			--]]
			statement = call

		else
			state.nextToken                 = statementStartToken
			!SET_OR_RETURN_FALSE `statement = parseAssignment(state, block)`
		end
	end

	!ASSERT `statement`
	table.insert(block.statements, statement)

	eatTrailingSemicolon(state)
	return true
end

function _G.parseBlock(state, parentNode)
	-- Note: We assume the '{' has been eaten already.

	local blockStartToken     = state.nextToken-1
	local block               = astNewNode(AstBlock, blockStartToken, parentNode)

	!if DEBUG then
		--[[
		setmetatable(block, {__newindex=function(block, k, v)
			assert(k ~= 1)
			rawset(block, k, v)
		end})
		--]]
	!end

	local statementStartToken = blockStartToken
	local lastNodeType        = 0

	while true do
		local tokType, tokValue, token = peekNextToken(state)

		if not tokType then
			!ERROR_OR_RETURN `errorParsing(state, blockStartToken, "Unfinished block.")`

		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			eatNextToken(state)
			break

		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),";") then
			eatNextToken(state)

			-- We allow empty statement like Lua 5.2+ does (so things like ';(x and func1 or func2)()'
			-- always work, no matter what comes previously). :EmptyStatement
			if not state.soft then  parserMessageLine(io.stderr, state, token, "Warning", "Empty statement.")  end

		else
			if !!(CONST_SET{ nodeTypes.AstReturn,nodeTypes.AstBreak,nodeTypes.AstContinue })[lastNodeType] then
				local nodeTitle
					=  lastNodeType == !(nodeTypes.AstReturn)   and "return"
					or lastNodeType == !(nodeTypes.AstBreak)    and "break"
					or lastNodeType == !(nodeTypes.AstContinue) and "continue"
					or assert(lastNodeType)

				local extra
					=  lastNodeType ~= !(nodeTypes.AstReturn) and ""
					or getLast(block.statements).values[1]    and " (Note: The function has return arguments.)"
					or                                            " (Note: The function has no return arguments.)"

				!ERROR_OR_RETURN `errorParsing(state, state.nextToken, "Unreachable code after %s statement.%s", nodeTitle, extra)`
			end

			statementStartToken = state.nextToken
			!DO_OR_RETURN `parseOneStatementButSometimesMoreAndAddToBlock(state, block)`

			local statement = getLast(block.statements)
			lastNodeType    = statement.nodeType -- This is for return/break/continue check.
		end
	end

	return block
end

-- block = parseBlockOrScopedStatement( compilationState, parentNode )
function _G.parseBlockOrScopedStatement(state, parentNode)
	local tokType, tokValue, token = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		eatNextToken(state)
		return (parseBlock(state, parentNode)) -- May return nil.
	end

	local block = astNewNode(AstBlock, token, parentNode)

	!DO_OR_RETURN `parseOneStatementButSometimesMoreAndAddToBlock(state, block)`
	return block
end

function _G.parseImportOrLoad(state, parentNode)
	local import = astNewNode(AstImport, state.nextToken, parentNode)

	local tokType, tokValue = eatNextToken(state)
	if isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import") then
		-- void
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"load") then
		import.isLoad = true
	else
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected '!load' or '!import'.")`
	end
	if import.isLoad and astIsOrIsInModule(import) then
		!ERROR_OR_RETURN `errorParsingNext(state, "Modules cannot use !load.")`
	end

	local tokType, tokValue = eatNextToken(state)
	if tokType ~= !(TOKEN_STRING) then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected a string.")`
	end
	import.importName = tokValue:gsub("\\", "/") -- Normalize paths.

	return import
end

function _G.parseRun(state, parentNode, mustBeExpression)
	local tokType, tokValue, token = eatNextToken(state)
	if not isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"run") then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected '!run'.")`
	end

	local runNode  = astNewNode(AstRun,    token, parentNode)
	local lambda   = astNewNode(AstLambda, token, parentNode) -- @Cleanup: Never output this function (or inner functions) in the final program (even if --nostrip is set)?
	runNode.lambda = lambda

	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		eatNextToken(state)

		if mustBeExpression then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected an expression.")`
		end

		!SET_OR_RETURN `local block = parseBlock(state, lambda)`
		lambda.body                 = block
		table.insert(lambda.statements, block)

	else
		local expectValue = not isScope(parentNode)

		if expectValue then
			local args          = astNewNode(AstArguments, token, lambda)
			lambda.argumentsOut = args
			table.insert(lambda.statements, args)

			local arg         = astNewNode(AstArgument, token, args)
			args.arguments[1] = arg

			local decl        = astNewNode(AstDeclaration, token, arg)
			arg.declaration   = decl

			local ident       = astNewNode(AstIdentifier, token, decl)
			ident.name        = "_1"
			ident.declaration = decl
			decl.name         = ident

			local typeNode    = astNewNode(AstType, token, decl)
			typeNode.kind     = !(TYPE_KIND_SIMPLE_BUILTIN)
			typeNode.typeName = "any" -- Good for now?
			decl.type         = typeNode
		end

		local block = astNewNode(AstBlock, token, lambda)
		lambda.body = block
		table.insert(lambda.statements, block)

		local exprStartToken = state.nextToken

		if expectValue then
			local returnNode        = astNewNode(AstReturn, token, block)
			returnNode.runDirective = runNode
			block.statements[1]     = returnNode
			!SET_OR_RETURN `returnNode.values[1] = parseExpression(state, returnNode)`
		else
			!SET_OR_RETURN `block.statements[1]  = parseExpression(state, block)`
		end

		-- Catch situations like these which are probably errors:
		--   local v = !run func
		--   local v = !run foo.func
		local exprIsOnlyIdents = true

		for token = exprStartToken, state.nextToken-1 do
			tokType, tokValue = getToken(state.tokens, token)
			if not (tokType == !(TOKEN_IDENTIFIER) or isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),".")) then
				exprIsOnlyIdents = false
				break
			end
		end

		if exprIsOnlyIdents then
			tokType, tokValue = getToken(state.tokens, state.nextToken-1)
			assert(tokType == !(TOKEN_IDENTIFIER))
			!ERROR_OR_RETURN `errorParsingAfterLast(state, "Ambiguity in !run expression: Did you mean to call %s()?", tokValue)`
		end
	end

	lambda.bodyEndToken = state.nextToken-1
	return runNode
end

-- success = parseFileScopeOrNamespaceStatements( state, parentScope, isTopLevel, singleStatement )
-- WARNING: parentScope is currently modified even if success==false!
function _G.parseFileScopeOrNamespaceStatements(state, scope, isTopLevel, singleStatement)
	while true do
		local tokType,  tokValue, token = peekNextToken(state, 1)
		local tokType2, tokValue2       = peekNextToken(state, 2)

		if not tokType and isTopLevel then
			break

		----------------------------------------------------------------

		elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"local","export") or (
			isToken(tokType, tokValue,  !(TOKEN_KEYWORD),"using") and
			isToken(tokType2,tokValue2, !(TOKEN_KEYWORD),"local","export")
		) then
			!DO_OR_RETURN_FALSE `parseDeclarationStatement(state, scope, false)`

		elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"static") or (
			isToken(tokType, tokValue,  !(TOKEN_KEYWORD),"using") and
			isToken(tokType2,tokValue2, !(TOKEN_KEYWORD),"static")
		) then
			if tokValue == "using" then  eatNextToken(state)  end
			!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Static variables cannot be declared in file scope or in namespaces.")`

		elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import","load") then
			-- @Incomplete: Warn about duplicate imports? Maybe not necessay as things will only ever be imported once anyway.
			!SET_OR_RETURN_FALSE `local import = parseImportOrLoad(state, scope)`
			statement                          = import

			table.insert(scope.statements, import)
			if not import.isLoad then
				table.insert(scope.imports, import)
			end

		elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"using") then
			!SET_OR_RETURN_FALSE `local using = parseUsing(state, scope)`
			statement                         = using

			table.insert(scope.statements, using)
			table.insert(scope.usings,     using)

		elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"assert","print") then
			!SET_OR_RETURN_FALSE `local debugNode = parseDebugNode(state, scope)`
			table.insert(scope.statements, debugNode)

		elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"if") then
			!SET_OR_RETURN_FALSE `local ifOrStaticIf = parseIfOrStaticIf(state, scope, true)`
			table.insert(scope.statements, ifOrStaticIf)

		elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"run") then
			!SET_OR_RETURN_FALSE `local runNode = parseRun(state, scope, false)`
			table.insert(scope.statements, runNode)

		elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"preload") then
			eatNextToken(state)
			if not isTopLevel then
				!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "!preload statements are only supported directly in file-scope.")`
			end

			tokType, tokValue, token = eatNextToken(state)
			if tokType ~= !(TOKEN_STRING) then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Expected a string containing Lua code.")`
			end

			local lua = tokValue:gsub("\n%s*$", "")
			if not lua:find"[^%s]" then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "String with Lua code must not be empty.")`
			end

			local spaceBefore = lua:match"^%s*\n"
			local lineOffset  = 0

			if spaceBefore then
				local _, nlCount = spaceBefore:gsub("\n", "%0")
				lineOffset       = nlCount
				lua              = lua:sub(#spaceBefore+1)
			end

			local chunk, err = loadstring(lua, "@(lua)")
			if not chunk then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "This string does not contain valid Lua code: %s", err)`
			end

			table.insert(state.luaPreloads, {
				lua        = lua,
				token      = token,
				lineOffset = lineOffset,
			})

		----------------------------------------------------------------

		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),";") then
			eatNextToken(state)
			if not state.soft then  parserMessageLine(io.stderr, state, token, "Warning", "Empty statement.")  end -- :EmptyStatement

		elseif not (isTopLevel or singleStatement) and isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			eatNextToken(state)
			break
		else
			!if DEBUG then
				print(TOKEN_TITLES[state.tokens.type[state.nextToken]])
			!end
			if isTopLevel or singleStatement then
				!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Expected file-level declaration.")`
			else
				!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Expected '}'.")`
			end
		end

		if singleStatement then  break  end
	end

	return true
end

function _G.parseFileScope(state, parentNode, path, isModule, moduleName)
	local fileScope      = astNewNode(AstFileScope, state.nextToken, parentNode)
	fileScope.path       = path
	fileScope.isModule   = isModule
	fileScope.moduleName = moduleName

	local tokType, tokValue = peekNextToken(state)
	if tokType == !(TOKEN_DUMMY) then
		eatNextToken(state)
	end

	!DO_OR_RETURN `parseFileScopeOrNamespaceStatements(state, fileScope, true, false)`

	return fileScope
end

function _G.astMoveRelevantThingsFromFileScopeToGlobalScope(state, fileScope)
	!ASSERT `not fileScope.isModule`
	!ASSERT `not fileScope.queued`

	local globalScope = state.globalScope

	for i, decl in ipairsr(fileScope.declarations) do
		if isDeclarationExported(decl) then
			removeUnordered(fileScope.declarations, i)
			table.insert(globalScope.declarations, decl)
		end
	end

	insertArrayItems(globalScope.imports, fileScope.imports)
	fileScope.imports = {}
end

function _G.parseGlobalScope(state, firstFilePath)
	local globalScope          = astNewNode(AstGlobalScope, state.nextToken)
	state.globalScope          = globalScope

	local firstFileScope       = parseFileScope(state, globalScope, firstFilePath, false, "")
	globalScope.firstFileScope = firstFileScope

	table.insert(globalScope.statements, firstFileScope)
	table.insert(globalScope.fileScopes, firstFileScope)

	astMoveRelevantThingsFromFileScopeToGlobalScope(state, firstFileScope)

	return globalScope
end

-- call = parseCall( compilationState, parentNode, couldBeType [, callee=theFollowingIdentifier, isMethod=false ] )
function _G.parseCall(state, parentNode, couldBeType, callee, isMethod)
	assert(type(couldBeType) == "boolean")

	if not callee then
		!SET_OR_RETURN `callee = parseIdentifier(state, parentNode)` -- We'll update the parent later.
	end

	isMethod = isMethod or false
	local call

	while true do
		local tokType, tokValue, token = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected '('.")`
		end

		call              = astNewNode(AstCall, token, parentNode)
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			eatNextToken(state)

			-- Should struct arguments be able to have default values, allowing foo()
			-- to possibly be a type?
			couldBeType = false

		else
			!DO_OR_RETURN `parseExpressionList(state, call, call.arguments)`

			tokType, tokValue = eatNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')' or ','.")`
			end
		end

		call.couldBeTypeWithParameters = couldBeType

		callee.parent = call
		call.callee   = callee
		call.isMethod = isMethod

		tokType, tokValue = peekNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then  break  end

		call.couldBeTypeWithParameters = false
		callee   = call
		isMethod = false
	end

	return call
end

function _G.parseLambda(state, parentNode)
	local lambda = astNewNode(AstLambda, state.nextToken, parentNode)

	-- Captures.
	local tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[") then
		eatNextToken(state)
		!DO_OR_RETURN `parseNameList(state, lambda, lambda.captures, false)`

		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"]") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ']'.")`
		end
	end

	-- Input arguments.
	tokType, tokValue = eatNextToken(state)
	if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
		!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '('.")`
	end

	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
		eatNextToken(state)

	else
		!SET_OR_RETURN `local args = parseArguments(state, lambda, true)`
		lambda.argumentsIn         = args

		local takenNames = {}
		local gotError   = false

		-- Add declarations for values that will be baked (only types so far).
		for _, arg in ipairs(args.arguments) do
			astVisitAllNodes(arg, function(node)
				if node.nodeType ~= !(nodeTypes.AstBake) then  return  end

				lambda.isPolymorphic = true

				local bake  = node
				local ident = bake.name
				local name  = ident.name

				if takenNames[name] then
					gotError = true
					!ERROR_OR_RETURN `
						printerr()
						parserMessage(io.stderr, state, ident.token,      "Error", "Duplicate placeholder type name '%s'.", name)
						parserMessage(io.stderr, state, takenNames[name], "Info",  "...previous name is here.")
						exitFailure()
					`
				end
				takenNames[name] = ident.token

				local decl        = astNewNode(AstDeclaration, bake.token, lambda)
				ident.declaration = decl
				decl.name         = astCopy(ident, nil, decl)
				decl.kind         = !(DECL_KIND_LOCAL_CONST)

				-- Note: We're not setting decl.type nor decl.value, leaving the declaration unfinished.
				-- It should be ok as polymorphic functions shouldn't get inferred.

				table.insert(lambda.statements,       decl)
				table.insert(lambda.declarations,     decl)
				table.insert(lambda.bakeDeclarations, decl)

				return !(VISIT_IGNORE_CHILDREN)
			end)
		end

		if gotError then  return nil  end
		table.insert(lambda.statements, args)

		for _, arg in ipairs(args.arguments) do
			table.insert(lambda.declarations, arg.declaration)

			local decl = arg.declaration

			if arg.autobake == !(AUTOBAKE_REQUIRED) then
				lambda.isPolymorphic = true

				local typeNode       = astNewNode(AstType, decl.token, decl)
				typeNode.kind        = !(TYPE_KIND_SIMPLE_BUILTIN)
				typeNode.typeName    = "placeholder"

				decl.kind            = !(DECL_KIND_LOCAL_CONST)
				decl.value           = typeNode -- During baking this may end up being replaced with something that's not a type, but we don't care about that at this moment!
			end

			if arg.isUsing then
				local using       = astNewNode(AstUsing, arg.token, lambda)

				local ident       = astNewNode(AstIdentifier, arg.token, using)
				ident.name        = decl.name.name
				ident.declaration = decl
				using.expression  = ident

				table.insert(lambda.statements, using)
				table.insert(lambda.usings,     using)
			end
		end

		if lambda.isPolymorphic and lambda.captures[1] then
			!ERROR_OR_RETURN `errorParsing(state, lambda.token, "Polymorphic functions cannot have captures.")`
		end

		if args.arguments[1] and getLast(args.arguments).declaration.name.nodeType == !(nodeTypes.AstVararg) then
			lambda.takingVararg = true
		end

		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end
	end

	-- Output arguments.
	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"->") then
		eatNextToken(state)

		local argsOutStartToken = state.nextToken
		local args              = nil

		tokType, tokValue         = peekNextToken(state, 1)
		local tokType2, tokValue2 = peekNextToken(state, 2)

		-- (...) -> void
		if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"void") then
			eatNextToken(state)

			-- The following error detection erroneously matches some valid situations, e.g.:
			-- local funcSig, Bool :: ()->void, bool

			--[[
			tokType, tokValue = peekNextToken(state)
			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
				!ERROR_OR_RETURN `errorParsingNext(state, "Argument list with 'void' cannot have other arguments.")`
			end
			--]]

		-- (...) -> (name:type, ...)
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
			and (
				tokType2 == !(TOKEN_IDENTIFIER)
				or isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"...","_","$") -- '$' is just for a better error message. Output arguments cannot be baked.
			)
		then
			eatNextToken(state)
			tokType, tokValue = peekNextToken(state)

			-- '()' is the same as 'void'.
			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
				eatNextToken(state)

			else
				!SET_OR_RETURN `args = parseArguments(state, lambda, false)`

				tokType, tokValue = eatNextToken(state)
				if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
					!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
				end
			end

			-- If the return type is a function signature, i.e. () -> () -> ...
			tokType, tokValue = peekNextToken(state)
			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"->") then
				state.nextToken = argsOutStartToken
				!SET_OR_RETURN `args = parseNamelessArguments(state, lambda)` -- Replace any output arguments we just parsed.
			end

		-- (...) -> type, ...
		else
			!SET_OR_RETURN `args = parseNamelessArguments(state, lambda)`
		end

		if args then
			lambda.argumentsOut = args
			table.insert(lambda.statements, args)
		end
	end

	-- Body.
	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		eatNextToken(state)

		!SET_OR_RETURN `local block = parseBlock(state, lambda)`
		lambda.body                 = block
		table.insert(lambda.statements, block)

		lambda.bodyEndToken = state.nextToken-1 -- The '}'.

	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"foreign") then
		eatNextToken(state)
		lambda.bodyIsForeign = true

		local block = astNewNode(AstBlock, state.nextToken-1, lambda) -- Dummy block.
		lambda.body = block
		table.insert(lambda.statements, block)

		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_IDENTIFIER)) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected foreign source. (Valid values: lua, method, compiler)")`
		elseif not !!(anyV(`tokValue`, "lua","method","compiler")) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Invalid source '%s'. (Valid values: lua, method, compiler)", tokValue)`
		end
		lambda.foreignSource = tokValue

		tokType, tokValue = peekNextToken(state)
		if isToken(tokType,tokValue, !(TOKEN_STRING)) then
			eatNextToken(state)
			lambda.foreignSourceName = tokValue
		else
			-- void  (lambda.foreignSourceName will be the name of whatever declared constant the lambda is attached to.)
			!ERROR_OR_RETURN `errorParsingAfterLast(state, "@Incomplete: Infer lambda.foreignSourceName")` -- TEMP
		end

		lambda.bodyEndToken = state.nextToken-1
	else
		lambda.bodyEndToken = state.nextToken-1 -- Dummy value that shouldn't be used since there's no body.
	end

	if lambda.isPolymorphic and not lambda.body then
		!ERROR_OR_RETURN `errorParsing(state, lambda.token, "Types of functions cannot be polymorphic - only functions themselves can.")`
	elseif lambda.captures[1] and not lambda.body then
		!ERROR_OR_RETURN `errorParsingAfterLast(state, "Expected a body for function with captures.")`
	elseif lambda.captures[1] and lambda.bodyIsForeign then
		!ERROR_OR_RETURN `errorParsing(state, lambda.token, "Foreign functions cannot have captures.")`
	end

	return lambda
end



-- expression = parseExpression( compilationState, parentNode [, previousOperatorPrecedence, expectLeftValue=false ] )
function _G.parseExpression(state, parentNode, prevOpPrecedence, expectLeftValue)
	prevOpPrecedence = prevOpPrecedence or 0

	local tokType,  tokValue, exprStartToken = eatNextToken(state)
	local tokType2, tokValue2                = peekNextToken(state, 1)
	local tokType3, tokValue3                = peekNextToken(state, 2)
	local expr, token

	local encounteredParentheses = false

	-- Function call or type with parameters.
	--
	-- Note: We also detect function calls later by the binary operations.
	-- The difference is that here we may have a type.
	--
	if
		tokType == !(TOKEN_IDENTIFIER)
		and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"(")
	then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseCall(state, parentNode, true)`

	-- Built-in type.
	elseif isTokenBuiltinType(tokType, tokValue) then
		local typeNode    = astNewNode(AstType, exprStartToken, parentNode)
		typeNode.kind     = !(TYPE_KIND_SIMPLE_BUILTIN)
		typeNode.typeName = tokValue
		expr              = typeNode

		-- @Polish: Check if there's a '(' after this and give error early.

	-- Identifier.
	elseif tokType == !(TOKEN_IDENTIFIER) then
		local ident = astNewNode(AstIdentifier, exprStartToken, parentNode)
		ident.name  = tokValue
		expr        = ident

	-- Literal.
	elseif isTokenLiteral(tokType, tokValue) or (isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"+","-") and !!(anyV(`tokType2`, TOKEN_FLOAT,TOKEN_INTEGER))) then
		local literal = astNewNode(AstLiteral, exprStartToken, parentNode)

		if tokType == !(TOKEN_KEYWORD) then
			if tokValue == "nil" then
				literal.literalType = !(LITERAL_NIL)
				literal.value       = nil
			else
				literal.literalType = !(LITERAL_BOOLEAN)
				literal.value       = tokValue == "true"
			end

		elseif tokType == !(TOKEN_PUNCTUATION) then
			literal.literalType = TOKEN_TYPE_TO_LITERAL_TYPE[tokType2]
			literal.value       = tokValue2 * (tokValue == "-" and -1 or 1)
			eatNextToken(state)
		else
			literal.literalType = TOKEN_TYPE_TO_LITERAL_TYPE[tokType]
			literal.value       = tokValue
		end

		expr = literal

	-- Vararg.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"...") then
		expr         = astNewNode(AstVararg, exprStartToken, parentNode)
		local lambda = getLambda(expr)
		if not (lambda and lambda.takingVararg) then
			errorParsing(state, exprStartToken, "This is not inside a vararg function.")
		end

	-- Table constructor.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		!SET_OR_RETURN `expr = parseTable(state, parentNode)`

	-- Unary operation.
	elseif
		isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"+","-","#") or
		isToken(tokType,tokValue, !(TOKEN_KEYWORD),"not")
	then
		local unary                      = astNewNode(AstUnary, exprStartToken, parentNode)
		unary.operation                  = tokValue
		!SET_OR_RETURN `unary.expression = parseExpression(state, unary, OPERATOR_PRECEDENCE.unary)`
		expr                             = unary

	-- Function signature (type) or lambda.
	--
	--     inArgs [-> outArgs] [body]
	--     captures inArgs [-> outArgs] body
	--
	--     captures = '[' capture1, ... ']'
	--     inArgs   = ( [ inArg1, ... ] )
	--     inArg    = [ $ [ ? ] ] name1 [, ... ] : [ $ ] type [ = defaultValue ]
	--     inArg    = using       name1 [, ... ] : [ $ ] type [ = defaultValue ]
	--     outArgs  = void
	--     outArgs  = type1 [, ... ]
	--     outArgs  = ( outArg1 [, ... ] )
	--     outArg   = name1 [, ... ] : type
	--     body     = { ... }
	--
	elseif
		(
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
			and (
				isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),")")
				or isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"$")
				or isToken(tokType2,tokValue2, !(TOKEN_KEYWORD),"using")
				or (
					(
						isToken(tokType2,tokValue2, !(TOKEN_IDENTIFIER)) or
						isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"...")
					)
					and isToken(tokType3,tokValue3, !(TOKEN_PUNCTUATION),":",",","=")
				)
			)
		)
		or (
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[")
			and not isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"]")
		)
	then
		putBackLastToken(state)
		!SET_OR_RETURN `local lambda = parseLambda(state, parentNode)`

		if lambda.body then
			expr = lambda
		else
			local typeNode          = astNewNode(AstType, lambda.token, parentNode)
			typeNode.kind           = !(TYPE_KIND_FUNCTION)
			typeNode.functionHeader = lambda
			lambda.parent           = typeNode
			expr                    = typeNode
		end

	-- Parentheses (must be detected after lambda).
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
		encounteredParentheses = true
		!SET_OR_RETURN `expr   = parseExpression(state, parentNode)`

		if !!(anyV(`expr.nodeType`, nodeTypes.AstCall,nodeTypes.AstVararg)) then
			-- This is so we know whether to adjust the return values to one or not in certain situations.
			-- Note: Functions with a return argument after the first one marked as #must cannot have their
			-- return arguments adjusted to one.
			expr.surroundedByParentheses = true
		end

		tokType, tokValue = eatNextToken(state)

		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		--[[ @Incomplete :ParenthesesAmbiguityError
		if expectLeftValue and expr.nodeType == !(nodeTypes.AstIdentifier) then
			!ERROR_OR_RETURN `errorParsing(state, exprStartToken, "Unexpected parentheses around identifier.")`
		end
		--]]

	-- Cast.
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"cast") then
		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '('.")`
		end

		local cast                      = astNewNode(AstCast, exprStartToken, parentNode)
		!SET_OR_RETURN `cast.targetType = parseExpression(state, cast)`

		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		!SET_OR_RETURN `cast.expression = parseExpression(state, cast, OPERATOR_PRECEDENCE.cast)`
		expr                            = cast

	-- Type of.
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"type_of") then
		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '('.")`
		end

		local typeOf                      = astNewNode(AstTypeOf, exprStartToken, parentNode)
		!SET_OR_RETURN `typeOf.expression = parseExpression(state, typeOf)`

		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		expr = typeOf

	-- Array type.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[") and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"]") then
		eatNextToken(state) -- ']'

		local typeNode = astNewNode(AstType, exprStartToken, parentNode)
		typeNode.kind  = !(TYPE_KIND_ARRAY)

		!SET_OR_RETURN `typeNode.arrayItemType = parseExpression(state, typeNode)`
		expr                                   = typeNode

	-- Unicode codepoint.
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"char") then
		tokType, tokValue, token = eatNextToken(state)

		if not isToken(tokType,tokValue, !(TOKEN_STRING)) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected a string.")`
		elseif tokValue == "" then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected a UTF-8 character in the string.")`
		elseif tokValue:find!("^"..UTF8_CHARACTER_PATTERN.."$") then
			-- void
		elseif tokValue:find!("^"..UTF8_CHARACTER_PATTERN) then
			!ERROR_OR_RETURN `errorParsingLast(state, "The string must contain a single UTF-8 character.")`
		else
			!ERROR_OR_RETURN `errorParsingLast(state, "Invalid UTF-8 string.")`
		end

		local literal       = astNewNode(AstLiteral, token, parentNode)
		literal.literalType = !(LITERAL_INTEGER)
		literal.value       = utf8Codepoint(tokValue)

		expr = literal

	-- Import/load.
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"load") then
		!ERROR_OR_RETURN `errorParsingLast(state, "!load must be a full statement. It cannot be part of an expression.")`
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import") then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseImportOrLoad(state, parentNode)`
		-- !ERROR_OR_RETURN `errorParsingLast(state, "Invalid place for '!%s'.", tokValue)`

	-- Struct/enum.
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"struct") then
		-- eatNextToken(state)
		!SET_OR_RETURN `expr = parseStruct(state, parentNode)`
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"enum") then
		-- eatNextToken(state)
		!SET_OR_RETURN `expr = parseEnum(state, parentNode)`

	-- Foreign value or struct.
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"foreign") then
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"struct") then
			eatNextToken(state)
			!SET_OR_RETURN `struct = parseStruct(state, parentNode)`
			struct.isForeign       = true
			expr                   = struct
		else
			!SET_OR_RETURN `expr = parseForeign(state, parentNode)`
		end

	-- Baked parameter.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"$") then
		local bake                = astNewNode(AstBake, exprStartToken, parentNode)
		!SET_OR_RETURN `bake.name = parseIdentifier(state, bake)`
		expr                      = bake

	-- Run directive.
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"run") then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseRun(state, parentNode, true)` -- @Incomplete: Allow a block here.

	-- Type information.
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"type_info") then
		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '('.")`
		end

		local typeInfoNode                      = astNewNode(AstTypeInfo, exprStartToken, parentNode)
		!SET_OR_RETURN `typeInfoNode.expression = parseExpression(state, typeInfoNode)`

		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		expr = typeInfoNode

	-- Null value.
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"NULL") then
		expr = astNewNode(AstNull, exprStartToken, parentNode)

	-- Namespace.
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"namespace") then
		tokType, tokValue = eatNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '{'.")`
		end

		local namespace = astNewNode(AstNamespace, exprStartToken, parentNode)
		!DO_OR_RETURN `parseFileScopeOrNamespaceStatements(state, namespace, false, false)` -- Note: This should eat the ending '}'.

		expr = namespace

	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"_") then
		!ERROR_OR_RETURN `errorParsingLast(state, "Invalid place for a blank name.")`
	else
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected an expression.")`
	end

	-- Expressions involving several things next to each other.
	local nextCanBeMethodCall = false

	while true do
		tokType,  tokValue, token = peekNextToken(state, 1)
		tokType2, tokValue2       = peekNextToken(state, 2)

		local thisCanBeMethodCall = nextCanBeMethodCall
		nextCanBeMethodCall       = false

		if not tokType then
			break

		-- Left-associative binary operations.
		elseif
			(
				isToken(tokType,tokValue, !(TOKEN_KEYWORD),"and","or") or
				isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"+","-","*","/","//","%","<",">","<=",">=","==","~=")
			)
			and OPERATOR_PRECEDENCE[tokValue] > prevOpPrecedence
			and not (
				isToken(tokType, tokValue,  !(TOKEN_PUNCTUATION),"==") and
				isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"{")
			)
		then
			eatNextToken(state)

			local binary                 = astNewNode(AstBinary, token, parentNode)
			binary.operation             = tokValue
			binary.left                  = expr
			!SET_OR_RETURN `binary.right = parseExpression(state, binary, OPERATOR_PRECEDENCE[tokValue])`
			expr.parent                  = binary
			expr                         = binary

		-- Right-associative binary operations.
		-- @Incomplete: Combine string concatenations in some way?
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"^","..")
			and OPERATOR_PRECEDENCE[tokValue] > prevOpPrecedence
		then
			eatNextToken(state)

			local binary                 = astNewNode(AstBinary, token, parentNode)
			binary.operation             = tokValue
			binary.left                  = expr
			!SET_OR_RETURN `binary.right = parseExpression(state, binary, OPERATOR_PRECEDENCE[tokValue]-1)` -- The -1 makes this right-associative.
			expr.parent                  = binary
			expr                         = binary

		-- Lookup using '.'. (t.k is syntactic sugar for t["k"])
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),".")
			and !(OPERATOR_PRECEDENCE.access) > prevOpPrecedence
		then
			eatNextToken(state)

			local access = astNewNode(AstAccess, token, parentNode)

			tokType, tokValue, token = eatNextToken(state)
			if tokType ~= !(TOKEN_IDENTIFIER) then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected an identifier.")`
			end

			local literal       = astNewNode(AstLiteral, token, access)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = tokValue

			access.object       = expr
			access.member       = literal

			expr.parent         = access
			expr                = access

			nextCanBeMethodCall = true

		-- Lookup using '['.
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[")
			and !(OPERATOR_PRECEDENCE.access) > prevOpPrecedence
		then
			eatNextToken(state)

			local access                  = astNewNode(AstAccess, token, parentNode)
			access.object                 = expr
			!SET_OR_RETURN `access.member = parseExpression(state, access, OPERATOR_PRECEDENCE[tokValue])`

			tokType, tokValue = eatNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION), "]") then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected ']'.")`
			end

			expr.parent = access
			expr        = access

		-- Function call.
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
			and !(OPERATOR_PRECEDENCE.call) > prevOpPrecedence
		then
			!SET_OR_RETURN `expr = parseCall(state, parentNode, false, expr, false)`

		-- Method call.
		elseif
			(
				isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"!")
				and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"(")
			)
			and !(OPERATOR_PRECEDENCE.call) > prevOpPrecedence
		then
			tokType, tokValue = peekLastToken(state)

			if not isToken(tokType,tokValue, !(TOKEN_IDENTIFIER)) then
				!ERROR_OR_RETURN `errorParsingNext(state, "Expected a method name before this.")`
			elseif not thisCanBeMethodCall then
				putBackLastToken(state)
				!ERROR_OR_RETURN `errorParsingNext(state, "Expected an object to call a method on.")`
			end

			eatNextToken(state)
			!SET_OR_RETURN `expr = parseCall(state, parentNode, false, expr, true)`

		-- Compound type.
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"|")
			and !(OPERATOR_PRECEDENCE.compound) > prevOpPrecedence
		then
			eatNextToken(state)

			local typeNodeCompound = astNewNode(AstType, token, parentNode)
			typeNodeCompound.kind  = !(TYPE_KIND_COMPOUND)

			table.insert(typeNodeCompound.components, expr)

			while true do
				!SET_OR_RETURN `local typeExpr = parseExpression(state, parentNode, OPERATOR_PRECEDENCE.compound)`
				table.insert(typeNodeCompound.components, typeExpr)

				tokType, tokValue = peekNextToken(state)

				if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"|") then
					eatNextToken(state)
					tokType, tokValue = peekNextToken(state)
				else
					break
				end
			end

			expr.parent = typeNodeCompound
			expr        = typeNodeCompound

		-- Conditional.
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"?")
			and !(OPERATOR_PRECEDENCE.conditional) > prevOpPrecedence
		then
			eatNextToken(state)

			local conditional = astNewNode(AstConditional, token, parentNode)

			!SET_OR_RETURN `conditional.condition = expr`
			tokType, tokValue                     = peekNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
				conditional.conditionAndBranchTrue = conditional.condition
			else
				!SET_OR_RETURN `conditional.branchTrue = parseExpression(state, conditional, OPERATOR_PRECEDENCE.conditional-1)` -- The -1 makes this right-associative.
			end

			tokType, tokValue = eatNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected ':'.")`
			end

			!SET_OR_RETURN `conditional.branchFalse = parseExpression(state, conditional, OPERATOR_PRECEDENCE.conditional-1)` -- The -1 makes this right-associative.

			expr.parent = conditional
			expr        = conditional

		else
			break
		end
	end

	if expectLeftValue then
		if expr.nodeType == !(nodeTypes.AstIdentifier) then
			if encounteredParentheses then
				!ERROR_OR_RETURN `errorParsing(state, exprStartToken, "Unexpected parentheses around identifier.")` -- :ParenthesesAmbiguityError
			end
		elseif expr.nodeType == !(nodeTypes.AstAccess) then
			-- void
		else
			tokType, tokValue = peekNextToken(state)
			if isTokenAssigning(tokType, tokValue) then
				!ERROR_OR_RETURN `errorParsingAfterLast(state, "Expected an assignment target to the left of '%s'. Ambigous statement.", tokValue)`
			else
				!ERROR_OR_RETURN `errorParsing(state, exprStartToken, "Ambigous statement.")`
			end
		end
	end

	return expr
end



-- tokenType, tokenValue, tokenIndex = eatNextToken( compilationState )
function _G.eatNextToken(state)
	local i         = state.nextToken
	state.nextToken = i+1
	local tokType, tokValue = getToken(state.tokens, i)
	return tokType, tokValue, i
end

-- tokenType, tokenValue, tokenIndex = peekNextToken( compilationState [, steps=1 ] )
function _G.peekNextToken(state, steps)
	steps   = steps or 1
	local i = state.nextToken+steps-1
	local tokType, tokValue = getToken(state.tokens, i)
	return tokType, tokValue, i
end

function _G.peekLastToken(state)
	return getToken(state.tokens, state.nextToken-1)
end

function _G.putBackLastToken(state)
	state.nextToken = state.nextToken-1
	assert(state.nextToken >= 1)
end

function _G.eatTrailingSemicolon(state)
	local tokType, tokValue = peekNextToken(state)
	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),";") then
		eatNextToken(state)
	end
end



-- errorParsing( compilationState, tokenIndex, formatString, ... )
function _G.errorParsing(state, i, s, ...)
	local tokens = state.tokens

	local path
		=  tokens.file[i]
		or tokens.file[1] -- Not great, but better than crashing.
		or errorInternal("No tokens.")

	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)

	local ptr
		=  tokens.position1[i]
		or i <= 1 and 1
		or tokens.count > 0 and tokens.position2[tokens.count]+1
		or #buffer

	!TRACE(2)
	errorInFile(buffer, path, ptr, "Parser", s, ...)
end

-- parserMessage( [ outputFile=io.stdout, ] compilationState, token, label, formatString, ... )
function _G.parserMessage(file, state, token, label, s, ...)
	if type(file) ~= "userdata" then  return parserMessage(io.stdout, file, state, token, label, s, ...)  end

	local tokens = state.tokens
	local path   = tokens.file[token]      or errorInternal("No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	reportMessageInFile(file, buffer, path, tokens.position1[token], label, "Parser", s, ...)
end

-- parserMessageAfter( [ outputFile=io.stdout, ] compilationState, token, label, formatString, ... )
function _G.parserMessageAfter(file, state, token, label, s, ...)
	if type(file) ~= "userdata" then  return parserMessage(io.stdout, file, state, token, label, s, ...)  end

	local tokens = state.tokens
	local path   = tokens.file[token]      or errorInternal("No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	reportMessageInFile(file, buffer, path, tokens.position2[token]+1, label, "Parser", s, ...)
end

-- parserMessageLine( [ outputFile=io.stdout, ] compilationState, token, label, formatString, ... )
function _G.parserMessageLine(file, state, token, label, s, ...)
	if type(file) ~= "userdata" then  return parserMessageLine(io.stdout, file, state, token, label, s, ...)  end

	local tokens = state.tokens
	local path   = tokens.file[token] or errorInternal("No tokens.")

	-- Temp until tokens.line1 has useful values.
	local buffer     = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	local ptr        = tokens.position1[token]
	local _, nlCount = buffer:sub(1, ptr-1):gsub("\n", "%0")
	local ln         = nlCount+1

	reportMessageOnLine(file, path, ln, label, "Parser", s, ...)
	-- reportMessageOnLine(file, path, tokens.line1[token], label, "Parser", s, ...)
end

-- errorParsingAfter( compilationState, tokenIndex, formatString, ... )
function _G.errorParsingAfter(state, i, s, ...)
	local tokens = state.tokens

	local path
		=  tokens.file[i]
		or tokens.file[1] -- Not great, but better than crashing.
		or errorInternal("No tokens.")

	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)

	local ptr
		=  tokens.position2[i] and tokens.position2[i]+1
		or i <= 1 and 1
		or tokens.count > 0 and tokens.position2[tokens.count]+1
		or #buffer

	!TRACE(2)
	errorInFile(buffer, path, ptr, "Parser", s, ...)
end

function _G.errorParsingLast(state, ...)
	errorParsing(state, state.nextToken-1, ...)
end
function _G.errorParsingNext(state, ...)
	errorParsing(state, state.nextToken, ...)
end

function _G.errorParsingAfterPrevious(state, ...)
	errorParsingAfter(state, state.nextToken-2, ...)
end
function _G.errorParsingAfterLast(state, ...)
	errorParsingAfter(state, state.nextToken-1, ...)
end



function _G.errorUnhandledNodeType(state, node)
	!if DEBUG then
		printerr()
		astPrintTree(io.stderr, node)
		-- !ifDEBUG `astPrintTree(io.stderr, state.globalScope)`
	!end
	nodeError(state, node, "Debug", "Internal compiler error: Incomplete: Unhandled node type '%s'.", (AST_NODE_TYPE_NAMES[node.nodeType] or node.nodeType))
end

function _G.errorUnhandledType(state, node, typeInfo)
	!if DEBUG then
		printerr()
		astPrintTree(io.stderr, node)
	!end
	nodeError(state, node, "Debug", "Internal compiler error: Incomplete: Unhandled type '%s'.", getFriendlyTypeInfoName(typeInfo))
end



-- nodeError( compilationState, node, agent, formatString, ... )
function _G.nodeError(state, node, agent, s, ...)
	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal("No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	!TRACE(2)
	errorInFile(buffer, path, tokens.position1[token], agent, s, ...)
end

-- nodeErrorAfter( compilationState, node, agent, formatString, ... )
function _G.nodeErrorAfter(state, node, agent, s, ...)
	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal("No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	!TRACE(2)
	errorInFile(buffer, path, tokens.position2[token]+1, agent, s, ...)
end

-- nodeMessage( [ outputFile=io.stdout, ] compilationState, node, label, agent, formatString, ... )
function _G.nodeMessage(file, state, node, label, agent, s, ...)
	if type(file) ~= "userdata" then  return nodeMessage(io.stdout, file, state, node, label, agent, s, ...)  end

	local tokens = state.tokens
	local token  = node.token
	local path   = tokens.file[token]      or errorInternal("No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	reportMessageInFile(file, buffer, path, tokens.position1[token], label, agent, s, ...)
end

function _G.where(state, node)
	!ASSERT `node` -- I keep forgetting the state argument...
	nodeMessage(io.stdout, state, node, "Debug", nil, "Here!")
end



-- astPrint    ( [ outputFile=io.stdout, ] node )
-- astPrintTree( [ outputFile=io.stdout, ] node )
do
	local file
	local printNode -- Forward declaration.

	local function write(...)
		file:write(...)
	end

	local function printNodeList(list, indent, printed, printChildren, keyPrefix)
		for i, node in ipairs(list) do
			printNode(node, indent, printed, printChildren, (keyPrefix and keyPrefix..i))
		end
	end

	function printNode(node, indent, printed, printChildren, keyName)
		!local INDENT            = "    "
		!local CHILD_PRINT_START = "if not printChildren then write('\\n') else write('" .. (PRINT_NODE_BRACKETS and " {" or "") .. "\\n')"
		!local CHILD_PRINT_END   = (PRINT_NODE_BRACKETS and "write(indentStr, '}\\n') " or "") .. "end"

		local indentStr = (!(INDENT)):rep(indent)

		assert(node.s)

		write(indentStr)
		if keyName then  write(keyName, " ")  end
		write(AST_NODE_TYPE_NAMES[node.nodeType] or "?")
		write(" @", node.s)
		if node.parent then  write(" ^", node.parent.s)  end

		local queued = node.queued
		if not queued then
			-- void
		elseif queued.unqueued then
			write(" uq:", PIPE_TITLES[queued.pipe])
		else
			write(" p:", PIPE_TITLES[queued.pipe])
			local dependency = queued.waitingOn
			if dependency then
				write(" w:", DEPEND_TITLES[dependency.dependType])
				if !!(anyV(`dependency.dependType`, DEPEND_NODE_INFERRED,DEPEND_NODE_INFERRED_FULLY,DEPEND_NODE_EMITTED)) then
					write(":", dependency.dependOn.node.s)
				end
			end
		end

		if printed[node] then
			write("  !!! ERROR: RECURSION DETECTED !!!\n")
		else
			printed[node] = true

			if node.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = node
				write(" (", ident.name)
				if ident.inferredType then  write(", type=", getFriendlyTypeInfoName(ident.inferredType))  end
				if ident.inferredType and getTypeRepresentedByExpression(ident) then  write(", typeRepresented=", getFriendlyTypeInfoName(getTypeRepresentedByExpression(ident)))  end
				if ident.declaration  then  write(", decl=", ident.declaration.s)  end
				write(")\n")

			elseif node.nodeType == !(nodeTypes.AstUnary) then
				local unary = node
				write(" (", unary.operation, ")")
				!!(CHILD_PRINT_START)
				if unary.expression then  printNode(unary.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstBinary) then
				local binary = node
				write(" (", binary.operation, ")")
				!!(CHILD_PRINT_START)
				if binary.left  then  printNode(binary.left,  indent+1, printed, printChildren)  end
				write(indentStr, !(INDENT.."op "), binary.operation, "\n")
				if binary.right then  printNode(binary.right, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstAccess) then
				local access = node
				write(" (")
				write(
					access.object and access.object.inferredType and getFriendlyTypeInfoName(
						getTypeRepresentedByExpression(access.object)
						or access.object.inferredType
					)
					or "?"
				)
				write(".")
				write(
					access.member and (
						(access.member.nodeType == !(nodeTypes.AstLiteral) and tostring(access.member.value))
						or (access.inferredType and getFriendlyTypeInfoName(access.member.inferredType))
					)
					or "?"
				)
				write(")")
				!!(CHILD_PRINT_START)
				if access.object then  printNode(access.object, indent+1, printed, printChildren)  end
				if access.member then  printNode(access.member, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstDeclaration) then
				local decl = node
				if decl.addedByPolymorph then  write(" (addedByPolymorph)")  end
				if decl.assignment       then  write(" (assignment ", decl.assignment.s, " i=", decl.assignmentIndex, ")")  end
				write(" (", (DECL_KIND_TITLES[decl.kind] or "?"))
				if decl.valueTypeInfo    then  write(", typeRepresented=", getFriendlyTypeInfoName(decl.valueTypeInfo))  end
				write(")")

				!!(CHILD_PRINT_START)
				if decl.name  then  printNode(decl.name,  indent+1, printed, printChildren)           end
				if decl.type  then  printNode(decl.type,  indent+1, printed, printChildren, "TYPE")   end
				if decl.value then  printNode(decl.value, indent+1, printed, printChildren, "VALUE")  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstTable) then
				local tableNode = node
				!!(CHILD_PRINT_START)
				for i, tableField in ipairs(tableNode.fields) do
					if tableField.key   then  printNode(tableField.key,   indent+1, printed, printChildren, i.."K")  end
					if tableField.value then  printNode(tableField.value, indent+1, printed, printChildren, i.."V")  end
				end
				if tableNode.trailingExpression then  printNode(tableNode.trailingExpression, indent+1, printed, printChildren, "...")  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstCall) then
				local call = node
				assert(not (call.couldBeTypeWithParameters and call.isMethod))
				if call.couldBeTypeWithParameters then  write(" (couldBeType)")    end
				if call.isMethod                  then  write(" (method)")         end
				if call.surroundedByParentheses   then  write(" (adjustArgsTo1)")  end
				!!(CHILD_PRINT_START)
				if call.callee then  printNode(call.callee, indent+1, printed, printChildren)  end
				printNodeList(call.arguments, indent+1, printed, printChildren, "ARG")
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstArguments) then
				local args = node
				!!(CHILD_PRINT_START)
				printNodeList(args.arguments, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstArgument) then
				local arg = node
				if arg.autobake == !(AUTOBAKE_ENABLED)  then  write(" (autobake=may)")   end
				if arg.autobake == !(AUTOBAKE_REQUIRED) then  write(" (autobake=must)")  end
				!!(CHILD_PRINT_START)
				if arg.declaration then  printNode(arg.declaration, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstType) then
				local typeNode = node
				write(" (", TYPE_KIND_TITLES[typeNode.kind])
				if typeNode.representedType then
					write(", typeRepresented=", getFriendlyTypeInfoName(typeNode.representedType))
				elseif typeNode.typeName ~= "" then
					write(", name=", typeNode.typeName)
				end
				write(")")
				!!(CHILD_PRINT_START)
				if typeNode.kind == !(TYPE_KIND_FUNCTION) then
					if typeNode.functionHeader then  printNode(typeNode.functionHeader, indent+1, printed, printChildren)  end
				elseif typeNode.kind == !(TYPE_KIND_ARRAY) then
					if typeNode.arrayItemType then  printNode(typeNode.arrayItemType, indent+1, printed, printChildren)  end
				elseif typeNode.kind == !(TYPE_KIND_POLY_STRUCT) then
					if typeNode.arguments then  printNodeList(typeNode.arguments, indent+1, printed, printChildren)  end
				elseif typeNode.kind == !(TYPE_KIND_COMPOUND) then
					if typeNode.components then  printNodeList(typeNode.components, indent+1, printed, printChildren)  end
				end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstTypeOf) then
				local typeOf = node
				!!(CHILD_PRINT_START)
				if typeOf.expression then  printNode(typeOf.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstAssignment) then
				local assignment = node
				if assignment.forDeclaration then
					write(" (forDeclaration")
					for _, decl in ipairs(assignment.declarations) do
						write(" ", decl.s)
					end
					write(")")
				end
				if assignment.addedByPolymorph then  write(" (addedByPolymorph)")  end
				write(" (", assignment.binaryOperation, "=)")
				!!(CHILD_PRINT_START)
				printNodeList(assignment.targets, indent+1, printed, printChildren)
				write(indentStr, !(INDENT.."op "), assignment.binaryOperation, "=\n")
				printNodeList(assignment.values, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstCast) then
				local cast = node
				if cast.inferredType then  write(" (", getFriendlyTypeInfoName(cast.inferredType), ")")  end
				!!(CHILD_PRINT_START)
				if cast.targetType then  printNode(cast.targetType, indent+1, printed, printChildren)  end
				if cast.expression then  printNode(cast.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstIf) or node.nodeType == !(nodeTypes.AstStaticIf) then
				local ifBranch = node
				!!(CHILD_PRINT_START)
				if ifBranch.condition   then  printNode(ifBranch.condition,   indent+1, printed, printChildren)           end
				if ifBranch.branchTrue  then  printNode(ifBranch.branchTrue,  indent+1, printed, printChildren, "TRUE")   end
				if ifBranch.branchFalse then  printNode(ifBranch.branchFalse, indent+1, printed, printChildren, "FALSE")  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstConditional) then
				local conditional = node
				!!(CHILD_PRINT_START)
				if conditional.condition   then  printNode(conditional.condition,   indent+1, printed, printChildren)           end
				if conditional.branchTrue  then  printNode(conditional.branchTrue,  indent+1, printed, printChildren, "TRUE")   end
				if conditional.branchFalse then  printNode(conditional.branchFalse, indent+1, printed, printChildren, "FALSE")  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstWhile) then
				local whileLoop = node
				!!(CHILD_PRINT_START)
				if whileLoop.condition then  printNode(whileLoop.condition, indent+1, printed, printChildren)  end
				if whileLoop.body      then  printNode(whileLoop.body,      indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstFor) then
				local forLoop = node
				write(" (", FOR_TITLES[forLoop.forType])
				if forLoop.reverse then  write(", reverse")  end
				write(")")
				!!(CHILD_PRINT_START)
				printNodeList(forLoop.names,       indent+1, printed, printChildren, "NAME")
				printNodeList(forLoop.expressions, indent+1, printed, printChildren, "EXPR")
				if forLoop.body then  printNode(forLoop.body, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstReturn) then
				local returnNode = node
				if returnNode.runDirective then  write(" (runDirective ", returnNode.runDirective.s, ")")  end
				!!(CHILD_PRINT_START)
				printNodeList(returnNode.values, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif !!(anyV(`node.nodeType`, nodeTypes.AstBreak,nodeTypes.AstContinue)) then
				local breakOrContinue = node
				if breakOrContinue.loopName then  write(" (", breakOrContinue.loopName.name, ")")  end
				write("\n")

			elseif node.nodeType == !(nodeTypes.AstDefer) then
				local defer = node
				!!(CHILD_PRINT_START)
				if defer.body then  printNode(defer.body, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstImport) then
				local import = node
				write(" (", (import.isLoad and "load " or "import "), import.importName, ")")
				write("\n")

			elseif node.nodeType == !(nodeTypes.AstForeign) then
				local foreign = node
				if foreign.inferredType then  write(" (", getFriendlyTypeInfoName(foreign.inferredType), ")")  end
				write(" (", foreign.source, " ", foreign.sourceName, ")")
				write("\n")

			elseif node.nodeType == !(nodeTypes.AstUsing) then
				local using = node
				!!(CHILD_PRINT_START)
				if using.expression then  printNode(using.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstVararg) then
				local vararg = node
				if vararg.surroundedByParentheses then  write(" (adjustTo1)")  end
				write("\n")

			elseif node.nodeType == !(nodeTypes.AstGlobalScope) then
				local globalScope = node
				!!(CHILD_PRINT_START)
				printNodeList(globalScope.statements, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstDebug) then
				local debugNode = node
				!!(CHILD_PRINT_START)
				printNode(debugNode.expression, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstBake) then
				local bake = node
				!!(CHILD_PRINT_START)
				printNode(bake.name, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstRun) then
				local runNode = node
				!!(CHILD_PRINT_START)
				printNode(runNode.lambda, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstLiteral) then
				local literal = node
				write(" (")

				if !!(anyV(`literal.literalType`, LITERAL_BOOLEAN,LITERAL_NIL)) then
					write(tostring(literal.value))

				else
					!local MAX_CHARS = 100
					local vStr = tostring(literal.value):sub(1, !(MAX_CHARS))

					vStr = vStr:gsub(".", function(c)
						local byte = c:byte()
						return
							byte == !(("\n"):byte())   and "{NL}"  or
							byte == !(("\r"):byte())   and "{CR}"  or
							byte == !(("\t"):byte())   and "{TAB}" or
							byte >= 32 and byte <= 126 and c       or -- Printable ASCII characters.
							"?"
					end)

					write(LITERAL_TITLES[literal.literalType])

					if literal.literalType == !(LITERAL_STRING) then
						write("(", #literal.value, ")")
					end

					if vStr ~= "" then  write(": ", vStr:sub(1, !(MAX_CHARS)))  end
				end

				write(")\n")

			elseif node.nodeType == !(nodeTypes.AstSwitch) then
				local switch = node
				if switch.complete then  write(" (complete)")  end
				!!(CHILD_PRINT_START)
				if switch.value then  printNode(switch.value, indent+1, printed, printChildren)  end
				for _, case in ipairs(switch.cases) do
					if case.value then  printNode(case.value, indent+1, printed, printChildren)  end
					if case.body  then  printNode(case.body,  indent+1, printed, printChildren)  end
				end
				!!(CHILD_PRINT_END)

			elseif node.declarations then -- AstScope and substructs.
				if node.nodeType == !(nodeTypes.AstLambda) then
					local lambda     = node
					local assignment = astFindParent1(lambda, !(nodeTypes.AstAssignment))
					local i          = assignment and assignment.forDeclaration and indexOf(assignment.values, lambda)
					if lambda.isPolymorphic then  write(" (polymorphs=", #lambda.polymorphs, ")")  end
					if i                    then  write(" (", assignment.targets[i].name,     ")")  end

				elseif node.nodeType == !(nodeTypes.AstFileScope) then
					local fileScope = node
					write(" (", fileScope.path, ")")

				elseif !!(anyV(`node.nodeType`, nodeTypes.AstStruct,nodeTypes.AstEnum)) then
					local structOrEnum = node
					local typeInfo     = structOrEnum.representedType
					if typeInfo and typeInfo.name ~= "" then  write(" (", typeInfo.name, ")")  end
				end

				!!(CHILD_PRINT_START)
				if node.nodeType == !(nodeTypes.AstStruct) then
					if node.keyType   then  printNode(node.keyType,   indent+1, printed, printChildren, "K")  end
					if node.valueType then  printNode(node.valueType, indent+1, printed, printChildren, "V")  end
				end
				printNodeList(node.statements, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			else
				write("\n")
			end
		end
	end

	function _G.astPrintTree(_file, node)
		if type(_file) ~= "userdata" then  _file, node = io.stdout, _file  end
		file = _file
		printNode(node, 0, {}, true)
	end

	function _G.astPrint(_file, node)
		if type(_file) ~= "userdata" then  _file, node = io.stdout, _file  end
		file = _file
		printNode(node, 0, {}, false)
	end
end



-- parent, childClosestToParent = astFindParent ( node, parentNodeTypeSet )
-- parent, childClosestToParent = astFindParent1( node, parentNodeType    )
function _G.astFindParent(node, nodeTypeSet)
	local lastNode = node

	while true do
		node = node.parent
		if not node                   then  return nil,  nil       end
		if nodeTypeSet[node.nodeType] then  return node, lastNode  end

		lastNode = node
	end
end
function _G.astFindParent1(node, parentNodeType)
	local lastNode = node

	while true do
		node = node.parent
		if not node                        then  return nil,  nil       end
		if node.nodeType == parentNodeType then  return node, lastNode  end

		lastNode = node
	end
end
-- scope, statement = astFindParentScope( node )
function _G.astFindParentScope(node)
	local lastNode = node

	while true do
		node = node.parent
		if not node  then  return nil, nil end

		if !!(CONST_SET(scopeNodeTypes))[node.nodeType] then
			return node, lastNode
		end

		lastNode = node
	end
end

function _G.astFindCommonParent(node1, node2)
	while true do
		node1 = node1.parent
		if not node1                  then  return nil    end
		if astHasParent(node2, node1) then  return node1  end
	end
end

function _G.astHasParent(node, parent)
	while true do
		node = node.parent
		if not node       then  return false  end
		if node == parent then  return true   end
	end
end

-- node = astFindInTree( topNode, nodeType1, ... )
-- Note: The returned node may be topNode.
function _G.astFindInTree(topNode, ...)
	local nodeTypes    = {...}
	local nodeToReturn = nil

	astVisitAllNodes(topNode, function(node)
		if indexOf(nodeTypes, node.nodeType) then
			nodeToReturn = node
			return !(VISIT_BREAK)
		end
	end)

	return nodeToReturn
end



function _G.astIsOrIsInModule(node)
	local fileScope = (node.nodeType == !(nodeTypes.AstFileScope) and node or astFindParent1(node, !(nodeTypes.AstFileScope)))
	return fileScope ~= nil and fileScope.isModule
end



-- astVisitAllNodes           ( topNode, callback )
-- astVisitAllNodesLeavesFirst( topNode, callback )
-- astVisitAllNodesInUnit     ( topNode, visitLambdaNodes, callback )  -- Does not visit the contents of e.g. lambdas and types.
-- [ controlValue = ] callback( node, container, key )  -- Not return anything is the same as returning VISIT_CONTINUE.
-- controlValue = VISIT_CONTINUE|VISIT_BREAK|VISIT_IGNORE_CHILDREN
-- Note: VISIT_IGNORE_CHILDREN triggers an error in astVisitAllNodesLeavesFirst().
do
	local visit -- Forward declaraion.

	local VISITORS = {
		!(
		local TEMPLATE_FUNCTION_HEADER, TEMPLATE_FUNCTION_FOOTER = `
			[$nodeType--[[$name]]] = function(visited, cb, leavesFirst, node)
				`,`
			end,
		`

		local TEMPLATE_TRAVERSE_NODE_IF_SET = `
			if node.$field and visit(visited, cb, leavesFirst, node, "$field", node.$field) then  return true  end
		`
		local TEMPLATE_TRAVERSE_ARRAY = `
			local arr = node.$field
			for i, subNode in ipairs(arr) do
				if visit(visited, cb, leavesFirst, arr, i, subNode) then  return true  end
			end
		`
		local TEMPLATE_TRAVERSE_ARRAY_IF_SET = `
			local arr = node.$field
			if arr then
				for i, subNode in ipairs(arr) do
					if visit(visited, cb, leavesFirst, arr, i, subNode) then  return true  end
				end
			end
		`
		local TEMPLATE_TRAVERSE_FIELDS = `
			for _, tableField in ipairs(node.$field) do
				if tableField.key   and visit(visited, cb, leavesFirst, tableField, "key",   tableField.key  ) then  return true  end
				if tableField.value and visit(visited, cb, leavesFirst, tableField, "value", tableField.value) then  return true  end
			end
		`
		local TEMPLATE_TRAVERSE_CASES = `
			for _, case in ipairs(node.$field) do
				if case.value and visit(visited, cb, leavesFirst, case, "value", case.value) then  return true  end
				if case.body  and visit(visited, cb, leavesFirst, case, "body",  case.body ) then  return true  end
			end
		`

		for nodeType, name in ipairs(nodeTypeNames) do
			local fields = structs[name] or error(name)

			__LUA(templateToLua(TEMPLATE_FUNCTION_HEADER, {nodeType=nodeType, name=name}, (nodeType == 1 and -3 or -1)))

			for _, field in ipairs(fields) do
				local k = field[1]

				if field.ast == "node" then
					__LUA(templateToLua(TEMPLATE_TRAVERSE_NODE_IF_SET, {field=k}))

				elseif field.ast == "array" then
					if field[2] then
						__LUA(templateToLua(TEMPLATE_TRAVERSE_ARRAY, {field=k}))
					else
						__LUA(templateToLua(TEMPLATE_TRAVERSE_ARRAY_IF_SET, {field=k}))
					end

				elseif field.ast == "fields" then
					__LUA(templateToLua(TEMPLATE_TRAVERSE_FIELDS, {field=k}))

				elseif field.ast == "cases" then
					__LUA(templateToLua(TEMPLATE_TRAVERSE_CASES, {field=k}))

				elseif field.ast then
					error(field.ast)
				end
			end

			__LUA(templateToLua(TEMPLATE_FUNCTION_FOOTER, {}, -1))
		end
		)
	}

	function visit(visited, cb, leavesFirst, container, key, node)
		-- Note: We return true from this function if we want to break.

		if visited[node] then
			!ifDEBUG `astPrintTree(node)`
			errorInternal("Node already visited.")
		end
		visited[node] = true

		if not leavesFirst then
			local controlValue = cb(node, container, key) or !(VISIT_CONTINUE)
			if controlValue == !(VISIT_CONTINUE) then
				-- void
			elseif controlValue == !(VISIT_BREAK) then
				return true
			elseif controlValue == !(VISIT_IGNORE_CHILDREN) then
				return false
			end
		end

		local visitor = VISITORS[node.nodeType] or errorInternal(state, node)
		if visitor(visited, cb, leavesFirst, node) then  return true  end

		if leavesFirst then
			local controlValue = cb(node, container, key) or !(VISIT_CONTINUE)
			if controlValue == !(VISIT_CONTINUE) then
				-- void
			elseif controlValue == !(VISIT_BREAK) then
				return true
			elseif controlValue == !(VISIT_IGNORE_CHILDREN) then
				errorInternal("VISIT_IGNORE_CHILDREN does not work when visiting leaves first.")
			end
		end

		return false
	end

	function _G.astVisitAllNodes(node, cb)
		visit({}, cb, false, nil, nil, node)
	end

	function _G.astVisitAllNodesLeavesFirst(node, cb)
		visit({}, cb, true,  nil, nil, node)
	end

	function _G.astVisitAllNodesInUnit(topNode, visitLambdas, cb)
		astVisitAllNodes(topNode, function(node, container, key)
			local visitNode     = true
			local visitChildren = true

			if node.nodeType == !(nodeTypes.AstType) then
				visitChildren = false
			elseif node.nodeType == !(nodeTypes.AstLambda) then
				visitNode     = visitLambdas
				visitChildren = node == topNode
			end

			local controlValue = !(VISIT_CONTINUE)
			if visitNode then
				controlValue = cb(node, container, key) or !(VISIT_CONTINUE)
			end

			if visitChildren then
				return controlValue
			else
				return controlValue == !(VISIT_BREAK) and !(VISIT_BREAK) or !(VISIT_IGNORE_CHILDREN)
			end
		end)
	end
end



do
	local copyTree -- Forward declaraion.

	local COPIERS = {
		!(
		local TEMPLATE_FUNCTION_HEADER, TEMPLATE_FUNCTION_FOOTER = `
			[$nodeType--[[$name]]] = function(node, token, parent, copies)
				local copy   = astNewNode($name, (token or node.token), parent)
				copies[node] = copy
				`,`
				return copy
			end,
		`

		local TEMPLATE_COPY_VALUE = `
			copy.$field = node.$field
		`
		local TEMPLATE_COPY_VALUE_ARRAY = `
			copy.$field = {unpack(node.$field)}
		`
		local TEMPLATE_COPY_VALUE_ARRAY_IF_SET = `
			copy.$field = node.$field and {unpack(node.$field)}
		`
		local TEMPLATE_COPY_NODE_IF_SET = `
			copy.$field = node.$field and copyTree(node.$field, token, copy, copies)
		`
		local TEMPLATE_COPY_ARRAY = `
			local arrCopy = copy.$field
			for i, subNode in ipairs(node.$field) do
				arrCopy[i] = copyTree(subNode, token, copy, copies)
			end
		`
		local TEMPLATE_COPY_ARRAY_IF_SET = `
			if node.$field then
				local arrCopy = copy.$field or {}
				copy.$field   = arrCopy
				for i, subNode in ipairs(node.$field) do
					arrCopy[i] = copyTree(subNode, token, copy, copies)
				end
			end
		`
		local TEMPLATE_COPY_FIELDS = `
			local fieldsCopy = copy.$field

			for i, tableField in ipairs(node.$field) do
				local tableFieldCopy = TableField()
				tableFieldCopy.key   = tableField.key   and copyTree(tableField.key,   token, copy, copies)
				tableFieldCopy.value = tableField.value and copyTree(tableField.value, token, copy, copies)
				fieldsCopy[i]        = tableFieldCopy
			end
		`
		local TEMPLATE_COPY_CASES = `
			local casesCopy = copy.$field

			for i, case in ipairs(node.$field) do
				local caseCopy = SwitchCase()
				caseCopy.value = case.value and copyTree(case.value, token, copy, copies)
				caseCopy.body  = case.body  and copyTree(case.body,  token, copy, copies)
				casesCopy[i]   = caseCopy
			end
		`

		local fieldsToIgnore = {}
		for _, field in ipairs(structs._AstNode) do
			fieldsToIgnore[field[1]] = true
		end

		for nodeType, name in ipairs(nodeTypeNames) do
			local fields = structs[name] or error(name)

			__LUA(templateToLua(TEMPLATE_FUNCTION_HEADER, {nodeType=nodeType, name=name}, (nodeType == 1 and -3 or -1), -1))

			for _, field in ipairs(fields) do
				local k = field[1]

				if fieldsToIgnore[k] or field.doNotCopy then
					-- void

				elseif field.ast == "node" then
					__LUA(templateToLua(TEMPLATE_COPY_NODE_IF_SET, {field=k}))

				elseif field.ast == "array" then
					if field[2] then
						__LUA(templateToLua(TEMPLATE_COPY_ARRAY, {field=k}))
					else
						__LUA(templateToLua(TEMPLATE_COPY_ARRAY_IF_SET, {field=k}))
					end

				elseif field.ast == "fields" then
					__LUA(templateToLua(TEMPLATE_COPY_FIELDS, {field=k}))

				elseif field.ast == "cases" then
					__LUA(templateToLua(TEMPLATE_COPY_CASES, {field=k}))

				elseif field.ast then
					error(field.ast)

				else
					if field.astRef ~= "array" then
						__LUA(templateToLua(TEMPLATE_COPY_VALUE, {field=k}))
					elseif field[2] then
						__LUA(templateToLua(TEMPLATE_COPY_VALUE_ARRAY, {field=k}))
					else
						__LUA(templateToLua(TEMPLATE_COPY_VALUE_ARRAY_IF_SET, {field=k}))
					end
				end
			end

			__LUA(templateToLua(TEMPLATE_FUNCTION_FOOTER, {}, -1, -1))
		end
		)
	}

	function copyTree(node, token, parent, copies)
		!ASSERT `not copies[node]`
		local copier = COPIERS[node.nodeType] or errorInternal(state, node)
		return copier(node, token, (parent or node.parent), copies)
	end

	local FIXERS = {
		!(
		local TEMPLATE_FUNCTION_HEADER, TEMPLATE_FUNCTION_FOOTER = `
			[$nodeType--[[$name]]] = function(copy, copies)
				`,`
			end,
		`

		local TEMPLATE_FIX_NODE = `
			copy.$field = copies[copy.$field] or copy.$field
		`
		local TEMPLATE_FIX_ARRAY = `
			local arrCopy = copy.$field
			for i, subCopy in ipairs(arrCopy) do
				arrCopy[i] = copies[subCopy] or subCopy
			end
		`
		local TEMPLATE_FIX_ARRAY_IF_SET = `
			local arrCopy = copy.$field
			if arrCopy then
				for i, subCopy in ipairs(arrCopy) do
					arrCopy[i] = copies[subCopy] or subCopy
				end
			end
		`

		for nodeType, name in ipairs(nodeTypeNames) do
			local fields = structs[name] or error(name)

			__LUA(templateToLua(TEMPLATE_FUNCTION_HEADER, {nodeType=nodeType, name=name}, (nodeType == 1 and -3 or -1), -1))

			for _, field in ipairs(fields) do
				local k = field[1]

				if not field.astRef then
					-- void
				elseif field.astRef == "node" then
					__LUA(templateToLua(TEMPLATE_FIX_NODE, {field=k}))
				elseif field.astRef == "array" then
					if field[2] then
						__LUA(templateToLua(TEMPLATE_FIX_ARRAY, {field=k}))
					else
						__LUA(templateToLua(TEMPLATE_FIX_ARRAY_IF_SET, {field=k}))
					end
				else
					error(field.astRef)
				end
			end

			__LUA(templateToLua(TEMPLATE_FUNCTION_FOOTER, {}, -1, -1))
		end
		)
	}

	-- copy, copies = astCopy( node [, token=node.token, parent=node.parent ] )
	-- copies = { [node1]=copy1, ... }
	-- Note: Copies the whole tree. We also don't touch any queued.
	function _G.astCopy(node, token, parent)
		local copies = {}
		local copy   = copyTree(node, token, parent, copies)

		astVisitAllNodes(copy, function(copy)
			local fixer = FIXERS[copy.nodeType] or errorInternal(state, copy)
			fixer(copy, copies)
		end)

		return copy, copies
	end
end



-- expression = astGetExpressionVisuallyFurthestToTheLeft( expression [, onlyFollowCalls=false ] )
function _G.astGetExpressionVisuallyFurthestToTheLeft(expr, onlyFollowCalls)
	while expr.replacing do  expr = expr.replacing  end

	if expr.nodeType == !(nodeTypes.AstCall) then
		local call = expr
		return astGetExpressionVisuallyFurthestToTheLeft(call.callee, onlyFollowCalls)

	elseif onlyFollowCalls then
		return expr

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr
		return astGetExpressionVisuallyFurthestToTheLeft(binary.left, false)

	elseif expr.nodeType == !(nodeTypes.AstAccess) then
		local access = expr
		return astGetExpressionVisuallyFurthestToTheLeft(access.object, false)

	elseif expr.nodeType == !(nodeTypes.AstConditional) then
		local conditional = expr
		return astGetExpressionVisuallyFurthestToTheLeft(conditional.condition, false)

	else
		return expr
	end
end

-- expression = astGetExpressionVisuallyFurthestToTheRight( expression )
function _G.astGetExpressionVisuallyFurthestToTheRight(expr)
	while expr.replacing do  expr = expr.replacing  end

	if expr.nodeType == !(nodeTypes.AstCall) then
		local call = expr
		return call.arguments[1] and astGetExpressionVisuallyFurthestToTheRight(getLast(call.arguments)) or call

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr
		return astGetExpressionVisuallyFurthestToTheRight(binary.right)

	elseif expr.nodeType == !(nodeTypes.AstAccess) then
		local access = expr
		return astGetExpressionVisuallyFurthestToTheRight(access.member)

	elseif expr.nodeType == !(nodeTypes.AstReturn) then
		local returnNode = expr
		return returnNode.values[1] and astGetExpressionVisuallyFurthestToTheRight(getLast(returnNode.values)) or returnNode

	elseif expr.nodeType == !(nodeTypes.AstType) then
		local typeNode = expr
		return
			typeNode.functionHeader and astGetExpressionVisuallyFurthestToTheRight(typeNode.functionHeader)      or
			typeNode.arrayItemType  and astGetExpressionVisuallyFurthestToTheRight(typeNode.arrayItemType)       or
			typeNode.arguments      and astGetExpressionVisuallyFurthestToTheRight(getLast(typeNode.arguments))  or
			typeNode.components[1]  and astGetExpressionVisuallyFurthestToTheRight(getLast(typeNode.components)) or
			typeNode

	elseif expr.nodeType == !(nodeTypes.AstDeclaration) then
		local decl = expr
		return
			decl.assignment and astGetExpressionVisuallyFurthestToTheRight(decl.assignment) or
			decl.type       and astGetExpressionVisuallyFurthestToTheRight(decl.type)       or
			decl.name

	elseif expr.nodeType == !(nodeTypes.AstAssignment) then
		local assignment = expr
		return astGetExpressionVisuallyFurthestToTheRight(getLast(assignment.values))

	elseif expr.nodeType == !(nodeTypes.AstConditional) then
		local conditional = expr
		return astGetExpressionVisuallyFurthestToTheLeft(conditional.branchFalse, false)

	-- @Incomplete: Handle many more nodes...

	elseif expr.statements then
		local scope = expr
		return scope.statements[1] and astGetExpressionVisuallyFurthestToTheRight(getLast(scope.statements)) or scope

	else
		return expr
	end
end

-- expression = astGetCalleeVisuallyFurthestToTheLeft( call )
function _G.astGetCalleeVisuallyFurthestToTheLeft(call)
	return astGetExpressionVisuallyFurthestToTheLeft(call, true)
end



function _G.astGetDepth(node)
	local depth = 1
	node        = node.parent

	while node do
		node  = node.parent
		depth = depth+1
	end

	return depth
end



-- isNodeAt( state, node, filePath [, lineNumber=any ] )
function _G.isNodeAt(state, node, targetPath, targetLn)
	local token  = node.token
	local tokens = state.tokens
	local path   = tokens.file[token] or errorInternal("No tokens.")

	if path ~= targetPath then  return false  end
	if not targetLn       then  return true  end

	-- Temp until tokens.line1 has useful values.
	local buffer     = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	local ptr        = tokens.position1[token]
	local _, nlCount = buffer:sub(1, ptr-1):gsub("\n", "%0")
	local ln         = nlCount+1

	return ln == targetLn
end



function _G.isLiteral(node, literalType)
	return node.nodeType == !(nodeTypes.AstLiteral) and node.literalType == literalType
end



-- literal = newLiteral( parent, token, literalType, value [, typeInfo ] )
function _G.newLiteral(parent, token, literalType, value, typeInfo)
	local literal        = astNewNode(AstLiteral, token, parent)
	literal.literalType  = literalType
	literal.value        = value
	literal.inferredType = typeInfo
	return literal
end



function _G.astGetOriginal(node)
	while node.replacing do
		node = node.replacing
	end
	return node
end

function _G.astGetReplacement(node)
	while node.replacedBy do
		node = node.replacedBy
	end
	return node
end


