--[[============================================================
--=
--=  Parser
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	errorParsing*
	parse*
	printAst

--============================================================]]

!(
local PRINT_NODE_BRACKETS = false

local function ERROR_OR_RETURN(errCode)
	__LUA("if state.soft then return nil end ")
	__LUA(errCode,"")
end

local function SET_OR_RETURN(assignmentCode)
	local preCode, sufCode = assignmentCode:match"^([^=]+)=(.*)$"
	if not preCode then  error(assignmentCode)  end

	__LUA("local __value__ = ",sufCode)
	__LUA(" if not __value__ then return nil end ")
	__LUA(preCode," = __value__")
end

local function DO_OR_RETURN(exprCode)
	__LUA("if not (",exprCode,") then return nil end")
end
)



_G.!struct"ParseState"{
	fileBuffers = {},
	tokens      = {},
	nextToken   = 1,
	soft        = false, -- Enabling this will make parsing functions return nil on error instead of triggering an actual error.
}



!(
_G.nodeTypes        = {}
local nodeTypeN     = 0
local nodeTypeNames = {}

local function structAst(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			nodeTypeN         = nodeTypeN+1
			fields._overrides = {nodeType=nodeTypeN}

			nodeTypeNames[nodeTypeN] = name
			nodeTypes[name]          = nodeTypeN
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_AstNode"{
	nodeType = 0,
	s        = 0, -- Serial number.
	parent   = NIL,
	token    = 1,
}

local !structAst"AstType:_AstNode"{
	isPlaceholder     = false,
	typeName          = "",
	functionSignature = NIL, -- AstLambda without a body.
	arguments         = NIL, -- []AstExpression (Is set for parameterized structs.)
}

!structAst"_AstExpression:_AstNode"{
}
local !structAst"AstIdentifier:_AstExpression"{
	name          = "",
	declarationId = 0,
}
local !structAst"AstLiteral:_AstExpression"{
	literalType = 0,
	value       = NIL, -- The value depends on what literalType is. Could be a number, string or whatever.
}
local !structAst"AstUnary:_AstExpression"{
	operation  = "",
	expression = NIL,
}
local !structAst"AstBinary:_AstExpression"{
	operation = "",
	left      = NIL,
	right     = NIL,
}
local !structAst"AstTable:_AstExpression"{
	-- [1]=field1, ...
}
local !structAst"AstCall:_AstExpression"{
	couldBeTypeWithParameters = false,
	isMethod                  = false,
	surroundedByParenthesis   = false,
	callee                    = NIL, -- AstExpression
	arguments                 = {},  -- []AstExpression
}
local !structAst"AstArgument:_AstNode"{
	name          = NIL, -- AstIdentifier
	argumentTypes = {},  -- []AstType
	defaultValue  = NIL,
	autobake      = 0,   -- 0=disabled, 1=enabled, 2=required  @Incomplete

	-- For an in arg, this indicates optionality.
	-- For an out arg, if there's a !must then it must not be adjusted away by the caller.
	isRequired    = false,
}
local !structAst"AstArguments:_AstExpression"{ -- @Cleanup: Move this into an array in the parent (like expression lists).
	-- [1]=argument1, ...
}
local !structAst"AstLambda:_AstExpression"{
	argumentsIn  = NIL, -- AstArguments
	argumentsOut = NIL, -- AstArguments
	body         = NIL, -- AstBlock (If this is nil then the lambda is a function signature.)
}
local !structAst"AstTypeOf:_AstExpression"{
	expression = NIL,
}
local !structAst"AstCast:_AstExpression"{
	targetType = NIL, -- AstType
	expression = NIL,
}

local !structAst"AstStatement:_AstNode"{ -- Needed? I think so?
	what = NIL,
}

local !structAst"AstDeclaration:_AstNode"{
	names      = {},
	isLocal    = true,
	valueTypes = {},  -- No value here means the type is inferred.
	values     = {},  -- Nil for the corresponding name means default value, which depends on the value type.
	isConstant = false,
	tags       = {},  -- @Incomplete
}

local !structAst"AstAssignment:_AstNode"{
	operation = "",
	targets   = {}, -- []AstExpression
	values    = {}, -- []AstExpression
}

!structAst"_AstControlStructure:_AstNode"{
}
local !structAst"AstIf:_AstControlStructure"{
	condition   = NIL,
	branchTrue  = NIL,
	branchFalse = NIL,
}
local !structAst"AstWhile:_AstControlStructure"{
	condition = NIL,
	body      = NIL,
}
local !structAst"AstFor:_AstControlStructure"{
	forType     = FOR_TYPE_NUMERIC,
	names       = {},
	expressions = {}, -- []AstExpression
	body        = NIL,
}

local !structAst"AstBlock:_AstNode"{
	-- [1]=statement1, ...
}

!structAst"_AstDeclarativeScope:_AstNode"{
	declarations = {},
}
local !structAst"AstFileScope:_AstDeclarativeScope"{
	path = "",
}

_G.AST_NODE_TYPE_NAMES = !(nodeTypeNames)



local !struct"TableField"{
	key   = NIL,
	value = NIL,
}



local TOKEN_TYPE_TO_LITERAL_TYPE = !({
	[TOKEN_TYPE_NUMBER]  = LITERAL_TYPE_NUMBER,
	[TOKEN_TYPE_INTEGER] = LITERAL_TYPE_INTEGER,
	[TOKEN_TYPE_STRING]  = LITERAL_TYPE_STRING,
})



-- node:AstNodeType = astNewNode( state, AstNodeType [, parentNode ] )
do
	local serialN = 0

	function _G.astNewNode(state, AstNodeType, parentNode)
		if not AstNodeType then  error("No AstNodeType specified.", 2)  end

		serialN = serialN+1

		local node  = AstNodeType()
		node.s      = serialN
		node.parent = parentNode
		node.token  = state.nextToken-1 -- This ain't working too well. @FixMe

		--[[
		if
			false
			-- or serialN == 22
			or parentNode and parentNode.s == 21
		then
			-- errorParsingLast(state, "DEBUG")
			error("DEBUG")
		end
		--]]

		return node
	end
end



function _G.parseIdentifier(state, parentNode)
	local tokType, tokValue = consumeNextToken(state)
	if tokType ~= !(TOKEN_TYPE_IDENTIFIER) then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected an identifier.")`
	end

	local ident = astNewNode(state, AstIdentifier, parentNode)
	ident.name  = tokValue

	return ident
end

function _G.parseType(state, parentNode)
	local tokType, tokValue = consumeNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"typeOf") then
		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '('.")`
		end

		local typeOf                      = astNewNode(state, AstTypeOf, parentNode)
		!SET_OR_RETURN `typeOf.expression = parseExpression(state, typeOf)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		return typeOf

	elseif isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"[") then
		local tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"]") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ']'.")`
		end

		local literal                 = astNewNode(state, AstLiteral, parentNode)
		literal.literalType           = !(LITERAL_TYPE_ARRAY)
		!SET_OR_RETURN `literal.value = parseType(state, literal)` -- Not sure if it's good that literal.value can be an AstNode along other literals.

		return literal
	end

	local isBuiltinType = isTokenBuiltinType(tokType, tokValue)
	local identType

	if isBuiltinType or tokType == !(TOKEN_TYPE_IDENTIFIER) then
		identType               = astNewNode(state, AstType, parentNode)
		identType.isPlaceholder = not isBuiltinType
		identType.typeName      = tokValue
	else
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected a type.")`
	end

	-- User type parameters.
	tokType2, tokValue2 = peekNextToken(state)

	if isToken(tokType2,tokValue2, !(TOKEN_TYPE_PUNCTUATION),"(") then
		consumeNextToken(state)

		if isBuiltinType then
			!ERROR_OR_RETURN `errorParsingLast(state, "Built-in types have no parameters.")`
		end

		identType.arguments = {}
		!DO_OR_RETURN `parseExpressionList(state, identType, identType.arguments)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end
	end

	return identType
end

-- success = parsePipeSeparatedTypes( state, parentNode, identifierTypes )
function _G.parsePipeSeparatedTypes(state, parentNode, identTypes)
	while true do
		local identType = parseType(state, parentNode)
		if not identType then  return false  end

		table.insert(identTypes, identType)
		local tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"|") then
			consumeNextToken(state)
			tokType, tokValue = peekNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"nil") then
				consumeNextToken(state)

				local identType    = astNewNode(state, AstType, parentNode)
				identType.typeName = "nil"

				table.insert(identTypes, identType)
				break

			else
				-- Continue the loop.
			end

		else
			break
		end
	end

	return true
end

function _G.parseTable(state, parentNode)
	-- Note: We assume the '{' has been consumed already.

	local tableStartIndex = state.nextToken
	local tableNode       = astNewNode(state, AstTable, parentNode)
	local listIndex       = 0

	while true do
		local tokType, tokValue = peekNextToken(state)

		if not tokType then
			!ERROR_OR_RETURN `errorParsing(state, tableStartIndex, "Unfinished table.")`
		elseif isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"}") then
			consumeNextToken(state)
			break
		end

		local tokType2, tokValue2 = peekNextToken(state, 2)
		local tableField          = TableField()
		local tableKey

		-- [k]=v
		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"[") then
			consumeNextToken(state)

			!SET_OR_RETURN `tableKey = parseExpression(state, tableNode)`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"]") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ']'.")`
			end

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"=") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '='.")`
			end

		-- k=v
		elseif
			tokType == !(TOKEN_TYPE_IDENTIFIER)
			and isToken(tokType2,tokValue2, !(TOKEN_TYPE_PUNCTUATION),"=")
		then
			consumeNextToken(state)
			local literal       = astNewNode(state, AstLiteral, tableNode)
			literal.literalType = !(LITERAL_TYPE_STRING)
			literal.value       = tokValue
			tableKey            = literal
			consumeNextToken(state) -- The equal sign.

		-- v
		elseif
			tokType == !(TOKEN_TYPE_IDENTIFIER)
			or isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"(")
			or isTokenLiteral(tokType, tokValue)
		then
			listIndex           = listIndex+1
			local literal       = astNewNode(state, AstLiteral, tableNode)
			literal.literalType = !(LITERAL_TYPE_INTEGER)
			literal.value       = listIndex
			tableKey            = literal

		else
			!ERROR_OR_RETURN `errorParsingNext(state, "Expected a table field.")`
		end

		assert(tableKey)

		tableField.key                   = tableKey
		!SET_OR_RETURN `tableField.value = parseExpression(state, tableNode)`

		table.insert(tableNode, tableField)

		tokType, tokValue = consumeNextToken(state)
		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"}") then
			break
		elseif isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),",",";") then
			-- void
			-- Note: A trailing comma or semicolon at the end of the arg list is permitted.
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ','.")`
		end
	end

	return tableNode
end

-- Parse comma-separated expressions. Used for function calls and struct parameters.
-- success = parseExpressionList( state, parentNode, expressions )
function _G.parseExpressionList(state, parentNode, expressions)
	while true do
		local expr = parseExpression(state, parentNode)
		if not expr then  return false  end
		table.insert(expressions, expr)

		local tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),",") then
			consumeNextToken(state)
			-- Continue the loop.
		else
			break
		end
	end

	return true
end

function _G.parseArguments(state, parentNode, isInput)
	local argsStartIndex = state.nextToken
	local args           = astNewNode(state, AstArguments, parentNode)

	local tokType, tokValue

	while true do
		-- Argument name(s).
		local argGroup = {}

		while true do
			tokType, tokValue = consumeNextToken(state)
			if tokType ~= !(TOKEN_TYPE_IDENTIFIER) then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected an identifier.")`
			end

			local arg   = astNewNode(state, AstArgument,   args)
			local ident = astNewNode(state, AstIdentifier, arg)
			ident.name  = tokValue
			arg.name    = ident

			table.insert(args,     arg)
			table.insert(argGroup, arg)

			tokType, tokValue = consumeNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),":") then
				break
			elseif isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),",") then
				-- Continue the loop.
			else
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ':'.")`
			end
		end

		-- Type(s).
		local tokIndex = state.nextToken
		for _, arg in ipairs(argGroup) do
			state.nextToken = tokIndex
			!DO_OR_RETURN `parsePipeSeparatedTypes(state, arg, arg.argumentTypes)` -- @Speed: Parse once then just copy the first one.
		end

		-- Default value.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"=") then
			consumeNextToken(state)
			if not isInput then
				!ERROR_OR_RETURN `errorParsingLast(state, "Output arguments cannot have default values.")`
			end

			local tokIndex = state.nextToken
			for _, arg in ipairs(argGroup) do
				state.nextToken            = tokIndex
				!SET_OR_RETURN `local expr = parseExpression(state, arg)` -- @Speed: Parse once then just copy the first one.
				arg.defaultValue           = expr

				-- If the value is nil then we make sure 'nil' is one of the types.
				if
					expr.nodeType == !(nodeTypes.AstLiteral)
					and expr.literalType == !(LITERAL_TYPE_NIL)
					and not itemWith1(arg.argumentTypes, "typeName", "nil")
				then
					local identType    = astNewNode(state, AstType, arg)
					identType.typeName = "nil"
					table.insert(arg.argumentTypes, identType)
				end
			end
		end

		-- @Incomplete: Set arg.isRequired.
		-- if isInput then
		-- 	arg.isRequired = (arg.defaultValue == nil)
		-- else
		-- 	-- @Incomplete: Set arg.isRequired if there's a !must somewhere closeby.
		-- end

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),",") then
			consumeNextToken(state)
			-- Continue the loop.
		else
			break
		end
	end

	return args
end

function _G.parseDeclaration(state, parentNode)
	--[[
	local a = 0         -- Variable, inferred type.
	local b:number = 0  -- Variable, explicit type.
	local c:number      -- Variable, getting a default value.
	local A :: 0        -- Constant, inferred type.
	local B:number : 0  -- Constant, explicit type.
	local a,b,c = 0,f() -- Multiples always have either inferred or the same type.  @Incomplete: Store arrays of names and values.
	local a,b:int : 1,2
	]]

	local decl = astNewNode(state, AstDeclaration, parentNode)

	local tokType, tokValue = consumeNextToken(state)
	if not isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"local","global") then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected 'local'.")`
	end
	decl.isLocal = (tokValue == "local")

	!DO_OR_RETURN `parseNameList(state, decl, decl.names)`

	local typesStartToken = state.nextToken -- Dummy position, kinda.
	tokType, tokValue = peekNextToken(state)

	-- Type is specified and/or we have a constant.
	if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),":") then
		consumeNextToken(state)

		typesStartToken   = state.nextToken
		tokType, tokValue = peekNextToken(state)

		-- Inferred type.
		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),":") then
			-- void

			-- @Robustness: Mark the declaration to have it's type inferred instead of just
			-- leaving decl.valueTypes empty? Or should we have an AstTypeInferred node?

		-- Specified type.
		else
			!DO_OR_RETURN `parsePipeSeparatedTypes(state, decl, decl.valueTypes)`
		end

	-- We must have = or : after the identifier, for specified or inferred type.
	elseif not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"=") then
		!ERROR_OR_RETURN `errorParsingAfterLast(state, "Expected ':' or '='.")`
	end

	-- Values.
	local valueListStartToken = state.nextToken -- Dummy position, kinda.
	tokType, tokValue         = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"=",":") then
		consumeNextToken(state)

		if tokValue == ":" then
			decl.isConstant = true

			if decl.valueTypes[2] then
				-- Navigate back to the actual error position.
				state.nextToken = typesStartToken
				parseType(state)
				!ERROR_OR_RETURN `errorParsingNext(state, "Constants can only be of one type.")`
			end
		end

		valueListStartToken = state.nextToken
		!DO_OR_RETURN `parseExpressionList(state, decl, decl.values)`

	elseif decl.valueTypes[2] then
		!ERROR_OR_RETURN `errorParsingAfterLast(state, "Initial values are required if multiple types are specified.")`
	end

	-- Quickly check if there are obviously too many values.
	if #decl.values > #decl.names then
		-- Navigate back to the actual error position.
		state.nextToken = valueListStartToken
		parseExpression(state)
		for i = 1, #decl.names-1 do
			consumeNextToken(state) -- ","
			parseExpression(state)
		end
		!ERROR_OR_RETURN `errorParsingNext(state, "There are more values than names being declared.")`
	end

	return decl
end

local function isAtAssignment(state)
	local startIndex = state.nextToken

	state.soft       = true
	local exprListOk = parseExpressionList(state, nil, {})
	state.soft       = false

	if not exprListOk then
		state.nextToken = startIndex
		return false
	end

	local tokType, tokValue = consumeNextToken(state)
	if not isTokenAssigning(tokType, tokValue) then
		state.nextToken = startIndex
		return false
	end

	state.nextToken = startIndex
	return true
end

function _G.parseAssignment(state, parentNode)
	local assignmentStartToken = state.nextToken
	local assignment           = astNewNode(state, AstAssignment, parentNode)

	!DO_OR_RETURN `parseExpressionList(state, assignment, assignment.targets)`

	for i, expr in ipairs(assignment.targets) do
		if not (
			expr.nodeType == !(nodeTypes.AstIdentifier)
			or (expr.nodeType == !(nodeTypes.AstBinary) and expr.operation == ".")
		) then
			-- Navigate back to the actual error position.
			state.nextToken = assignmentStartToken
			for i = 1, i-1 do
				parseExpression(state)
				consumeNextToken(state) -- ","
			end
			!ERROR_OR_RETURN `errorParsingNext(state, "Expected assignment expression to resolve into a variable or table field.")`
		end
	end

	local tokType, tokValue = consumeNextToken(state)
	if not isTokenAssigning(tokType, tokValue) then
		!ERROR_OR_RETURN `errorParsingNext(state, "Expected '='.")`
	end

	assignment.operation = tokValue

	local valueListStartToken = state.nextToken
	!DO_OR_RETURN `parseExpressionList(state, assignment, assignment.values)`

	-- Quickly check if there are obviously too many values.
	if #assignment.values > #assignment.targets then
		-- Navigate back to the actual error position.
		state.nextToken = valueListStartToken
		parseExpression(state)
		for i = 1, #assignment.targets-1 do
			consumeNextToken(state) -- ","
			parseExpression(state)
		end
		!ERROR_OR_RETURN `errorParsingNext(state, "There are more values than assignment targets.")`
	end

	return assignment
end

-- Add the names to the 'names' array.
-- success = parseNameList( state, parentNode, names )
function _G.parseNameList(state, parentNode, names)
	while true do
		local ident = parseIdentifier(state, parentNode)
		if not ident then  return false  end

		table.insert(names, ident)
		local tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),",") then
			consumeNextToken(state)
			-- Continue the loop.
		else
			break
		end
	end

	return true
end

function _G.parseStatementInImperativeScope(state, block)
	local statementStartIndex = state.nextToken
	local statement           = astNewNode(state, AstStatement, block)

	local tokType,  tokValue  = peekNextToken(state, 1)
	local tokType2, tokValue2 = peekNextToken(state, 2)
	local tokType3, tokValue3 = peekNextToken(state, 3)
	local tokType4, tokValue4 = peekNextToken(state, 4)

	if isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"local","global") then
		!SET_OR_RETURN `statement.what = parseDeclaration(state, statement)`

	elseif isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"return") then
		!ERROR_OR_RETURN `errorParsingNext(state, "@Incomplete: return")`

	elseif isAtAssignment(state) then
		!SET_OR_RETURN `statement.what = parseAssignment(state, statement)`

	elseif tokType == !(TOKEN_TYPE_IDENTIFIER) and (
			isToken(tokType2,tokValue2, !(TOKEN_TYPE_PUNCTUATION),"(")
			-- or isToken(tokType2,tokValue2, !(TOKEN_TYPE_PUNCTUATION),"{")
			-- or tokType2 == !(TOKEN_TYPE_STRING)
		)
	then
		!SET_OR_RETURN `statement.what = parseCall(state, statement, false)`

	elseif isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"if") and (
		isToken(tokType2,tokValue2, !(TOKEN_TYPE_DIRECTIVE),"complete")
		or (
			isToken(tokType2,tokValue2, !(TOKEN_TYPE_IDENTIFIER))
			and isToken(tokType3,tokValue3, !(TOKEN_TYPE_PUNCTUATION),"==")
			and isToken(tokType4,tokValue4, !(TOKEN_TYPE_PUNCTUATION),"{")
		)
	) then
		!ERROR_OR_RETURN `errorParsingNext(state, "@Incomplete: if x == {case...}")`

	elseif isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"if") then
		consumeNextToken(state)

		local ifBranch                      = astNewNode(state, AstIf, statement)
		!SET_OR_RETURN `ifBranch.condition  = parseExpression(state, ifBranch)`
		!SET_OR_RETURN `ifBranch.branchTrue = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, ifBranch)`
		statement.what                      = ifBranch

		while true do
			tokType, tokValue = peekNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"elseif") then
				consumeNextToken(state)
				-- Continue.
			else
				break
			end

			local ifBranchElse                      = astNewNode(state, AstIf, ifBranch)
			!SET_OR_RETURN `ifBranchElse.condition  = parseExpression(state, ifBranchElse)`
			!SET_OR_RETURN `ifBranchElse.branchTrue = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, ifBranchElse)`

			ifBranch.branchFalse = ifBranchElse
			ifBranch             = ifBranchElse
		end

		if isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"else") then
			consumeNextToken(state)
			!SET_OR_RETURN `ifBranch.branchFalse = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, ifBranch)`
		end

	elseif isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"while") then
		consumeNextToken(state)

		local whileLoop                     = astNewNode(state, AstWhile, statement)
		!SET_OR_RETURN `whileLoop.condition = parseExpression(state, whileLoop)`
		!SET_OR_RETURN `whileLoop.body      = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, whileLoop)`
		statement.what                      = whileLoop

	elseif isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"for") then
		consumeNextToken(state)

		local forStartIndex = state.nextToken
		local forLoop       = astNewNode(state, AstFor, statement)

		local exprListWeMayOrMayNotUse = {}
		!DO_OR_RETURN `parseExpressionList(state, forLoop, exprListWeMayOrMayNotUse)`

		tokType, tokValue = peekNextToken(state)
		local twoParter

		-- FOR_TYPE_ITERATOR  for v1, ... in iter [, state [, init ] ]
		if isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"in") then
			forLoop.forType = !(FOR_TYPE_ITERATOR)
		-- FOR_TYPE_SHORT  for v1, ... : obj
		elseif isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),":") then
			forLoop.forType = !(FOR_TYPE_SHORT)
			twoParter       = true
		-- FOR_TYPE_NUMERIC  for start, end [, step ]
		elseif #exprListWeMayOrMayNotUse >= 2 then -- If more than 3 arguments are specified then we'll get an error later.
			forLoop.forType = !(FOR_TYPE_NUMERIC)
			twoParter       = false
		-- FOR_TYPE_NUMERIC  for i = start, end [, step ]
		elseif #exprListWeMayOrMayNotUse == 1 and isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"=") then
			forLoop.forType = !(FOR_TYPE_NUMERIC)
			twoParter       = true
		-- FOR_TYPE_SHORT  for obj
		elseif #exprListWeMayOrMayNotUse == 1 then
			forLoop.forType = !(FOR_TYPE_SHORT)
			twoParter       = false
		else
			state.nextToken = forStartIndex
			!ERROR_OR_RETURN `errorParsingNext(state, "Could not determine what kind of 'for' statement this is.")`
		end

		if forLoop.forType == !(FOR_TYPE_NUMERIC) then
			local paramStartIndex

			-- for i = start, end [, step ]
			if twoParter then
				state.nextToken = forStartIndex
				!DO_OR_RETURN `parseNameList(state, forLoop, forLoop.names)`

				assert(#forLoop.names == 1)

				tokType, tokValue = consumeNextToken(state) -- Should eat the '='.
				assert(isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"="))

				paramStartIndex = state.nextToken
				!DO_OR_RETURN `parseExpressionList(state, forLoop, forLoop.expressions)`

			-- for start, end [, step ]
			else
				paramStartIndex     = state.nextToken
				forLoop.expressions = exprListWeMayOrMayNotUse

				-- Is this name generation really necessay? For the other 'for' loop paths we don't generate names (yet).
				local ident = astNewNode(state, AstIdentifier, forLoop)
				ident.name  = "it"
				table.insert(forLoop.names, ident)
			end

			if #forLoop.expressions < 2 then
				!ERROR_OR_RETURN `errorParsingAfterLast(state, "Expected 2 or 3 parameters for the numeric 'for' loop.")`

			elseif #forLoop.expressions > 3 then
				-- Navigate back to the actual error position.
				state.nextToken = paramStartIndex
				tokType, tokValue = parseExpression(state)
				consumeNextToken(state) -- ','
				tokType, tokValue = parseExpression(state)
				consumeNextToken(state) -- ','
				tokType, tokValue = parseExpression(state)

				!ERROR_OR_RETURN `errorParsingNext(state, "Expected 2 or 3 parameters for the numeric 'for' loop.")`
			end

		elseif forLoop.forType == !(FOR_TYPE_SHORT) then
			-- for v1, ... : obj
			if twoParter then
				state.nextToken = forStartIndex
				!DO_OR_RETURN `parseNameList(state, forLoop, forLoop.names)`

				tokType, tokValue = consumeNextToken(state) -- Should eat the ':'.
				assert(isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),":"))

				local exprListStartIndex = state.nextToken
				!DO_OR_RETURN `parseExpressionList(state, forLoop, forLoop.expressions)`

				if forLoop.expressions[2] then
					-- Navigate back to the actual error position.
					state.nextToken = exprListStartIndex
					parseExpression(state)
					!ERROR_OR_RETURN `errorParsingNext(state, "Expected a single parameter for the short-form 'for' loop.")`
				end

				-- @Incomplete: Generate 'itIndex' name for arrays (and more?) if necessary (when types are figured out).

			-- for obj
			else
				forLoop.expressions = exprListWeMayOrMayNotUse
				assert(#forLoop.expressions == 1)

				-- @Incomplete: Generate 'it' and 'itIndex' names for arrays (and more?) if necessary (when types are figured out).
			end

		-- for v1, ... in iter [, state [, init ] ]
		else
			state.nextToken = forStartIndex
			!DO_OR_RETURN `parseNameList(state, forLoop, forLoop.names)`

			tokType, tokValue = consumeNextToken(state) -- Should eat the 'in'.
			assert(isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"in"))

			!DO_OR_RETURN `parseExpressionList(state, forLoop, forLoop.expressions)`
		end

		!SET_OR_RETURN `forLoop.body = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, forLoop, true)`
		statement.what               = forLoop

	-- Table lookup ending in a function call.
	-- Note: We must detect assignments before this!
	elseif
		(
			tokType == !(TOKEN_TYPE_IDENTIFIER)
			and isToken(tokType2,tokValue2, !(TOKEN_TYPE_PUNCTUATION),".")
		)
		or isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"(")
	then
		!SET_OR_RETURN `local expr = parseExpression(state, statement)`

		if not (expr.nodeType == !(nodeTypes.AstCall)) then
			!ERROR_OR_RETURN `errorParsing(state, statementStartIndex, "Expected the statement to end in a function call.")`
		end

		statement.what = expr

	else
		!ERROR_OR_RETURN `errorParsingNext(state, "Unexpected token at the start of a new statement.")`
	end

	tokType, tokValue = peekNextToken(state)
	if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),";") then
		consumeNextToken(state)
	end

	return statement
end

function _G.parseBlock(state, parentNode)
	-- Note: We assume the '{' has been consumed already.

	local blockStartIndex = state.nextToken
	local block           = astNewNode(state, AstBlock, parentNode)

	while true do
		local tokType, tokValue = peekNextToken(state)

		if not tokType then
			!ERROR_OR_RETURN `errorParsing(state, blockStartIndex, "Unfinished block.")`

		elseif isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"}") then
			consumeNextToken(state)
			break

		elseif isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),";") then
			!ERROR_OR_RETURN `errorParsingNext(state, "Statement is empty.")`

		else
			!SET_OR_RETURN `local statement = parseStatementInImperativeScope(state, block)`
			table.insert(block, statement)
		end
	end

	return block
end

-- node = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement( state, parentNode [, requireBlock=false ] )
function _G.parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, parentNode, requireBlock)
	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"{") then
		consumeNextToken(state)
		return parseBlock(state, parentNode) -- May return nil.
	end

	!SET_OR_RETURN `local statement = parseStatementInImperativeScope(state, parentNode)`

	-- We only need to wrap declarations and 'for' bodies in a block (I think).
	if requireBlock or statement.what.nodeType == !(nodeTypes.AstDeclaration) then
		local block = astNewNode(state, AstBlock, parentNode)
		table.insert(block, statement)

		statement.parent = block
		return block
	end

	-- Is it ok to strip the statement like this? @Robustness?
	statement.what.parent = parentNode
	return statement.what
end

function _G.parseFileScope(state, path, parentNode)
	local fileScope = astNewNode(state, AstFileScope, parentNode)
	fileScope.path  = path

	while true do
		local tokType, tokValue = peekNextToken(state)

		if not tokType then
			break

		elseif isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"local","global") then
			!SET_OR_RETURN `local decl = parseDeclaration(state, fileScope)`
			table.insert(fileScope.declarations, decl)

		elseif isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"export","use","useLibrary") then
			!ERROR_OR_RETURN `errorParsingNext(state, "@Incomplete: Handle '%s'.", tokValue)`

		else
			!ERROR_OR_RETURN `errorParsingNext(state, "Expected file level declaration.")`
		end
	end

	return fileScope
end

-- call = parseCall( state, parentNode, couldBeType [, callee=theFollowingIdentifier, isMethod=false ] )
function _G.parseCall(state, parentNode, couldBeType, callee, isMethod)
	assert(type(couldBeType) == "boolean")

	if not callee then
		!SET_OR_RETURN `callee = parseIdentifier(state)` -- We'll set the parent later.
	end

	isMethod = isMethod or false
	local call

	while true do
		local tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected '('.")`
		end

		call              = astNewNode(state, AstCall, parentNode)
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),")") then
			consumeNextToken(state)

			-- Should struct arguments be able to have default values, allowing foo()
			-- to possibly be a type?
			couldBeType = false

		else
			!DO_OR_RETURN `parseExpressionList(state, call, call.arguments)`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),")") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')' or ','.")`
			end
		end

		call.couldBeTypeWithParameters = couldBeType

		callee.parent = call
		call.callee   = callee
		call.isMethod = isMethod

		tokType, tokValue = peekNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"(") then  break  end

		call.couldBeTypeWithParameters = false
		callee   = call
		isMethod = false
	end

	return call
end



-- expression = parseExpression( state, parentNode [, minOperatorPrecedence ] )
function _G.parseExpression(state, parentNode, minOpPrecedence)
	-- @Robustness: Check that parents are set correctly everywhere in here.

	minOpPrecedence = minOpPrecedence or 0

	local tokType,  tokValue, exprStartIndex = consumeNextToken(state)
	local tokType2, tokValue2                = peekNextToken(state, 1)
	local tokType3, tokValue3                = peekNextToken(state, 2)
	local expr

	-- Function call or type with parameters.
	--
	-- Note: We also detect function calls later by the binary operations.
	-- The difference is that here we may have a type.
	--
	if
		tokType == !(TOKEN_TYPE_IDENTIFIER)
		and isToken(tokType2,tokValue2, !(TOKEN_TYPE_PUNCTUATION),"(")
	then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseCall(state, parentNode, true)`

	-- Built-in type.
	elseif isTokenBuiltinType(tokType, tokValue) then
		local identType    = astNewNode(state, AstType, parentNode)
		identType.typeName = tokValue
		expr               = identType

		-- @Incomplete: Check if there's a '(' after this and give error early.

	-- Identifier or literal.
	elseif tokType == !(TOKEN_TYPE_IDENTIFIER) or isTokenLiteral(tokType, tokValue) then
		if tokType == !(TOKEN_TYPE_IDENTIFIER) then
			local ident = astNewNode(state, AstIdentifier, parentNode)
			ident.name  = tokValue
			expr        = ident

		elseif tokType == !(TOKEN_TYPE_KEYWORD) then
			local literal = astNewNode(state, AstLiteral, parentNode)

			if tokValue == "nil" then
				literal.literalType = !(LITERAL_TYPE_NIL)
				literal.value       = nil
			else
				literal.literalType = !(LITERAL_TYPE_BOOLEAN)
				literal.value       = tokValue == "true"
			end

			expr = literal

		else
			local literal       = astNewNode(state, AstLiteral, parentNode)
			literal.literalType = TOKEN_TYPE_TO_LITERAL_TYPE[tokType]
			literal.value       = tokValue
			expr                = literal
		end

	-- Table constructor.
	elseif isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"{") then
		!SET_OR_RETURN `expr = parseTable(state, parentNode)`

	-- Unary operation.
	elseif
		isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"+","-","#") or
		isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"not")
	then
		local unaryOp                      = astNewNode(state, AstUnary, parentNode)
		unaryOp.operation                  = tokValue
		!SET_OR_RETURN `unaryOp.expression = parseExpression(state, unaryOp, OPERATOR_PRECEDENCE.unary)`
		expr                               = unaryOp

	-- Function signature (type) or lambda.
	--
	--     inArgs [-> outArgs] [body]
	--
	--     inArgs  = ( [ inName1:inType1, ... ] )
	--     outArgs = void
	--     outArgs = outType1 [, ... ]
	--     outArgs = ( outName1:outType1 [, ... ] )
	--     body    = { ... }
	--
	elseif
		isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"(")
		and (
			isToken(tokType2,tokValue2, !(TOKEN_TYPE_PUNCTUATION),")")
			or (
				isToken(tokType2,tokValue2, !(TOKEN_TYPE_IDENTIFIER))
				and isToken(tokType3,tokValue3, !(TOKEN_TYPE_PUNCTUATION),":",",")
			)
		)
	then
		local lambda = astNewNode(state, AstLambda, parentNode)

		-- In args.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),")") then
			consumeNextToken(state)

		else
			!SET_OR_RETURN `lambda.argumentsIn = parseArguments(state, lambda, true)`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),")") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
			end
		end

		-- Out args.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"->") then
			consumeNextToken(state)

			tokType, tokValue = peekNextToken(state)

			-- () -> void
			if isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"void") then
				consumeNextToken(state)

				tokType, tokValue = peekNextToken(state)
				if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),",") then
					!ERROR_OR_RETURN `errorParsingNext(state, "Argument list with 'void' cannot have other arguments.")`
				end

			-- () -> (name:type, ...)
			elseif isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"(") then
				consumeNextToken(state)

				!SET_OR_RETURN `lambda.argumentsOut = parseArguments(state, lambda, false)`

				tokType, tokValue = consumeNextToken(state)
				if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),")") then
					!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
				end

			-- () -> type, ...
			else
				local args          = astNewNode(state, AstArguments, lambda)
				lambda.argumentsOut = args

				while true do
					local arg = astNewNode(state, AstArgument, args)
					!DO_OR_RETURN `parsePipeSeparatedTypes(state, arg, arg.argumentTypes)`

					tokType, tokValue = peekNextToken(state)
					if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),",") then
						consumeNextToken(state)
					else
						break
					end
				end
			end
		end

		-- Body.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"{") then
			consumeNextToken(state)

			!SET_OR_RETURN `lambda.body = parseBlock(state, lambda)`
			expr                        = lambda

		else
			local identType             = astNewNode(state, AstType, parentNode)
			identType.isPlaceholder     = true
			identType.functionSignature = lambda
			expr                        = identType
		end

	-- Parenthesis.
	elseif isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"(") then
		!SET_OR_RETURN `expr = parseExpression(state, parentNode)`

		if expr.nodeType == !(nodeTypes.AstCall) then
			-- This is so we know whether to adjust the return values to one or not in certain situations.
			-- Note: Functions with a return argument after the first one marked as #must cannot have their
			-- return arguments adjusted to one.
			expr.surroundedByParenthesis = true
		end

		tokType, tokValue = consumeNextToken(state)

		if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

	-- Type.
	elseif isToken(tokType,tokValue, !(TOKEN_TYPE_DIRECTIVE),"type") then
		-- Note: parseType() does not recognize !type which is why you can't put
		-- the directive anywhere a type is expected. Should we change this?
		!SET_OR_RETURN `expr = parseType(state, parentNode)`

	elseif
		isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"typeOf") or
		isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"[")
	then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseType(state, parentNode)`

	-- Cast.
	elseif isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"cast") then
		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '('.")`
		end

		local cast                      = astNewNode(state, AstCast, parentNode)
		!SET_OR_RETURN `cast.targetType = parseType(state, cast)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		!SET_OR_RETURN `cast.expression = parseExpression(state, cast, math.huge)` -- @Incomplete: Give casting an operator precedence.
		expr                            = cast

	else
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected a value.")`
	end

	-- Binary operations.
	local nextCanBeMethodCall = false

	while true do
		tokType,  tokValue  = peekNextToken(state, 1)
		tokType2, tokValue2 = peekNextToken(state, 2)

		local thisCanBeMethodCall = nextCanBeMethodCall
		nextCanBeMethodCall       = false

		if not tokType then
			break

		-- Arithmetic opration, comparison or string concatination.
		-- @Incomplete: Combine string concatinations in some way?
		elseif (
			isToken(tokType,tokValue, !(TOKEN_TYPE_KEYWORD),"and","or")
			or isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),
				"+","-","*","/","//","^","%","<",">","<=",">=","==","~=",".."
			)
		) and OPERATOR_PRECEDENCE[tokValue] >= minOpPrecedence then
			consumeNextToken(state)

			local binOp                 = astNewNode(state, AstBinary, parentNode)
			binOp.operation             = tokValue
			binOp.left                  = expr
			!SET_OR_RETURN `binOp.right = parseExpression(state, binOp, OPERATOR_PRECEDENCE[tokValue])`
			expr.parent                 = binOp
			expr                        = binOp

		-- Table lookup or similar using '.'.
		elseif
			isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),".")
			and OPERATOR_PRECEDENCE["."] > minOpPrecedence -- Note: Not using >= here.
		then
			consumeNextToken(state)

			local binOp     = astNewNode(state, AstBinary, parentNode)
			binOp.operation = "."

			tokType, tokValue = consumeNextToken(state)
			if tokType ~= !(TOKEN_TYPE_IDENTIFIER) then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected an identifier.")`
			end

			local literal       = astNewNode(state, AstLiteral, binOp)
			literal.literalType = !(LITERAL_TYPE_STRING)
			literal.value       = tokValue

			binOp.left          = expr
			binOp.right         = literal

			expr.parent         = binOp
			expr                = binOp

			nextCanBeMethodCall = true

		-- Table lookup or similar using '['.
		elseif
			isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"[")
			and OPERATOR_PRECEDENCE["."] > minOpPrecedence -- Note: Not using >= here.
		then
			consumeNextToken(state)

			local binOp                 = astNewNode(state, AstBinary, parentNode)
			binOp.operation             = "."
			binOp.left                  = expr
			!SET_OR_RETURN `binOp.right = parseExpression(state, binOp, OPERATOR_PRECEDENCE[tokValue])`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION), "]") then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected ']'.")`
			end

			expr.parent = binOp
			expr        = binOp

		-- Function call.
		elseif
			isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"(")
			and OPERATOR_PRECEDENCE.call >= minOpPrecedence
		then
			!SET_OR_RETURN `expr = parseCall(state, parentNode, false, expr, false)`

		-- Method call.
		elseif
			(
				isToken(tokType,tokValue, !(TOKEN_TYPE_PUNCTUATION),"!")
				and isToken(tokType2,tokValue2, !(TOKEN_TYPE_PUNCTUATION),"(")
			)
			and OPERATOR_PRECEDENCE.call >= minOpPrecedence
		then
			tokType, tokValue = peekLastToken(state)

			if not isToken(tokType,tokValue, !(TOKEN_TYPE_IDENTIFIER)) then
				!ERROR_OR_RETURN `errorParsingNext(state, "Expected a method name before this.")`
			elseif not thisCanBeMethodCall then
				putBackLastToken(state)
				!ERROR_OR_RETURN `errorParsingNext(state, "Expected an object to call a method on.")`
			end

			consumeNextToken(state)
			!SET_OR_RETURN `expr = parseCall(state, parentNode, false, expr, true)`

		else
			break
		end
	end

	return expr
end



-- tokenType, tokenValue, tokenIndex = consumeNextToken( parseState )
function _G.consumeNextToken(state)
	local i         = state.nextToken
	state.nextToken = i+1
	local tokType, tokValue = getToken(state.tokens, i)
	return tokType, tokValue, i
end

-- tokenType, tokenValue = peekNextToken( state [, steps=1 ] )
function _G.peekNextToken(state, steps)
	steps   = steps or 1
	local i = state.nextToken+steps-1
	return getToken(state.tokens, i)
end

function _G.peekLastToken(state)
	return getToken(state.tokens, state.nextToken-1)
end

function _G.putBackLastToken(state)
	state.nextToken = state.nextToken-1
	assert(state.nextToken >= 1)
end



do
	-- errorParsing( parseState, tokenIndex, formatString, ... )
	function _G.errorParsing(state, i, s, ...)
		local tokens = state.tokens

		local path
			=  tokens.file[i]
			or tokens.file[1] -- Not great, but better than crashing.
			or errorInternal(2, "No tokens.")

		local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)

		local ptr
			=  tokens.position1[i]
			or i <= 1 and 1
			or tokens.count > 0 and tokens.position2[tokens.count]+1
			or #buffer

		errorInFile(buffer, path, ptr, "Parser", s, ...)
	end

	-- errorParsingAfter( parseState, tokenIndex, formatString, ... )
	function _G.errorParsingAfter(state, i, s, ...)
		local tokens = state.tokens

		local path
			=  tokens.file[i]
			or tokens.file[1] -- Not great, but better than crashing.
			or errorInternal(2, "No tokens.")

		local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)

		local ptr
			=  tokens.position2[i] and tokens.position2[i]+1
			or i <= 1 and 1
			or tokens.count > 0 and tokens.position2[tokens.count]+1
			or #buffer

		errorInFile(buffer, path, ptr, "Parser", s, ...)
	end

	function _G.errorParsingLast(state, ...)
		errorParsing(state, state.nextToken-1, ...)
	end
	function _G.errorParsingNext(state, ...)
		errorParsing(state, state.nextToken, ...)
	end

	function _G.errorParsingAfterPrevious(state, ...)
		errorParsingAfter(state, state.nextToken-2, ...)
	end
	function _G.errorParsingAfterLast(state, ...)
		errorParsingAfter(state, state.nextToken-1, ...)
	end
end



-- printAst( node [, fileToPrintTo=io.stdout ] )
do
	local file
	local printNode -- Forward declaration.

	local function write(...)
		file:write(...)
	end

	local function printNodeList(list, indent, printed, keyPrefix)
		for i, node in ipairs(list) do
			printNode(node, indent, printed, (keyPrefix and keyPrefix..i))
		end
	end

	function printNode(node, indent, printed, keyName)
		!local BLOCK_START = PRINT_NODE_BRACKETS and `write(" {")`             or ``
		!local BLOCK_END   = PRINT_NODE_BRACKETS and `write(indentStr, "}\n")` or ``

		local indentStr = ("\t"):rep(indent)

		write(indentStr)
		if keyName then  write(keyName, " ")  end
		write(AST_NODE_TYPE_NAMES[node.nodeType] or "?")
		write(" @", node.s)
		if node.parent then  write(" ^", node.parent.s)  end

		if printed[node] then
			write("  !!! ERROR: RECURSION DETECTED !!!\n")
		else
			printed[node] = true

			if node.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = node
				write(" (", ident.name, ")\n")

			elseif node.nodeType == !(nodeTypes.AstBinary) then
				local binOp = node
				write(" (", binOp.operation, ")")
				!!(BLOCK_START)
				write("\n")
				if binOp.left  then  printNode(binOp.left,  indent+1, printed)  end
				write(indentStr, "\top ", binOp.operation, "\n")
				if binOp.right then  printNode(binOp.right, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstUnary) then
				local unaryOp = node
				write(" (", unaryOp.operation, ")")
				!!(BLOCK_START)
				write("\n")
				if unaryOp.expression then  printNode(unaryOp.expression, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstDeclaration) then
				local decl = node
				if decl.isConstant then  write(" (const)")  end
				!!(BLOCK_START)
				write("\n")
				printNodeList(decl.names,      indent+1, printed, "NAME")
				printNodeList(decl.valueTypes, indent+1, printed, "TYPE")
				printNodeList(decl.values,     indent+1, printed, "VAL")
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstTable) then
				local tableNode = node
				!!(BLOCK_START)
				write("\n")
				for i, tableField in ipairs(tableNode) do
					if tableField.key   then  printNode(tableField.key,   indent+1, printed, i.."K")  end
					if tableField.value then  printNode(tableField.value, indent+1, printed, i.."V")  end
				end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstCall) then
				local call = node
				assert(not (call.couldBeTypeWithParameters and call.isMethod))
				if call.couldBeTypeWithParameters then  write(" (couldBeType)")    end
				if call.isMethod                  then  write(" (method)")         end
				if call.surroundedByParenthesis   then  write(" (adjustArgsTo1)")  end
				!!(BLOCK_START)
				write("\n")
				if call.callee then  printNode(call.callee, indent+1, printed)  end
				printNodeList(call.arguments, indent+1, printed, "ARG")
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstLambda) then
				local lambda = node
				!!(BLOCK_START)
				write("\n")
				if lambda.argumentsIn then
					printNode(lambda.argumentsIn, indent+1, printed, "IN")
					-- printNodeList(lambda.argumentsIn, indent+1, printed, "IN")
				end
				if lambda.argumentsOut then
					printNode(lambda.argumentsOut, indent+1, printed, "OUT")
					-- printNodeList(lambda.argumentsOut, indent+1, printed, "OUT")
				end
				if lambda.body then  printNode(lambda.body, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstArguments) then
				local args = node
				!!(BLOCK_START)
				write("\n")
				printNodeList(args, indent+1, printed)
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstArgument) then
				local arg = node
				!!(BLOCK_START)
				write("\n")
				if arg.name then  printNode(arg.name, indent+1, printed)  end
				printNodeList(arg.argumentTypes, indent+1, printed, "TYPE")
				if arg.defaultValue  then  printNode(arg.defaultValue, indent+1, printed, "DEFAULT")  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstBlock) then
				local block = node
				!!(BLOCK_START)
				write("\n")
				printNodeList(block, indent+1, printed)
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstStatement) then
				local statement = node
				!!(BLOCK_START)
				write("\n")
				if statement.what then  printNode(statement.what, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstType) then
				local identType = node
				if identType.typeName ~= "" then  write(" (", identType.typeName, ")")  end
				!!(BLOCK_START)
				write("\n")
				if identType.functionSignature then
					printNode(identType.functionSignature, indent+1, printed)
				elseif identType.arguments then
					printNodeList(identType.arguments, indent+1, printed, "ARG")
				end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstTypeOf) then
				local typeOf = node
				!!(BLOCK_START)
				write("\n")
				if typeOf.expression then  printNode(typeOf.expression, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstAssignment) then
				local assignment = node
				write(" (", assignment.operation, ")")
				!!(BLOCK_START)
				write("\n")
				printNodeList(assignment.targets, indent+1, printed)
				write(indentStr, "\top ", assignment.operation, "\n")
				printNodeList(assignment.values, indent+1, printed)
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstCast) then
				local cast = node
				!!(BLOCK_START)
				write("\n")
				if cast.targetType then  printNode(cast.targetType, indent+1, printed)  end
				if cast.expression then  printNode(cast.expression, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstIf) then
				local ifBranch = node
				!!(BLOCK_START)
				write("\n")
				if ifBranch.condition   then  printNode(ifBranch.condition,   indent+1, printed)           end
				if ifBranch.branchTrue  then  printNode(ifBranch.branchTrue,  indent+1, printed, "TRUE")   end
				if ifBranch.branchFalse then  printNode(ifBranch.branchFalse, indent+1, printed, "FALSE")  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstWhile) then
				local whileLoop = node
				!!(BLOCK_START)
				write("\n")
				if whileLoop.condition then  printNode(whileLoop.condition, indent+1, printed)  end
				if whileLoop.body      then  printNode(whileLoop.body,      indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstFor) then
				local forLoop = node
				write(" (", FOR_TYPE_TITLES[forLoop.forType], ")")
				!!(BLOCK_START)
				write("\n")
				printNodeList(forLoop.names,       indent+1, printed, "NAME")
				printNodeList(forLoop.expressions, indent+1, printed, "EXPR")
				if forLoop.body then  printNode(forLoop.body, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstLiteral) then
				local literal = node

				if literal.literalType == !(LITERAL_TYPE_ARRAY) then
					write(" (array)")
					!!(BLOCK_START)
					write("\n")
					printNode(literal.value, indent+1, printed)
					!!(BLOCK_END)

				else
					write(" (")

					if isAny(literal.literalType, !(LITERAL_TYPE_BOOLEAN),!(LITERAL_TYPE_NIL)) then
						write(tostring(literal.value))

					else
						!local MAX_CHARS = 100
						local vStr = tostring(literal.value):sub(1, !(MAX_CHARS))

						vStr = vStr:gsub(".", function(c)
							local byte = c:byte()
							return
								byte == !(("\n"):byte())   and "{NL}"  or
								byte == !(("\r"):byte())   and "{CR}"  or
								byte == !(("\t"):byte())   and "{TAB}" or
								byte >= 32 and byte <= 126 and c       or -- Printable ASCII characters.
								"?"
						end)

						write(LITERAL_TYPE_TITLES[literal.literalType])

						if literal.literalType == !(LITERAL_TYPE_STRING) then
							write("(", #literal.value, ")")
						end

						if vStr ~= "" then  write(": ", vStr:sub(1, !(MAX_CHARS)))  end
					end

					write(")\n")
				end

			elseif node.declarations then
				if node.nodeType == !(nodeTypes.AstFileScope) then
					local fileScope = node
					write(" (", fileScope.path, ")")
				end

				!!(BLOCK_START)
				write("\n")
				printNodeList(node.declarations, indent+1, printed)
				!!(BLOCK_END)

			else
				write("\n")
			end
		end
	end

	function _G.printAst(node, _file)
		file = _file or io.stdout
		printNode(node, 0, {})
	end
end


