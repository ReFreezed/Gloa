--[[============================================================
--=
--=  Parser
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	astCopy
	astFindParent, astFindCommonParent, astHasParent
	astGetExpressionVisuallyFurthestToTheLeft, astGetCalleeVisuallyFurthestToTheLeft
	astNewNode
	astPrint, astPrintTree
	astVisitAllNodes, astVisitAllNodesLeavesFirst
	errorParsing*, errorUnhandledNodeType, parserMessage*
	parse*

--============================================================]]

!(
local PRINT_NODE_BRACKETS = false

local function errorOrReturn(errCode, returnValueCode)
	__LUA("if state.soft then return ",returnValueCode," end ")
	__LUA(errCode)
end
local function ERROR_OR_RETURN      (errCode)  errorOrReturn(errCode, "nil"  )  end
local function ERROR_OR_RETURN_FALSE(errCode)  errorOrReturn(errCode, "false")  end

local function setOrReturn(assignmentCode, returnValueCode)
	local preCode, sufCode = assignmentCode:match"^([^=]+)=(.*)$"
	if not preCode then  error(assignmentCode)  end

	-- local x = ...
	if preCode:find"^%s*local%s" then
		local var = preCode:match"^%s*local%s+([%w_]+)" or error(preCode)
		__LUA(assignmentCode)
		__LUA(" if not ",var," then return ",returnValueCode," end ")

	-- x = ...
	elseif preCode:find"^%s*[%w_]+%s*$" then
		local var = preCode:match"[%w_]+" or error(preCode)
		__LUA(assignmentCode)
		__LUA(" if not ",var," then return ",returnValueCode," end ")

	-- x.y = ...
	else
		__LUA("local __value__ =",sufCode)
		__LUA(" if not __value__ then return ",returnValueCode," end ")
		__LUA(preCode,"= __value__")
	end
end
local function SET_OR_RETURN      (assignmentCode)  setOrReturn(assignmentCode, "nil"  )  end
local function SET_OR_RETURN_FALSE(assignmentCode)  setOrReturn(assignmentCode, "false")  end

local function doOrReturn(exprCode, returnValueCode)
	__LUA("if not (",exprCode,") then return ",returnValueCode," end")
end
local function DO_OR_RETURN      (exprCode)  doOrReturn(exprCode, "nil"  )  end
local function DO_OR_RETURN_FALSE(exprCode)  doOrReturn(exprCode, "false")  end
)



!(
_G.nodeTypes        = {}
local nodeTypeN     = 0
local nodeTypeNames = {}

local function structAst(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			nodeTypeN         = nodeTypeN+1
			fields._overrides = {nodeType=nodeTypeN}

			nodeTypes[name]          = nodeTypeN
			nodeTypeNames[nodeTypeN] = name
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_AstNode"{
	nodeType = 0,
	s        = 0,   -- Serial number.
	parent   = NIL, -- AstNode
	token    = 1,
	-- Pipe phase:
	queued   = NIL, -- Queued
}
_G.!structAst"AstTypeDefinition:_AstNode"{ -- Created during type phase.
	-- Type phase:
	name       = NIL,   -- AstIdentifier|AstVararg
	scope      = NIL,   -- AstGlobalScope|AstFileScope|AstBlock|AstStruct|AstFor|AstLambda|AstEnum (This should be the same as the parent.)
	isConstant = false,
	canShadow  = false, -- @Cleanup: Probably don't need to store this here.
	typeInfo   = NIL,   -- TypeInfo
	typeInfoForDeclaration = NIL, -- Type represented by the value in type declarations. If this is set then the identifier can be used in places where a type is expected.
}

!structAst"_AstExpression:_AstNode"{
	-- Type phase:
	inferredType = NIL, -- TypeInfo
	-- Bytecode phase:
	constant     = NIL, -- Constant
}
_G.!structAst"AstIdentifier:_AstExpression"{
	name = "",
	-- Type phase:
	placeDeclared = NIL, -- AstDeclaration|AstStruct|AstFor|AstLambda (Can/should this be moved to AstTypeDefinition?)
	declaration   = NIL, -- AstDeclaration
	definition    = NIL, -- AstTypeDefinition
}
_G.!structAst"AstVararg:_AstExpression"{
	surroundedByParenthesis = false,
}
_G.!structAst"AstLiteral:_AstExpression"{
	literalType = 0,
	value       = NIL, -- The value depends on what literalType is. Could be a number, string or whatever.
}
_G.!structAst"AstType:_AstExpression"{
	isUserType        = false,
	typeName          = "",
	functionSignature = NIL, -- AstLambda without a body. This is used to create the actual function type.
	arrayItemType     = NIL, -- AstType
	arguments         = NIL, -- []AstExpression (Is set for parameterized structs.)
	-- Type phase:
	typeInfo          = NIL,
	representedType   = NIL, -- TypeInfo
	declaration       = NIL, -- AstDeclaration
	definition        = NIL, -- AstTypeDefinition
}
_G.!structAst"AstUnary:_AstExpression"{
	operation  = "",  -- "-" or "not" etc.
	expression = NIL, -- AstExpression
}
_G.!structAst"AstBinary:_AstExpression"{
	operation = "",  -- "+" or "-" etc.
	left      = NIL, -- AstExpression
	right     = NIL, -- AstExpression
}
local !struct"TableField"{ key=NIL, value=NIL }
_G.!structAst"AstTable:_AstExpression"{
	-- [1]=tableField1, ...
}
_G.!structAst"AstCall:_AstExpression"{
	couldBeTypeWithParameters = false,
	isMethod                  = false,
	surroundedByParenthesis   = false,
	callee                    = NIL, -- AstExpression
	arguments                 = {},  -- []AstExpression
}
_G.!structAst"AstArgument:_AstNode"{
	declaration = NIL, -- AstDeclaration
	group       = 0,   -- Arguments in the same group have the same type. This is a small optimization for the typer.
	autobake    = 0,   -- 0=disabled, 1=enabled, 2=required  @Incomplete

	-- For an in arg, this indicates optionality.
	-- For an out arg, if there's a !must then it must not be adjusted away by the caller.
	isRequired  = false,
}
_G.!structAst"AstArguments:_AstExpression"{ -- @Cleanup: Move this into an array in the parent (like expression lists). (Also, this probably shouldn't have been an expression.)
	-- [1]=argument1, ...
}
_G.!structAst"AstLambda:_AstExpression"{
	argumentsIn  = NIL, -- AstArguments
	argumentsOut = NIL, -- AstArguments
	body         = NIL, -- AstBlock  (If this is nil then the lambda is a function signature.)
	-- Type phase:
	definitions   = {},  -- []AstTypeDefinition (Note that the body has it's own definitions.)
	definedLocals = {},
}
_G.!structAst"AstTypeOf:_AstExpression"{
	expression = NIL,
}
_G.!structAst"AstCast:_AstExpression"{
	targetType = NIL, -- AstType
	expression = NIL, -- AstExpression
}
_G.!structAst"AstImport:_AstExpression"{
	isLoad     = false,
	importName = "",
	-- Type phase:
	fileScope  = NIL, -- AstFileScope
}

_G.!structAst"AstStatement:_AstNode"{ -- Needed? I think so?
	what = NIL,
}

_G.!structAst"AstDeclaration:_AstNode"{
	names              = {},  -- [](AstIdentifier|AstVararg)
	types              = {},  -- []AstType  (No value here means the types are inferred.)
	notes              = {},  -- []AstNote  @Incomplete: Nodes.
	isGlobalOrExported = false,
	isConstant         = false,
	canShadow          = false,

	-- assignment      = nil means all names gets their default value (which depends on the type, of which there must be only one).
	assignment         = NIL, -- AstAssignment

	-- Type phase:
	inferredTypes      = {},  -- []TypeInfo (One for each name.)
}

_G.!structAst"AstAssignment:_AstNode"{
	operation = "=",
	targets   = {}, -- []AstExpression
	values    = {}, -- []AstExpression
}

!structAst"_AstJump:_AstNode"{}
_G.!structAst"AstReturn:_AstJump"{
	values = {}, -- []AstExpression
}
_G.!structAst"AstBreak:_AstJump"{
	loopName = NIL, -- AstIdentifier
}
_G.!structAst"AstContinue:_AstJump"{
	loopName = NIL, -- AstIdentifier
}

_G.!structAst"AstDefer:_AstNode"{
	body = NIL, -- AstBlock
}

!structAst"_AstControlStructure:_AstNode"{}
_G.!structAst"AstIf:_AstControlStructure"{
	condition   = NIL, -- AstExpression
	branchTrue  = NIL, -- AstBlock
	branchFalse = NIL, -- AstBlock
}
_G.!structAst"AstWhile:_AstControlStructure"{
	condition   = NIL, -- AstExpression
	body        = NIL, -- AstBlock
}
_G.!structAst"AstFor:_AstControlStructure"{
	forType     = FOR_NUMERIC,
	names       = {},  -- []AstIdentifier  @Incomplete @Cleanup: Use AstDeclaration in AstFor.
	expressions = {},  -- []AstExpression
	body        = NIL, -- AstBlock
	-- Type phase:
	definitions   = {},  -- []AstTypeDefinition (Note that the body has it's own definitions.)
	definedLocals = {},
}

!structAst"_AstDeclarativeScope:_AstNode"{
	declarations       = {}, -- []AstDeclaration
	imports            = {}, -- []AstImport
	-- includedNamespaces = {}, -- []AstImport  @Depricated
	-- Type phase:
	definitions   = {}, -- []AstTypeDefinition
	definedLocals = {},
}
_G.!structAst"AstStruct:_AstDeclarativeScope"{
	arguments       = NIL, -- AstArguments
	-- Type phase:
	representedType = NIL, -- TypeInfoStruct
}
_G.!structAst"AstEnum:_AstDeclarativeScope"{ -- Should this be a DeclarativeScope?
	memberType      = NIL, -- AstType
	-- Type phase:
	representedType = NIL, -- TypeInfoEnum
}
_G.!structAst"AstFileScope:_AstDeclarativeScope"{
	isModule = false,
	path     = "",
}
_G.!structAst"AstGlobalScope:_AstDeclarativeScope"{
	firstFileScope = NIL, -- AstFileScope
	fileScopes     = {},  -- []AstFileScope
}

_G.!structAst"AstBlock:_AstNode"{
	-- [1]=statement1, ...
	-- Type phase:
	definitions   = {}, -- []AstTypeDefinition
	definedLocals = {},
}

_G.AST_NODE_TYPE_NAMES = !(nodeTypeNames)



local TOKEN_TYPE_TO_LITERAL_TYPE = !({
	[TOKEN_FLOAT]   = LITERAL_FLOAT,
	[TOKEN_INTEGER] = LITERAL_INTEGER,
	[TOKEN_STRING]  = LITERAL_STRING,
})



-- node:AstNodeType = astNewNode( AstNodeType, token [, parentNode ] )
do
	local serialN = 0

	function _G.astNewNode(AstNodeType, token, parentNode)
		if not AstNodeType then  errorInternal(2, "No AstNodeType specified.")  end
		!ifDEBUG`assert(token)`

		if not parentNode and AstNodeType ~= AstGlobalScope then
			errorInternal(2, "No parent.")
		end

		serialN = serialN+1

		local node  = AstNodeType()
		node.s      = serialN
		node.parent = parentNode
		node.token  = token

		--[[
		if
			false
			-- or serialN == 22
			or parentNode and parentNode.s == 21
		then
			errorInternal("DEBUG")
		end
		--]]

		return node
	end
end



-- identifier = parseIdentifier( compilationState, parentNode [, placeDeclared ] )
--
-- placeDeclared should be set when they are declared, i.e. in declarations or
-- function argument lists (loose identifiers should have it be nil as we figure
-- it out during type inference (or maybe not?)).
--
function _G.parseIdentifier(state, parentNode, placeDeclared)
	local tokType, tokValue, token = consumeNextToken(state)
	if tokType ~= !(TOKEN_IDENTIFIER) then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected an identifier.")`
	end

	local ident         = astNewNode(AstIdentifier, token, parentNode)
	ident.name          = tokValue
	ident.placeDeclared = placeDeclared

	return ident
end

function _G.parseType(state, parentNode)
	local tokType, tokValue, token = consumeNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"type_of") then
		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '('.")`
		end

		local typeOf                      = astNewNode(AstTypeOf, token, parentNode)
		!SET_OR_RETURN `typeOf.expression = parseExpression(state, typeOf)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		return typeOf

	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[") then
		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"]") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ']'.")`
		end

		local typeNode      = astNewNode(AstType, token, parentNode)
		typeNode.isUserType = true

		!SET_OR_RETURN `typeNode.arrayItemType = parseType(state, typeNode)`

		return typeNode

	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
		local typeNode      = astNewNode(AstType, token, parentNode)
		typeNode.isUserType = true

		!SET_OR_RETURN `typeNode.functionSignature = parseLambda(state, typeNode, false)`

		return typeNode
	end

	local isBuiltinType = isTokenBuiltinType(tokType, tokValue)
	local typeNode

	if isBuiltinType or tokType == !(TOKEN_IDENTIFIER) then
		typeNode            = astNewNode(AstType, token, parentNode)
		typeNode.isUserType = not isBuiltinType
		typeNode.typeName   = tokValue
	else
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected a type.")`
	end

	-- User type parameters.
	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
		consumeNextToken(state)

		if isBuiltinType then
			!ERROR_OR_RETURN `errorParsingLast(state, "Built-in types have no parameters.")`
		end

		typeNode.arguments = {}
		!DO_OR_RETURN `parseExpressionList(state, typeNode, typeNode.arguments)`
		assert(typeNode.arguments[1])

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end
	end

	return typeNode
end

-- success = parsePipeSeparatedTypes( compilationState, parentNode, identifierTypes )
function _G.parsePipeSeparatedTypes(state, parentNode, typeNodes)
	-- @Incomplete: Detect repeated types. (This may be more difficult than it seems. It's possibly a task for the typer.)
	while true do
		!SET_OR_RETURN_FALSE `local typeNode = parseType(state, parentNode)`
		table.insert(typeNodes, typeNode)

		local tokType, tokValue, token = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"|") then
			consumeNextToken(state)
			tokType, tokValue, token = peekNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"nil") then
				consumeNextToken(state)

				typeNode          = astNewNode(AstType, token, parentNode)
				typeNode.typeName = "nil"
				table.insert(typeNodes, typeNode)

				break

			else
				-- Continue the loop.
			end

		else
			break
		end
	end

	return true
end

function _G.parseTable(state, parentNode)
	-- Note: We assume the '{' has been consumed already.

	local tableStartToken = state.nextToken-1
	local tableNode       = astNewNode(AstTable, tableStartToken, parentNode)
	local listIndex       = 0

	while true do
		local tokType, tokValue = peekNextToken(state)

		if not tokType then
			!ERROR_OR_RETURN `errorParsing(state, tableStartToken, "Unfinished table.")`
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			consumeNextToken(state)
			break
		end

		local tokType2, tokValue2, token = peekNextToken(state, 2)
		local tableField                 = TableField()
		local tableKey

		-- [k]=v
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[") then
			consumeNextToken(state)

			!SET_OR_RETURN `tableKey = parseExpression(state, tableNode)`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"]") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ']'.")`
			end

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '='.")`
			end

		-- k=v
		elseif
			tokType == !(TOKEN_IDENTIFIER)
			and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"=")
		then
			consumeNextToken(state)
			local literal       = astNewNode(AstLiteral, token, tableNode)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = tokValue
			tableKey            = literal
			consumeNextToken(state) -- The equal sign.

		-- v
		elseif
			tokType == !(TOKEN_IDENTIFIER)
			or isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
			or isTokenLiteral(tokType, tokValue)
		then
			listIndex           = listIndex+1
			local literal       = astNewNode(AstLiteral, token, tableNode) -- Note: The token position of the key and value will be the same.
			literal.literalType = !(LITERAL_INTEGER)
			literal.value       = listIndex
			tableKey            = literal

		else
			!ERROR_OR_RETURN `errorParsingNext(state, "Expected a table field.")`
		end

		assert(tableKey)

		tableField.key                   = tableKey
		!SET_OR_RETURN `tableField.value = parseExpression(state, tableNode)`

		table.insert(tableNode, tableField)

		tokType, tokValue = consumeNextToken(state)
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			break
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",",";") then
			-- void
			-- Note: A trailing comma or semicolon at the end of the arg list is permitted.
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ','.")`
		end
	end

	return tableNode
end

-- Parse comma-separated expressions. Used for function calls and struct parameters.
-- success = parseExpressionList( compilationState, parentNode, expressions [, expectLeftValues=false ] )
function _G.parseExpressionList(state, parentNode, expressions, expectLeftValues)
	while true do
		!SET_OR_RETURN_FALSE `local expr = parseExpression(state, parentNode, nil, expectLeftValues)`
		table.insert(expressions, expr)

		local tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			consumeNextToken(state)
			-- Continue the loop.
		else
			break
		end
	end

	return true
end

-- parseArguments( compilationState, parentNode, isInput, placeDeclared )
-- placeDeclared = AstLambda|AstStruct
function _G.parseArguments(state, parentNode, isInput, placeDeclared)
	local args       = astNewNode(AstArguments, state.nextToken, parentNode)
	local takenNames = {}
	local gotVararg  = false
	local tokType, tokValue, token

	for groupN = 1, math.huge do
		-- Argument name(s).
		local argGroup = {}

		while true do
			tokType, tokValue, token = consumeNextToken(state)
			if not (tokType == !(TOKEN_IDENTIFIER) or isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"...")) then
				!ERROR_OR_RETURN `errorParsingLast(state, "Argument list: Expected an identifier.")`
			end

			local arg = astNewNode(AstArgument, token, args)
			arg.group = groupN

			table.insert(args,     arg)
			table.insert(argGroup, arg)

			local decl      = astNewNode(AstDeclaration, token, arg)
			arg.declaration = decl

			local nameNode

			if tokType == !(TOKEN_IDENTIFIER) then
				local ident         = astNewNode(AstIdentifier, token, decl)
				ident.name          = tokValue
				ident.placeDeclared = placeDeclared
				ident.declaration   = decl
				nameNode            = ident

				if takenNames[ident.name] then
					!ERROR_OR_RETURN `errorParsingLast(state, "Duplicate name '%s'.", ident.name)`
				end
				takenNames[ident.name] = true

			else
				gotVararg   = true
				nameNode    = astNewNode(AstVararg, token, decl)
			end

			decl.names[1] = nameNode

			tokType, tokValue = consumeNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
				break
			elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
				-- Continue the loop.
			else
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ':'.")`
			end

			if gotVararg then
				!ERROR_OR_RETURN `errorParsingLast(state, "Vararg must be the last argument.")`
			end
		end

		-- Type(s).
		token = state.nextToken
		for _, arg in ipairs(argGroup) do
			state.nextToken = token
			local decl      = arg.declaration
			!DO_OR_RETURN `parsePipeSeparatedTypes(state, decl, decl.types)` -- @Speed: Parse once then just copy the first one.
		end

		-- Default value.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
			consumeNextToken(state)
			if not isInput then
				!ERROR_OR_RETURN `errorParsingLast(state, "Output arguments cannot have default values.")`
			end

			token = state.nextToken
			for i, arg in ipairs(argGroup) do
				state.nextToken       = token
				local decl            = arg.declaration

				local assignment      = astNewNode(AstAssignment, token, decl)
				decl.assignment       = assignment

				local identCopy       = astCopy(decl.names[1])
				identCopy.parent      = assignment
				assignment.targets[1] = identCopy

				!SET_OR_RETURN `local expr = parseExpression(state, assignment)` -- @Speed: Parse once then just copy the first one.
				assignment.values[1]       = expr

				-- If the value is nil then we make sure 'nil' is one of the types.
				if
					i == 1
					and expr.nodeType == !(nodeTypes.AstLiteral)
					and expr.literalType == !(LITERAL_NIL)
					and not itemWith1(decl.types, "typeName", "nil")
				then
					local typeNode    = astNewNode(AstType, expr.token, decl)
					typeNode.typeName = "nil"
					table.insert(decl.types, typeNode)
				end
			end
		end

		-- Set if shadowing is allowed.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"shadow") then
			consumeNextToken(state)
			for _, arg in ipairs(argGroup) do
				arg.declaration.canShadow = true
			end
		end

		-- @Incomplete: Set arg.isRequired.
		-- if isInput then
		-- 	arg.isRequired = (arg.declaration.values[1] == nil)
		-- else
		-- 	-- @Incomplete: Set arg.isRequired if there's a !must somewhere closeby.
		-- end

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			consumeNextToken(state)
			-- Continue the loop.
		else
			break
		end

		if gotVararg then
			!ERROR_OR_RETURN `errorParsingLast(state, "Vararg must be the last argument.")`
		end
	end

	return args
end

function _G.parseNamelessArguments(state, parentNode, placeDeclared)
	local args = astNewNode(AstArguments, state.nextToken, parentNode)

	for groupN = 1, math.huge do
		local arg = astNewNode(AstArgument, state.nextToken, args)
		arg.group = groupN
		table.insert(args, arg)

		local decl      = astNewNode(AstDeclaration, arg.token, arg)
		arg.declaration = decl
		!DO_OR_RETURN `parsePipeSeparatedTypes(state, decl, decl.types)`

		local ident         = astNewNode(AstIdentifier, decl.token, decl)
		ident.name          = "__UNNAMED_"..groupN.."__"
		ident.placeDeclared = placeDeclared
		ident.declaration   = decl
		decl.names[1]       = ident

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			consumeNextToken(state)
		else
			break
		end
	end

	return args
end

function _G.parseStruct(state, parentNode)
	local struct            = astNewNode(AstStruct, state.nextToken-1, parentNode) -- The token should be the 'struct' keyword.
	local tokType, tokValue = consumeNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
		!SET_OR_RETURN `struct.arguments = parseArguments(state, struct, true, struct)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		tokType, tokValue = consumeNextToken(state)
	end

	if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '{'.")`
	end

	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
		consumeNextToken(state)

	else
		-- Note: We allow a trailing comma/semicolon after the members.
		while true do
			local declType             = !(DECLARATION_STRUCT)
			!SET_OR_RETURN `local decl = parseDeclaration(state, struct, declType)`

			table.insert(struct.declarations, decl)
			tokType, tokValue = consumeNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",",";") then
				-- Continue the loop.
			elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
				break
			else
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '}'.")`
			end

			tokType, tokValue = peekNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
				consumeNextToken(state)
				break
			end
		end
	end

	return struct
end

function _G.parseEnum(state, parentNode)
	local enum              = astNewNode(AstEnum, state.nextToken-1, parentNode) -- The token should be the 'enum' keyword.
	local tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"float","int","string","bool","type") then -- We don't allow 'table' or '*' or anything user-defined.
		!SET_OR_RETURN `enum.memberType = parseType(state, enum)`
	end

	tokType, tokValue = consumeNextToken(state)

	if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		local tokType2, tokValue2 = peekNextToken(state)
		if
			(tokType == !(TOKEN_IDENTIFIER) or isTokenBuiltinType(tokType, tokValue))
			and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"{")
		then
			!ERROR_OR_RETURN `errorParsingLast(state, "Supported enum member types are: int, string, type, bool, float")`
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '{'.")`
		end
	end

	tokType, tokValue = peekNextToken(state)

	-- Note: We allow a trailing comma/semicolon after the members.
	while true do
		local declType             = !(DECLARATION_ENUM)
		!SET_OR_RETURN `local decl = parseDeclaration(state, enum, declType)`

		table.insert(enum.declarations, decl)
		tokType, tokValue = consumeNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",",";") then
			-- Continue the loop.
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			break
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '}'.")`
		end

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			consumeNextToken(state)
			break
		end
	end

	return enum
end

-- declaration     = parseDeclaration( compilationState, parentNode [, declarationType=DECLARATION_NORMAL ] )
-- declarationType = DECLARATION_NORMAL|DECLARATION_STRUCT|DECLARATION_ENUM
function _G.parseDeclaration(state, parentNode, declType)
	--[[
	local a = 0         -- Variable, inferred type.
	local b:float = 0   -- Variable, explicit type.
	local c:float       -- Variable, getting a default value.
	local A :: 0        -- Constant, inferred type.
	local B:float : 0   -- Constant, explicit type.
	local a,b,c = 0,f() -- Multiples always have either inferred type...
	local a,b:int : 1,2 -- ...or the same type.
	local A :: struct {}
	local A :: enum   {}
	local a :: !import "lib"
	]]

	declType   = declType or !(DECLARATION_NORMAL)
	local decl = astNewNode(AstDeclaration, state.nextToken, parentNode)

	if declType == !(DECLARATION_NORMAL) then
		local tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_KEYWORD),"local","global","export") then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected 'local'.")`
		end
		decl.isGlobalOrExported = isAny(tokValue, "global","export")
	end

	local nameListStartToken = state.nextToken
	if declType == !(DECLARATION_NORMAL) then
		!DO_OR_RETURN `parseNameList(state, decl, decl.names, decl)`
	else
		!SET_OR_RETURN `local ident = parseIdentifier(state, decl, decl)`
		table.insert(decl.names, ident)
	end

	for _, ident in ipairs(decl.names) do
		ident.declaration = decl
	end

	local typesStartToken          = state.nextToken -- Dummy position, kinda.
	local tokType, tokValue, token = peekNextToken(state)

	-- Type is specified and/or we have a constant.
	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
		consumeNextToken(state)

		typesStartToken   = state.nextToken
		tokType, tokValue = peekNextToken(state)

		-- Inferred type.
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
			-- void

			-- @Robustness: Mark the declaration to have it's type inferred instead of just
			-- leaving decl.types empty? Or should we have an AstTypeInferred node?

		-- Specified type.
		else
			if declType == !(DECLARATION_ENUM) then
				!ERROR_OR_RETURN `errorParsingNext(state, "The type of the members must be specified after the 'enum' keyword.")`
			else
				!DO_OR_RETURN `parsePipeSeparatedTypes(state, decl, decl.types)`
			end
		end

	-- We must have = or : after the identifier, for specified or inferred type.
	elseif not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
		!ERROR_OR_RETURN `errorParsingAfterLast(state, "Expected ':' or '='.")`
	end

	tokType, tokValue, token = peekNextToken(state)

	-- Variable.
	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
		consumeNextToken(state)

		local assignment = astNewNode(AstAssignment, token, decl)
		for i, ident in ipairs(decl.names) do
			local identCopy       = astCopy(ident)
			identCopy.parent      = assignment
			assignment.targets[i] = identCopy
		end
		decl.assignment = assignment

		if declType == !(DECLARATION_ENUM) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Enum members must be constant.")`
		-- elseif declType == !(DECLARATION_STRUCT) then
		-- 	!SET_OR_RETURN `local expr = parseExpression(state, assignment)`
		-- 	table.insert(assignment.values, expr)
		elseif declType == !(DECLARATION_NORMAL) then
			!DO_OR_RETURN `parseExpressionList(state, decl, assignment.values)`
		else
			!SET_OR_RETURN `local expr = parseExpression(state, assignment)`
			table.insert(assignment.values, expr)
		end

	-- Constant.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
		consumeNextToken(state)
		decl.isConstant = true

		if decl.types[2] then
			!ERROR_OR_RETURN `errorParsing(state, decl.types[2].token-1, "Constants can only be of one type.")`
		end

		-- @CopyPaste from above.
		local assignment = astNewNode(AstAssignment, token, decl)
		for i, ident in ipairs(decl.names) do
			local identCopy       = astCopy(ident)
			identCopy.parent      = assignment
			assignment.targets[i] = identCopy
		end
		decl.assignment = assignment

		if declType == !(DECLARATION_NORMAL) then
			!DO_OR_RETURN `parseExpressionList(state, decl, assignment.values)`
		else
			!SET_OR_RETURN `local expr = parseExpression(state, assignment)`
			table.insert(assignment.values, expr)
		end

	elseif decl.types[2] then
		!ERROR_OR_RETURN `errorParsingAfterLast(state, "Initial values are required if multiple types are specified.")`
	end

	-- Set if shadowing is allowed.
	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"shadow") then
		consumeNextToken(state)

		if decl.isConstant then
			!ERROR_OR_RETURN `errorParsingLast(state, "Constants cannot be shadows.")`
		elseif declType == !(DECLARATION_STRUCT) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Struct members cannot be marked as shadows.")`
		elseif declType == !(DECLARATION_STRUCT) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Enum members cannot be marked as shadows.")`
		elseif declType ~= !(DECLARATION_NORMAL) then
			errorInternal(declType)
		end

		decl.canShadow = true
	end

	-- Quickly check if there are obviously too many values.
	if decl.assignment and #decl.assignment.values > #decl.names then
		!ERROR_OR_RETURN `errorParsing(state, decl.assignment.values[#decl.names+1].token-1, "There are more values than names being declared.")`
	end

	return decl
end

function _G.parseAssignment(state, parentNode)
	local assignmentStartToken = state.nextToken
	local assignment           = astNewNode(AstAssignment, assignmentStartToken, parentNode)

	!DO_OR_RETURN `parseExpressionList(state, assignment, assignment.targets, true)`

	for i, expr in ipairs(assignment.targets) do
		if not (
			expr.nodeType == !(nodeTypes.AstIdentifier)
			or (expr.nodeType == !(nodeTypes.AstBinary) and expr.operation == ".")
		) then
			!ERROR_OR_RETURN `errorParsing(state, expr.token, "Expected assignment expression to resolve into a variable or table field.")`
		end
	end

	local tokType, tokValue = consumeNextToken(state)
	if not isTokenAssigning(tokType, tokValue) then
		!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '='.")`
	end
	assignment.operation = tokValue

	!DO_OR_RETURN `parseExpressionList(state, assignment, assignment.values)`

	-- Quickly check if there are obviously too many values.
	if #assignment.values > #assignment.targets then
		!ERROR_OR_RETURN `errorParsing(state, assignment.values[#assignment.targets+1].token-1, "There are more values than assignment targets.")`
	end

	return assignment
end

-- Add the names to the 'names' array.
-- success = parseNameList( compilationState, parentNode, names [, placeDeclared ] )
function _G.parseNameList(state, parentNode, names, placeDeclared)
	local takenNames = {}

	while true do
		!SET_OR_RETURN_FALSE `local ident = parseIdentifier(state, parentNode, placeDeclared)`

		if takenNames[ident.name] then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Duplicate name '%s'.", ident.name)`
		end
		takenNames[ident.name] = true

		table.insert(names, ident)
		local tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			consumeNextToken(state)
			-- Continue the loop.
		else
			break
		end
	end

	return true
end

function _G.parseStatement(state, parentNode)
	local statement = astNewNode(AstStatement, state.nextToken, parentNode)

	local tokType,  tokValue  = peekNextToken(state, 1)
	local tokType2, tokValue2 = peekNextToken(state, 2)
	local tokType3, tokValue3 = peekNextToken(state, 3)
	local tokType4, tokValue4 = peekNextToken(state, 4)
	local token

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"local") then
		!SET_OR_RETURN `statement.what = parseDeclaration(state, statement)`
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"global") then
		!ERROR_OR_RETURN `errorParsingNext(state, "Globals can only be declared in file scope.")`
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"export") then
		!ERROR_OR_RETURN `errorParsingNext(state, "Exports can only be declared in file scope.")`

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"return") then
		consumeNextToken(state)

		local returnNode = astNewNode(AstReturn, statement.token, statement)

		--
		-- Note: Considering this following ambigous situation we have to check whether any values should be returned.
		-- As a bonus we also figure if we're even inside a function, though I'm not sure this'll work when we have static code. @Robustness
		--
		--     if x return
		--     func() -- Returned expression, or separate statement after 'if'?
		--
		local lambda = astFindParent(statement, !(nodeTypes.AstLambda))
		if not lambda then
			-- This shouldn't happen as parseStatement() shouldn't be called
			-- by anything that does not parse return statements.
			!ERROR_OR_RETURN `errorParsingNext(state, "Not inside a function.")`
		end

		if lambda.argumentsOut and lambda.argumentsOut[1] then
			!DO_OR_RETURN `parseExpressionList(state, returnNode, returnNode.values)`
		end

		statement.what = returnNode

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"break","continue") then
		consumeNextToken(state)

		local keyword         = tokValue
		local breakOrContinue = astNewNode((keyword == "break" and AstBreak or AstContinue), statement.token, statement)

		tokType, tokValue = peekNextToken(state)

		if tokType == !(TOKEN_IDENTIFIER) then
			local loop = astFindParent(breakOrContinue, !(nodeTypes.AstFor), !(nodeTypes.AstWhile))
			if not loop then
				!ERROR_OR_RETURN `errorParsingNext(state, "Not inside a loop.")`
			end

			repeat
				if loop.nodeType == !(nodeTypes.AstFor) and itemWith1(loop.names, "name", tokValue) then
					!SET_OR_RETURN `breakOrContinue.loopName = parseIdentifier(state, breakOrContinue)`
					break
				end

				loop = astFindParent(loop, !(nodeTypes.AstFor), !(nodeTypes.AstWhile))
			until not loop
		end

		statement.what = breakOrContinue

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"do") then
		consumeNextToken(state)
		!SET_OR_RETURN `statement.what = parseBlockOrScopedStatement(state, statement)`

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"defer") then
		consumeNextToken(state)

		local defer                = astNewNode(AstDefer, statement.token, statement)
		!SET_OR_RETURN `defer.body = parseBlockOrScopedStatement(state, defer)`

		statement.what = defer

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"if") and (
		isToken(tokType2,tokValue2, !(TOKEN_DIRECTIVE),"complete")
		or (
			isToken(tokType2,tokValue2, !(TOKEN_IDENTIFIER))
			and isToken(tokType3,tokValue3, !(TOKEN_PUNCTUATION),"==")
			and isToken(tokType4,tokValue4, !(TOKEN_PUNCTUATION),"{")
		)
	) then
		!ERROR_OR_RETURN `errorParsingNext(state, "@Incomplete: if x == {case...}")`

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"if") then
		consumeNextToken(state)

		local ifBranch                      = astNewNode(AstIf, statement.token, statement)
		!SET_OR_RETURN `ifBranch.condition  = parseExpression(state, ifBranch)`
		!SET_OR_RETURN `ifBranch.branchTrue = parseBlockOrScopedStatement(state, ifBranch)`
		statement.what                      = ifBranch

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"else") then
			consumeNextToken(state)
			!SET_OR_RETURN `ifBranch.branchFalse = parseBlockOrScopedStatement(state, ifBranch)`
		end

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"while") then
		consumeNextToken(state)

		local whileLoop                     = astNewNode(AstWhile, statement.token, statement)
		!SET_OR_RETURN `whileLoop.condition = parseExpression(state, whileLoop)`
		!SET_OR_RETURN `whileLoop.body      = parseBlockOrScopedStatement(state, whileLoop)`
		statement.what                      = whileLoop

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"for") then
		consumeNextToken(state)

		local forStartIndex = state.nextToken
		local forLoop       = astNewNode(AstFor, statement.token, statement)

		local exprListWeMayOrMayNotUse = {}
		!DO_OR_RETURN `parseExpressionList(state, forLoop, exprListWeMayOrMayNotUse)`

		tokType, tokValue = peekNextToken(state)
		local twoParter

		-- FOR_ITERATOR  for v1, ... in iter [, state [, init ] ]
		if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"in") then
			forLoop.forType = !(FOR_ITERATOR)
		-- FOR_SHORT  for v1, ... : obj
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
			forLoop.forType = !(FOR_SHORT)
			twoParter       = true
		-- FOR_NUMERIC  for start, end [, step ]
		elseif #exprListWeMayOrMayNotUse >= 2 then -- If more than 3 arguments are specified then we'll get an error later.
			forLoop.forType = !(FOR_NUMERIC)
			twoParter       = false
		-- FOR_NUMERIC  for i = start, end [, step ]
		elseif #exprListWeMayOrMayNotUse == 1 and isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
			forLoop.forType = !(FOR_NUMERIC)
			twoParter       = true
		-- FOR_SHORT  for obj
		elseif #exprListWeMayOrMayNotUse == 1 then
			forLoop.forType = !(FOR_SHORT)
			twoParter       = false
		else
			state.nextToken = forStartIndex
			!ERROR_OR_RETURN `errorParsingNext(state, "Could not determine what kind of 'for' statement this is.")`
		end

		if forLoop.forType == !(FOR_NUMERIC) then
			-- for i = start, end [, step ]
			if twoParter then
				state.nextToken = forStartIndex
				!DO_OR_RETURN `parseNameList(state, forLoop, forLoop.names)`

				assert(#forLoop.names == 1)

				tokType, tokValue = consumeNextToken(state) -- Should eat the '='.
				assert(isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"="))

				!DO_OR_RETURN `parseExpressionList(state, forLoop, forLoop.expressions)`

			-- for start, end [, step ]
			else
				forLoop.expressions = exprListWeMayOrMayNotUse

				-- Is this name generation really necessay? For the other 'for' loop paths we don't generate names (yet).
				local ident         = astNewNode(AstIdentifier, statement.token, forLoop)
				ident.name          = "it"
				ident.placeDeclared = forLoop
				-- @Incomplete: Add declarations to AstFor and set ident.declaration.
				table.insert(forLoop.names, ident)
			end

			if #forLoop.expressions < 2 then
				!ERROR_OR_RETURN `errorParsingAfterLast(state, "Expected 2 or 3 parameters for the numeric 'for' loop.")`

			elseif #forLoop.expressions > 3 then
				!ERROR_OR_RETURN `errorParsing(state, forLoop.expressions[4].token-1, "Expected 2 or 3 parameters for the numeric 'for' loop.")`
			end

		elseif forLoop.forType == !(FOR_SHORT) then
			-- for v1, ... : obj
			if twoParter then
				state.nextToken = forStartIndex
				!DO_OR_RETURN `parseNameList(state, forLoop, forLoop.names)`

				tokType, tokValue = consumeNextToken(state) -- Should eat the ':'.
				assert(isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":"))

				!DO_OR_RETURN `parseExpressionList(state, forLoop, forLoop.expressions)`

				if forLoop.expressions[2] then
					!ERROR_OR_RETURN `errorParsing(state, forLoop.expressions[2].token-1, "Expected a single parameter for the short-form 'for' loop.")`
				end

				-- @Incomplete: Generate 'itIndex' name for arrays (and more?) if necessary (when types are figured out).

			-- for obj
			else
				forLoop.expressions = exprListWeMayOrMayNotUse
				assert(#forLoop.expressions == 1)

				-- @Incomplete: Generate 'it' and 'itIndex' names for arrays (and more?) if necessary (when types are figured out).
			end

		-- for v1, ... in iter [, state [, init ] ]
		else
			state.nextToken = forStartIndex
			!DO_OR_RETURN `parseNameList(state, forLoop, forLoop.names)`

			tokType, tokValue = consumeNextToken(state) -- Should eat the 'in'.
			assert(isToken(tokType,tokValue, !(TOKEN_KEYWORD),"in"))

			!DO_OR_RETURN `parseExpressionList(state, forLoop, forLoop.expressions)`
		end

		!SET_OR_RETURN `forLoop.body = parseBlockOrScopedStatement(state, forLoop)`
		statement.what               = forLoop

	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import","load") then
		!SET_OR_RETURN `statement.what = parseImportOrLoad(state, statement)`

	else
		state.soft     = true
		local exprTest = parseExpression(state, statement)
		state.soft     = false

		if not exprTest then
			!ERROR_OR_RETURN `
				printerr()
				parserMessage(io.stderr, state, statement.token, "Error", "Could not parse statement starting here.")

				state.nextToken = statement.token
				parseExpression(state, statement) -- Should call exitFailure() at some point.
				exitFailure() -- Just to be safe.
			`

		elseif exprTest.nodeType == !(nodeTypes.AstCall) then
			local call = exprTest
			--[[ @Incomplete :ParenthesisAmbiguityError
			if
				isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
				and call.callee.nodeType == !(nodeTypes.AstCall)
				and astGetCalleeVisuallyFurthestToTheLeft(call).nodeType == !(nodeTypes.AstIdentifier)
			then
				!ERROR_OR_RETURN `errorParsing(state, statement.token, "Ambigous expression being called.")`
			end
			--]]
			statement.what = call

		else
			state.nextToken                = statement.token
			!SET_OR_RETURN `statement.what = parseAssignment(state, statement)`
		end
	end

	tokType, tokValue = peekNextToken(state)
	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),";") then
		consumeNextToken(state)
	end

	return statement
end

function _G.parseBlock(state, parentNode)
	-- Note: We assume the '{' has been consumed already.

	local blockStartToken     = state.nextToken
	local block               = astNewNode(AstBlock, blockStartToken, parentNode)

	local statementStartToken = blockStartToken
	local lastNodeType        = 0

	while true do
		local tokType, tokValue, token = peekNextToken(state)

		if not tokType then
			!ERROR_OR_RETURN `errorParsing(state, blockStartToken, "Unfinished block.")`

		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			consumeNextToken(state)
			break

		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),";") then
			consumeNextToken(state)
			-- We allow empty statement like Lua 5.2+ does (so things like ';(x and func1 or func2)()'
			-- always work, no matter what comes previously). :EmptyStatement
			if not state.soft then  parserMessageLine(io.stderr, state, token, "Warning", "Empty statement.")  end

		else
			if isAny(lastNodeType, !(nodeTypes.AstReturn),!(nodeTypes.AstBreak),!(nodeTypes.AstContinue)) then
				local nodeTitle
					=  lastNodeType == !(nodeTypes.AstReturn)   and "Return"
					or lastNodeType == !(nodeTypes.AstBreak)    and "Break"
					or lastNodeType == !(nodeTypes.AstContinue) and "Continue"
					or assert(lastNodeType)

				-- @Incomplete: If it's a return statement, tell whether the function wants any values returned.
				!ERROR_OR_RETURN `errorParsing(state, statementStartToken, "%s statements must be at the end of the scope.", nodeTitle)`
			end

			statementStartToken             = state.nextToken
			!SET_OR_RETURN `local statement = parseStatement(state, block)`

			table.insert(block, statement)
			lastNodeType = statement.what.nodeType
		end
	end

	return block
end

-- block = parseBlockOrScopedStatement( compilationState, parentNode )
function _G.parseBlockOrScopedStatement(state, parentNode)
	local tokType, tokValue, token = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		consumeNextToken(state)
		return parseBlock(state, parentNode) -- May return nil.
	end

	local block = astNewNode(AstBlock, token, parentNode)

	!SET_OR_RETURN `local statement = parseStatement(state, block)`
	table.insert(block, statement)

	return block
end

function _G.parseImportOrLoad(state, parentNode)
	local import = astNewNode(AstImport, state.nextToken, parentNode)

	local tokType, tokValue = consumeNextToken(state)
	if isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import") then
		-- void
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"load") then
		import.isLoad = true
	else
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected '!load' or '!import'.")`
	end

	local tokType, tokValue = consumeNextToken(state)
	if tokType ~= !(TOKEN_STRING) then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected a string.")`
	end
	import.importName = tokValue

	return import
end

function _G.parseFileScope(state, parentNode, path)
	local fileScope = astNewNode(AstFileScope, state.nextToken, parentNode)
	fileScope.path  = path

	while true do
		local tokType, tokValue, token = peekNextToken(state)

		if not tokType then
			break

		elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import","load") then
			-- @Incomplete: Warn about duplicate imports? Maybe not necessay as things will only ever be imported once anyway.
			!SET_OR_RETURN `local import = parseImportOrLoad(state, fileScope)`
			table.insert(fileScope.imports, import)

		elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"local","global","export") then
			!SET_OR_RETURN `local decl = parseDeclaration(state, fileScope)`
			table.insert(fileScope.declarations, decl)

		elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"using") then
			!ERROR_OR_RETURN `errorParsingNext(state, "@Incomplete: Handle '%s'.", tokValue)`

		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),";") then
			consumeNextToken(state)
			if not state.soft then  parserMessageLine(io.stderr, state, token, "Warning", "Empty statement.")  end -- :EmptyStatement

		else
			!ERROR_OR_RETURN `errorParsingNext(state, "Expected file level declaration.")`
		end
	end

	return fileScope
end

-- call = parseCall( compilationState, parentNode, couldBeType [, callee=theFollowingIdentifier, isMethod=false ] )
function _G.parseCall(state, parentNode, couldBeType, callee, isMethod)
	assert(type(couldBeType) == "boolean")

	if not callee then
		!SET_OR_RETURN `callee = parseIdentifier(state, parentNode)` -- We'll update the parent later.
	end

	isMethod = isMethod or false
	local call

	while true do
		local tokType, tokValue, token = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected '('.")`
		end

		call              = astNewNode(AstCall, token, parentNode)
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			consumeNextToken(state)

			-- Should struct arguments be able to have default values, allowing foo()
			-- to possibly be a type?
			couldBeType = false

		else
			!DO_OR_RETURN `parseExpressionList(state, call, call.arguments)`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')' or ','.")`
			end
		end

		call.couldBeTypeWithParameters = couldBeType

		callee.parent = call
		call.callee   = callee
		call.isMethod = isMethod

		tokType, tokValue = peekNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then  break  end

		call.couldBeTypeWithParameters = false
		callee   = call
		isMethod = false
	end

	return call
end

-- parseLambda( compilationState, parentNode [, allowBody=false ] )
function _G.parseLambda(state, parentNode, allowBody)
	-- Note: We assume the initial '(' has been consumed already.

	local lambda = astNewNode(AstLambda, state.nextToken-1, parentNode)

	-- In args.
	local tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
		consumeNextToken(state)

	else
		!SET_OR_RETURN `lambda.argumentsIn = parseArguments(state, lambda, true, lambda)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end
	end

	-- Out args.
	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"->") then
		consumeNextToken(state)
		local argsOutStartToken = state.nextToken

		tokType, tokValue = peekNextToken(state)

		-- (...) -> void
		if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"void") then
			consumeNextToken(state)

			-- The following error detection erroneously matches some valid situations, e.g.:
			-- local funcSig, Bool :: ()->void, bool

			--[[
			tokType, tokValue = peekNextToken(state)
			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
				!ERROR_OR_RETURN `errorParsingNext(state, "Argument list with 'void' cannot have other arguments.")`
			end
			--]]

		-- (...) -> (name:type, ...)
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			consumeNextToken(state)
			tokType, tokValue = peekNextToken(state)

			-- '()' is the same as 'void'.
			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
				consumeNextToken(state)

			else
				!SET_OR_RETURN `lambda.argumentsOut = parseArguments(state, lambda, false, lambda)`

				tokType, tokValue = consumeNextToken(state)
				if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
					!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
				end
			end

			-- If the return type is a function signature, i.e. () -> () -> ...
			tokType, tokValue = peekNextToken(state)
			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"->") then
				state.nextToken = argsOutStartToken
				!SET_OR_RETURN `lambda.argumentsOut = parseNamelessArguments(state, lambda, lambda)` -- Replace any argumentsOut we just parsed.
			end

		-- (...) -> type, ...
		else
			!SET_OR_RETURN `lambda.argumentsOut = parseNamelessArguments(state, lambda, lambda)`
		end
	end

	-- Body.
	if allowBody then
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
			consumeNextToken(state)
			!SET_OR_RETURN `lambda.body = parseBlock(state, lambda)`
		end
	end

	return lambda
end



-- expression = parseExpression( compilationState, parentNode [, minOperatorPrecedence, expectLeftValue=false ] )
function _G.parseExpression(state, parentNode, minOpPrecedence, expectLeftValue)
	-- @Robustness: Check that parents are set correctly everywhere in here.

	minOpPrecedence = minOpPrecedence or 0

	local tokType,  tokValue, exprStartToken = consumeNextToken(state)
	local tokType2, tokValue2                = peekNextToken(state, 1)
	local tokType3, tokValue3                = peekNextToken(state, 2)
	local expr, token

	local encounteredParenthesis = false

	-- Function call or type with parameters.
	--
	-- Note: We also detect function calls later by the binary operations.
	-- The difference is that here we may have a type.
	--
	if
		tokType == !(TOKEN_IDENTIFIER)
		and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"(")
	then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseCall(state, parentNode, true)`

	-- Built-in type.
	elseif isTokenBuiltinType(tokType, tokValue) then
		local typeNode    = astNewNode(AstType, exprStartToken, parentNode)
		typeNode.typeName = tokValue
		expr              = typeNode

		-- @Polish: Check if there's a '(' after this and give error early.

	-- Identifier or literal.
	elseif tokType == !(TOKEN_IDENTIFIER) or isTokenLiteral(tokType, tokValue) then
		if tokType == !(TOKEN_IDENTIFIER) then
			local ident = astNewNode(AstIdentifier, exprStartToken, parentNode)
			ident.name  = tokValue
			expr        = ident

		elseif tokType == !(TOKEN_KEYWORD) then
			local literal = astNewNode(AstLiteral, exprStartToken, parentNode)

			if tokValue == "nil" then
				literal.literalType = !(LITERAL_NIL)
				literal.value       = nil
			else
				literal.literalType = !(LITERAL_BOOLEAN)
				literal.value       = tokValue == "true"
			end

			expr = literal

		else
			local literal       = astNewNode(AstLiteral, exprStartToken, parentNode)
			literal.literalType = TOKEN_TYPE_TO_LITERAL_TYPE[tokType]
			literal.value       = tokValue
			expr                = literal
		end

	-- Vararg.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"...") then
		expr = astNewNode(AstVararg, exprStartToken, parentNode)

	-- Table constructor.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		!SET_OR_RETURN `expr = parseTable(state, parentNode)`

	-- Unary operation.
	elseif
		isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"+","-","#") or
		isToken(tokType,tokValue, !(TOKEN_KEYWORD),"not")
	then
		local unaryOp                      = astNewNode(AstUnary, exprStartToken, parentNode)
		unaryOp.operation                  = tokValue
		!SET_OR_RETURN `unaryOp.expression = parseExpression(state, unaryOp, OPERATOR_PRECEDENCE.unary)`
		expr                               = unaryOp

	-- Function signature (type) or lambda.
	--
	--     inArgs [-> outArgs] [body]
	--
	--     inArgs  = ( [ inArg1, ... ] )
	--     inArg   = name1 [, ... ] : type [ = defaultValue ]
	--     outArgs = void
	--     outArgs = type1 [, ... ]
	--     outArgs = ( outArg1 [, ... ] )
	--     outArg  = name1 [, ... ] : type
	--     body    = { ... }
	--
	elseif
		isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
		and (
			isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),")")
			or (
				(
					isToken(tokType2,tokValue2, !(TOKEN_IDENTIFIER))
					or isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"...")
				)
				and isToken(tokType3,tokValue3, !(TOKEN_PUNCTUATION),":",",")
			)
		)
	then
		!SET_OR_RETURN `local lambda = parseLambda(state, parentNode, true)`

		if lambda.body then
			expr = lambda
		else
			local typeNode             = astNewNode(AstType, lambda.token, parentNode)
			typeNode.isUserType        = true
			typeNode.functionSignature = lambda
			lambda.parent              = typeNode
			expr                       = typeNode
		end

	-- Parenthesis (must be detected after lambda).
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
		encounteredParenthesis = true
		!SET_OR_RETURN `expr   = parseExpression(state, parentNode)`

		if isAny(expr.nodeType, !(nodeTypes.AstCall), !(nodeTypes.AstVararg)) then
			-- This is so we know whether to adjust the return values to one or not in certain situations.
			-- Note: Functions with a return argument after the first one marked as #must cannot have their
			-- return arguments adjusted to one.
			expr.surroundedByParenthesis = true
		end

		tokType, tokValue = consumeNextToken(state)

		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		--[[ @Incomplete :ParenthesisAmbiguityError
		if expectLeftValue and expr.nodeType == !(nodeTypes.AstIdentifier) then
			!ERROR_OR_RETURN `errorParsing(state, exprStartToken, "Unexpected parenthesis around identifier.")`
		end
		--]]

	-- Cast.
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"cast") then
		tokType, tokValue, token = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '('.")`
		end

		local cast                      = astNewNode(AstCast, token-1, parentNode)
		!SET_OR_RETURN `cast.targetType = parseType(state, cast)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		!SET_OR_RETURN `cast.expression = parseExpression(state, cast, math.huge)` -- @Incomplete: Give casting an operator precedence.
		expr                            = cast

	-- Type.
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"type") then
		-- Note: parseType() does not recognize !type which is why you can't put
		-- the directive anywhere a type is expected. Should we change this?
		!SET_OR_RETURN `expr = parseType(state, parentNode)`

	elseif
		isToken(tokType,tokValue, !(TOKEN_KEYWORD),"type_of") or
		isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[")
	then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseType(state, parentNode)`

	elseif
		isToken(tokType,tokValue, !(TOKEN_KEYWORD),"type_of") or
		isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[")
	then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseType(state, parentNode)`

	-- Unicode codepoint.
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"char") then
		tokType, tokValue, token = consumeNextToken(state)

		if not isToken(tokType,tokValue, !(TOKEN_STRING)) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected a string.")`
		elseif tokValue == "" then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected a UTF-8 character in the string.")`
		elseif tokValue:find!("^"..UTF8_CHARACTER_PATTERN.."$") then
			-- void
		elseif tokValue:find!("^"..UTF8_CHARACTER_PATTERN) then
			!ERROR_OR_RETURN `errorParsingLast(state, "The string must contain a single UTF-8 character.")`
		else
			!ERROR_OR_RETURN `errorParsingLast(state, "Invalid UTF-8 string.")`
		end

		local literal       = astNewNode(AstLiteral, token, parentNode)
		literal.literalType = !(LITERAL_INTEGER)
		literal.value       = utf8Codepoint(tokValue)

		expr = literal

	-- Import/load.
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import","load") then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseImportOrLoad(state, parentNode)`
		-- !ERROR_OR_RETURN `errorParsingLast(state, "Invalid place for '!%s'.", tokValue)`

	-- Struct/enum.
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"struct") then
		-- consumeNextToken(state)
		!SET_OR_RETURN `expr = parseStruct(state, parentNode)` -- @Cleanup: Make this an AstType node instead.
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"enum") then
		-- consumeNextToken(state)
		!SET_OR_RETURN `expr = parseEnum(state, parentNode)` -- @Cleanup: Make this an AstType node instead.

	else
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected a value.")`
	end

	-- Binary operations.
	local nextCanBeMethodCall = false

	while true do
		tokType,  tokValue, token = peekNextToken(state, 1)
		tokType2, tokValue2       = peekNextToken(state, 2)

		local thisCanBeMethodCall = nextCanBeMethodCall
		nextCanBeMethodCall       = false

		if not tokType then
			break

		-- Arithmetic opration, comparison or string concatination.
		-- @Incomplete: Combine string concatinations in some way?
		elseif (
			isToken(tokType,tokValue, !(TOKEN_KEYWORD),"and","or")
			or isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),
				"+","-","*","/","//","^","%","<",">","<=",">=","==","~=",".."
			)
		) and OPERATOR_PRECEDENCE[tokValue] >= minOpPrecedence then
			consumeNextToken(state)

			local binOp                 = astNewNode(AstBinary, token, parentNode)
			binOp.operation             = tokValue
			binOp.left                  = expr
			!SET_OR_RETURN `binOp.right = parseExpression(state, binOp, OPERATOR_PRECEDENCE[tokValue])`
			expr.parent                 = binOp
			expr                        = binOp

		-- Table lookup or similar using '.'.
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),".")
			and OPERATOR_PRECEDENCE["."] > minOpPrecedence -- Note: Not using >= here.
		then
			consumeNextToken(state)

			local binOp     = astNewNode(AstBinary, token, parentNode)
			binOp.operation = "."

			tokType, tokValue, token = consumeNextToken(state)
			if tokType ~= !(TOKEN_IDENTIFIER) then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected an identifier.")`
			end

			local literal       = astNewNode(AstLiteral, token, binOp)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = tokValue

			binOp.left          = expr
			binOp.right         = literal

			expr.parent         = binOp
			expr                = binOp

			nextCanBeMethodCall = true

		-- Table lookup or similar using '['.
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[")
			and OPERATOR_PRECEDENCE["."] > minOpPrecedence -- Note: Not using >= here.
		then
			consumeNextToken(state)

			local binOp                 = astNewNode(AstBinary, token, parentNode)
			binOp.operation             = "."
			binOp.left                  = expr
			!SET_OR_RETURN `binOp.right = parseExpression(state, binOp, OPERATOR_PRECEDENCE[tokValue])`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION), "]") then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected ']'.")`
			end

			expr.parent = binOp
			expr        = binOp

		-- Function call.
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
			and OPERATOR_PRECEDENCE.call >= minOpPrecedence
		then
			!SET_OR_RETURN `expr = parseCall(state, parentNode, false, expr, false)`

		-- Method call.
		elseif
			(
				isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"!")
				and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"(")
			)
			and OPERATOR_PRECEDENCE.call >= minOpPrecedence
		then
			tokType, tokValue = peekLastToken(state)

			if not isToken(tokType,tokValue, !(TOKEN_IDENTIFIER)) then
				!ERROR_OR_RETURN `errorParsingNext(state, "Expected a method name before this.")`
			elseif not thisCanBeMethodCall then
				putBackLastToken(state)
				!ERROR_OR_RETURN `errorParsingNext(state, "Expected an object to call a method on.")`
			end

			consumeNextToken(state)
			!SET_OR_RETURN `expr = parseCall(state, parentNode, false, expr, true)`

		else
			break
		end
	end

	if expectLeftValue then
		if expr.nodeType == !(nodeTypes.AstIdentifier) then
			if encounteredParenthesis then
				!ERROR_OR_RETURN `errorParsing(state, exprStartToken, "Unexpected parenthesis around identifier.")` -- :ParenthesisAmbiguityError
			end
		elseif expr.nodeType == !(nodeTypes.AstBinary) and expr.operation == "." then
			-- void
		else
			tokType, tokValue = peekNextToken(state)
			if isTokenAssigning(tokType, tokValue) then
				!ERROR_OR_RETURN `errorParsingAfterLast(
					state,
					"Expected '.' and a table field name as an assignment target to the left of '%s'. Ambigous expression.",
					tokValue
				)`
			else
				!ERROR_OR_RETURN `errorParsing(state, exprStartToken, "Ambigous expression.")`
			end
		end
	end

	return expr
end



-- tokenType, tokenValue, tokenIndex = consumeNextToken( compilationState )
function _G.consumeNextToken(state)
	local i         = state.nextToken
	state.nextToken = i+1
	local tokType, tokValue = getToken(state.tokens, i)
	return tokType, tokValue, i
end

-- tokenType, tokenValue, tokenIndex = peekNextToken( compilationState [, steps=1 ] )
function _G.peekNextToken(state, steps)
	steps   = steps or 1
	local i = state.nextToken+steps-1
	local tokType, tokValue = getToken(state.tokens, i)
	return tokType, tokValue, i
end

function _G.peekLastToken(state)
	return getToken(state.tokens, state.nextToken-1)
end

function _G.putBackLastToken(state)
	state.nextToken = state.nextToken-1
	assert(state.nextToken >= 1)
end



-- errorParsing( compilationState, tokenIndex, formatString, ... )
function _G.errorParsing(state, i, s, ...)
	local tokens = state.tokens

	local path
		=  tokens.file[i]
		or tokens.file[1] -- Not great, but better than crashing.
		or errorInternal(2, "No tokens.")

	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)

	local ptr
		=  tokens.position1[i]
		or i <= 1 and 1
		or tokens.count > 0 and tokens.position2[tokens.count]+1
		or #buffer

	errorInFile(buffer, path, ptr, "Parser", s, ...)
end

-- parserMessage( [ outputFile=io.stdout, ] compilationState, token, label, formatString, ... )
function _G.parserMessage(file, state, token, label, s, ...)
	if type(file) ~= "userdata" then  return parserMessage(io.stdout, file, state, token, label, s, ...)  end

	local tokens = state.tokens
	local path   = tokens.file[token]      or errorInternal(2, "No tokens.")
	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)
	reportMessageInFile(file, buffer, path, tokens.position1[token], label, "Parser", s, ...)
end

-- parserMessageLine( [ outputFile=io.stdout, ] compilationState, token, label, formatString, ... )
function _G.parserMessageLine(file, state, token, label, s, ...)
	if type(file) ~= "userdata" then  return parserMessageLine(io.stdout, file, state, token, label, s, ...)  end

	local tokens = state.tokens
	local path   = tokens.file[token] or errorInternal(2, "No tokens.")
	reportMessageOnLine(file, path, tokens.line1[token], label, "Parser", s, ...)
end

-- errorParsingAfter( compilationState, tokenIndex, formatString, ... )
function _G.errorParsingAfter(state, i, s, ...)
	local tokens = state.tokens

	local path
		=  tokens.file[i]
		or tokens.file[1] -- Not great, but better than crashing.
		or errorInternal(2, "No tokens.")

	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)

	local ptr
		=  tokens.position2[i] and tokens.position2[i]+1
		or i <= 1 and 1
		or tokens.count > 0 and tokens.position2[tokens.count]+1
		or #buffer

	errorInFile(buffer, path, ptr, "Parser", s, ...)
end

function _G.errorParsingLast(state, ...)
	errorParsing(state, state.nextToken-1, ...)
end
function _G.errorParsingNext(state, ...)
	errorParsing(state, state.nextToken, ...)
end

function _G.errorParsingAfterPrevious(state, ...)
	errorParsingAfter(state, state.nextToken-2, ...)
end
function _G.errorParsingAfterLast(state, ...)
	errorParsingAfter(state, state.nextToken-1, ...)
end

function _G.errorUnhandledNodeType(node)
	!if DEBUG then
		astPrintTree(node)
	!end
	errorInternal(2, "Incomplete: Unhandled node type '%s'.", (AST_NODE_TYPE_NAMES[node.nodeType] or node.nodeType))
end



-- astPrint    ( [ outputFile=io.stdout, ] node )
-- astPrintTree( [ outputFile=io.stdout, ] node )
do
	local file
	local printNode -- Forward declaration.

	local function write(...)
		file:write(...)
	end

	local function printNodeList(list, indent, printed, printChildren, keyPrefix)
		for i, node in ipairs(list) do
			printNode(node, indent, printed, printChildren, (keyPrefix and keyPrefix..i))
		end
	end

	function printNode(node, indent, printed, printChildren, keyName)
		!local INDENT            = "    "
		!local CHILD_PRINT_START = "if not printChildren then write('\\n') else write('" .. (PRINT_NODE_BRACKETS and " {" or "") .. "\\n')"
		!local CHILD_PRINT_END   = (PRINT_NODE_BRACKETS and "write(indentStr, '}\\n') " or "") .. "end"

		local indentStr = (!(INDENT)):rep(indent)

		assert(node.s)

		write(indentStr)
		if keyName then  write(keyName, " ")  end
		write(AST_NODE_TYPE_NAMES[node.nodeType] or "?")
		write(" @", node.s)
		if node.parent then  write(" ^", node.parent.s)  end

		if printed[node] then
			write("  !!! ERROR: RECURSION DETECTED !!!\n")
		else
			printed[node] = true

			if node.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = node
				write(" (", ident.name, ")\n")

			elseif node.nodeType == !(nodeTypes.AstBinary) then
				local binOp = node
				write(" (", binOp.operation, ")")
				!!(CHILD_PRINT_START)
				if binOp.left  then  printNode(binOp.left,  indent+1, printed, printChildren)  end
				write(indentStr, !(INDENT.."op "), binOp.operation, "\n")
				if binOp.right then  printNode(binOp.right, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstUnary) then
				local unaryOp = node
				write(" (", unaryOp.operation, ")")
				!!(CHILD_PRINT_START)
				if unaryOp.expression then  printNode(unaryOp.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstDeclaration) then
				local decl = node
				if decl.isConstant and decl.isGlobalOrExported then
					write(" (global/exported const)")
				elseif decl.isConstant then
					write(" (const)")
				elseif decl.isGlobalOrExported then
					write(" (global/exported)")
				end
				!!(CHILD_PRINT_START)
				printNodeList(decl.names,  indent+1, printed, printChildren, "NAME")
				printNodeList(decl.types,  indent+1, printed, printChildren, "TYPE")
				if decl.assignment then  printNode(decl.assignment, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstTable) then
				local tableNode = node
				!!(CHILD_PRINT_START)
				for i, tableField in ipairs(tableNode) do
					if tableField.key   then  printNode(tableField.key,   indent+1, printed, printChildren, i.."K")  end
					if tableField.value then  printNode(tableField.value, indent+1, printed, printChildren, i.."V")  end
				end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstCall) then
				local call = node
				assert(not (call.couldBeTypeWithParameters and call.isMethod))
				if call.couldBeTypeWithParameters then  write(" (couldBeType)")    end
				if call.isMethod                  then  write(" (method)")         end
				if call.surroundedByParenthesis   then  write(" (adjustArgsTo1)")  end
				!!(CHILD_PRINT_START)
				if call.callee then  printNode(call.callee, indent+1, printed, printChildren)  end
				printNodeList(call.arguments, indent+1, printed, printChildren, "ARG")
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstLambda) then
				local lambda = node
				local decl   = astFindParent(lambda, !(nodeTypes.AstDeclaration))
				local i      = decl and decl.assignment and indexOf(decl.assignment.values, lambda)
				if i then  write(" (", decl.names[i].name, ")")  end
				!!(CHILD_PRINT_START)
				if lambda.argumentsIn then
					printNode(lambda.argumentsIn, indent+1, printed, printChildren, "IN")
					-- printNodeList(lambda.argumentsIn, indent+1, printed, printChildren, "IN")
				end
				if lambda.argumentsOut then
					printNode(lambda.argumentsOut, indent+1, printed, printChildren, "OUT")
					-- printNodeList(lambda.argumentsOut, indent+1, printed, printChildren, "OUT")
				end
				if lambda.body then  printNode(lambda.body, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstArguments) then
				local args = node
				!!(CHILD_PRINT_START)
				printNodeList(args, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstArgument) then
				local arg = node
				!!(CHILD_PRINT_START)
				if arg.declaration then  printNode(arg.declaration, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstBlock) then
				-- @Incomplete: We don't print blocks.declarations as they already exist among the statements.
				local block = node
				!!(CHILD_PRINT_START)
				printNodeList(block, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstStatement) then
				local statement = node
				!!(CHILD_PRINT_START)
				if statement.what then  printNode(statement.what, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstType) then
				local typeNode = node
				if typeNode.typeName ~= "" then  write(" (", typeNode.typeName, ")")  end
				!!(CHILD_PRINT_START)
				if typeNode.functionSignature then
					printNode(typeNode.functionSignature, indent+1, printed, printChildren)
				elseif typeNode.arguments then
					printNodeList(typeNode.arguments, indent+1, printed, printChildren, "ARG")
				end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstTypeOf) then
				local typeOf = node
				!!(CHILD_PRINT_START)
				if typeOf.expression then  printNode(typeOf.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstAssignment) then
				local assignment = node
				write(" (", assignment.operation, ")")
				!!(CHILD_PRINT_START)
				printNodeList(assignment.targets, indent+1, printed, printChildren)
				write(indentStr, !(INDENT.."op "), assignment.operation, "\n")
				printNodeList(assignment.values, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstCast) then
				local cast = node
				!!(CHILD_PRINT_START)
				if cast.targetType then  printNode(cast.targetType, indent+1, printed, printChildren)  end
				if cast.expression then  printNode(cast.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstIf) then
				local ifBranch = node
				!!(CHILD_PRINT_START)
				if ifBranch.condition   then  printNode(ifBranch.condition,   indent+1, printed, printChildren)           end
				if ifBranch.branchTrue  then  printNode(ifBranch.branchTrue,  indent+1, printed, printChildren, "TRUE")   end
				if ifBranch.branchFalse then  printNode(ifBranch.branchFalse, indent+1, printed, printChildren, "FALSE")  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstWhile) then
				local whileLoop = node
				!!(CHILD_PRINT_START)
				if whileLoop.condition then  printNode(whileLoop.condition, indent+1, printed, printChildren)  end
				if whileLoop.body      then  printNode(whileLoop.body,      indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstFor) then
				local forLoop = node
				write(" (", FOR_TITLES[forLoop.forType], ")")
				!!(CHILD_PRINT_START)
				printNodeList(forLoop.names,       indent+1, printed, printChildren, "NAME")
				printNodeList(forLoop.expressions, indent+1, printed, printChildren, "EXPR")
				if forLoop.body then  printNode(forLoop.body, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstReturn) then
				local returnNode = node
				!!(CHILD_PRINT_START)
				printNodeList(returnNode.values, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif isAny(node.nodeType, !(nodeTypes.AstBreak), !(nodeTypes.AstContinue)) then
				local breakOrContinue = node
				if breakOrContinue.loopName then  write(" (", breakOrContinue.loopName.name, ")")  end
				write("\n")

			elseif node.nodeType == !(nodeTypes.AstDefer) then
				local defer = node
				!!(CHILD_PRINT_START)
				if defer.body then  printNode(defer.body, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstImport) then
				local import = node
				write(" (", (import.isLoad and "load " or "import "), import.importName, ")")
				write("\n")

			elseif node.nodeType == !(nodeTypes.AstVararg) then
				local vararg = node
				if vararg.surroundedByParenthesis then  write(" (adjustTo1)")  end
				write("\n")

			elseif node.nodeType == !(nodeTypes.AstTypeDefinition) then
				local defn = node
				assert(defn.typeInfo)
				write(" (")
				write(defn.name.name)
				write(", ", getFriendlyTypeInfoName(defn.typeInfo))
				if defn.typeInfoForDeclaration then  write(", ", getFriendlyTypeInfoName(defn.typeInfoForDeclaration))  end
				write(")\n")

			elseif node.nodeType == !(nodeTypes.AstGlobalScope) then
				local globalScope = node
				!!(CHILD_PRINT_START)
				printNodeList(globalScope.fileScopes, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(nodeTypes.AstLiteral) then
				local literal = node
				write(" (")

				if isAny(literal.literalType, !(LITERAL_BOOLEAN),!(LITERAL_NIL)) then
					write(tostring(literal.value))

				else
					!local MAX_CHARS = 100
					local vStr = tostring(literal.value):sub(1, !(MAX_CHARS))

					vStr = vStr:gsub(".", function(c)
						local byte = c:byte()
						return
							byte == !(("\n"):byte())   and "{NL}"  or
							byte == !(("\r"):byte())   and "{CR}"  or
							byte == !(("\t"):byte())   and "{TAB}" or
							byte >= 32 and byte <= 126 and c       or -- Printable ASCII characters.
							"?"
					end)

					write(LITERAL_TITLES[literal.literalType])

					if literal.literalType == !(LITERAL_STRING) then
						write("(", #literal.value, ")")
					end

					if vStr ~= "" then  write(": ", vStr:sub(1, !(MAX_CHARS)))  end
				end

				write(")\n")

			elseif node.declarations then
				if node.nodeType == !(nodeTypes.AstFileScope) then
					local fileScope = node
					write(" (", fileScope.path, ")")
				end
				if isAny(node.nodeType, !(nodeTypes.AstStruct),!(nodeTypes.AstEnum)) then
					local structOrEnum = node
					local typeInfo     = structOrEnum.representedType
					if typeInfo and typeInfo.name ~= "" then  write(" (", typeInfo.name, ")")  end
				end

				!!(CHILD_PRINT_START)
				if node.nodeType == !(nodeTypes.AstStruct) and node.arguments then
					printNodeList(node.arguments, indent+1, printed, printChildren)
				end
				if node.imports then  printNodeList(node.imports, indent+1, printed, printChildren)  end
				printNodeList(node.declarations, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			else
				write("\n")
			end
		end
	end

	function _G.astPrintTree(_file, node)
		if type(_file) ~= "userdata" then  _file, node = io.stdout, _file  end
		file = _file
		printNode(node, 0, {}, true)
	end

	function _G.astPrint(_file, node)
		if type(_file) ~= "userdata" then  _file, node = io.stdout, _file  end
		file = _file
		printNode(node, 0, {}, false)
	end
end



-- parent, childClosestToParent = astFindParent( node, nodeType1, ... )
function _G.astFindParent(node, ...)
	local lastNode = node

	while true do
		node = node.parent
		if not node                  then  return nil,  nil       end
		if isAny(node.nodeType, ...) then  return node, lastNode  end

		lastNode = node
	end
end

function _G.astFindCommonParent(node1, node2)
	while true do
		node1 = node1.parent
		if not node1                  then  return nil    end
		if astHasParent(node2, node1) then  return node1  end
	end
end

function _G.astHasParent(node, parent)
	while true do
		node = node.parent
		if not node       then  return false  end
		if node == parent then  return true   end
	end
end



-- astVisitAllNodes           ( topNode, callback )
-- astVisitAllNodesLeavesFirst( topNode, callback )
-- [ controlValue = ] callback( node, container, key )  -- Not return anything is the same as returning VISIT_CONTINUE.
-- controlValue = VISIT_CONTINUE|VISIT_BREAK|VISIT_IGNORE_CHILDREN
-- Note: VISIT_IGNORE_CHILDREN does nothing when using astVisitAllNodesLeavesFirst().
do
	local function visit(visited, cb, leavesFirst, container, key, node)
		-- Note: We return true from this function if we want to break.
		!(
		local INDENT = ("\t"):rep(3)

		local function visitIfNotNil(var) return function(fieldNames)
			__LUA("\n",INDENT,"local subNode")
			for _, fieldName in ipairs(fieldNames) do
				__LUA("\n",INDENT,"subNode = ",var,".",fieldName)
				__LUA("\n",INDENT,"if subNode and visit(visited, cb, leavesFirst, ",var,", ",toLua(fieldName),", subNode) then  return true  end")
			end
		end end

		local function visitList(var) return function(fieldNames)
			__LUA("\n",INDENT,"local arr")
			for _, fieldName in ipairs(fieldNames) do
				__LUA("\n",INDENT,"arr = ",var) ; if fieldName ~= "" then  __LUA(".",fieldName)  end
				__LUA("\n",INDENT,"for i, subNode in ipairs(arr) do")
				__LUA("\n",INDENT,"\tif visit(visited, cb, leavesFirst, arr, i, subNode) then  return true  end")
				__LUA("\n",INDENT,"end ")
			end
		end end
		)

		assert(not visited[node])
		visited[node] = true

		if not leavesFirst then
			local controlValue = cb(node, container, key)
			if controlValue == !(VISIT_BREAK) then
				return true
			elseif controlValue == !(VISIT_IGNORE_CHILDREN) then
				return false
			end
		end

		if node.nodeType == !(nodeTypes.AstTypeDefinition)  then  -- void
		elseif node.nodeType == !(nodeTypes.AstIdentifier)  then  -- void
		elseif node.nodeType == !(nodeTypes.AstVararg)      then  -- void
		elseif node.nodeType == !(nodeTypes.AstLiteral)     then  -- void
		elseif node.nodeType == !(nodeTypes.AstType)        then
			!visitIfNotNil"node"{"functionSignature","arrayItemType"}
			if node.arguments then
				!visitList"node"{"arguments"}
			end
		elseif node.nodeType == !(nodeTypes.AstUnary)       then  !visitIfNotNil"node"{"expression"}
		elseif node.nodeType == !(nodeTypes.AstBinary)      then  !visitIfNotNil"node"{"left","right"}
		elseif node.nodeType == !(nodeTypes.AstTable)       then
			for _, tableField in ipairs(node) do
				!visitIfNotNil"tableField"{"key","value"}
			end
		elseif node.nodeType == !(nodeTypes.AstCall)        then  !visitIfNotNil"node"{"callee"} ; visitList"node"{"arguments"}
		elseif node.nodeType == !(nodeTypes.AstArgument)    then  !visitIfNotNil"node"{"declaration"}
		elseif node.nodeType == !(nodeTypes.AstArguments)   then  !visitList"node"{""}
		elseif node.nodeType == !(nodeTypes.AstLambda)      then  !visitIfNotNil"node"{"argumentsIn","argumentsOut","body"}
		elseif node.nodeType == !(nodeTypes.AstTypeOf)      then  !visitIfNotNil"node"{"expression"}
		elseif node.nodeType == !(nodeTypes.AstCast)        then  !visitIfNotNil"node"{"targetType","expression"}
		elseif node.nodeType == !(nodeTypes.AstStatement)   then  !visitIfNotNil"node"{"what"}
		elseif node.nodeType == !(nodeTypes.AstDeclaration) then  !visitList"node"{"names","types","notes"} ; visitIfNotNil"node"{"assignment"}
		elseif node.nodeType == !(nodeTypes.AstAssignment)  then  !visitList"node"{"targets","values"}
		elseif node.nodeType == !(nodeTypes.AstReturn)      then  !visitList"node"{"values"}
		elseif node.nodeType == !(nodeTypes.AstBreak)       then  !visitIfNotNil"node"{"loopName"}
		elseif node.nodeType == !(nodeTypes.AstContinue)    then  !visitIfNotNil"node"{"loopName"}
		elseif node.nodeType == !(nodeTypes.AstDefer)       then  !visitIfNotNil"node"{"body"}
		elseif node.nodeType == !(nodeTypes.AstImport)      then  -- void
		elseif node.nodeType == !(nodeTypes.AstIf)          then  !visitIfNotNil"node"{"condition","branchTrue","branchFalse"}
		elseif node.nodeType == !(nodeTypes.AstWhile)       then  !visitIfNotNil"node"{"condition","body"}
		elseif node.nodeType == !(nodeTypes.AstFor)         then  !visitList"node"{"names","expressions"} ; visitIfNotNil"node"{"body"}
		elseif node.nodeType == !(nodeTypes.AstStruct)      then  !visitList"node"{--[["includedNamespaces",]]"declarations"} ; visitIfNotNil"node"{"arguments"}
		elseif node.nodeType == !(nodeTypes.AstEnum)        then  !visitList"node"{--[["includedNamespaces",]]"declarations"} ; visitIfNotNil"node"{"memberType"}
		elseif node.nodeType == !(nodeTypes.AstFileScope)   then  !visitList"node"{"imports","declarations"}
		elseif node.nodeType == !(nodeTypes.AstGlobalScope) then  !visitList"node"{"fileScopes"}
		elseif node.nodeType == !(nodeTypes.AstBlock)       then  !visitList"node"{""}
		else
			errorUnhandledNodeType(node)
		end

		if leavesFirst and cb(node, container, key) == !(VISIT_BREAK) then
			return true
		end

		return false
	end

	function _G.astVisitAllNodes(node, cb)
		visit({}, cb, false, nil, nil, node)
	end

	function _G.astVisitAllNodesLeavesFirst(node, cb)
		visit({}, cb, true,  nil, nil, node)
	end
end



function _G.astCopy(node)
	-- @Incomplete: Copy/create new queued? Maybe that should be done by the caller?
	local copy

	if node.nodeType == !(nodeTypes.AstIdentifier) then
		local ident        = node
		copy               = astNewNode(AstIdentifier, ident.token, ident.parent)
		copy.name          = ident.name
		copy.placeDeclared = ident.placeDeclared
		copy.declaration   = ident.declaration
		copy.definition    = ident.definition

	else
		errorUnhandledNodeType(node)
	end

	return copy or errorInternal()
end



-- expression = astGetExpressionVisuallyFurthestToTheLeft( expression [, onlyFollowCalls=false ] )
function _G.astGetExpressionVisuallyFurthestToTheLeft(expr, onlyFollowCalls)
	if expr.nodeType == !(nodeTypes.AstCall) then
		local call = expr
		return astGetExpressionVisuallyFurthestToTheLeft(call.callee, onlyFollowCalls)

	elseif onlyFollowCalls then
		return expr

	elseif expr.nodeType == !(nodeTypes.AstBinary) then
		local binary = expr
		return astGetExpressionVisuallyFurthestToTheLeft(binary.left, false)

	else
		return expr
	end
end

-- expression = astGetCalleeVisuallyFurthestToTheLeft( call )
function _G.astGetCalleeVisuallyFurthestToTheLeft(call)
	return astGetExpressionVisuallyFurthestToTheLeft(call, true)
end


