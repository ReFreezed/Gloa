--[[============================================================
--=
--=  Parser
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	addDeclarationToNames
	astCopy, astCopyIdentifier
	astFindParent*, astFindParentScope, astFindCommonParent, astHasParent, astFindInTree, astFindInUnit*
	astFindTokenAtNode
	astGetDepth
	astGetExpressionVisuallyFurthestToThe*, astGetCalleeVisuallyFurthestToTheLeft
	astGetOriginal, astGetReplacement
	astIsOrIsInModule
	astMoveRelevantThingsFromFileScopeToGlobalScope
	astNewNode
	astPrint, astPrintTree
	astVisitAllNodes, astVisitAllNodesLeavesFirst, astVisitAllNodesInUnit
	errorParsing*, parserMessage*
	errorUnhandledNodeType, errorUnhandledType
	isLiteral
	isNodeAt
	newLiteral, newIdentifier
	nodeError, nodeMessage, where
	parseFileScope, parseBlockStatements
	peekNextTok

--============================================================]]
!recordLineNumber(@file, @line)

!local CHECK_FOR_VISITED_NODES = 1==0



--[[INSERT:parserFunctionLocals]]



!(
local PRINT_NODE_BRACKETS = 1==0

local function errorOrReturn(errCode, returnValueCode)
	__LUA("if state.soft then return ",returnValueCode," end ")
	__LUA(errCode)
end
local function ERROR_OR_RETURN_NIL  (errCode)              errorOrReturn(errCode, "nil")       end
local function ERROR_OR_RETURN_FALSE(errCode)              errorOrReturn(errCode, "false")     end
local function ERROR_OR_RETURN_VALUE(errCode, returnCode)  errorOrReturn(errCode, returnCode)  end

local function setOrReturn(assignmentCode, returnValueCode)
	local preCode, sufCode = assignmentCode:match"^([^=]+)=(.*)$"
	if not preCode then  error(assignmentCode)  end

	-- local x = ...
	if preCode:find"^%s*local%s" then
		local var = preCode:match"^%s*local%s+([%w_]+)" or error(preCode)
		__LUA(assignmentCode)
		__LUA(" if not ",var," then return ",returnValueCode," end ")

	-- x = ...
	elseif preCode:find"^%s*[%w_]+%s*$" then
		local var = preCode:match"[%w_]+" or error(preCode)
		__LUA(assignmentCode)
		__LUA(" if not ",var," then return ",returnValueCode," end ")

	-- x.y = ...
	else
		__LUA("local __value__ =",sufCode)
		__LUA(" if not __value__ then return ",returnValueCode," end ")
		__LUA(preCode,"= __value__")
	end
end
local function SET_OR_RETURN_NIL  (assignmentCode)  setOrReturn(assignmentCode, "nil"  )  end
local function SET_OR_RETURN_FALSE(assignmentCode)  setOrReturn(assignmentCode, "false")  end

local function doOrReturn(exprCode, returnValueCode)
	__LUA("if not (",exprCode,") then return ",returnValueCode," end")
end
local function DO_OR_RETURN_NIL  (exprCode)  doOrReturn(exprCode, "nil"  )  end
local function DO_OR_RETURN_FALSE(exprCode)  doOrReturn(exprCode, "false")  end
)



!(
local astTypeToStructName    = {}
_G.astStructNameToType       = {}
_G.scopeNodeTypes            = {}
_G.scopeNodeTypesDeclarative = {}
_G.scopeNodeTypesImperative  = {}

local function structAst(nameAndParent) return function(fields)
	local name        = nameAndParent:match"^[%w_]+"
	local scopeType   = fields._scopeType
	fields._scopeType = nil

	if not name:find"^_" then
		local nodeTypeField           = itemWith1(fields._overrides, 1, `nodeType`) or error(name)
		local nodeType                = nodeTypeField[2] or error(name)
		astTypeToStructName[nodeType] = name
		astStructNameToType[name]     = nodeType

		if scopeType then
			local scopesOfType
				=  scopeType == "declarative" and scopeNodeTypesDeclarative
				or scopeType == "imperative"  and scopeNodeTypesImperative
				or error(scopeType)

			table.insert(scopeNodeTypes, nodeType)
			table.insert(scopesOfType,   nodeType)
		end
	end

	struct(nameAndParent)(fields)
end end
)

!struct"_AstNode"{
	{`nodeType`,   0},
	{`s`,          0},   -- Serial number.
	{`parent`,     nil}, -- AstNode
	{`source`,     nil}, -- { path=realOrFakePath, string=actualSourceString }
	{`position`,   1},
	{`line`,       1},
	{`replacedBy`, nil}, -- AstNode
	{`replacing`,  nil}, -- AstNode
	-- Pipe phases:
	{`queued`,     nil}, -- Queued
}
_G.!structAst"AstDummy:_AstNode"{
	_overrides = {{`nodeType`,AST_DUMMY}},
}

!structAst"_AstExpression:_AstNode"{
	-- Type phase:
	{`inferredType`, nil}, -- TypeInfo
}
_G.!structAst"AstIdentifier:_AstExpression"{
	_overrides = {{`nodeType`,AST_IDENTIFIER}},
	{`kind`,        IDENT_KIND_LOOSE}, -- IDENT_KIND_IGNORE|IDENT_KIND_LOOSE|IDENT_KIND_ASSIGNMENT|IDENT_KIND_DECLARATION|IDENT_KIND_DECLARATION_ASSIGNMENT
	{`name`,        ""},
	-- Type phase:
	{`declaration`, nil, astRef="node"}, -- AstDeclaration
	{`fromUsing`,   nil, astRef="node"}, -- AstUsing
	{`fromVariant`, false}, -- Helps with value validation in declarations. @Ugly
}
_G.!structAst"AstVararg:AstIdentifier"{
	_overrides = {{`nodeType`,AST_VARARG}, {`name`,"..."}},
	{`surroundedByParentheses`, false},
}
_G.!structAst"AstBlank:AstIdentifier"{
	_overrides = {{`nodeType`,AST_BLANK}, {`name`,"_"}},
}
_G.!structAst"AstLiteral:_AstExpression"{
	_overrides = {{`nodeType`,AST_LITERAL}},
	{`literalType`,   0},
	{`value`,         nil}, -- The value depends on what literalType is. Could be a number, string or whatever.
	-- Emit phase:
	{`valueConstant`, nil}, -- Constant
}
_G.!structAst"AstType:_AstExpression"{
	_overrides = {{`nodeType`,AST_TYPE}},
	{`functionHeader`,    nil, ast="node"},    -- AstLambda without a body. This is used to create the actual function type.
	{`arrayItemType`,     nil, ast="node"},    -- AstType
	{`arguments`,         nil, ast="array"},   -- []AstExpression  Is set for parameterized structs.
	{`components`,        nil, ast="array"},   -- []AstExpression  Used if kind is TYPE_KIND_COMPOUND. Is set when needed.
	{`kind`,              TYPE_KIND_UNSET},    -- TYPE_KIND_SIMPLE_BUILTIN|TYPE_KIND_USER|TYPE_KIND_FUNCTION|TYPE_KIND_ARRAY|TYPE_KIND_COMPOUND
	{`typeName`,          ""},
	{`typeReferenceNode`, nil, astRef="node"}, -- AstExpression  Node that represents the type. (This is kind of a hack for !self.)
	-- Type phase:
	{`representedType`,   nil},                -- TypeInfo
	{`declaration`,       nil, astRef="node"}, -- AstDeclaration
}
_G.!structAst"AstUnary:_AstExpression"{
	_overrides = {{`nodeType`,AST_UNARY}},
	{`expression`, nil, ast="node"}, -- AstExpression
	{`operation`,  ""},              -- "-" or "not" etc.
}
_G.!structAst"AstBinary:_AstExpression"{
	_overrides = {{`nodeType`,AST_BINARY}},
	{`left`,      nil, ast="node"}, -- AstExpression
	{`right`,     nil, ast="node"}, -- AstExpression
	{`operation`, ""},  -- "+" or "-" etc.
}
_G.!structAst"AstAccess:_AstExpression"{
	_overrides = {{`nodeType`,AST_ACCESS}},
	{`object`, nil, ast="node"}, -- AstExpression
	{`member`, nil, ast="node"}, -- AstExpression
}
_G.!struct"KeyValuePair"{
	{`key`,            nil}, -- AstExpression
	{`value`,          nil}, -- AstExpression
	{`keyIsGenerated`, false},
	-- Type phase:
	{`argumentIndex`,  0},   -- Used for AstCall.argumentsNamed.
}
_G.!structAst"AstTable:_AstExpression"{
	_overrides = {{`nodeType`,AST_TABLE}},
	{`fields`,                {},  ast="fields"}, -- []KeyValuePair
	{`trailingExpression`,    nil, ast="node"},   -- AstVararg|AstCall  This expression potentially expands to multiple values in any resulting Lua table.
	{`highestGeneratedIndex`, 0},
}
_G.!structAst"AstCall:_AstExpression"{
	_overrides = {{`nodeType`,AST_CALL}},
	{`callee`,                  nil, ast="node"},   -- AstExpression
	{`arguments`,               {},  ast="array"},  -- []AstExpression  @Speed: Only set this when needed.
	{`argumentsNamed`,          {},  ast="fields"}, -- []KeyValuePair   @Speed: Only set this when needed.
	{`isMethod`,                false},
	{`surroundedByParentheses`, false},
	{`inline`,                  INLINE_MAY},
	-- Type phase:
	{`wantLocation`,            false}, -- Set if the called function has wantCallerLocation set (i.e. !caller_location is used somewhere).
	-- Emit phase:
	{`locationConstant`,        nil},   -- Constant  Optimization: Instead of generating this for every call we only do it if the callee may require it.
}
_G.!structAst"AstTypeOf:_AstExpression"{
	_overrides = {{`nodeType`,AST_TYPE_OF}},
	{`expression`,      nil, ast="node"}, -- AstExpression
	-- Type phase:
	{`representedType`, nil}, -- TypeInfo
}
_G.!structAst"AstVariantOf:_AstExpression"{
	_overrides = {{`nodeType`,AST_VARIANT_OF}},
	{`call`, nil, ast="node"}, -- AstCall  This may end up being AstType which is a type error.
}
_G.!structAst"AstTypeInfo:_AstExpression"{
	_overrides = {{`nodeType`,AST_TYPE_INFO}},
	{`expression`,    nil, ast="node"}, -- AstExpression
	-- Type phase:
	{`valueTypeInfo`, nil}, -- TypeInfo
	-- Emit phase:
	{`valueConstant`, nil}, -- Constant
}
_G.!structAst"AstLocation:_AstExpression"{
	_overrides = {{`nodeType`,AST_LOCATION}},
	{`expression`,    nil, ast="node"}, -- AstExpression  If this is empty then the target is the location node itself.
	{`ofCaller`,      false},           -- Used as default values for function arguments.
	-- Type phase:
	{`target`,        nil}, -- AstNode
	-- Emit phase:
	{`valueConstant`, nil}, -- Constant
}
_G.!structAst"AstCast:_AstExpression"{
	_overrides = {{`nodeType`,AST_CAST}},
	{`targetType`, nil, ast="node"}, -- AstType
	{`expression`, nil, ast="node"}, -- AstExpression
	{`isImplicit`, false},           -- Implicit casts include e.g. 'if "foo" {...}'
}
_G.!structAst"AstImport:_AstExpression"{
	_overrides = {{`nodeType`,AST_IMPORT}},
	{`isLoad`,     false},
	{`importName`, ""},
	{`exported`,   false},
	-- Type phase:
	{`fileScope`,  nil, astRef="node"}, -- AstFileScope
}
_G.!structAst"AstForeign:_AstExpression"{
	_overrides = {{`nodeType`,AST_FOREIGN}},
	{`foreignSource`,     ""},           -- "compiler"|"lua"|"method"
	{`foreignSourceName`, nil, ast=nil}, -- AstLiteral (string)  Never inferred. The name may be inferred from a declaration.
	-- Type phase:
	{`foreignSourceId`,   ""}, -- Is foreignSource and foreignSourceName combined.
	-- Emit phase:
	{`valueConstant`,     nil}, -- Constant
}
_G.!structAst"AstConditional:_AstExpression"{
	_overrides = {{`nodeType`,AST_CONDITIONAL}},
	{`condition`,              nil, ast="node"},    -- AstExpression
	{`branchTrue`,             nil, ast="node"},    -- AstExpression  (If this is nil then condition (or rather conditionAndBranchTrue) is used for this branch.)
	{`branchFalse`,            nil, ast="node"},    -- AstExpression
	{`conditionAndBranchTrue`, nil, astRef="node"}, -- AstExpression
}
_G.!structAst"AstBake:_AstExpression"{
	_overrides = {{`nodeType`,AST_BAKE}},
	{`name`, nil, ast="node"}, -- AstIdentifier
}
_G.!structAst"AstRun:_AstExpression"{
	_overrides = {{`nodeType`,AST_RUN}},
	{`lambda`, nil, ast="node"}, -- AstLambda
}
_G.!structAst"AstNull:_AstExpression"{
	_overrides = {{`nodeType`,AST_NULL}},
}

_G.!structAst"AstUsing:_AstNode"{
	_overrides = {{`nodeType`,AST_USING}},
	{`expression`,          nil, ast="node"},    -- AstExpression
	-- Type phase:
	{`scope`,               nil, astRef="node"}, -- AstScope
	{`variableDeclaration`, nil, astRef="node"}, -- AstDeclaration
}

_G.!structAst"AstDebug:_AstNode"{
	_overrides = {{`nodeType`,AST_DEBUG}},
	{`expression`, nil, ast="node"}, -- AstExpression
	{`action`,     ""},              -- "assert"|"print"
}

_G.!structAst"AstArgument:_AstNode"{
	_overrides = {{`nodeType`,AST_ARGUMENT}},
	{`declaration`,     nil, ast="node"}, -- AstDeclaration
	{`assignment`,      nil, ast="node"}, -- AstAssignment
	{`group`,           1}, -- Arguments in the same group have the same type. This is a small optimization for the typer.
	{`autobake`,        AUTOBAKE_DISABLED},
	{`hasPlaceholders`, false},
	{`isUsing`,         false}, -- Is it better to store this on declarations?

	-- For an input argument, this indicates optionality.
	-- For an output argument, if there's a !must then it must not be adjusted away by the caller.
	{`isRequired`,      false},
}
_G.!structAst"AstArguments:_AstNode"{
	_overrides = {{`nodeType`,AST_ARGUMENTS}},
	{`arguments`, {}, ast="array"}, -- []AstArgument
}

_G.!structAst"AstDeclaration:_AstNode"{
	_overrides = {{`nodeType`,AST_DECLARATION}},
	{`type`,                 nil, ast="node"},  -- AstType  If this is nil then the type is inferred from the value.
	{`value`,                nil, ast="node"},  -- AstExpression  Either this or assignment should be set, or neither for getting the default value for the type. This node is used in static context.
	{`name`,                 nil, ast="node"},  -- AstIdentifier|AstVararg|AstBlank
	{`notes`,                nil, ast="array"}, -- []AstExpression  Is set when needed.

	{`kind`,                 DECL_KIND_LOCAL_VAR}, -- DECL_KIND_LOCAL_VAR|DECL_KIND_LOCAL_CONST|DECL_KIND_EXPORT_VAR|DECL_KIND_EXPORT_CONST|DECL_KIND_STATIC  @Incomplete: DECL_KIND_READ_ONLY  Note: Globals are exports.
	{`canShadow`,            false},
	{`addedByPolymorph`,     false},
	{`isDocumentation`,      false}, -- Some declared names basically only exist for documentation purposes, i.e. function output arguments.

	{`assignment`,           nil, astRef="node"}, -- AstAssignment
	{`assignmentIndex`,      1},

	-- Type phase:
	{`inferredType`,         nil}, -- TypeInfo  @Cleanup: Maybe use a different name as declarations are not expressions. Need to update the dependency code in that case.
	{`valueTypeInfo`,        nil}, -- TypeInfo  Type represented by the assigned value if the declaration is constant. If this is set then the declared identifier can be used in places where a type is expected. Can be nil.
	{`checkedRedeclaration`, false},
	{`overloads`,            nil}, -- []AstDeclaration  Is set when needed.
	{`overloadOf`,           nil, astRef="node"}, -- AstDeclaration  (If this is self then we're the base declaration for the overloads and the overloads array should be filled.)
	{`overloadsLocked`,      false},

	-- Emit phase:
	{`valueConstant`,        nil}, -- Constant
	{`topScopeName`,         ""},
	{`localName`,            ""},
}

_G.!structAst"AstAssignment:_AstNode"{
	_overrides = {{`nodeType`,AST_ASSIGNMENT}},
	{`targets`,         {},  ast="array"},    -- [](AstIdentifier|AstAccess|AstBlank)
	{`values`,          {},  ast="array"},    -- []AstExpression

	-- Assignments can have some targets that's part of a declaration and others that were declared before.
	{`forDeclaration`,  false},
	{`declarations`,    nil, astRef="array"}, -- []AstDeclaration  Is set if forDeclaration is set. This array does not include declarations marked as "previously declared" and will have 'false' in place of those!

	{`binaryOperation`, ""}, -- Empty means plain assignment.
}

!structAst"_AstJump:_AstNode"{}
_G.!structAst"AstReturn:_AstJump"{
	_overrides = {{`nodeType`,AST_RETURN}},
	{`values`,       {},  ast="array"},   -- []AstExpression
	{`runDirective`, nil, astRef="node"}, -- AstRun
}
_G.!structAst"AstBreak:_AstJump"{
	_overrides = {{`nodeType`,AST_BREAK}},
	{`loopName`, nil, ast=nil      }, -- AstIdentifier  Never inferred. Just for debugging.
	{`loop`,     nil, astRef="node"}, -- AstFor|AstWhile
}
_G.!structAst"AstContinue:_AstJump"{
	_overrides = {{`nodeType`,AST_CONTINUE}},
	{`loopName`, nil, ast=nil      }, -- AstIdentifier  Never inferred. Just for debugging.
	{`loop`,     nil, astRef="node"}, -- AstFor|AstWhile
}

_G.!structAst"AstDefer:_AstNode"{
	_overrides = {{`nodeType`,AST_DEFER}},
	{`body`, nil, ast="node"}, -- AstBlock
}

!structAst"_AstScope:_AstNode"{
	{`statementsStatic`,    {},  ast="array"},    -- []AstNode
	{`statementsDynamic`,   {},  ast="array"},    -- []AstNode
	{`declarations`,        {},  astRef="array"}, -- []AstDeclaration  (Note that inner blocks have their own declarations.)
	{`declarationsByName`,  {},  astRef="names"}, -- { name1, [name1]=declaration1, [declaration1]=nameIndex1, ... }
	{`declarationsByName2`, {},  astRef="names"}, -- Fallback for declarationsByName when checking for redeclarations/overloads.
	{`imports`,             nil, astRef="array"}, -- []AstImport  Is set when needed.
	{`usings`,              nil, astRef="array"}, -- []AstUsing   Is set when needed.
	-- Type phase:
	{`declarationsInTree`,  {}, doNotCopy=true}, -- Includes all child scopes. Does not include shadows.
}
_G.!structAst"AstBlock:_AstScope"{
	_overrides = {{`nodeType`,AST_BLOCK}},
	_scopeType = "imperative",
}
_G.!structAst"AstFileScope:_AstScope"{
	_overrides = {{`nodeType`,AST_FILE_SCOPE}},
	_scopeType = "declarative",
	{`valueToExport`, nil, ast="node"}, -- Used when outputting a Lua module.
	{`path`,          ""},              -- @Cleanup: Can we remove this in favor of node.source.path?
	{`isModule`,      false},
	{`moduleName`,    ""},
}
_G.!structAst"AstGlobalScope:_AstScope"{
	_overrides = {{`nodeType`,AST_GLOBAL_SCOPE}},
	_scopeType = "declarative",
	{`fileScopes`,                 {},  astRef="array"}, -- []AstFileScope
	{`fileScopeWithValueToExport`, nil, astRef="node"},  -- See AstFileScope.valueToExport
}
_G.!structAst"AstFor:_AstScope"{
	_overrides = {{`nodeType`,AST_FOR}},
	_scopeType = "imperative",
	{`expressions`,   {},  ast="array"},   -- []AstExpression  @Cleanup: Move these into AstFor.statementsDynamic?
	{`names`,         {},  ast=nil    },   -- []AstIdentifier  These are never inferred, but instead copied to declarations. @Cleanup: Can we get rid of this in favor of the copy we currently make?
	{`forType`,       FOR_NUMERIC},        -- @Cleanup: Rename to "kind" or "forKind"?
	{`body`,          nil, astRef="node"}, -- AstBlock
	{`reverse`,       false},
	{`hasNamedJumps`, false},
	{`hasContinues`,  false},
}
!structAst"_AstScopeExpression:_AstScope"{
	-- Type phase:
	{`inferredType`,    nil}, -- TypeInfo
	{`representedType`, nil}, -- TypeInfoStruct|TypeInfoEnum  (Used for AstEnum and AstStruct. Is nil otherwise.)
}
_G.!structAst"AstStruct:_AstScopeExpression"{
	_overrides = {{`nodeType`,AST_STRUCT}},
	_scopeType = "declarative",

	{`inherits`,              nil, astRef="array"}, -- []AstExpression  Is set when needed.

	{`keyType`,               nil, ast="node"},     -- AstExpression
	{`valueType`,             nil, ast="node"},     -- AstExpression

	{`polymorphs`,            nil, astRef="array"}, -- []AstDeclaration  If this is set then the struct is polymorphic.
	{`polymorphSourceStruct`, nil, astRef="node"},  -- AstStruct
	{`bakeDeclarations`,      nil, astRef="array"}, -- []AstDeclaration  Is set when needed.

	{`isForeign`,             false},               -- Foreign structs cannot be instantiated.
	-- {`foreignThroughNode`,    nil, astRef="node"},  -- AstNode
}
_G.!structAst"AstEnum:_AstScopeExpression"{
	_overrides = {{`nodeType`,AST_ENUM}},
	_scopeType = "declarative",
	{`memberType`, nil, ast="node"}, -- AstType
	{`autoValue`,  0},
}
_G.!structAst"AstLambda:_AstScopeExpression"{
	_overrides = {{`nodeType`,AST_LAMBDA}},
	_scopeType = "imperative",

	{`captures`,          nil, ast="array"}, -- []AstIdentifier  Is set when needed.
	{`captureAll`,        false},
	{`argumentsIn`,       nil, astRef="node"}, -- AstArguments  Is set when needed.
	{`argumentsOut`,      nil, astRef="node"}, -- AstArguments  Is set when needed.
	{`takingVararg`,      false},
	{`inline`,            INLINE_MAY},

	{`body`,              nil, astRef="node"}, -- AstBlock  (If this is nil then the lambda is a function signature. If bodyIsForeign is set then this is a dummy block.)
	{`bodyIsForeign`,     false},              -- @Cleanup: Use AstForeign instead of all this stuff.
	{`foreignSource`,     ""},                 -- "compiler"|"lua"|"method"
	{`foreignSourceName`, nil, ast=nil},       -- AstLiteral (string)  Never inferred. The name may be inferred from a declaration.

	{`bodyEndDummy`,      nil}, -- AstDummy  For better error messages.

	{`polymorphs`,            nil, astRef="array"}, -- []AstDeclaration  If this is set then the lambda is polymorphic.
	{`polymorphSourceLambda`, nil, astRef="node"},  -- AstLambda
	{`bakeDeclarations`,      nil, astRef="array"}, -- []AstDeclaration  Is set when needed.
	{`bakeValues`,            nil, astRef="array"}, -- []AstExpression   Is set when needed.

	{`bodyTextLambda`,    nil, astRef="node"}, -- AstLambda

	{`metaOnly`,          false}, -- If this is set then this won't get written to the final output - only to the metaprogram.
	{`wantCallerLocation`,false},

	-- Type phase:
	{`foreignSourceId`,   ""}, -- Is foreignSource and foreignSourceName combined.

	-- Emit phase:
	{`valueConstant`,     nil}, -- Constant
}
_G.!structAst"AstNamespace:_AstScopeExpression"{
	_overrides = {{`nodeType`,AST_NAMESPACE}},
	_scopeType="declarative",
	{`namespaceReferenceNode`, nil, astRef="node"}, -- AstNamespace  (This is kind of a hack for !self.)
}

_G.!structAst"AstIf:_AstNode"{
	_overrides = {{`nodeType`,AST_IF}},
	{`condition`,   nil, ast="node"}, -- AstExpression
	{`branchTrue`,  nil, ast="node"}, -- AstBlock
	{`branchFalse`, nil, ast="node"}, -- AstBlock  May be nil.
}
_G.!structAst"AstStaticIf:AstIf"{
	_overrides = {{`nodeType`,AST_STATIC_IF}},
}
_G.!structAst"AstWhile:_AstNode"{
	_overrides = {{`nodeType`,AST_WHILE}},
	{`condition`,     nil, ast="node"}, -- AstExpression
	{`body`,          nil, ast="node"}, -- AstBlock
	{`hasNamedJumps`, false},
	{`hasContinues`,  false},
}
_G.!struct"SwitchCase"{
	{`value`,       nil}, -- AstExpression
	{`body`,        nil}, -- AstBlock
	{`fallThrough`, false},
}
_G.!structAst"AstSwitch:_AstNode"{
	_overrides = {{`nodeType`,AST_SWITCH}},
	{`value`,    nil, ast="node"},  -- AstExpression
	{`cases`,    {},  ast="cases"}, -- []SwitchCase
	{`complete`, false},
}

_G.SCOPES                = !(scopeNodeTypes)
_G.SCOPES_DECLARATIVE    = !(scopeNodeTypesDeclarative)
_G.SCOPES_IMPERATIVE     = !(scopeNodeTypesImperative)
_G.SCOPE_SET             = !(Set(scopeNodeTypes))
_G.SCOPE_SET_DECLARATIVE = !(Set(scopeNodeTypesDeclarative))
_G.SCOPE_SET_IMPERATIVE  = !(Set(scopeNodeTypesImperative))



-- node:nodeConstructor = astNewNode( nodeConstructor, tokOrSourceNode, parent )
-- globalScope          = astNewNode( AstGlobalScope,  tokOrSourceNode [, parent ] )
-- dummy                = astNewNode( AstDummy,        tokOrSourceNode [, parent ] )
do
	local serialN = 0

	function _G.astNewNode(nodeConstructor, tokOrSourceNode, parent)
		!ASSERT `nodeConstructor`
		!ASSERT `tokOrSourceNode`

		if not parent and not (nodeConstructor == AstGlobalScope or nodeConstructor == AstDummy) then
			errorInternal(2, "No parent.")
		end

		serialN = serialN + 1

		local node    = nodeConstructor()
		node.s        = serialN
		node.parent   = parent
		node.source   = tokOrSourceNode.source
		node.position = tokOrSourceNode.position1 or tokOrSourceNode.position
		node.line     = tokOrSourceNode.line1     or tokOrSourceNode.line

		!if DEBUG and 1==0 then
			-- Who made us?!
			if false
				or serialN == 487
				-- or parent and parent.s == 21
			then
				print("astNewNode", node.s, AST_NAMES[node.nodeType])
				printTraceback()
				-- errorInternal("DEBUG")
			end
		!end

		!if EXTRA_STATS then
			nodeCreationCounts[node.nodeType] = nodeCreationCounts[node.nodeType] + 1
		!end

		return node
	end
end

!(
local fileLocals = {}

local function FILE_LOCAL(header)
	local funcNameAndArgs, funcName = header:match"^function ((%w+)%(.+)$"
	assert(funcName, header)

	table.insert(fileLocals, funcName)

	__LUA("function ", funcNameAndArgs)

	preprocessorOutputAtDuringPost("parserFunctionLocals", F(
		"local %s",
		table.concat(fileLocals, ", ")
	))
end
)



!(
local      EAT_NEXT_TOKEN = `state.nextToken = state.nextToken + 1` -- This macro does not "return" anything, unlike the function with the same name.
local PUT_BACK_LAST_TOKEN = `state.nextToken = state.nextToken - 1`
local     PEEK_LAST_TOKEN = `state.tokens[state.nextToken-1]`

-- lua = IS_TOK         ( [ localTokNum, ] tokenType [, tokenValue1, ... ] )
-- lua = IS_EXISTING_TOK( [ localTokNum, ] tokenType [, tokenValue1, ... ] )
local function IS_TOK(localTokNum, tokType, tokValue1, ...)
	if type(tokType) ~= "number" then
		return IS_TOK(nil, localTokNum, tokType, tokValue1, ...)
	end

	local localSuffix = localTokNum and F("%d", localTokNum) or ""

	if     ...       then  return F("(tok%s and tok%s.type == %s and %s[tok%s.value])",   localSuffix, localSuffix, toLua(tokType), CONST_SET{tokValue1,...}, localSuffix)
	elseif tokValue1 then  return F("(tok%s and tok%s.type == %s and tok%s.value == %s)", localSuffix, localSuffix, toLua(tokType), localSuffix, toLua(tokValue1))
	else                   return F("(tok%s and tok%s.type == %s)",                       localSuffix, localSuffix, toLua(tokType), localSuffix)  end
end
local function IS_EXISTING_TOK(localTokNum, tokType, tokValue1, ...)
	if type(tokType) ~= "number" then
		return IS_EXISTING_TOK(nil, localTokNum, tokType, tokValue1, ...)
	end

	local localSuffix = localTokNum and F("%d", localTokNum) or ""

	if     ...       then  return F("(tok%s.type == %s and %s[tok%s.value])",   localSuffix, toLua(tokType), CONST_SET{tokValue1,...}, localSuffix)
	elseif tokValue1 then  return F("(tok%s.type == %s and tok%s.value == %s)", localSuffix, toLua(tokType), localSuffix, toLua(tokValue1))
	else                   return F("(tok%s.type == %s)",                       localSuffix, toLua(tokType), localSuffix)  end
end
)

-- tok, token = eatNextTok ( compilationState )
-- tok, token = peekNextTok( compilationState, steps )
local function eatNextTok(state)
	local i   = state.nextToken
	local tok = state.tokens[i]
	state.nextToken = i + 1
	return tok, i
end
local function peekNextTok(state, steps)
	local i = state.nextToken + steps - 1
	return state.tokens[i], i
end
_G.peekNextTok = peekNextTok

local function eatTrailingSemicolon(state)
	local tok = state.tokens[state.nextToken]
	if !!(IS_TOK(TOKEN_PUNCTUATION, ";")) then
		!!(EAT_NEXT_TOKEN) -- ';'
	end
end



local function parseIdentifier(state, parent)
	local tok, token = eatNextTok(state)
	if not !!(IS_TOK(TOKEN_IDENTIFIER)) then
		!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected an identifier.")`
	end

	local ident = astNewNode(AstIdentifier, tok, parent)
	ident.name  = tok.value

	return ident
end

local function parseUsing(state, parent)
	local tok = eatNextTok(state) -- 'using'
	!ASSERT(IS_TOK(TOKEN_KEYWORD, "using"))

	local using                          = astNewNode(AstUsing, tok, parent)
	!SET_OR_RETURN_NIL `using.expression = parseExpression(state, using)`

	return using
end

local function parseForeign(state, parent)
	-- Note: Assume '!foreign' has been eaten already.

	local foreign = astNewNode(AstForeign, state.tokens[state.nextToken-1], parent)

	local tok = eatNextTok(state)
	if not (tok and tok.type == !(TOKEN_IDENTIFIER)) then
		!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected foreign source. (Valid values: lua, method, compiler)")`
	elseif not !!(CONST_SET{"lua","method","compiler"})[tok.value] then
		!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Invalid source '%s'. (Valid values: lua, method, compiler)", tok.value)`
	end
	foreign.foreignSource = tok.value

	tok = peekNextTok(state, 1)
	if tok and tok.type == !(TOKEN_STRING) then
		!!(EAT_NEXT_TOKEN) -- the string
		foreign.foreignSourceName = newLiteral(foreign, tok, !(LITERAL_STRING), tok.value)
	else
		-- void  (foreign.foreignSourceName will be the name of whatever declared constant the foreign is attached to.)
		!ERROR_OR_RETURN_NIL `errorParsingAfterLast(state, "@Incomplete: Infer foreign.foreignSourceName")` -- @Temp
	end

	return foreign
end

local function parseTable(state, parent)
	-- Note: Assume '{' has been eaten already.

	local tableNode      = astNewNode(AstTable, state.tokens[state.nextToken-1], parent)
	local fields         = tableNode.fields
	local generatedIndex = 0

	while true do
		local tok, token = peekNextTok(state, 1)

		if not tok then
			!ERROR_OR_RETURN_NIL `errorParsing(state, tableNode, "Unfinished table.")` -- We probably don't ever get here because of the quick bracket check.
		elseif !!(IS_EXISTING_TOK(TOKEN_PUNCTUATION, "}")) then
			!!(EAT_NEXT_TOKEN) -- '}'
			break
		end

		local tok2       = peekNextTok(state, 2)
		local tableField = KeyValuePair()
		local tableKey

		-- [k]=v
		if !!(IS_EXISTING_TOK(TOKEN_PUNCTUATION, "[")) then
			!!(EAT_NEXT_TOKEN) -- '['

			!SET_OR_RETURN_NIL `tableKey = parseExpression(state, tableNode)`

			tok = eatNextTok(state)
			if not !!(IS_TOK(TOKEN_PUNCTUATION, "]")) then
				!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ']'.")`
			end

			tok = eatNextTok(state)
			if not !!(IS_TOK(TOKEN_PUNCTUATION, "=")) then
				!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '=' after the key.")`
			end

		-- k=v
		elseif tok.type == !(TOKEN_IDENTIFIER) and !!(IS_TOK(2, TOKEN_PUNCTUATION, "=")) then
			!!(EAT_NEXT_TOKEN) -- the identifier
			local literal       = astNewNode(AstLiteral, tok, tableNode)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = tok.value
			tableKey            = literal
			!!(EAT_NEXT_TOKEN) -- '='

		-- v
		else
			generatedIndex      = generatedIndex + 1
			local literal       = astNewNode(AstLiteral, tok, tableNode) -- Note: The token position of the key and value will be the same.
			literal.literalType = !(LITERAL_INTEGER)
			literal.value       = generatedIndex
			tableKey            = literal

			tableField.keyIsGenerated = true
		end

		assert(tableKey)

		tableField.key                       = tableKey
		!SET_OR_RETURN_NIL `tableField.value = parseExpression(state, tableNode)`

		table.insert(fields, tableField)

		tok = eatNextTok(state)
		if !!(IS_TOK(TOKEN_PUNCTUATION, "}")) then
			break
		elseif !!(IS_TOK(TOKEN_PUNCTUATION, ",",";")) then
			-- void  (Note: A trailing comma or semicolon at the end of the argument list is permitted.)
		else
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ','.")`
		end
	end

	local lastField = fields[#fields]

	if lastField and lastField.keyIsGenerated and lastField.value.nodeType == !(AST_VARARG) and not lastField.value.surroundedByParentheses then
		local vararg    = lastField.value
		vararg.parent   = tableNode
		fields[#fields] = nil
		generatedIndex  = generatedIndex-1
		tableNode.trailingExpression = vararg
	end

	tableNode.highestGeneratedIndex = generatedIndex
	return tableNode
end

-- Parse comma-separated expressions. Used for function calls, struct parameters, assignments etc.
-- success = parseExpressionList( compilationState, parent, expressions, expressionsNamed=nil, expectLvalues )
local function parseExpressionList(state, parent, expressions, expressionsNamed, expectLvalues)
	local takenNames = expressionsNamed and {--[[ [name1]=identifier, ... ]]} or nil

	while true do
		local tok  = peekNextTok(state, 1)
		local tok2 = peekNextTok(state, 2)

		if expectLvalues and !!(IS_TOK(TOKEN_PUNCTUATION, "_")) then
			local blank = astNewNode(AstBlank, tok, parent)
			!!(EAT_NEXT_TOKEN) -- '_'
			table.insert(expressions, blank)

		elseif expressionsNamed and tok.type == !(TOKEN_IDENTIFIER) and !!(IS_TOK(2, TOKEN_PUNCTUATION, "=")) then
			local exprNamed                   = KeyValuePair()
			!SET_OR_RETURN_FALSE `local ident = parseIdentifier(state, parent)`
			ident.kind                        = !(IDENT_KIND_IGNORE)
			exprNamed.key                     = ident

			if takenNames[ident.name] then
				!ERROR_OR_RETURN_NIL `
					printerr()
					parserMessage(io.stderr, state, state.tokens[state.nextToken-1], "Error", "Duplicate name '%s'.", ident.name)
					parserMessage(io.stderr, state, takenNames[ident.name],          "Info",  "...name was previously used here.")
					exitFailure()
				`
			end
			takenNames[ident.name] = ident

			!!(EAT_NEXT_TOKEN) -- '='

			!SET_OR_RETURN_FALSE `exprNamed.value = parseExpression(state, parent, nil, expectLvalues)`
			table.insert(expressionsNamed, exprNamed)

		else
			!SET_OR_RETURN_FALSE `local expr = parseExpression(state, parent, nil, expectLvalues)`
			table.insert(expressions, expr)
		end

		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_PUNCTUATION, ",")) then
			!!(EAT_NEXT_TOKEN) -- ','
			-- Continue the loop.
		else
			break
		end
	end

	return true
end

local function concatNamesInArgumentGroupForError(argsInGroup)
	if argsInGroup.n == 1 then  return argsInGroup[1].declaration.name.name  end

	local names = {}

	for i, arg in ipairsN(argsInGroup) do
		names[i] = arg.declaration.name.name
	end

	return table.concat(names, "', '", 1, argsInGroup.n-1) .. "' and '" .. names[argsInGroup.n]
end

local function parseArguments(state, parent, isInput, allowVoid)
	-- Note: Assume '(' has been eaten already.

	local args            = astNewNode(AstArguments, state.tokens[state.nextToken], parent)
	local takenNames      = {--[[ [name1]=identifier, ... ]]}
	local gotVararg       = false
	local gotDefaultValue = false

	local tok = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_KEYWORD, "void")) then
		!!(EAT_NEXT_TOKEN) -- 'void'

		if not allowVoid then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Cannot use 'void' here.")` -- We currently never get here. 2021-08-06
		end

		return args
	end

	for groupN = 1, 1/0 do
		-- Argument name(s).
		local argsInGroup = getRecycledTable() or {}
		argsInGroup.n     = 0
		local isUsing     = false

		local tok, token    = peekNextTok(state, 1)
		local argStartTok   = tok
		local argStartToken = token

		if !!(IS_TOK(TOKEN_KEYWORD, "using")) then
			!!(EAT_NEXT_TOKEN) -- 'using'
			isUsing = true

			if not isInput then
				-- Maybe we should allow 'using' here, but apply it the types instead of the names in the declarations?
				!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Cannot apply 'using' to output arguments.")`
			end
		end

		while true do
			local autobake = !(AUTOBAKE_DISABLED)
			tok, token     = eatNextTok(state)

			if !!(IS_TOK(TOKEN_PUNCTUATION, "$")) then
				if not isInput then
					!ERROR_OR_RETURN_NIL `errorParsing(state, tok, "Only input arguments can be auto-baked.")`
				elseif isUsing then
					!ERROR_OR_RETURN_NIL `errorParsing(state, argStartTok, "Cannot using auto-baked arguments.")`
				end

				autobake = !(AUTOBAKE_REQUIRED)
				tok      = peekNextTok(state, 1)

				if !!(IS_TOK(TOKEN_PUNCTUATION, "?")) then
					!!(EAT_NEXT_TOKEN) -- '?'
					autobake = !(AUTOBAKE_ENABLED)
					!ERROR_OR_RETURN_NIL `errorParsing(state, token+1, "Optional auto-baking of arguments isn't supported yet. Omit '?' to force auto-baking.")` -- @Incomplete
				end

				tok = eatNextTok(state)
			end

			if not (tok.type == !(TOKEN_IDENTIFIER) or !!(IS_TOK(TOKEN_PUNCTUATION, "...","_"))) then
				!ERROR_OR_RETURN_NIL `errorParsing(state, token, "Argument list: Expected an identifier.")`
			end

			local arg    = astNewNode(AstArgument, tok, args)
			arg.group    = groupN
			arg.autobake = autobake
			arg.isUsing  = isUsing

			table.insert(args.arguments, arg)
			insertN     (argsInGroup,    arg)

			local decl           = astNewNode(AstDeclaration, tok, arg)
			decl.isDocumentation = not isInput
			arg.declaration      = decl

			if tok.type == !(TOKEN_IDENTIFIER) then
				local ident       = astNewNode(AstIdentifier, tok, decl)
				ident.kind        = !(IDENT_KIND_DECLARATION)
				ident.name        = tok.value
				ident.declaration = decl
				decl.name         = ident

				if takenNames[ident.name] then
					!ERROR_OR_RETURN_NIL `
						printerr()
						parserMessage(io.stderr, state, state.tokens[state.nextToken-1], "Error", "Duplicate name '%s'.", ident.name)
						parserMessage(io.stderr, state, takenNames[ident.name],          "Info",  "...name was previously used here.")
						exitFailure()
					`
				end
				takenNames[ident.name] = ident

			elseif tok.value == "..." then
				gotVararg = true

				if isUsing then
					!ERROR_OR_RETURN_NIL `errorParsing(state, argStartTok, "Cannot apply 'using' to varargs.")`
				elseif autobake ~= !(AUTOBAKE_DISABLED) then
					!ERROR_OR_RETURN_NIL `errorParsing(state, argStartTok, "Auto-baking of varargs is not supported.")`
				end

				local vararg       = astNewNode(AstVararg, tok, decl)
				vararg.kind        = !(IDENT_KIND_DECLARATION)
				vararg.declaration = decl
				decl.name          = vararg

			else
				local blank       = astNewNode(AstBlank, tok, decl)
				blank.kind        = !(IDENT_KIND_DECLARATION)
				blank.declaration = decl
				decl.name         = blank

				if arg.autobake ~= !(AUTOBAKE_DISABLED) then
					errorParsing(state, state.nextToken-2, "Blank arguments cannot be auto-baked.")
				end
			end

			tok = peekNextTok(state, 1)

			if !!(IS_TOK(TOKEN_PUNCTUATION, ":","=")) then
				break
			elseif !!(IS_TOK(TOKEN_PUNCTUATION, ",")) then
				!!(EAT_NEXT_TOKEN) -- ','
				-- Continue the loop.
			else
				!ERROR_OR_RETURN_NIL `errorParsingAfterLast(state, "Expected ':' after argument names.")`
			end

			if gotVararg then
				tok = peekNextTok(state, 1)
				if !!(IS_TOK(TOKEN_PUNCTUATION, "...")) then
					!ERROR_OR_RETURN_NIL `errorParsingNext(state, "Only one vararg allowed.")`
				else
					!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Vararg must be the last argument.")`
				end
			end
		end

		local tok2 = peekNextTok(state, 2)

		-- Type(s).
		if not !!(IS_TOK(TOKEN_PUNCTUATION, ":")) then
			-- void

		elseif !!(IS_TOK(2, TOKEN_PUNCTUATION, "=")) then
			!!(EAT_NEXT_TOKEN) -- ':'

		else
			!!(EAT_NEXT_TOKEN) -- ':'

			local hasPlaceholders = false
			token                 = state.nextToken

			for i, arg in ipairsN(argsInGroup) do
				state.nextToken               = token
				local decl                    = arg.declaration
				!SET_OR_RETURN_NIL `decl.type = parseExpression(state, decl)` -- @Speed: Parse once then just copy the first one?

				if i == 1 then
					astVisitAllNodes(decl.type, function(node)
						if node.nodeType == !(AST_BAKE) then
							hasPlaceholders = true
							return !(VISIT_BREAK)
						end
					end)

				elseif hasPlaceholders then
					-- Make sure (a,b:$T) works.
					astVisitAllNodes(decl.type, function(node, container, key)
						if node.nodeType ~= !(AST_BAKE) then  return  end

						if not container then
							container = decl
							key       = "type"
						end

						local bake     = node
						local ident    = bake.name

						ident.parent   = node.parent
						container[key] = ident

						return !(VISIT_IGNORE_CHILDREN)
					end)
				end

				arg.hasPlaceholders = hasPlaceholders
			end
		end

		-- Default value.
		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_PUNCTUATION, "=")) then
			gotDefaultValue = true
			!!(EAT_NEXT_TOKEN) -- '='

			if not isInput then
				!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Output arguments cannot have default values.")`
			end

			token = state.nextToken

			for _, arg in ipairsN(argsInGroup) do
				state.nextToken = token

				if arg.autobake ~= !(AUTOBAKE_DISABLED) then
					!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Default values for auto-baked arguments are not supported yet.")`
				end

				local decl = arg.declaration

				if decl.name.nodeType == !(AST_VARARG) then
					!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Varargs cannot have default values.")`
				else
					assert(decl.name.nodeType == !(AST_IDENTIFIER) or decl.name.nodeType == !(AST_BLANK))
				end

				tok = peekNextTok(state, 1)

				-- @Speed: Parse the value once, then just copy the first one?
				if !!(IS_TOK(TOKEN_DIRECTIVE, "caller_location")) then
					!!(EAT_NEXT_TOKEN) -- '!caller_location'

					if parent.nodeType ~= !(AST_LAMBDA) then
						!ERROR_OR_RETURN_NIL `errorParsingLast(state, "!caller_location can only be used among function arguments.")`
					end

					local loc    = astNewNode(AstLocation, tok, decl)
					loc.ofCaller = true
					decl.value   = loc

				else
					!SET_OR_RETURN_NIL `decl.value = parseExpression(state, decl)`
				end
			end

		elseif gotDefaultValue and not gotVararg then
			!ERROR_OR_RETURN_NIL `errorParsingAfterLast(
				state,
				"Missing default value for '%s'. All optional arguments must be at the end of the argument list.",
				concatNamesInArgumentGroupForError(argsInGroup)
			)`
		end

		-- Set additional flags.
		while true do
			tok = peekNextTok(state, 1)

			if !!(IS_TOK(TOKEN_DIRECTIVE, "shadow")) then
				!!(EAT_NEXT_TOKEN) -- '!shadow'
				if argsInGroup[1].declaration.canShadow then
					!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Duplicate !shadow.")`
				elseif not isInput then
					!ERROR_OR_RETURN_NIL `errorParsingLast(state, "!shadow does nothing for return values.")`
				end
				for _, arg in ipairsN(argsInGroup) do
					arg.declaration.canShadow = true
				end

			elseif !!(IS_TOK(TOKEN_DIRECTIVE, "must")) then
				!!(EAT_NEXT_TOKEN) -- '!must'
				local lastArg = argsInGroup[argsInGroup.n]
				if lastArg.isRequired then
					!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Duplicate !must.")`
				elseif isInput then
					!ERROR_OR_RETURN_NIL `errorParsingLast(state, "!must can only be used for return values.")`
				end
				lastArg.isRequired = true -- We update isRequired for all arguments below.

			else
				break
			end
		end

		recycleTable(argsInGroup)
		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_PUNCTUATION, ",")) then
			!!(EAT_NEXT_TOKEN) -- ','
			-- Continue the loop.
		else
			break
		end

		if gotVararg then
			tok = peekNextTok(state, 1)
			if !!(IS_TOK(TOKEN_PUNCTUATION, "...")) then
				!ERROR_OR_RETURN_NIL `errorParsingNext(state, "Only one vararg allowed.")`
			else
				!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Vararg must be the last argument.")`
			end
		end
	end

	if isInput then
		for _, arg in ipairs(args.arguments) do
			arg.isRequired = (arg.declaration.value == nil and arg.declaration.name.nodeType ~= !(AST_VARARG))
		end
	else
		local argIndex = lastIndexWith1(args.arguments, "isRequired", true)
		if argIndex then
			for argIndex = 1, argIndex-1 do
				args.arguments[argIndex].isRequired = true
			end
		end
	end

	return args
end

local function parseNamelessOutputArguments(state, parent)
	local args = astNewNode(AstArguments, state.tokens[state.nextToken], parent)

	for groupN = 1, 1/0 do
		local arg = astNewNode(AstArgument, state.tokens[state.nextToken], args)
		arg.group = groupN
		table.insert(args.arguments, arg)

		local decl           = astNewNode(AstDeclaration, arg, arg)
		decl.isDocumentation = true
		arg.declaration      = decl

		local tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_PUNCTUATION, "...")) then
			!!(EAT_NEXT_TOKEN) -- '...'

			local vararg       = astNewNode(AstVararg, decl, decl)
			vararg.kind        = !(IDENT_KIND_DECLARATION)
			vararg.declaration = decl
			decl.name          = vararg

			!SET_OR_RETURN_NIL `decl.type = parseExpression(state, decl)`

		else
			!SET_OR_RETURN_NIL `decl.type = parseExpression(state, decl)`

			local ident       = astNewNode(AstIdentifier, decl, decl)
			ident.kind        = !(IDENT_KIND_DECLARATION)
			ident.declaration = decl
			decl.name         = ident
		end

		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_DIRECTIVE, "must")) then
			!!(EAT_NEXT_TOKEN) -- '!must'
			arg.isRequired = true -- We update isRequired for all arguments below.
		end

		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_PUNCTUATION, ",")) then
			!!(EAT_NEXT_TOKEN) -- ','
		else
			break
		end

		if decl.name.nodeType == !(AST_VARARG) then
			tok = peekNextTok(state, 1)
			if !!(IS_TOK(TOKEN_PUNCTUATION, "...")) then
				!ERROR_OR_RETURN_NIL `errorParsingNext(state, "Only one vararg allowed.")`
			else
				!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Vararg must be the last argument.")`
			end
		end
	end

	local argIndex = lastIndexWith1(args.arguments, "isRequired", true)
	if argIndex then
		for argIndex = 1, argIndex-1 do
			args.arguments[argIndex].isRequired = true
		end
	end

	return args
end

-- success = parseNotes( state, declaration )
local function parseNotes(state, decl)
	local prevOpPrecedence = !(math.min(OPERATOR_PRECEDENCE.call, OPERATOR_PRECEDENCE.access) - 1)
	local tok              = peekNextTok(state, 1)

	while !!(IS_TOK(TOKEN_PUNCTUATION, "@")) do
		!!(EAT_NEXT_TOKEN) -- '@'

		!SET_OR_RETURN_FALSE `local note = parseExpression(state, decl, prevOpPrecedence)`

		decl.notes = decl.notes or {}
		table.insert(decl.notes, note)

		tok = peekNextTok(state, 1)
	end

	return true
end

local function parseStruct(state, parent)
	local struct = astNewNode(AstStruct, state.tokens[state.nextToken-1], parent) -- The token should be the 'struct' keyword.
	local tok    = eatNextTok(state)

	if !!(IS_TOK(TOKEN_PUNCTUATION, "(")) then
		tok = peekNextTok(state, 1)
		if !!(IS_TOK(TOKEN_PUNCTUATION, ")")) or !!(IS_TOK(TOKEN_KEYWORD, "void")) then
			!ERROR_OR_RETURN_NIL `errorParsingNext(state, "Polymorphic structs cannot have an empty argument list.")`
		end

		struct.polymorphs              = {}
		!SET_OR_RETURN_NIL `local args = parseArguments(state, struct, true, false)`

		local gotError = false

		astVisitAllNodes(args, function(node)
			if node.nodeType == !(AST_VARARG) then
				gotError = true
				!ERROR_OR_RETURN_VALUE(`errorParsing(state, node, "Struct arguments cannot be variable.")`, toLua(VISIT_BREAK))

			elseif node.nodeType == !(AST_ARGUMENT) then
				if node.autobake ~= !(AUTOBAKE_DISABLED) and not state.soft then
					state.warnings = state.warnings+1
					parserMessageLine(io.stderr, state, node, "Warning", "Struct arguments are always auto-baked and thus don't need any $.")
				end

			elseif node.nodeType == !(AST_BAKE) then
				!ERROR_OR_RETURN_VALUE(`errorParsing(state, node, "Placeholder types are not supported in struct arguments.")`, toLua(VISIT_BREAK))
			end
		end)

		if gotError then  return nil  end

		-- Move declarations from the temporary args node into the struct for later baking.
		for _, arg in ipairs(args.arguments) do
			local decl  = arg.declaration
			decl.parent = struct
			decl.kind   = !(DECL_KIND_LOCAL_CONST)

			struct.bakeDeclarations = struct.bakeDeclarations or {}
			table.insert(struct.statementsStatic, decl)
			table.insert(struct.declarations,     decl)
			table.insert(struct.bakeDeclarations, decl)
			addDeclarationToNames(struct, decl)
		end

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ')' to end argument list.")`
		end

		tok = eatNextTok(state)
	end

	if not !!(IS_TOK(TOKEN_PUNCTUATION, "{")) then
		!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '{' to start struct body.")`
	end

	-- local takenNames = {} -- Doesn't work because of overloads! We'll have to wait until infer pipe detects any invalid redeclaration.

	-- Note: We allow a trailing comma/semicolon after the last member.
	while true do
		tok              = peekNextTok(state, 1)
		local tok2       = peekNextTok(state, 2)
		local tok3       = peekNextTok(state, 3)
		local parsedDecl = nil

		if !!(IS_TOK(TOKEN_PUNCTUATION, "}")) then
			!!(EAT_NEXT_TOKEN) -- '}'
			break

		elseif !!(IS_TOK(TOKEN_DIRECTIVE, "assert","print")) then
			!SET_OR_RETURN_NIL `local debugNode = parseDebugNode(state, struct)`
			table.insert(struct.statementsStatic, debugNode)

		elseif !!(IS_TOK(TOKEN_KEYWORD, "using")) and not (
			tok3
			and tok2.type == !(TOKEN_IDENTIFIER)
			and !!(IS_TOK(3, TOKEN_PUNCTUATION, "=",":"))
		) then
			!!(EAT_NEXT_TOKEN) -- 'using'
			!SET_OR_RETURN_NIL `local expr = parseExpression(state, struct)`

			struct.inherits = struct.inherits or {}
			table.insert(struct.statementsStatic, expr)
			table.insert(struct.inherits,         expr)

		elseif !!(IS_TOK(TOKEN_DIRECTIVE, "key","value")) then
			!!(EAT_NEXT_TOKEN) -- '!key' or '!value'

			local what      = tok.value
			local fieldName = (what == "key") and "keyType" or "valueType"

			tok = eatNextTok(state)
			if not !!(IS_TOK(TOKEN_PUNCTUATION, ":")) then
				!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ':' after '!%s'.", what)`
			end

			if struct[fieldName] then
				!ERROR_OR_RETURN_NIL `
					local prevToken = astFindTokenAtNode(state, struct[fieldName])
					printerr()
					parserMessage(io.stderr, state, state.tokens[state.nextToken-2], "Error", "Duplicate !%s in struct.",      what)
					if prevToken then -- Should always pass.
					parserMessage(io.stderr, state, state.tokens[prevToken-2],       "Info",  "...previous !%s defined here.", what)
					end
					exitFailure()
				`
			end

			!SET_OR_RETURN_NIL `struct[fieldName] = parseExpression(state, struct)`

		else
			local declType = !(DECLARATION_STRUCT)
			!DO_OR_RETURN_NIL `parseDeclarationStatement(state, struct, false, declType)`
			parsedDecl     = getLast(struct.declarations)

			-- if takenNames[parsedDecl.name.name] then
			-- 	!ERROR_OR_RETURN_NIL `
			-- 		printerr()
			-- 		parserMessage(io.stderr, state, parsedDecl,                       "Error", "Duplicate member '%s' in struct.", parsedDecl.name.name)
			-- 		parserMessage(io.stderr, state, takenNames[parsedDecl.name.name], "Info",  "...previous declaration here.")
			-- 		exitFailure()
			-- 	`
			-- end
			-- takenNames[parsedDecl.name.name] = parsedDecl
		end

		local token
		tok, token                = eatNextTok(state)
		local maybeMoreStatements = !!(IS_TOK(TOKEN_PUNCTUATION, ",",";"))

		if parsedDecl then
			!DO_OR_RETURN_NIL `parseNotes(state, parsedDecl)`
		end

		if maybeMoreStatements then
			-- Continue the loop.
		elseif !!(IS_TOK(TOKEN_PUNCTUATION, "}")) then
			break
		else
			!ERROR_OR_RETURN_NIL `errorParsingAfter(state, token-1, "Expected '}' to end struct.")`
		end
	end

	return struct
end

local function parseEnum(state, parent)
	local enum = astNewNode(AstEnum, state.tokens[state.nextToken-1], parent) -- The token should be the 'enum' keyword.
	local tok  = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_KEYWORD, "float","int","string","bool","Type")) then -- We don't allow 'table', 'any' or anything user-defined.
		!SET_OR_RETURN_NIL `enum.memberType = parseExpression(state, enum, 1/0)`
	end

	tok = eatNextTok(state)

	if not !!(IS_TOK(TOKEN_PUNCTUATION, "{")) then
		local tok2 = peekNextTok(state, 1)
		if
			(
				tok.type == !(TOKEN_IDENTIFIER)
				or !!(IS_TOK(TOKEN_KEYWORD, unpack(BUILTIN_TYPE_KEYWORDS)))
			)
			and !!(IS_TOK(2, TOKEN_PUNCTUATION, "{"))
		then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Supported enum member types are: int, string, Type, bool, float")`
		else
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '{' to start enum body.")`
		end
	end

	local takenNames = {}

	-- Note: We allow a trailing comma/semicolon after the members.
	while true do
		local declType = !(DECLARATION_ENUM)
		!DO_OR_RETURN_NIL `parseDeclarationStatement(state, enum, false, declType)`

		local token
		tok, token                = eatNextTok(state)
		local maybeMoreStatements = !!(IS_TOK(TOKEN_PUNCTUATION, ",",";"))

		local parsedDecl = getLast(enum.declarations)
		!DO_OR_RETURN_FALSE `parseNotes(state, parsedDecl)`

		if takenNames[parsedDecl.name.name] then
			!ERROR_OR_RETURN_NIL `
				printerr()
				parserMessage(io.stderr, state, parsedDecl,                       "Error", "Duplicate member '%s' in enum.", parsedDecl.name.name)
				parserMessage(io.stderr, state, takenNames[parsedDecl.name.name], "Info",  "...previous declaration here.")
				exitFailure()
			`
		end
		takenNames[parsedDecl.name.name] = parsedDecl

		if maybeMoreStatements then
			-- Continue the loop.
		elseif !!(IS_TOK(TOKEN_PUNCTUATION, "}")) then
			break
		else
			!ERROR_OR_RETURN_NIL `errorParsingAfter(state, token-1, "Expected '}' to end enum.")`
		end

		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_PUNCTUATION, "}")) then
			!!(EAT_NEXT_TOKEN) -- '}'
			break
		end
	end

	return enum
end

-- success = parseDeclarationStatement( compilationState, parentScope, inImperativeScope [, declarationType=DECLARATION_NORMAL ] )
-- declarationType = DECLARATION_NORMAL | DECLARATION_STRUCT | DECLARATION_ENUM
!FILE_LOCAL `function parseDeclarationStatement(state, scope, imperative, declType)`
	--[[
	local a := 0        -- Variable, inferred type.
	local a  = 0        -- Variable, inferred type (same as the above).
	local b:float = 0   -- Variable, explicit type.
	local c:float       -- Variable, getting the default value for the type.
	local A :: 0        -- Constant, inferred type.
	local B:float : 0   -- Constant, explicit type.
	local a,b,c = 0,f() -- Multiples always have either inferred type...
	local a,b:int : 1,2 -- ...or the same type.
	local A :: struct {}
	local A :: enum   {}
	local a :: !import "lib"
	]]

	declType = declType or !(DECLARATION_NORMAL)

	local declarations        = {} -- []AstDeclaration
	local declNames           = {} -- []AstIdentifier
	local declNamesFromBefore = {--[[ name1=true, ... ]]}
	local isUsing             = false
	local declKind

	local tok = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_KEYWORD, "using")) then
		!!(EAT_NEXT_TOKEN) -- 'using'
		isUsing = true
	end

	local kindToken = state.nextToken

	if declType == !(DECLARATION_NORMAL) then
		tok = eatNextTok(state)

		if not !!(IS_TOK(TOKEN_KEYWORD)) then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Expected 'local'.")` -- I don't think we ever get here. 2021-08-07
		elseif tok.value == "local" then
			declKind = !(DECL_KIND_LOCAL_VAR)
		elseif tok.value == "export" then
			declKind = !(DECL_KIND_EXPORT_VAR)
		elseif tok.value == "static" then
			declKind = !(DECL_KIND_STATIC) ; imperative = false
		-- elseif tok.value == "read_only" then
		-- 	declKind = !(DECL_KIND_READ_ONLY)
		else
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Expected 'local'.")` -- I don't think we ever get here. 2021-08-07
		end

	else
		declKind = !(DECL_KIND_LOCAL_VAR)
	end

	local nameListStartToken = state.nextToken
	-- local takenNames      = {} -- @Incomplete: Use this? Or is this a copypaste error? 2021-07-22 (Probably the latter.)

	if declType == !(DECLARATION_NORMAL) then
		!DO_OR_RETURN_FALSE `parseNameList(state, scope, declNames, declNamesFromBefore, true)` -- Note: We update parent here below.

		for i, ident in ipairs(declNames) do
			local decl        = astNewNode(AstDeclaration, ident, scope)
			declarations[i]   = decl

			ident.kind        = !(IDENT_KIND_DECLARATION)
			ident.declaration = decl
			ident.parent      = decl

			decl.name         = ident
		end

	else
		tok = peekNextTok(state, 1)
		if not tok then
			-- We shouldn't get here because struct/enum declarations are always surrounded
			-- by {}, and the bracket quick check should detect missing end brackets.
			!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Expected an identifier in declaration.")`
		end

		local decl      = astNewNode(AstDeclaration, tok, scope)
		declarations[1] = decl
		local ident

		if declType == !(DECLARATION_STRUCT) and !!(IS_TOK(TOKEN_DIRECTIVE, "call","iterator")) then
			!!(EAT_NEXT_TOKEN) -- '!call' or '!iterator'
			ident      = astNewNode(AstIdentifier, tok, decl)
			ident.name = "!"..tok.value
		else
			!SET_OR_RETURN_FALSE `ident = parseIdentifier(state, decl)`
		end

		ident.kind        = !(IDENT_KIND_DECLARATION)
		ident.declaration = decl
		decl.position     = ident.position
		decl.line         = ident.line
		decl.name         = ident
		table.insert(declNames, ident)
	end

	!ASSERT `declarations[1]`
	!ASSERT `#declarations == #declNames`

	local typesStartToken = state.nextToken -- Dummy position, kinda.
	tok                   = peekNextTok(state, 1)

	-- local x: someType
	-- local x := value
	-- local x :: value
	if !!(IS_TOK(TOKEN_PUNCTUATION, ":")) then
		!!(EAT_NEXT_TOKEN) -- ':'

		typesStartToken = state.nextToken
		tok             = peekNextTok(state, 1)

		-- Inferred type.
		if !!(IS_TOK(TOKEN_PUNCTUATION, ":","=")) then
			-- void

		-- Specified type.
		else
			if declType == !(DECLARATION_ENUM) then
				!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "The type of the members must be specified after the 'enum' keyword.")`
			end
			for _, decl in ipairs(declarations) do
				state.nextToken                 = typesStartToken
				!SET_OR_RETURN_FALSE `decl.type = parseExpression(state, decl)` -- @Speed: Parse once then just copy the first one.
			end
		end

	-- local x = value
	elseif !!(IS_TOK(TOKEN_PUNCTUATION, "=")) then
		-- void

	-- enum { NAME1, NAME2 }
	elseif declType == !(DECLARATION_ENUM) and !!(IS_TOK(TOKEN_PUNCTUATION, ",","}")) then
		-- void

	else
		!ERROR_OR_RETURN_FALSE `errorParsingAfterLast(state, "Expected ':' or '=' in declaration.")`
	end

	tok = peekNextTok(state, 1)

	local assignment  = nil
	local isConst     = false

	if !!(IS_TOK(TOKEN_PUNCTUATION, "=",":")) then
		!!(EAT_NEXT_TOKEN) -- '=' or ':'
		isConst = (tok.value == ":")

		if isConst then
			imperative = false
			if     declKind == !(DECL_KIND_LOCAL_VAR)  then  declKind = !(DECL_KIND_LOCAL_CONST)
			elseif declKind == !(DECL_KIND_EXPORT_VAR) then  declKind = !(DECL_KIND_EXPORT_CONST)
			elseif declKind == !(DECL_KIND_STATIC)     then  !ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Static names cannot be constant.")`
			else                                             errorInternal("%s", declKind)  end
		elseif declType == !(DECLARATION_ENUM) then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Enum members must be constant.")`
		end

		if imperative then
			assignment                = astNewNode(AstAssignment, state.tokens[state.nextToken-1], scope)
			assignment.forDeclaration = true
			assignment.declarations   = {}

			for i, decl in ipairs(declarations) do
				local identCopy       = astCopy(declNames[i], nil, assignment)
				assignment.targets[i] = identCopy

				decl.assignment       = assignment
				decl.assignmentIndex  = i

				if declNamesFromBefore[identCopy.name] then
					identCopy.declaration      = nil
					identCopy.kind             = !(IDENT_KIND_ASSIGNMENT)
					assignment.declarations[i] = false -- False instead of nil so there are no gaps in the array as that would mess up astCopy().
				else
					identCopy.kind             = !(IDENT_KIND_DECLARATION_ASSIGNMENT)
					assignment.declarations[i] = decl
				end
			end

			if declType == !(DECLARATION_NORMAL) then
				!DO_OR_RETURN_FALSE `parseExpressionList(state, assignment, assignment.values, nil, false)`
			else
				!SET_OR_RETURN_FALSE `local expr = parseExpression(state, assignment)`
				table.insert(assignment.values, expr)
			end

		else
			for i, decl in ipairs(declarations) do
				if i > 1 then
					tok = eatNextTok(state)
					if not !!(IS_TOK(TOKEN_PUNCTUATION, ",")) then
						!ERROR_OR_RETURN_FALSE `errorParsingAfterPrevious(state, "Missing a value for '%s'.", decl.name.name)`
					end
				end

				decl.value = parseExpression(state, decl)
			end
		end

	elseif declType == !(DECLARATION_ENUM) then
		local enum = scope
		!ASSERT("enum.nodeType == "..AST_ENUM) -- Note: We don't support !if or anything in enums, so the parent scope should always be the enum.

		if enum.memberType and not (enum.memberType.typeName == "int" or enum.memberType.typeName == "string") then
			!ERROR_OR_RETURN_FALSE `errorParsingAfterLast(state, "Expected a value for '%s'. (Only int and string enums support automatic values.)", declNames[1].name)`
		end

		if not enum.memberType or enum.memberType.typeName == "int" then
			enum.autoValue        = enum.autoValue + 1
			declarations[1].value = newLiteral(declarations[1], state.tokens[nameListStartToken], !(LITERAL_INTEGER), enum.autoValue)
		elseif enum.memberType.typeName == "string" then
			declarations[1].value = newLiteral(declarations[1], state.tokens[nameListStartToken], !(LITERAL_STRING), declNames[1].name)
		else
			errorInternal(state, enum.memberType, enum.memberType.typeName)
		end

		!ASSERT("declKind == "..DECL_KIND_LOCAL_VAR)

		declKind   = !(DECL_KIND_LOCAL_CONST)
		isConst    = true
		imperative = false
	end

	for _, decl in ipairs(declarations) do
		decl.kind = declKind
	end

	-- Validate "previously declared" flag.
	local hasDeclNamesFromBefore = next(declNamesFromBefore)
	if not hasDeclNamesFromBefore then
		-- void

	elseif not imperative then
		for _, ident in ipairs(declNames) do
			if declNamesFromBefore[ident.name] then
				errorParsing(state, ident, "Only imperative variable declarations can be flagged as 'previously declared'.") -- @Incomplete: Point at '^'.
			end
		end
		errorInternal(state, declarations[1])

	elseif not assignment then
		for _, ident in ipairs(declNames) do
			if declNamesFromBefore[ident.name] then
				errorParsing(state, ident, "Declarations with names flagged as 'previously declared' can only be used if there's an explicit assignment.") -- @Incomplete: Point at '^'.
			end
		end
		errorInternal(state, declarations[1])
	end

	-- Set if shadowing is allowed.
	tok = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_DIRECTIVE, "shadow")) then
		!!(EAT_NEXT_TOKEN) -- '!shadow'

		if isConst then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Constants cannot be shadows.")`
		elseif declType == !(DECLARATION_STRUCT) then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Struct members cannot be marked as shadows.")`
		elseif declType == !(DECLARATION_STRUCT) then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Enum members cannot be marked as shadows.")` -- We should never get here because enum members must be constant, and we already detect that.
		elseif declType ~= !(DECLARATION_NORMAL) then
			errorInternal(declType)
		end

		for _, decl in ipairs(declarations) do
			decl.canShadow = true
		end
	end

	-- Quickly check if the value count is obviously wrong.
	if assignment then
		local valueCount = #assignment.values
		local nameCount  = #declNames

		if valueCount > nameCount then
			!ERROR_OR_RETURN_FALSE `errorParsing(
				state, assignment.values[nameCount+1], -- @Incomplete: Point at the ',' right before.
				"There are more values than names being declared. (Expected %d value%s, got %d)",
				nameCount, (nameCount == 1 and "" or "s"), valueCount
			)`

		elseif isConst and valueCount < nameCount then -- I think we already detect this earlier in non-imperative context. 2021-08-07
			!ERROR_OR_RETURN_FALSE `errorParsingAfterLast(
				state,
				"No value for '%s'. Each constant must have it's own value. (Expected %d values, got %d)",
				declNames[valueCount+1].name, nameCount, valueCount
			)`
		end
	end

	if declType == !(DECLARATION_STRUCT) and not isConst and !!(CONST_SET{"!call","!iterator"})[declNames[1].name] then
		!ERROR_OR_RETURN_FALSE `errorParsing(state, declNames[1], "%s declarations must be constant.", declNames[1].name)`
	end

	if declType == !(DECLARATION_NORMAL) then  eatTrailingSemicolon(state)  end

	-- Notes (after any semicolon).
	if declType == !(DECLARATION_NORMAL) then
		local token = state.nextToken

		for _, decl in ipairs(declarations) do
			state.nextToken = token
			!DO_OR_RETURN_FALSE `parseNotes(state, decl)`

			if not decl.notes then  break  end
		end
	end

	-- Remove declarations that are marked as "previously declared".
	-- @Speed: Don't even create and add them in the first place.
	if imperative and hasDeclNamesFromBefore then
		for i, ident in ipairsr(declNames) do
			if declNamesFromBefore[ident.name] then
				table.remove(declarations, i)
			end
		end

		if not declarations[1] then
			errorParsing(state, kindToken, "Declaration statement has no new declarations - only previous declarations are used.")
		end
	end
	!ifDEBUG `declNames = nil` -- We should only use 'declarations' after this point.

	--
	-- Everything's done! Now we can modify the scope.
	--

	local statements = (imperative and scope.statementsDynamic or scope.statementsStatic)
	for _, decl in ipairs(declarations) do
		table.insert(statements,         decl)
		table.insert(scope.declarations, decl)
		addDeclarationToNames(scope, decl)
	end

	if assignment then
		table.insert(scope.statementsDynamic, assignment)
	end

	if isUsing then
		for _, decl in ipairs(declarations) do
			local using       = astNewNode(AstUsing, decl, scope)

			local ident       = astNewNode(AstIdentifier, decl, using)
			ident.kind        = !(IDENT_KIND_LOOSE)
			ident.name        = decl.name.name
			ident.declaration = decl
			using.expression  = ident

			scope.usings = scope.usings or {}
			table.insert(scope.statementsStatic, using)
			table.insert(scope.usings,           using)
		end
	end

	!if DEBUG then
		local decl1 = declarations[1]
		if decl1 and (decl1.kind == !(DECL_KIND_LOCAL_CONST) or decl1.kind == !(DECL_KIND_EXPORT_CONST)) then
			assert(decl1.value)
			assert(not assignment)
		end
	!end

	return true
end

local function parseAssignment(state, parent)
	local statementStartTok = state.tokens[state.nextToken]
	local assignment        = astNewNode(AstAssignment, (statementStartTok or getLast(state.tokens)), parent)

	!DO_OR_RETURN_NIL `parseExpressionList(state, assignment, assignment.targets, nil, true)`

	for _, expr in ipairs(assignment.targets) do
		if expr.nodeType == !(AST_IDENTIFIER) or expr.nodeType == !(AST_VARARG) or expr.nodeType == !(AST_BLANK) then
			expr.kind = !(IDENT_KIND_ASSIGNMENT)
		elseif expr.nodeType == !(AST_ACCESS) then
			-- void
		else
			-- parseExpressionList() already reports this error (though the message isn't great). 2021-08-07 @Cleanup
			!ERROR_OR_RETURN_NIL `errorParsing(state, expr, "Expected assignment target expression to resolve into a variable or lookup.")`
		end
	end

	local tok  = eatNextTok(state)
	local tok2 = peekNextTok(state, 1)

	if tok and isTokenAssigning(tok) then
		assignment.position        = tok.position1
		assignment.line            = tok.line1
		assignment.binaryOperation = tok.value:sub(1, -2) -- All assignments with extra operations (in the case of punctuation here) end with '=' (e.g. '+='). Here we just strip away the '='.

	elseif tok2 and !!(IS_EXISTING_TOK(TOKEN_KEYWORD, "and","or")) and !!(IS_EXISTING_TOK(2, TOKEN_PUNCTUATION, "=")) then
		!!(EAT_NEXT_TOKEN) -- '='

		-- Make sure there's no space before '=' as that's a little ambiguous. ('+=' etc. don't allow any space before '='.)
		if tok2.position1 ~= tok.position2 + 1 then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Did you mean '%s='?", tok.value)`
		end

		assignment.position        = tok.position1
		assignment.line            = tok.line1
		assignment.binaryOperation = tok.value

	else
		!TRACE()
		!ERROR_OR_RETURN_NIL `
			printerr()
			parserMessageAfter(io.stderr, state, state.tokens[state.nextToken-2], "Error", "Expected '=' in assignment statement.")
			parserMessage     (io.stderr, state, statementStartTok,               "Info",  "...start of statement is here.")
			exitFailure()
		`
	end

	!DO_OR_RETURN_NIL `parseExpressionList(state, assignment, assignment.values, nil, false)`

	-- Quickly check if there are obviously too many values.
	if #assignment.values > #assignment.targets then
		!ERROR_OR_RETURN_NIL `errorParsing(
			state, assignment.values[#assignment.targets+1], -- @Incomplete: Point at the ',' right before.
			"There are more values than assignment targets."
		)`
	end

	return assignment
end

-- Add the names to the 'names' array.
-- success = parseNameList( compilationState, parent, names, namesFromBefore=nil, allowBlanks )
!FILE_LOCAL `function parseNameList(state, parent, names, namesFromBefore, allowBlanks)`
	local takenNames = {}

	while true do
		local tok = peekNextTok(state, 1)
		local identOrBlank

		if allowBlanks and !!(IS_TOK(TOKEN_PUNCTUATION, "_")) then
			!!(EAT_NEXT_TOKEN) -- '_'
			identOrBlank = astNewNode(AstBlank, tok, parent)

		else
			local fromBefore = false

			if namesFromBefore and !!(IS_TOK(TOKEN_PUNCTUATION, "^")) then
				!!(EAT_NEXT_TOKEN) -- '^'
				fromBefore = true
			end

			!SET_OR_RETURN_FALSE `identOrBlank = parseIdentifier(state, parent)`
			if takenNames[identOrBlank.name] then
				!ERROR_OR_RETURN_FALSE `
					printerr()
					parserMessage(io.stderr, state, state.tokens[state.nextToken-1], "Error", "Duplicate name '%s'.", identOrBlank.name)
					parserMessage(io.stderr, state, takenNames[identOrBlank.name],   "Info",  "...name was previously used here.")
					exitFailure()
				`
			end
			takenNames[identOrBlank.name] = identOrBlank

			if fromBefore then
				namesFromBefore[identOrBlank.name] = true
			end
		end

		table.insert(names, identOrBlank)
		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_PUNCTUATION, ",")) then
			!!(EAT_NEXT_TOKEN) -- ','
			-- Continue the loop.
		else
			break
		end
	end

	return true
end

!FILE_LOCAL `function parseDebugNode(state, parent)`
	local tok = eatNextTok(state)
	if not !!(IS_TOK(TOKEN_DIRECTIVE)) then
		!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Internal compiler error: Expected a directive.")` -- The caller messed up.
	end

	local debugNode  = astNewNode(AstDebug, tok, parent)
	debugNode.action = tok.value

	!SET_OR_RETURN_NIL `debugNode.expression = parseExpression(state, debugNode)`

	return debugNode
end

local function parseIfBranch(state, ifOrStaticIf, isFileScopeOrNamespace)
	local tok = peekNextTok(state, 1)
	local block

	if !!(IS_TOK(TOKEN_KEYWORD, "void")) then
		!!(EAT_NEXT_TOKEN) -- 'void'

		block = astNewNode(AstBlock, tok, ifOrStaticIf)

	elseif isFileScopeOrNamespace then
		!ASSERT("ifOrStaticIf.nodeType == "..AST_STATIC_IF)

		-- This block will never get inferred - it's just for storing statements we may potentially use.
		-- (Should we have a dedicated node type for this? Probably not needed.)
		block = astNewNode(AstBlock, tok, ifOrStaticIf)

		if !!(IS_TOK(TOKEN_PUNCTUATION, "{")) then
			!!(EAT_NEXT_TOKEN) -- '{'
			!DO_OR_RETURN_NIL `parseFileScopeOrNamespaceStatements(state, block, false, false)`
		else
			!DO_OR_RETURN_NIL `parseFileScopeOrNamespaceStatements(state, block, false, true)`
		end

	else
		!SET_OR_RETURN_NIL `block = parseBlockOrScopedStatement(state, ifOrStaticIf)`
	end

	return block
end

local function parseIfOrStaticIf(state, parent, isFileScopeOrNamespace)
	local tok = eatNextTok(state)
	!if DEBUG then
		assert((tok.type == !(TOKEN_KEYWORD) or tok.type == !(TOKEN_DIRECTIVE)) and tok.value == "if")
	!end

	local nodeConstructor = tok.type == !(TOKEN_KEYWORD) and AstIf or AstStaticIf
	local ifOrStaticIf    = astNewNode(nodeConstructor, tok, parent)

	!SET_OR_RETURN_NIL `ifOrStaticIf.condition  = parseExpression(state, ifOrStaticIf)`
	!SET_OR_RETURN_NIL `ifOrStaticIf.branchTrue = parseIfBranch(state, ifOrStaticIf, isFileScopeOrNamespace)`

	tok = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_KEYWORD, "else")) then
		!!(EAT_NEXT_TOKEN) -- 'else'

		-- Make !if...elseif work.
		if nodeConstructor == AstStaticIf then
			local token
			tok, token = peekNextTok(state, 1)
			if !!(IS_TOK(TOKEN_KEYWORD, "if")) and tok.position1 == state.tokens[token-1].position1+4 then
				tok.type = !(TOKEN_DIRECTIVE) -- Just make the 'if' into '!if'.
			end
		end

		!SET_OR_RETURN_NIL `ifOrStaticIf.branchFalse = parseIfBranch(state, ifOrStaticIf, isFileScopeOrNamespace)`
	end

	return ifOrStaticIf
end

local function getBreakableNameFromSimpleExpression(expr)
	if expr.nodeType == !(AST_IDENTIFIER) then
		return expr.name

	elseif expr.nodeType == !(AST_UNARY) then
		if expr.operation == "not" and expr.expression.nodeType == !(AST_IDENTIFIER) then
			return expr.expression.name
		end

	elseif expr.nodeType == !(AST_BINARY) then
		if expr.left.nodeType == expr.right.nodeType then
			-- void
		elseif expr.left.nodeType == !(AST_IDENTIFIER) then
			if expr.right.nodeType == !(AST_LITERAL) then  return expr.left.name   end
		elseif expr.right.nodeType == !(AST_IDENTIFIER) then
			if expr.left.nodeType  == !(AST_LITERAL) then  return expr.right.name  end
		end
	end

	return ""
end

local function parseSwitch(state, parent, statementStartToken, valueExpr, complete)
	-- Note: Assume '... == {' has been eaten already.
	local switch     = astNewNode(AstSwitch, state.tokens[statementStartToken], parent)
	switch.complete  = complete
	switch.value     = valueExpr
	valueExpr.parent = switch

	local gotDefault = false
	local lastCaseToken, lastThroughToken

	while true do
		local tok = eatNextTok(state)
		if !!(IS_TOK(TOKEN_PUNCTUATION, "}")) then
			break
		elseif not !!(IS_TOK(TOKEN_KEYWORD, "case")) then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected 'case' or '}'.")`
		elseif gotDefault then
			-- @UX @Polish: Different message if there are two defaults.
			!ERROR_OR_RETURN_NIL `errorParsing(state, lastCaseToken, "The default case must be last.")`
		end

		lastCaseToken = state.nextToken - 1

		local case = SwitchCase()
		table.insert(switch.cases, case)

		tok = peekNextTok(state, 1)
		if !!(IS_TOK(TOKEN_PUNCTUATION, ":")) then
			gotDefault = true -- Omitted value means the default case.
		else
			!SET_OR_RETURN_NIL `case.value = parseExpression(state, switch)`
		end

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, ":")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ':' after the case.")`
		end

		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_DIRECTIVE, "through")) then
			!!(EAT_NEXT_TOKEN) -- '!through'

			-- This check is not needed as default cases must be last and we can never fall through the last case (default or not).
			-- if gotDefault then
			-- 	!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Cannot fall through the default case.")`
			-- end

			case.fallThrough = true
			lastThroughToken = state.nextToken - 1

		else
			case.body = astNewNode(AstBlock, (tok or getLast(state.tokens)), switch)

			while true do
				tok = peekNextTok(state, 1)
				if !!(IS_TOK(TOKEN_KEYWORD, "case")) or !!(IS_TOK(TOKEN_PUNCTUATION, "}")) then
					break
				elseif !!(IS_TOK(TOKEN_DIRECTIVE, "through")) then
					-- @Incomplete: Support !through after other statements. (ProgramWriter needs to get better!)
					!ERROR_OR_RETURN_NIL `errorParsingNext(state, "!through must currently be right after 'case'.")`
				end
				!DO_OR_RETURN_NIL `parseOneStatementButSometimesMoreAndAddToBlock(state, case.body)`
			end
		end
	end

	if switch.cases[1] and getLast(switch.cases).fallThrough then
		!ERROR_OR_RETURN_NIL `errorParsing(state, lastThroughToken, "Cannot fall through the last case.")`
	end

	return switch
end

-- success = parseOneStatementButSometimesMoreAndAddToBlock( state, block )
!FILE_LOCAL `function parseOneStatementButSometimesMoreAndAddToBlock(state, block)`
	local tok  = peekNextTok(state, 1)
	local tok2 = peekNextTok(state, 2)

	if !!(IS_TOK(TOKEN_KEYWORD, "local","static")) or (
		!!(IS_TOK(   TOKEN_KEYWORD, "using")) and
		!!(IS_TOK(2, TOKEN_KEYWORD, "local","static"))
	) then
		!DO_OR_RETURN_FALSE `parseDeclarationStatement(state, block, true)`
		return true
	end

	local statementStartToken = state.nextToken
	local statementStartTok   = state.tokens[statementStartToken]
	local statement

	if !!(IS_TOK(TOKEN_KEYWORD, "export")) or (
		!!(IS_TOK(   TOKEN_KEYWORD, "using")) and
		!!(IS_TOK(2, TOKEN_KEYWORD, "export"))
	) then
		if tok.value == "using" then  eatNextTok(state)  end
		!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Exports can only be declared in file scope or in namespaces.")`

	elseif !!(IS_TOK(TOKEN_KEYWORD, "return")) then
		local returnNode = astNewNode(AstReturn, tok, block)

		!!(EAT_NEXT_TOKEN) -- 'return'

		--
		-- Note: Considering this following @Ambiguous situation we have to check whether any values should be returned.
		-- As a bonus we also figure if we're even inside a function, though I'm not sure this'll work when we have static code. @Robustness
		--
		--   if x return
		--   func() -- Returned expression, or separate statement after 'if'?
		--
		local lambda = getLambda(returnNode)
		if not lambda then
			-- This shouldn't happen as this function shouldn't be called by anything that does not parse return statements.
			!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Internal compiler error: Not inside a function.")`
		end

		tok = peekNextTok(state, 1)
		if !!(IS_TOK(TOKEN_KEYWORD, "void")) then -- We allow 'return void' both for vararg functions and functions with no return values.
			!!(EAT_NEXT_TOKEN) -- 'void'
		elseif lambda.argumentsOut then
			!DO_OR_RETURN_FALSE `parseExpressionList(state, returnNode, returnNode.values, nil, false)`
		end

		statement = returnNode

	elseif !!(IS_TOK(TOKEN_KEYWORD, "break","continue")) then
		local keyword         = tok.value
		local isContinue      = keyword == "continue"
		local breakOrContinue = astNewNode((isContinue and AstContinue or AstBreak), tok, block)

		!!(EAT_NEXT_TOKEN) -- 'break' or 'continue'

		!local constName   = CONST_SET{ AST_FOR, AST_WHILE, AST_LAMBDA }
		local loopOrLambda = astFindParent(breakOrContinue, !!(constName))

		if not loopOrLambda or loopOrLambda.nodeType == !(AST_LAMBDA) then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Not inside a loop.")`
		end

		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_PUNCTUATION, "(")) then
			!!(EAT_NEXT_TOKEN) -- '('

			!SET_OR_RETURN_FALSE `local loopNameIdent = parseIdentifier(state, breakOrContinue)`

			tok = eatNextTok(state)

			if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
				!ERROR_OR_RETURN_FALSE `errorParsingAfterPrevious(state, "Expected ')' in %s expression.", keyword)`
			end

			local loopName    = loopNameIdent.name
			local loopClosest = loopOrLambda

			repeat
				-- We can break from these types of loops:
				--   for i = 1, 2  break(i)
				--   while x       break(x)
				--   while not x   break(x)
				-- We cannot break from these:
				--   for 1, 2   break(it)  -- 'it' is an implicit name. (We could make this work if necessary.)
				--   while x+y  break(x)   -- The condition expression is too complex. (What's "too complex" is debatable. @Revise)
				if
					loopOrLambda.nodeType == !(AST_FOR)   and itemWith1(loopOrLambda.names, "name", loopName) or
					loopOrLambda.nodeType == !(AST_WHILE) and getBreakableNameFromSimpleExpression(loopOrLambda.condition) == loopName
				then
					if loopOrLambda == loopClosest and not isContinue then
						-- void  We don't need a named break if we're breaking from the closest loop. (Should we save this info anyway for the metaprogram? Probably!)
					else
						breakOrContinue.loopName   = loopNameIdent
						breakOrContinue.loop       = loopOrLambda
						loopOrLambda.hasNamedJumps = true
						loopOrLambda.hasContinues  = loopOrLambda.hasContinues or isContinue
					end
					break

				elseif loopOrLambda.nodeType == !(AST_LAMBDA) then
					break -- Assume the identifier is part of a different statement.
				end

				!local constName = CONST_SET{ AST_FOR, AST_WHILE, AST_LAMBDA }
				loopOrLambda     = astFindParent(loopOrLambda, !!(constName))
			until not loopOrLambda

			if not loopOrLambda or loopOrLambda.nodeType == !(AST_LAMBDA) then
				!ERROR_OR_RETURN_FALSE `errorParsing(state, loopNameIdent, "Could not find what loop '%s' refers to.", loopName)`
			end

		elseif isContinue then
			breakOrContinue.loop       = loopOrLambda
			loopOrLambda.hasNamedJumps = true
			loopOrLambda.hasContinues  = true
		end

		statement = breakOrContinue

	elseif !!(IS_TOK(TOKEN_KEYWORD, "do")) then
		!!(EAT_NEXT_TOKEN) -- 'do'
		!SET_OR_RETURN_FALSE `statement = parseBlockOrScopedStatement(state, block)`

	elseif !!(IS_TOK(TOKEN_KEYWORD, "defer")) then
		local defer = astNewNode(AstDefer, tok, block)

		!!(EAT_NEXT_TOKEN) -- 'defer'
		!SET_OR_RETURN_FALSE `defer.body = parseBlockOrScopedStatement(state, defer)`

		statement = defer

	elseif !!(IS_TOK(TOKEN_KEYWORD, "if")) and !!(IS_TOK(2, TOKEN_DIRECTIVE, "complete")) then
		!!(EAT_NEXT_TOKEN) -- 'if'
		!!(EAT_NEXT_TOKEN) -- '!complete'
		!SET_OR_RETURN_FALSE `local expr = parseExpression(state, block)`

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, "==")) then
			!ERROR_OR_RETURN_FALSE `errorParsingAfterPrevious(state, "Expected '==' in switch statement.")`
		end

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, "{")) then
			!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Expected '{'.")` -- We probably never get here because the == would be part of a binary expression.
		end

		!SET_OR_RETURN_FALSE `statement = parseSwitch(state, block, statementStartToken, expr, true)`

	elseif !!(IS_TOK(TOKEN_KEYWORD, "if")) then
		!!(EAT_NEXT_TOKEN) -- 'if'
		!SET_OR_RETURN_FALSE `local expr = parseExpression(state, block)`
		tok  = peekNextTok(state, 1)
		tok2 = peekNextTok(state, 2)

		if !!(IS_TOK(TOKEN_PUNCTUATION, "==")) and !!(IS_TOK(2, TOKEN_PUNCTUATION, "{")) then
			!!(EAT_NEXT_TOKEN) -- '=='
			!!(EAT_NEXT_TOKEN) -- '{'
			!SET_OR_RETURN_FALSE `statement = parseSwitch(state, block, statementStartToken, expr, false)`

		else
			state.nextToken = statementStartToken
			!SET_OR_RETURN_FALSE `statement = parseIfOrStaticIf(state, block, false)`
		end

	elseif !!(IS_TOK(TOKEN_DIRECTIVE, "if")) then
		!SET_OR_RETURN_FALSE `statement = parseIfOrStaticIf(state, block, false)`

	elseif !!(IS_TOK(TOKEN_KEYWORD, "while")) then
		local whileLoop = astNewNode(AstWhile, tok, block)
		!!(EAT_NEXT_TOKEN) -- 'while'

		!SET_OR_RETURN_FALSE `whileLoop.condition = parseExpression(state, whileLoop)`
		tok                                       = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_KEYWORD, "void")) then
			!!(EAT_NEXT_TOKEN) -- 'void'
			whileLoop.body = astNewNode(AstBlock, tok, whileLoop)
		else
			!SET_OR_RETURN_FALSE `whileLoop.body = parseBlockOrScopedStatement(state, whileLoop)`
		end

		statement = whileLoop

	elseif !!(IS_TOK(TOKEN_KEYWORD, "for")) then
		local forLoop = astNewNode(AstFor, tok, block)

		!!(EAT_NEXT_TOKEN) -- 'for'
		tok = peekNextTok(state, 1)

		local tokAfterKeyword = tok

		-- FOR_SHORT  for < [ v1, ... : ] obj
		if !!(IS_TOK(TOKEN_PUNCTUATION, "<")) then
			!!(EAT_NEXT_TOKEN) -- '<'
			forLoop.reverse = true
		end

		local forStartIndex = state.nextToken

		local exprListWeMayOrMayNotUse = {}
		!DO_OR_RETURN_FALSE `parseExpressionList(state, forLoop, exprListWeMayOrMayNotUse, nil, false)`

		tok = peekNextTok(state, 1)
		local twoParter

		-- FOR_ITERATOR  for v1, ... in iter [, state [, init ] ]
		if !!(IS_TOK(TOKEN_KEYWORD, "in")) then
			forLoop.forType = !(FOR_ITERATOR)
		-- FOR_SHORT     for [ < ] v1, ... : obj
		elseif !!(IS_TOK(TOKEN_PUNCTUATION, ":")) then
			forLoop.forType = !(FOR_SHORT)
			twoParter       = true
		-- FOR_NUMERIC   for i = start, end [, step ]
		elseif !!(IS_TOK(TOKEN_PUNCTUATION, "=")) then
			forLoop.forType = !(FOR_NUMERIC)
			twoParter       = true
		-- FOR_NUMERIC   for start, end [, step ]
		elseif #exprListWeMayOrMayNotUse >= 2 then -- If more than 3 arguments are specified then we'll get an error later.
			forLoop.forType = !(FOR_NUMERIC)
			twoParter       = false
		-- FOR_SHORT     for [ < ] obj
		elseif #exprListWeMayOrMayNotUse == 1 then
			forLoop.forType = !(FOR_SHORT)
			twoParter       = false
		else
			!ERROR_OR_RETURN_FALSE `errorParsing(state, forLoop, "Could not determine what kind of 'for' statement this is.")` -- Not sure we ever actually get here.
		end

		if forLoop.reverse and forLoop.forType ~= !(FOR_SHORT) then
			!ERROR_OR_RETURN_FALSE `errorParsing(state, tokAfterKeyword, "Only short-form 'for' loops support the reverse operator.")`
		end

		if forLoop.forType == !(FOR_NUMERIC) then
			-- for i = start, end [, step ]
			if twoParter then
				state.nextToken = forStartIndex
				!DO_OR_RETURN_FALSE `parseNameList(state, forLoop, forLoop.names, nil, false)`

				if forLoop.names[2] then
					!ERROR_OR_RETURN_FALSE `errorParsing(state, forLoop.names[2], "Expected only one name in numeric 'for' loop.")`
				end

				tok = eatNextTok(state)
				assert(!!(IS_TOK(TOKEN_PUNCTUATION, "=")))

				!DO_OR_RETURN_FALSE `parseExpressionList(state, forLoop, forLoop.expressions, nil, false)`

			-- for start, end [, step ]
			else
				forLoop.expressions = exprListWeMayOrMayNotUse
			end

			if #forLoop.expressions < 2 then
				!ERROR_OR_RETURN_FALSE `errorParsingAfterLast(state, "Expected 2 or 3 parameters for the numeric 'for' loop.")`
			elseif #forLoop.expressions > 3 then
				!ERROR_OR_RETURN_FALSE `errorParsing(state, forLoop.expressions[4], "Expected 2 or 3 parameters for the numeric 'for' loop.")` -- @Incomplete: Point at the ',' right before.
			end

		elseif forLoop.forType == !(FOR_SHORT) then
			-- for [ < ] v1, ... : obj
			if twoParter then
				state.nextToken = forStartIndex
				!DO_OR_RETURN_FALSE `parseNameList(state, forLoop, forLoop.names, nil, false)`

				tok = eatNextTok(state)
				assert(!!(IS_TOK(TOKEN_PUNCTUATION, ":")))

				!DO_OR_RETURN_FALSE `parseExpressionList(state, forLoop, forLoop.expressions, nil, false)`

				if forLoop.expressions[2] then
					!ERROR_OR_RETURN_FALSE `errorParsing(state, forLoop.expressions[2], "Expected a single parameter for the short-form 'for' loop.")` -- @Incomplete: Point at the ',' right before.
				end

			-- for [ < ] obj
			else
				forLoop.expressions = exprListWeMayOrMayNotUse
				assert(#forLoop.expressions == 1)
			end

		-- for v1, ... in iter [, state [, init ] ]
		else
			state.nextToken = forStartIndex
			!DO_OR_RETURN_FALSE `parseNameList(state, forLoop, forLoop.names, nil, false)`

			tok = eatNextTok(state)
			assert(!!(IS_TOK(TOKEN_KEYWORD, "in")))

			!DO_OR_RETURN_FALSE `parseExpressionList(state, forLoop, forLoop.expressions, nil, false)`
		end

		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_KEYWORD, "void")) then
			!!(EAT_NEXT_TOKEN) -- 'void'
			forLoop.body = astNewNode(AstBlock, tok, forLoop)
		else
			!SET_OR_RETURN_FALSE `forLoop.body = parseBlockOrScopedStatement(state, forLoop)`
		end
		table.insert(forLoop.statementsStatic, forLoop.body)

		statement = forLoop

	elseif !!(IS_TOK(TOKEN_KEYWORD, "using")) then
		!SET_OR_RETURN_FALSE `local using = parseUsing(state, block)`
		statement                         = using

		block.usings = block.usings or {}
		table.insert(block.usings, using)
		-- Shouldn't we also insert 'using' into block.statementsStatic? @Robustness

	elseif !!(IS_TOK(TOKEN_DIRECTIVE, "assert","print")) then
		!SET_OR_RETURN_FALSE `statement = parseDebugNode(state, block)`

	elseif !!(IS_TOK(TOKEN_PUNCTUATION, "_")) then
		!SET_OR_RETURN_FALSE `statement = parseAssignment(state, block)`

	elseif !!(IS_TOK(TOKEN_DIRECTIVE, "run")) then
		!SET_OR_RETURN_FALSE `statement = parseRun(state, block, false)`

	else
		state.soft     = true
		local exprTest = parseExpression(state, block)
		state.soft     = false

		if not exprTest then
			-- !TRACE() -- This fixes the position of the traceback in the console, but we don't want the traceback to here!
			!ERROR_OR_RETURN_FALSE `
				printerr()
				parserMessage(io.stderr, state, statementStartTok, "Error", "Could not parse statement starting here.")

				state.nextToken = statementStartToken
				parseExpression(state, block) -- Should call exitFailure() at some point.
				exitFailure() -- Just to be safe.
			`

		elseif exprTest.nodeType == !(AST_CALL) then
			local call = exprTest
			if call.surroundedByParentheses then
				local token = (call.inline ~= !(INLINE_MAY)) and statementStartToken+1 or statementStartToken
				!ERROR_OR_RETURN_FALSE `errorParsing(state, token, "Invalid parenthesis around call.")`
			end
			--[[ @Incomplete :ParenthesesAmbiguityError
			if
				!!(IS_TOK(TOKEN_PUNCTUATION, "("))
				and call.callee.nodeType == !(AST_CALL)
				and astGetCalleeVisuallyFurthestToTheLeft(call).nodeType == !(AST_IDENTIFIER)
			then
				!ERROR_OR_RETURN_FALSE `errorParsing(state, statementStartToken, "Ambiguous expression being called.")`
			end
			--]]
			statement = call

		elseif exprTest.nodeType == !(AST_IMPORT) then
			-- @Incomplete: Warn about duplicate imports? It'll make imports more similar to how 'using's work.
			local import = exprTest
			statement    = import

			block.imports = block.imports or {}
			table.insert(block.imports, import)

		else
			state.nextToken                 = statementStartToken
			!SET_OR_RETURN_FALSE `statement = parseAssignment(state, block)`
		end
	end

	!ASSERT `statement`

	local statements = (
		!!(CONST_SET{
			AST_ASSIGNMENT,
			AST_BLOCK,
			AST_BREAK, AST_CONTINUE,
			AST_CALL,
			AST_DEFER,
			AST_FOR,
			AST_IF, AST_STATIC_IF, -- AST_STATIC_IF may have a mixture of static and dynamic statements.
			AST_RETURN,
			AST_SWITCH,
			AST_WHILE,
		})[statement.nodeType]
		and block.statementsDynamic
		or  block.statementsStatic
	)
	table.insert(statements, statement)

	eatTrailingSemicolon(state)
	return true
end

-- success = parseBlockStatements( state, block )
local function parseBlockStatements(state, block)
	!if DEBUG then
		--[[
		setmetatable(block, {__newindex=function(block, k, v)
			assert(k ~= 1)
			rawset(block, k, v)
		end})
		--]]
	!end

	local tok = peekNextTok(state, 1)
	if tok and tok.type == !(TOKEN_DUMMY) then
		!!(EAT_NEXT_TOKEN) -- dummy token
	end

	local lastNodeType = 0

	while true do
		tok = peekNextTok(state, 1)

		if not tok then
			!ERROR_OR_RETURN_FALSE `errorParsing(state, block, "Unfinished block.")` -- We probably don't ever get here because of the quick bracket check.

		elseif !!(IS_EXISTING_TOK(TOKEN_PUNCTUATION, "}")) then
			!!(EAT_NEXT_TOKEN) -- '}'
			break

		elseif !!(IS_EXISTING_TOK(TOKEN_PUNCTUATION, ";")) then
			!!(EAT_NEXT_TOKEN) -- ';'

			-- We allow empty statement like Lua 5.2+ does (so things like ';(x and func1 or func2)()'
			-- always work, no matter what comes previously). :EmptyStatement
			if not state.soft then
				state.warnings = state.warnings+1
				parserMessageLine(io.stderr, state, tok, "Warning", "Empty statement.")
			end

		else
			if !!(CONST_SET{ AST_RETURN, AST_BREAK, AST_CONTINUE })[lastNodeType] then
				local nodeTitle
					=  lastNodeType == !(AST_RETURN)   and "return"
					or lastNodeType == !(AST_BREAK)    and "break"
					or lastNodeType == !(AST_CONTINUE) and "continue"
					or assert(lastNodeType)

				local extra
					=  lastNodeType ~= !(AST_RETURN) and ""
					or getLambda(block).argumentsOut and " (Note: The function has return values.)"
					or                                   " (Note: The function has no return values.)"

				!ERROR_OR_RETURN_FALSE `errorParsing(state, state.nextToken, "Unreachable code after %s statement.%s", nodeTitle, extra)`
			end

			!DO_OR_RETURN_FALSE `parseOneStatementButSometimesMoreAndAddToBlock(state, block)`

			local statement = getLast(block.statementsDynamic)
			lastNodeType    = statement and statement.nodeType or 0
		end
	end

	return true
end
_G.parseBlockStatements = parseBlockStatements

local function parseBlock(state, parent)
	-- Note: Assume '{' has been eaten already.

	local block = astNewNode(AstBlock, state.tokens[state.nextToken-1], parent)
	!DO_OR_RETURN_NIL `parseBlockStatements(state, block)`

	return block
end

-- block = parseBlockOrScopedStatement( compilationState, parent )
!FILE_LOCAL `function parseBlockOrScopedStatement(state, parent)`
	local tok = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_PUNCTUATION, "{")) then
		!!(EAT_NEXT_TOKEN) -- '{'
		return (parseBlock(state, parent)) -- May return nil.
	end

	local block = astNewNode(AstBlock, tok, parent)

	!DO_OR_RETURN_NIL `parseOneStatementButSometimesMoreAndAddToBlock(state, block)`
	return block
end

local function parseImportOrLoad(state, parent)
	local tok    = eatNextTok(state)
	local import = astNewNode(AstImport, (tok or getLast(state.tokens)), parent)

	if !!(IS_TOK(TOKEN_DIRECTIVE, "import")) then
		-- void
	elseif !!(IS_TOK(TOKEN_DIRECTIVE, "load")) then
		import.isLoad = true
		if astIsOrIsInModule(import.parent) then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Modules cannot use !load.")`
		end
	else
		!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Internal compiler error: Expected '!load' or '!import'.")` -- The caller messed up.
	end

	local keyword = tok.value

	tok = eatNextTok(state)
	if not !!(IS_TOK(TOKEN_STRING)) then
		!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected a string after '!%s'.", keyword)`
	end
	import.importName = tok.value:gsub("\\", "/") -- Normalize paths.

	return import
end

!FILE_LOCAL `function parseRun(state, parent, mustBeExpression)`
	local tok = eatNextTok(state)
	if not !!(IS_TOK(TOKEN_DIRECTIVE, "run")) then
		!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Internal compiler error: Expected '!run'.")` -- The caller messed up.
	end

	local runNode  = astNewNode(AstRun,    tok, parent)
	local lambda   = astNewNode(AstLambda, tok, parent) -- @Cleanup: Never output this function (or inner functions) in the final program (even if --nostrip is set)?
	runNode.lambda = lambda

	tok = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_PUNCTUATION, "{")) then
		!!(EAT_NEXT_TOKEN) -- '{'

		if mustBeExpression then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected an expression. This is seen as a code block.")`
		end

		!SET_OR_RETURN_NIL `local block = parseBlock(state, lambda)`
		lambda.body                     = block
		table.insert(lambda.statementsStatic, block)

	else
		local expectValue = not isScope(parent)

		if expectValue then
			local args          = astNewNode(AstArguments, tok, lambda)
			lambda.argumentsOut = args
			table.insert(lambda.statementsStatic, args)

			local arg         = astNewNode(AstArgument, tok, args)
			args.arguments[1] = arg

			local decl        = astNewNode(AstDeclaration, tok, arg)
			arg.declaration   = decl

			local ident       = astNewNode(AstIdentifier, tok, decl)
			ident.kind        = !(IDENT_KIND_DECLARATION)
			ident.declaration = decl
			decl.name         = ident

			local typeNode    = astNewNode(AstType, tok, decl)
			typeNode.kind     = !(TYPE_KIND_SIMPLE_BUILTIN)
			typeNode.typeName = "any" -- Good for now?
			decl.type         = typeNode
		end

		local block = astNewNode(AstBlock, tok, lambda)
		lambda.body = block
		table.insert(lambda.statementsStatic, block)

		local exprStartToken = state.nextToken

		if expectValue then
			local returnNode                         = astNewNode(AstReturn, tok, block)
			returnNode.runDirective                  = runNode
			block.statementsDynamic[1]               = returnNode
			!SET_OR_RETURN_NIL `returnNode.values[1] = parseExpression(state, returnNode)`
		else
			!DO_OR_RETURN_NIL `parseOneStatementButSometimesMoreAndAddToBlock(state, block)`
		end

		-- Catch situations like these, which are probably errors:
		--   local v = !run func
		--   local v = !run foo.func
		if expectValue then
			local exprIsOnlyIdents = true

			for token = exprStartToken, state.nextToken-1 do
				tok = state.tokens[token]
				if not (tok.type == !(TOKEN_IDENTIFIER) or !!(IS_TOK(TOKEN_PUNCTUATION, "."))) then
					exprIsOnlyIdents = false
					break
				end
			end

			if exprIsOnlyIdents then
				tok = state.tokens[state.nextToken-1]
				assert(tok and tok.type == !(TOKEN_IDENTIFIER))
				!ERROR_OR_RETURN_NIL `errorParsingAfterLast(state, "Ambiguity in !run expression: Did you mean to call %s()?", tok.value)`
			end
		end
	end

	lambda.bodyEndDummy = astNewNode(AstDummy, state.tokens[state.nextToken-1])
	return runNode
end

-- success = parseFileScopeOrNamespaceStatements( state, parentScope, isTopLevel, singleStatement )
-- WARNING: parentScope is currently modified even if success==false!
!FILE_LOCAL `function parseFileScopeOrNamespaceStatements(state, scope, isTopLevel, singleStatement)`
	while true do
		local tok  = peekNextTok(state, 1)
		local tok2 = peekNextTok(state, 2)
		local tok3 = peekNextTok(state, 3)

		if not tok and isTopLevel then
			break

		----------------------------------------------------------------

		elseif !!(IS_TOK(TOKEN_KEYWORD, "local","export")) or (
			!!(IS_TOK(   TOKEN_KEYWORD, "using")) and
			!!(IS_TOK(2, TOKEN_KEYWORD, "local","export"))
		) then
			!DO_OR_RETURN_FALSE `parseDeclarationStatement(state, scope, false)`

		elseif !!(IS_TOK(TOKEN_KEYWORD, "static")) or (
			!!(IS_TOK(   TOKEN_KEYWORD, "using")) and
			!!(IS_TOK(2, TOKEN_KEYWORD, "static"))
		) then
			if tok.value == "using" then  eatNextTok(state)  end
			-- @UX: Maybe this should just be a warning and we parse a local instead.
			!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Static variables cannot be declared in file scope or in namespaces.")`

		elseif !!(IS_TOK(TOKEN_DIRECTIVE, "import","load")) then
			-- @Incomplete: Warn about duplicate imports? Maybe not necessay as things will only ever be imported once anyway.
			!SET_OR_RETURN_FALSE `local import = parseImportOrLoad(state, scope)`

			scope.imports = scope.imports or {}
			table.insert(scope.statementsStatic, import)
			table.insert(scope.imports,          import)

		elseif !!(IS_TOK(TOKEN_KEYWORD, "using")) then
			!SET_OR_RETURN_FALSE `local using = parseUsing(state, scope)`

			scope.usings = scope.usings or {}
			table.insert(scope.statementsStatic, using)
			table.insert(scope.usings,           using)

		elseif !!(IS_TOK(TOKEN_KEYWORD, "global")) then
			!!(EAT_NEXT_TOKEN) -- 'global'

			if astIsOrIsInModule(scope) then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Cannot export namespaces from modules into global space.")`
			end

			!SET_OR_RETURN_FALSE `local import = parseExpression(state, scope, 1/0)`
			if import.nodeType ~= !(AST_IMPORT) then
				errorInternal(state, import, "@Incomplete: Support any expression after 'global'. (Currently supported are !import, !load and !self)")
			end

			import.exported = true

			scope.imports = scope.imports or {}
			table.insert(scope.statementsStatic, import)
			table.insert(scope.imports,          import)

		elseif !!(IS_TOK(TOKEN_DIRECTIVE, "assert","print")) then
			!SET_OR_RETURN_FALSE `local debugNode = parseDebugNode(state, scope)`
			table.insert(scope.statementsStatic, debugNode)

		elseif !!(IS_TOK(TOKEN_DIRECTIVE, "if")) then
			!SET_OR_RETURN_FALSE `local ifOrStaticIf = parseIfOrStaticIf(state, scope, true)`
			table.insert(scope.statementsStatic, ifOrStaticIf)

		elseif !!(IS_TOK(TOKEN_DIRECTIVE, "run")) then
			!SET_OR_RETURN_FALSE `local runNode = parseRun(state, scope, false)`
			table.insert(scope.statementsStatic, runNode)

		elseif !!(IS_TOK(TOKEN_DIRECTIVE, "preload")) then
			!!(EAT_NEXT_TOKEN) -- '!preload'
			if not isTopLevel then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "!preload statements are only supported directly in file-scope.")`
			end

			local forCompiletime = false
			local forRuntime     = false

			tok = peekNextTok(state, 1)
			if !!(IS_TOK(TOKEN_IDENTIFIER, "compiletime")) then
				!!(EAT_NEXT_TOKEN) -- 'compiletime'
				forCompiletime = true
			elseif !!(IS_TOK(TOKEN_IDENTIFIER, "runtime")) then
				!!(EAT_NEXT_TOKEN) -- 'runtime'
				forRuntime = true
			end

			tok = eatNextTok(state)
			if not !!(IS_TOK(TOKEN_STRING)) then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Expected a string containing Lua code.")`
			end

			local lua = tok.value:gsub("\n%s*$", "")
			if not lua:find"[^%s]" then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "String with Lua code must not be empty.")`
			end

			local spaceBefore = lua:match"^%s*\n"
			local lineOffset  = 0

			if spaceBefore then
				local _, nlCount = spaceBefore:gsub("\n", "%0") -- @Speed
				lineOffset       = nlCount
				lua              = lua:sub(#spaceBefore+1)
			end

			local chunk, err = loadstring(lua, "@(lua)")
			if not chunk then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "This string does not contain valid Lua code: %s", err)`
			end

			local preloads
				=  forCompiletime and state.luaPreloadsCompiletime
				or forRuntime     and state.luaPreloadsRuntime
				or                    state.luaPreloads

			table.insert(preloads, {
				lua                   = lua,
				lineOffset            = lineOffset,
				path                  = tok.source.path,
				line                  = tok.line1,
				trimmedInitialNewline = tok.extra,
			})

		elseif !!(IS_TOK(TOKEN_KEYWORD, "export_value")) then
			!!(EAT_NEXT_TOKEN) -- '!export_value'
			if not isTopLevel then
				!ERROR_OR_RETURN_FALSE `errorParsingLast(state, "Values must be exported directly from file scope.")`
			end

			local fileScope = scope
			!ASSERT("fileScope.nodeType == "..AST_FILE_SCOPE)

			if fileScope.isModule then
				!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Cannot export values from modules.")`
			end

			if fileScope.valueToExport then
				!ERROR_OR_RETURN_FALSE `
					printerr()
					parserMessage(io.stderr, state, state.tokens[state.nextToken], "Error", "Multiple exported values.")
					parserMessage(io.stderr, state, fileScope.valueToExport,       "Info",  "...previous value is here.")
					exitFailure()
				`
			end

			!SET_OR_RETURN_FALSE `fileScope.valueToExport = parseExpression(state, fileScope)`

		----------------------------------------------------------------

		elseif !!(IS_TOK(TOKEN_PUNCTUATION, ";")) then
			!!(EAT_NEXT_TOKEN) -- ';'
			if not state.soft then
				state.warnings = state.warnings+1
				parserMessageLine(io.stderr, state, tok, "Warning", "Empty statement.") -- :EmptyStatement
			end

		elseif not (isTopLevel or singleStatement) and !!(IS_TOK(TOKEN_PUNCTUATION, "}")) then
			!!(EAT_NEXT_TOKEN) -- '}'
			break
		elseif !!(IS_TOK(TOKEN_DUMMY)) then
			!!(EAT_NEXT_TOKEN) -- dummy token
			break
		else
			!ifDEBUG `print(TOKEN_TITLES[state.tokens[state.nextToken].type])`
			if isTopLevel or singleStatement then
				!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Expected file-level declaration.")`
			else
				!ERROR_OR_RETURN_FALSE `errorParsingNext(state, "Expected declaration or '}'.")`
			end
		end

		if singleStatement then  break  end
	end

	return true
end

local function parseFileScope(state, parent, path, isModule, moduleName)
	local tok = peekNextTok(state, 1)
	if tok and tok.type == !(TOKEN_DUMMY) then
		!!(EAT_NEXT_TOKEN) -- dummy token
	end

	local fileScope      = astNewNode(AstFileScope, (tok or state.tokens[state.tokens.n]), parent)
	fileScope.path       = path
	fileScope.isModule   = isModule
	fileScope.moduleName = moduleName

	!DO_OR_RETURN_NIL `parseFileScopeOrNamespaceStatements(state, fileScope, true, false)`

	if fileScope.valueToExport then
		local globalScope = state.globalScope
		!ASSERT `parent == globalScope`

		if globalScope.fileScopeWithValueToExport then
			!ERROR_OR_RETURN_NIL `
				printerr()
				parserMessage(io.stderr, state, fileScope.valueToExport,                              "Error", "Multiple exported values across multiple files.")
				parserMessage(io.stderr, state, globalScope.fileScopeWithValueToExport.valueToExport, "Info",  "...previous value is here.")
				exitFailure()
			`
		end

		--
		-- Everything's done now, so it's ok to modify globalScope.
		--
		globalScope.fileScopeWithValueToExport = fileScope
	end

	return fileScope
end
_G.parseFileScope = parseFileScope

function _G.astMoveRelevantThingsFromFileScopeToGlobalScope(state, fileScope)
	!ASSERT `not fileScope.isModule`
	!ASSERT `not fileScope.queued`

	if not fileScope.imports then
		return
	end

	local globalScope    = state.globalScope
	local globalImports  = globalScope.imports -- May be nil.
	local unmovedImports = {}

	for _, import in ipairs(fileScope.imports) do
		if import.exported then
			if not globalImports then
				globalImports       = {}
				globalScope.imports = globalImports
			end
			table.insert(globalImports, import)
		else
			table.insert(unmovedImports, import)
		end
	end

	fileScope.imports = unmovedImports -- May be empty, but there's probably no reason to set .imports to nil in that case.
end

function _G.parseGlobalScope(state, firstFilePath)
	local tok         = peekNextTok(state, 1)
	local globalScope = astNewNode(AstGlobalScope, (tok or state.tokens[state.tokens.n]), nil)
	state.globalScope = globalScope

	local firstFileScope = parseFileScope(state, globalScope, firstFilePath, false, state.mainFileBasename)

	table.insert(globalScope.statementsStatic, firstFileScope)
	table.insert(globalScope.fileScopes,       firstFileScope)

	astMoveRelevantThingsFromFileScopeToGlobalScope(state, firstFileScope)
	return globalScope
end

-- call = parseCallChain( compilationState, parent, callee=theFollowingIdentifier, isMethod )
local function parseCallChain(state, parent, callee, isMethod)
	if not callee then
		!SET_OR_RETURN_NIL `callee = parseIdentifier(state, parent)` -- We'll update the parent in a moment.
	end

	isMethod = isMethod or false
	local call

	while true do
		local tok, token = eatNextTok(state)

		if tok and tok.type == !(TOKEN_STRING) then
			call = astNewNode(AstCall, tok, parent)

			local literal       = astNewNode(AstLiteral, tok, call)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = tok.value

			call.arguments[1] = literal

		elseif !!(IS_TOK(TOKEN_PUNCTUATION, "(")) then
			local tokPrev = state.tokens[token-1]
			if tok.line1 > (tokPrev.line2 or tokPrev.line1) then
				!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Ambiguous syntax. (Is this a call or a new statement?)")`
			end

			call = astNewNode(AstCall, tok, parent)
			tok  = peekNextTok(state, 1)

			if !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
				!!(EAT_NEXT_TOKEN) -- ')'

			else
				!DO_OR_RETURN_NIL `parseExpressionList(state, call, call.arguments, call.argumentsNamed, false)`

				tok = eatNextTok(state)
				if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
					!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ')' or ',' in call.")`
				end
			end

		else
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '(' to start call arguments.")` -- We may get here for inline calls.
		end

		callee.parent = call
		call.callee   = callee
		call.isMethod = isMethod

		tok = peekNextTok(state, 1)
		if not (!!(IS_TOK(TOKEN_PUNCTUATION, "(")) or (tok and tok.type == !(TOKEN_STRING))) then
			break
		end

		callee   = call
		isMethod = false
	end

	return call
end

local function parseLambda(state, parent)
	local lambda = astNewNode(AstLambda, state.tokens[state.nextToken], parent)

	-- Inline.
	local tok = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_KEYWORD, "inline")) then
		!!(EAT_NEXT_TOKEN) -- 'inline'
		lambda.inline = !(INLINE_YES)
	elseif !!(IS_TOK(TOKEN_KEYWORD, "no_inline")) then
		!!(EAT_NEXT_TOKEN) -- 'no_inline'
		lambda.inline = !(INLINE_NO)
	end

	-- Captures.
	tok = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_PUNCTUATION, "[")) then
		!!(EAT_NEXT_TOKEN) -- '['
		tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_PUNCTUATION, "*")) then
			!!(EAT_NEXT_TOKEN) -- '*'
			lambda.captureAll = true
		else
			lambda.captures = {}
			!DO_OR_RETURN_NIL `parseNameList(state, lambda, lambda.captures, nil, false)`
		end

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, "]")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ']' after captures.")`
		end
	end

	-- Input arguments.
	tok = eatNextTok(state)
	if not !!(IS_TOK(TOKEN_PUNCTUATION, "(")) then
		!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '(' to start argument list.")`
	end

	local callerLocationNode = nil
	tok                      = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
		!!(EAT_NEXT_TOKEN) -- ')'

	else
		!SET_OR_RETURN_NIL `local args = parseArguments(state, lambda, true, true)`
		lambda.argumentsIn             = args

		local takenNames = {--[[ [name1]=identifier, ... ]]}
		local gotError   = false

		-- Add declarations for values that will be baked (only types so far).
		for _, arg in ipairs(args.arguments) do
			astVisitAllNodes(arg, function(node)
				if node.nodeType == !(AST_LOCATION) then
					local loc = node
					if loc.ofCaller then
						lambda.wantCallerLocation = true
						callerLocationNode        = callerLocationNode or loc
					end
					return
				end

				if node.nodeType ~= !(AST_BAKE) then  return  end
				lambda.polymorphs = lambda.polymorphs or {}

				local bake  = node
				local ident = bake.name
				local name  = ident.name

				if takenNames[name] then
					gotError = true
					!ERROR_OR_RETURN_NIL `
						printerr()
						parserMessage(io.stderr, state, ident,            "Error", "Duplicate placeholder type name '%s'.", name)
						parserMessage(io.stderr, state, takenNames[name], "Info",  "...previous name is here.")
						exitFailure()
					`
				end
				takenNames[name] = ident

				local decl        = astNewNode(AstDeclaration, bake, lambda)
				ident.declaration = decl
				decl.name         = astCopyIdentifier(ident, nil, decl, !(IDENT_KIND_DECLARATION))
				decl.kind         = !(DECL_KIND_LOCAL_CONST)

				-- Note: We're not setting decl.type nor decl.value, leaving the declaration unfinished.
				-- It should be ok as polymorphic functions shouldn't get inferred.

				lambda.bakeDeclarations = lambda.bakeDeclarations or {}
				table.insert(lambda.statementsStatic, decl)
				table.insert(lambda.declarations,     decl)
				table.insert(lambda.bakeDeclarations, decl)
				addDeclarationToNames(lambda, decl)

				return !(VISIT_IGNORE_CHILDREN)
			end)
		end
		if gotError then  return nil  end

		table.insert(lambda.statementsStatic, args)

		for _, arg in ipairs(args.arguments) do
			local decl = arg.declaration

			table.insert(lambda.declarations, decl)
			addDeclarationToNames(lambda, decl)

			if arg.autobake == !(AUTOBAKE_REQUIRED) then
				lambda.polymorphs = lambda.polymorphs or {}

				local typeNode    = astNewNode(AstType, decl, decl)
				typeNode.kind     = !(TYPE_KIND_SIMPLE_BUILTIN)
				typeNode.typeName = "placeholder"

				decl.kind  = !(DECL_KIND_LOCAL_CONST)
				decl.value = typeNode -- During baking this may end up being replaced with something that's not a type, but we don't care about that at this moment!
			end

			if arg.isUsing then
				local using = astNewNode(AstUsing, arg, lambda)

				local ident       = astNewNode(AstIdentifier, arg, using)
				ident.kind        = !(IDENT_KIND_LOOSE)
				ident.name        = decl.name.name
				ident.declaration = decl
				using.expression  = ident

				lambda.usings = lambda.usings or {}
				table.insert(lambda.statementsStatic, using)
				table.insert(lambda.usings,           using)
			end
		end

		if lambda.polymorphs and (lambda.captures or lambda.captureAll) then
			!ERROR_OR_RETURN_NIL `errorParsing(state, lambda, "Polymorphic functions cannot have captures.")`
		end

		if args.arguments[1] and getLast(args.arguments).declaration.name.nodeType == !(AST_VARARG) then
			lambda.takingVararg = true
		end

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ')' to end argument list.")`
		end
	end

	if (lambda.captures or lambda.captureAll) and lambda.argumentsIn and not state.soft then
		for _, arg in ipairs(lambda.argumentsIn.arguments) do
			if arg.declaration.value then
				state.warnings = state.warnings+1
				parserMessageLine(
					io.stderr, state,
					astGetExpressionVisuallyFurthestToTheLeft(arg.declaration.value),
					"Warning", "Default values do not work on functions with captures."
				)
			end
		end
	end

	-- Output arguments.
	tok = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_PUNCTUATION, "->")) then
		!!(EAT_NEXT_TOKEN) -- '->'

		local argsOutStartToken = state.nextToken
		local args              = nil

		tok        = peekNextTok(state, 1)
		local tok2 = peekNextTok(state, 2)

		-- (...) -> void
		if !!(IS_TOK(TOKEN_KEYWORD, "void")) then
			!!(EAT_NEXT_TOKEN) -- 'void'

		-- (...) -> ()
		elseif
			!!(IS_TOK(   TOKEN_PUNCTUATION, "(")) and
			!!(IS_TOK(2, TOKEN_PUNCTUATION, ")"))
		then
			!ERROR_OR_RETURN_NIL `errorParsingNext(state, "Ambiguous '()'. (Does the function return no values or does it return a function that takes no arguments?)")`

		-- (...) -> (name:type, ...)
		elseif
			!!(IS_TOK(TOKEN_PUNCTUATION, "("))
			and tok2
			and (
				tok2.type == !(TOKEN_IDENTIFIER)
				or !!(IS_TOK(2, TOKEN_PUNCTUATION, "...","_","$")) -- '$' is just for a better error message. Output arguments cannot be baked.
				or !!(IS_TOK(2, TOKEN_KEYWORD,     "using"      )) -- This is just for a better error message. Output arguments cannot have using.
			)
		then
			!!(EAT_NEXT_TOKEN) -- '('
			tok = peekNextTok(state, 1)

			!SET_OR_RETURN_NIL `args = parseArguments(state, lambda, false, true)`
			!ASSERT `args.arguments[1]`

			tok = eatNextTok(state)
			if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
				!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ')' to end argument list.")`
			end

			-- If the return type is a function signature, i.e. () -> () -> ...
			tok = peekNextTok(state, 1)
			if !!(IS_TOK(TOKEN_PUNCTUATION, "->")) then
				state.nextToken          = argsOutStartToken
				!SET_OR_RETURN_NIL `args = parseNamelessOutputArguments(state, lambda)` -- Replace any output arguments we just parsed.
			end

		-- (...) -> type, ...
		else
			!SET_OR_RETURN_NIL `args = parseNamelessOutputArguments(state, lambda)`
		end

		if args then
			lambda.argumentsOut = args
			table.insert(lambda.statementsStatic, args)
		end
	end

	-- Body.
	tok = peekNextTok(state, 1)

	if !!(IS_TOK(TOKEN_PUNCTUATION, "{")) then
		!!(EAT_NEXT_TOKEN) -- '{'

		!SET_OR_RETURN_NIL `local block = parseBlock(state, lambda)`
		lambda.body                     = block
		table.insert(lambda.statementsStatic, block)

		lambda.bodyEndDummy = astNewNode(AstDummy, state.tokens[state.nextToken-1]) -- The '}'.

	elseif !!(IS_TOK(TOKEN_DIRECTIVE, "foreign")) then
		!!(EAT_NEXT_TOKEN) -- '!foreign'
		lambda.bodyIsForeign = true

		if lambda.wantCallerLocation then
			!ERROR_OR_RETURN_NIL `errorParsing(
				state, callerLocationNode,
				"Foreign functions cannot ulitize !caller_location as a default value - !location has to be used explicitly at the calling sites."
			)`
		end

		local block = astNewNode(AstBlock, tok, lambda) -- Dummy block.
		lambda.body = block
		table.insert(lambda.statementsStatic, block)

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_IDENTIFIER)) then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected foreign source. (Valid values: lua, method, compiler)")`
		elseif not !!(CONST_SET{"lua","method","compiler"})[tok.value] then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Invalid source '%s'. (Valid values: lua, method, compiler)", tok.value)`
		end
		lambda.foreignSource = tok.value

		tok = peekNextTok(state, 1)
		if !!(IS_TOK(TOKEN_STRING)) then
			!!(EAT_NEXT_TOKEN) -- the string
			lambda.foreignSourceName = newLiteral(lambda, tok, !(LITERAL_STRING), tok.value)
		else
			-- void  (lambda.foreignSourceName will be the name of whatever declared constant the lambda is attached to.)
			!ERROR_OR_RETURN_NIL `errorParsingAfterLast(state, "@Incomplete: Infer lambda.foreignSourceName")` -- @Temp
		end

		lambda.bodyEndDummy = astNewNode(AstDummy, state.tokens[state.nextToken-1])

	elseif !!(IS_TOK(TOKEN_DIRECTIVE, "body_text")) then
		!!(EAT_NEXT_TOKEN) -- '!body_text'

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, "{")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '{' after '!body_text'.")`
		end

		do
			local bodyTextLambda    = astNewNode(AstLambda, tok, lambda)
			bodyTextLambda.metaOnly = true
			lambda.bodyTextLambda   = bodyTextLambda
			table.insert(lambda.statementsStatic, bodyTextLambda)

			local argsOut               = astNewNode(AstArguments, tok, bodyTextLambda)
			bodyTextLambda.argumentsOut = argsOut
			table.insert(bodyTextLambda.statementsStatic, argsOut)

			local arg            = astNewNode(AstArgument, tok, argsOut)
			argsOut.arguments[1] = arg

			local decl           = astNewNode(AstDeclaration, tok, arg)
			arg.declaration      = decl

			decl.name            = newIdentifier(decl, tok, !(IDENT_KIND_DECLARATION), "", decl)

			local typeNode       = astNewNode(AstType, tok, decl)
			typeNode.kind        = !(TYPE_KIND_SIMPLE_BUILTIN)
			typeNode.typeName    = "string"
			decl.type            = typeNode

			!SET_OR_RETURN_NIL `local block = parseBlock(state, bodyTextLambda)`
			bodyTextLambda.body             = block
			table.insert(bodyTextLambda.statementsStatic, block)
		end

		local block = astNewNode(AstBlock, tok, lambda) -- Empty until bodyTextLambda has run.
		lambda.body = block
		table.insert(lambda.statementsStatic, block)

		lambda.bodyEndDummy                = astNewNode(AstDummy, state.tokens[state.nextToken-1]) -- The '}'.
		lambda.bodyTextLambda.bodyEndDummy = lambda.bodyEndDummy -- It should be fine to share the same dummy node.

	else
		lambda.bodyEndDummy = astNewNode(AstDummy, state.tokens[state.nextToken-1]) -- Dummy value that shouldn't be used since there's no body. (Maybe we can even leave it nil.)
	end

	-- Combination errors.

	if lambda.inline ~= !(INLINE_MAY) and not lambda.body then
		local inlineText = (lambda.inline == !(INLINE_YES)) and "inline" or "no-inline"
		!ERROR_OR_RETURN_NIL `errorParsingAfterLast(state, "Expected a body for %s marked function.", inlineText)`

	elseif lambda.inline == !(INLINE_YES) and (lambda.captures or lambda.captureAll) then
		-- We do allow no_inline because it's effectively a no-op for variables (including variable functions). Maybe we should emit a warning.
		!ERROR_OR_RETURN_NIL `errorParsing(state, lambda, "Inline marked functions cannot have captures.")`

	elseif lambda.inline == !(INLINE_YES) and lambda.bodyIsForeign then
		-- We do allow no_inline because it's effectively a no-op for foreign functions. Maybe we should emit a warning.
		!ERROR_OR_RETURN_NIL `errorParsing(state, lambda, "Foreign functions cannot be inlined.")`

	elseif lambda.polymorphs and not lambda.body then
		!ERROR_OR_RETURN_NIL `errorParsing(state, lambda, "Types of functions cannot be polymorphic - only functions themselves can.")`

	elseif (lambda.captures or lambda.captureAll) and not lambda.body then
		!ERROR_OR_RETURN_NIL `errorParsingAfterLast(state, "Expected a body for function with captures.")`

	elseif (lambda.captures or lambda.captureAll) and lambda.bodyIsForeign then
		!ERROR_OR_RETURN_NIL `errorParsing(state, lambda, "Foreign functions cannot have captures.")`
	end

	if lambda.bodyIsForeign and lambda.argumentsIn then
		for _, arg in ipairs(lambda.argumentsIn.arguments) do
			arg.declaration.isDocumentation = true
		end
	end

	return lambda
end



local expressionParserByTokenType = {}
local expressionParserByKeySymbol = {}
local expressionParserByDirective = {}

do
	-- Bool/nil value.
	expressionParserByKeySymbol["true"] = function(state, exprStartTok, parent)
		local literal       = astNewNode(AstLiteral, exprStartTok, parent)
		literal.literalType = !(LITERAL_BOOLEAN)
		literal.value       = true
		return literal
	end
	expressionParserByKeySymbol["false"] = function(state, exprStartTok, parent)
		local literal       = astNewNode(AstLiteral, exprStartTok, parent)
		literal.literalType = !(LITERAL_BOOLEAN)
		literal.value       = false
		return literal
	end
	expressionParserByKeySymbol["nil"] = function(state, exprStartTok, parent)
		local literal       = astNewNode(AstLiteral, exprStartTok, parent)
		literal.literalType = !(LITERAL_NIL)
		-- literal.value    = nil
		return literal
	end
	expressionParserByKeySymbol["NULL"] = function(state, exprStartTok, parent)
		return astNewNode(AstNull, exprStartTok, parent)
	end

	-- Number.
	expressionParserByTokenType[!(TOKEN_FLOAT)] = function(state, exprStartTok, parent)
		local literal       = astNewNode(AstLiteral, exprStartTok, parent)
		literal.literalType = !(LITERAL_FLOAT)
		literal.value       = exprStartTok.value
		return literal
	end
	expressionParserByTokenType[!(TOKEN_INTEGER)] = function(state, exprStartTok, parent)
		local literal       = astNewNode(AstLiteral, exprStartTok, parent)
		literal.literalType = !(LITERAL_INTEGER)
		literal.value       = exprStartTok.value
		return literal
	end
	expressionParserByTokenType[!(TOKEN_STRING)] = function(state, exprStartTok, parent)
		local literal       = astNewNode(AstLiteral, exprStartTok, parent)
		literal.literalType = !(LITERAL_STRING)
		literal.value       = exprStartTok.value
		return literal
	end

	-- Plain/relative identifier.
	expressionParserByTokenType[!(TOKEN_IDENTIFIER)] = function(state, exprStartTok, parent)
		local ident = astNewNode(AstIdentifier, exprStartTok, parent)
		ident.kind  = !(IDENT_KIND_LOOSE)
		ident.name  = exprStartTok.value
		return ident
	end
	expressionParserByKeySymbol["."] = function(state, exprStartTok, parent)
		!SET_OR_RETURN_NIL `local ident = parseIdentifier(state, parent)`
		ident.kind                      = !(IDENT_KIND_RELATIVE)
		return ident
	end

	-- Unary expression.
	expressionParserByKeySymbol["not"] = function(state, exprStartTok, parent)
		local unary                    = astNewNode(AstUnary, exprStartTok, parent)
		unary.operation                = exprStartTok.value
		!SET_OR_RETURN_NIL `local expr = parseExpression(state, unary, OPERATOR_PRECEDENCE.unary)`
		unary.expression               = expr

		-- @Incomplete: Treat '+n' and '-n' as numerals instead of unary expressions.

		return unary
	end
	expressionParserByKeySymbol["+"] = expressionParserByKeySymbol["not"]
	expressionParserByKeySymbol["-"] = expressionParserByKeySymbol["not"]
	expressionParserByKeySymbol["#"] = expressionParserByKeySymbol["not"]

	-- Table constructor.
	expressionParserByKeySymbol["{"] = function(state, exprStartTok, parent)
		return parseTable(state, parent)
	end

	-- Struct/enum.
	expressionParserByKeySymbol["struct"] = function(state, exprStartTok, parent)
		return parseStruct(state, parent)
	end
	expressionParserByKeySymbol["enum"] = function(state, exprStartTok, parent)
		return parseEnum(state, parent)
	end

	-- Cast.
	expressionParserByKeySymbol["cast"] = function(state, exprStartTok, parent)
		local cast = astNewNode(AstCast, exprStartTok, parent)

		local tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, "(")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '(' after 'cast'.")`
		end

		!SET_OR_RETURN_NIL `cast.targetType = parseExpression(state, cast)`

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ')' in cast.")`
		end

		!SET_OR_RETURN_NIL `cast.expression = parseExpression(state, cast, OPERATOR_PRECEDENCE.cast)`
		return cast
	end

	-- Vararg.
	expressionParserByKeySymbol["..."] = function(state, exprStartTok, parent)
		local vararg = astNewNode(AstVararg, exprStartTok, parent)
		vararg.kind  = !(IDENT_KIND_LOOSE)

		local lambda = getLambda(vararg)
		if not (lambda and lambda.takingVararg) then
			!ERROR_OR_RETURN_NIL `errorParsing(state, exprStartTok, "This is not inside a vararg function.")`
		end

		return vararg
	end

	-- Foreign value or struct.
	expressionParserByDirective["foreign"] = function(state, exprStartTok, parent)
		local tok = peekNextTok(state, 1)

		if !!(IS_TOK(TOKEN_KEYWORD, "struct")) then
			!!(EAT_NEXT_TOKEN) -- 'struct'

			!SET_OR_RETURN_NIL `local struct = parseStruct(state, parent)`
			struct.isForeign                 = true

			return struct

		else
			return parseForeign(state, parent)
		end
	end

	-- Import/load.
	expressionParserByDirective["import"] = function(state, exprStartTok, parent)
		!!(PUT_BACK_LAST_TOKEN)
		return parseImportOrLoad(state, parent)
	end
	expressionParserByDirective["load"] = expressionParserByDirective["import"]

	-- Baked parameter.
	expressionParserByKeySymbol["$"] = function(state, exprStartTok, parent)
		local bake                    = astNewNode(AstBake, exprStartTok, parent)
		!SET_OR_RETURN_NIL `bake.name = parseIdentifier(state, bake)`
		return bake
	end

	-- Type of.
	expressionParserByKeySymbol["type_of"] = function(state, exprStartTok, parent)
		local typeOf = astNewNode(AstTypeOf, exprStartTok, parent)

		local tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, "(")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '(' after 'type_of'.")`
		end

		!SET_OR_RETURN_NIL `typeOf.expression = parseExpression(state, typeOf)`

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ')' to end type_of() expression.")`
		end

		return typeOf
	end

	-- Variant of.
	expressionParserByKeySymbol["variant_of"] = function(state, exprStartTok, parent)
		local variant = astNewNode(AstVariantOf, exprStartTok, parent)

		local tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, "(")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '(' after 'variant_of'.")`
		end

		local expressionStartTok = peekNextTok(state, 1)
		!SET_OR_RETURN_NIL `variant.call = parseExpression(state, variant)`

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ')' to end variant_of() expression.")`
		elseif variant.call.nodeType ~= !(AST_CALL) then
			!ERROR_OR_RETURN_NIL `errorParsing(state, expressionStartTok, "Expected a call for variant_of().")`
		end

		return variant
	end

	-- Run directive.
	expressionParserByDirective["run"] = function(state, exprStartTok, parent)
		!!(PUT_BACK_LAST_TOKEN)
		return parseRun(state, parent, true) -- @Incomplete: Allow a block here.
	end

	-- Unicode codepoint.
	expressionParserByDirective["char"] = function(state, exprStartTok, parent)
		local tok = eatNextTok(state)

		if not (tok and tok.type == !(TOKEN_STRING)) then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected a string after '!char'.")`
		elseif tok.value == "" then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected a UTF-8 character in the string.")`
		elseif tok.value:find!("^"..UTF8_CHARACTER_PATTERN.."$") then
			-- void
		elseif tok.value:find!("^"..UTF8_CHARACTER_PATTERN) then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "The string must contain a single UTF-8 character.")`
		else
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Invalid UTF-8 string.")`
		end

		local literal       = astNewNode(AstLiteral, exprStartTok, parent)
		literal.literalType = !(LITERAL_INTEGER)
		literal.value       = utf8Codepoint(tok.value)

		return literal
	end

	-- Self (parent namespace).
	expressionParserByDirective["self"] = function(state, exprStartTok, parent)
		!local NAMESPACE_SCOPE_SET = CONST_SET{ AST_FILE_SCOPE, AST_NAMESPACE, AST_STRUCT--[[, AST_ENUM]] }
		local scope = (
			(!!(NAMESPACE_SCOPE_SET)[parent.nodeType] and parent)
			or astFindParent(parent, !!(NAMESPACE_SCOPE_SET))
			or errorInternal()
		)

		if scope.nodeType == !(AST_FILE_SCOPE) then
			local fileScope   = scope
			local import      = astNewNode(AstImport, exprStartTok, parent)
			import.isLoad     = not fileScope.isModule
			import.importName = fileScope.moduleName
			import.fileScope  = fileScope
			return import

		elseif scope.nodeType == !(AST_NAMESPACE) then
			local namespace                  = astNewNode(AstNamespace, exprStartTok, parent)
			namespace.namespaceReferenceNode = scope
			return namespace

		else
			local typeNode             = astNewNode(AstType, exprStartTok, parent)
			typeNode.kind              = !(TYPE_KIND_USER)
			typeNode.typeReferenceNode = scope
			return typeNode
		end
	end

	-- Namespace.
	expressionParserByKeySymbol["namespace"] = function(state, exprStartTok, parent)
		local tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, "{")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '{' after 'namespace'.")`
		end

		local namespace = astNewNode(AstNamespace, exprStartTok, parent)
		!DO_OR_RETURN_NIL `parseFileScopeOrNamespaceStatements(state, namespace, false, false)` -- Note: This should eat the ending '}'.

		return namespace
	end

	-- Type information.
	expressionParserByKeySymbol["type_info"] = function(state, exprStartTok, parent)
		local typeInfoNode = astNewNode(AstTypeInfo, exprStartTok, parent)

		local tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, "(")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '(' after 'type_info'.")`
		end

		!SET_OR_RETURN_NIL `typeInfoNode.expression = parseExpression(state, typeInfoNode)`

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ')' to end type_info() expression.")`
		end

		return typeInfoNode
	end

	-- Source code location.
	expressionParserByDirective["location"] = function(state, exprStartTok, parent)
		local loc = astNewNode(AstLocation, exprStartTok, parent)

		local tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, "(")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected '(' after 'location'.")`
		end

		tok = peekNextTok(state, 1)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
			!SET_OR_RETURN_NIL `loc.expression = parseExpression(state, loc)`
		end

		tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
			!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ')' to end location() expression.")`
		end

		return loc
	end

	-- Compiler value.
	expressionParserByDirective["compiler"] = function(state, exprStartTok, parent)
		local tok = eatNextTok(state)
		if not !!(IS_TOK(TOKEN_STRING)) then
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected a string with the name of a compiler-provided value.")`
		end

		local tokValue = tok.value

		if     tokValue == "typeTagAny"         then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_ANY))
		elseif tokValue == "typeTagArray"       then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_ARRAY))
		elseif tokValue == "typeTagBool"        then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_BOOL))
		elseif tokValue == "typeTagCompound"    then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_COMPOUND))
		elseif tokValue == "typeTagEnum"        then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_ENUM))
		elseif tokValue == "typeTagFloat"       then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_FLOAT))
		elseif tokValue == "typeTagFunction"    then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_FUNCTION))
		elseif tokValue == "typeTagInt"         then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_INT))
		elseif tokValue == "typeTagList"        then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_LIST))
		elseif tokValue == "typeTagNamespace"   then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_NAMESPACE))
		elseif tokValue == "typeTagNone"        then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_NONE))
		elseif tokValue == "typeTagPlaceholder" then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_PLACEHOLDER))
		elseif tokValue == "typeTagString"      then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_STRING))
		elseif tokValue == "typeTagStruct"      then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_STRUCT))
		elseif tokValue == "typeTagTable"       then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_TABLE))
		elseif tokValue == "typeTagType"        then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_TYPE))
		elseif tokValue == "typeTagVararg"      then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_VARARG))
		elseif tokValue == "typeTagVoid"        then  return newLiteral(parent, exprStartTok, !(LITERAL_INTEGER), !(TYPE_VOID))
		else
			!ERROR_OR_RETURN_NIL `errorParsingLast(state, "There is no compiler-provided value named '%s'.", valueToStringForMessage(tokValue))`
		end
	end

	-- Blank (invalid expression).
	expressionParserByKeySymbol["_"] = function(state, exprStartTok, parent)
		!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Invalid place for a blank name.")`
	end

	-- Function signature, lambda or parenthesis.
	expressionParserByKeySymbol["("] = function(state, exprStartTok, parent)
		local tok2 = peekNextTok(state, 1)
		local tok3 = peekNextTok(state, 2)

		-- Function signature (type) or lambda.
		--
		--   inArgs [-> outArgs] [body]
		--   captures inArgs [-> outArgs] body
		--
		--   captures = [ capture1, ... ]
		--   captures = [ * ]
		--   inArgs   = ( [ inArg1, ... ] )
		--   inArg    = [ $ [ ? ] ] name1 [, ... ] : [ $ ] type [ = defaultValue ]
		--   inArg    = using       name1 [, ... ] : [ $ ] type [ = defaultValue ]
		--   outArgs  = void
		--   outArgs  = type1 [, ... ]
		--   outArgs  = ( outArg1 [, ... ] )
		--   outArg   = name1 [, ... ] : type
		--   body     = { ... }
		--
		if
			tok2
			and (
				!!(IS_EXISTING_TOK(2, TOKEN_PUNCTUATION, ")","$"))
				or !!(IS_EXISTING_TOK(2, TOKEN_KEYWORD, "using","void"))
				or (
					tok3
					and (
						tok2.type == !(TOKEN_IDENTIFIER)
						or !!(IS_EXISTING_TOK(2, TOKEN_PUNCTUATION, "...","_"))
					)
					and !!(IS_EXISTING_TOK(3, TOKEN_PUNCTUATION, ":",",","="))
				)
			)
		then
			!!(PUT_BACK_LAST_TOKEN)
			!SET_OR_RETURN_NIL `local lambda = parseLambda(state, parent)`
			if lambda.body then  return lambda  end

			local typeNode          = astNewNode(AstType, lambda, parent)
			typeNode.kind           = !(TYPE_KIND_FUNCTION)
			typeNode.functionHeader = lambda
			lambda.parent           = typeNode

			if lambda.argumentsIn then
				for _, arg in ipairs(lambda.argumentsIn.arguments) do
					arg.declaration.isDocumentation = true
				end
			end

			return typeNode

		-- Parenthesis.
		else
			!SET_OR_RETURN_NIL `local expr = parseExpression(state, parent)`

			if !!(CONST_SET{ AST_CALL, AST_VARARG })[expr.nodeType] then
				-- This is so we know whether to adjust the return values to one or not in certain situations.
				-- Note: Functions with a return value after the first one marked as #must cannot have their
				-- return values adjusted to one.
				expr.surroundedByParentheses = true
			end

			local tok = eatNextTok(state)

			if not !!(IS_TOK(TOKEN_PUNCTUATION, ")")) then
				!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ')' to end parenthesis expression.")`
			end

			--[[ @Incomplete :ParenthesesAmbiguityError
			if expectLvalue and expr.nodeType == !(AST_IDENTIFIER) then
				!ERROR_OR_RETURN_NIL `errorParsing(state, exprStartTok, "Unexpected parentheses around identifier.")`
			end
			--]]

			return expr
		end
	end

	-- Array type or capturing lambda.
	expressionParserByKeySymbol["["] = function(state, exprStartTok, parent)
		local tok = peekNextTok(state, 1)

		-- Array type.
		if !!(IS_TOK(TOKEN_PUNCTUATION, "]")) then
			!!(EAT_NEXT_TOKEN) -- ']'

			local typeNode = astNewNode(AstType, exprStartTok, parent)
			typeNode.kind  = !(TYPE_KIND_ARRAY)

			!SET_OR_RETURN_NIL `typeNode.arrayItemType = parseExpression(state, typeNode, OPERATOR_PRECEDENCE.dotCast)`
			return typeNode

		-- Capturing lambda.
		else
			!!(PUT_BACK_LAST_TOKEN)
			!SET_OR_RETURN_NIL `local lambda = parseLambda(state, parent)`
			if lambda.body then  return lambda  end

			local typeNode          = astNewNode(AstType, lambda, parent)
			typeNode.kind           = !(TYPE_KIND_FUNCTION)
			typeNode.functionHeader = lambda
			lambda.parent           = typeNode

			if lambda.argumentsIn then
				for _, arg in ipairs(lambda.argumentsIn.arguments) do
					arg.declaration.isDocumentation = true
				end
			end

			return typeNode
		end
	end

	-- Built-in type.
	!for _, keyword in ipairs(BUILTIN_TYPE_KEYWORDS) do
		expressionParserByKeySymbol[!(keyword)] = function(state, exprStartTok, parent)
			local typeNode    = astNewNode(AstType, exprStartTok, parent)
			typeNode.kind     = !(TYPE_KIND_SIMPLE_BUILTIN)
			typeNode.typeName = !(keyword)

			-- @Polish: Check if there's a '(' after this and give error early.

			return typeNode
		end
	!end

	-- Inline call or lambda.
	expressionParserByKeySymbol["inline"] = function(state, exprStartTok, parent)
		local tok  = peekNextTok(state, 1)
		local tok2 = peekNextTok(state, 2)
		local tok3 = peekNextTok(state, 3)

		if
			(
				!!(IS_TOK(TOKEN_PUNCTUATION, "["))
				and not !!(IS_TOK(2, TOKEN_PUNCTUATION, "]"))
			)
			or (
				-- @Copypaste from expressionParserByKeySymbol["("]. @Cleanup
				tok2
				and !!(IS_TOK(TOKEN_PUNCTUATION, "("))
				and (
					!!(IS_EXISTING_TOK(2, TOKEN_PUNCTUATION, ")","$"))
					or !!(IS_EXISTING_TOK(2, TOKEN_KEYWORD, "using","void"))
					or (
						tok3
						and (
							tok2.type == !(TOKEN_IDENTIFIER)
							or !!(IS_EXISTING_TOK(2, TOKEN_PUNCTUATION, "...","_"))
						)
						and !!(IS_EXISTING_TOK(3, TOKEN_PUNCTUATION, ":",",","="))
					)
				)
			)
		then
			!!(PUT_BACK_LAST_TOKEN)
			!SET_OR_RETURN_NIL `local lambda = parseLambda(state, parent)`
			return lambda

		else
			local inlineKeyword            = !!(PEEK_LAST_TOKEN).value
			local prevOpPrecedence         = !(math.min(OPERATOR_PRECEDENCE.call, OPERATOR_PRECEDENCE.access) - 1)
			!SET_OR_RETURN_NIL `local call = parseExpression(state, parent, prevOpPrecedence)`

			if call.nodeType ~= !(AST_CALL) then
				!ERROR_OR_RETURN_NIL `errorParsing(state, tok, "Expected a call after '%s'. (Got '%s' node.)", inlineKeyword, AST_NAMES[call.nodeType])`
			elseif call.inline ~= !(INLINE_MAY) then
				!ERROR_OR_RETURN_NIL `errorParsing(state, tok, "Expected a call after '%s'.", inlineKeyword)`
			end

			call.inline = (inlineKeyword == "inline") and !(INLINE_YES) or !(INLINE_NO)
			return call
		end
	end
	expressionParserByKeySymbol["no_inline"] = expressionParserByKeySymbol["inline"]
end

-- expression = parseExpression( compilationState, parent [, previousOperatorPrecedence, expectLvalue=false ] )
!FILE_LOCAL `function parseExpression(state, parent, prevOpPrecedence, expectLvalue)`
	prevOpPrecedence = prevOpPrecedence or 0

	local exprStartTok = eatNextTok(state)
	if not exprStartTok then
		!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected an expression.")`
	end

	local tok                   = exprStartTok
	local tokType               = tok.type
	local startsWithParenthesis = !!(IS_EXISTING_TOK(TOKEN_PUNCTUATION, "("))
	local expr

	if expressionParserByTokenType[tokType] then
		!SET_OR_RETURN_NIL `expr = expressionParserByTokenType[tokType](state, exprStartTok, parent)`

	elseif (tokType == !(TOKEN_KEYWORD) or tokType == !(TOKEN_PUNCTUATION)) and expressionParserByKeySymbol[tok.value] then
		!SET_OR_RETURN_NIL `expr = expressionParserByKeySymbol[tok.value](state, exprStartTok, parent)`

	elseif tokType == !(TOKEN_DIRECTIVE) and expressionParserByDirective[tok.value] then
		!SET_OR_RETURN_NIL `expr = expressionParserByDirective[tok.value](state, exprStartTok, parent)`

	else
		!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected an expression.")`
	end

	-- Expressions involving several things next to each other.
	local nextCanBeMethodCall = false

	while true do
		tok = peekNextTok(state, 1)
		if not tok then  break  end

		local tokValue = tok.value
		local tok2     = peekNextTok(state, 2)

		local thisCanBeMethodCall = nextCanBeMethodCall
		nextCanBeMethodCall       = false

		--
		-- Non-punctuation.
		--

		-- Left-associative binary operations. (1)
		if !!(IS_EXISTING_TOK(TOKEN_KEYWORD, "and","or")) and not !!(IS_TOK(2, TOKEN_PUNCTUATION, "=")) and OPERATOR_PRECEDENCE[tokValue] > prevOpPrecedence then
			!!(EAT_NEXT_TOKEN) -- the binary operator

			local binary                     = astNewNode(AstBinary, tok, parent)
			binary.operation                 = tokValue
			binary.left                      = expr
			!SET_OR_RETURN_NIL `binary.right = parseExpression(state, binary, OPERATOR_PRECEDENCE[tokValue])`
			expr.parent                      = binary
			expr                             = binary

		-- Function call. (1)
		elseif tok.type == !(TOKEN_STRING) and !(OPERATOR_PRECEDENCE.call) > prevOpPrecedence then
			!SET_OR_RETURN_NIL `expr = parseCallChain(state, parent, expr, false)`

		--
		-- Punctuation.
		--
		elseif tok.type ~= !(TOKEN_PUNCTUATION) then
			break

		-- Left-associative binary operations. (2)
		elseif
			!!(CONST_SET{"+","-","*","/","//","%","<",">","<=",">=","==","~="})[tokValue]
			and OPERATOR_PRECEDENCE[tokValue] > prevOpPrecedence
		then
			if tokValue == "==" and !!(IS_TOK(2, TOKEN_PUNCTUATION, "{")) then -- Actually a switch statement.
				break
			end

			!!(EAT_NEXT_TOKEN) -- the binary operator

			local binary                     = astNewNode(AstBinary, tok, parent)
			binary.operation                 = tokValue
			binary.left                      = expr
			!SET_OR_RETURN_NIL `binary.right = parseExpression(state, binary, OPERATOR_PRECEDENCE[tokValue])`
			expr.parent                      = binary
			expr                             = binary

		-- Right-associative binary operations.
		-- @Incomplete: Combine string concatenations in some way?
		elseif (tokValue == "^" or tokValue == "..") and OPERATOR_PRECEDENCE[tokValue] > prevOpPrecedence then
			!!(EAT_NEXT_TOKEN) -- '^' or '..'

			local binary                     = astNewNode(AstBinary, tok, parent)
			binary.operation                 = tokValue
			binary.left                      = expr
			!SET_OR_RETURN_NIL `binary.right = parseExpression(state, binary, OPERATOR_PRECEDENCE[tokValue]-1)` -- The -1 makes this right-associative.
			expr.parent                      = binary
			expr                             = binary

		-- Lookup using '.'. (t.k is syntactic sugar for t["k"])
		elseif tokValue == "." and !(OPERATOR_PRECEDENCE.access) > prevOpPrecedence  and tok2 and tok2.type == !(TOKEN_IDENTIFIER) then
			!!(EAT_NEXT_TOKEN) -- '.'

			local access = astNewNode(AstAccess, tok, parent)

			tok = eatNextTok(state) -- the identifier
			-- if not (tok and tok.type == !(TOKEN_IDENTIFIER)) then -- We do this check for dot cast instead, because of its lower precedence. :TokenAfterDot
			-- 	!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected an identifier.")`
			-- end

			local literal       = astNewNode(AstLiteral, tok, access)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = tok.value

			access.object       = expr
			access.member       = literal

			expr.parent         = access
			expr                = access

			nextCanBeMethodCall = true

		-- Lookup using '['.
		elseif tokValue == "[" and !(OPERATOR_PRECEDENCE.access) > prevOpPrecedence then
			!!(EAT_NEXT_TOKEN) -- '['

			local access                      = astNewNode(AstAccess, tok, parent)
			access.object                     = expr
			!SET_OR_RETURN_NIL `access.member = parseExpression(state, access, OPERATOR_PRECEDENCE[tokValue])`

			tok = eatNextTok(state)
			if not !!(IS_TOK(TOKEN_PUNCTUATION,  "]")) then
				!ERROR_OR_RETURN_NIL `errorParsingAfterPrevious(state, "Expected ']' to end lookup.")`
			end

			expr.parent = access
			expr        = access

		-- Function call. (2)
		elseif tokValue == "(" and !(OPERATOR_PRECEDENCE.call) > prevOpPrecedence then
			!SET_OR_RETURN_NIL `expr = parseCallChain(state, parent, expr, false)`

		-- Method call.
		elseif
			(
				tokValue == "!"
				and tok2
				and (
					!!(IS_EXISTING_TOK(2, TOKEN_PUNCTUATION, "("))
					or tok2.type == !(TOKEN_STRING)
				)
			)
			and !(OPERATOR_PRECEDENCE.call) > prevOpPrecedence
		then
			tok = !!(PEEK_LAST_TOKEN)

			if not !!(IS_TOK(TOKEN_IDENTIFIER)) then
				!ERROR_OR_RETURN_NIL `errorParsingNext(state, "Expected a method name before this.")` -- @Incomplete: Don't require an identifier specifically. o["m"]!() should work.
			elseif not thisCanBeMethodCall then
				!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected an object to call a method on.")`
			end

			!!(EAT_NEXT_TOKEN)
			!SET_OR_RETURN_NIL `expr = parseCallChain(state, parent, expr, true)`

		-- Compound type.
		elseif tokValue == "|" and !(OPERATOR_PRECEDENCE.compound) > prevOpPrecedence then
			!!(EAT_NEXT_TOKEN) -- '|'

			local typeNodeCompound      = astNewNode(AstType, tok, parent)
			typeNodeCompound.kind       = !(TYPE_KIND_COMPOUND)
			typeNodeCompound.components = {}

			table.insert(typeNodeCompound.components, expr)

			while true do
				!SET_OR_RETURN_NIL `local typeExpr = parseExpression(state, parent, OPERATOR_PRECEDENCE.compound)`
				table.insert(typeNodeCompound.components, typeExpr)

				tok = peekNextTok(state, 1)

				if !!(IS_TOK(TOKEN_PUNCTUATION, "|")) then
					!!(EAT_NEXT_TOKEN) -- '|'
					tok = peekNextTok(state, 1)
				else
					break
				end
			end

			expr.parent = typeNodeCompound
			expr        = typeNodeCompound

		-- Dot cast. (type.{} is syntactic sugar for cast(type){} and type.NULL is syntactic sugar for cast(type)NULL)
		-- Note that dot casts and lookups have different precedence.
		elseif
			tokValue == "."
			-- and (tok2 and (!!(IS_EXISTING_TOK(2, TOKEN_PUNCTUATION, "{")) or !!(IS_EXISTING_TOK(2, TOKEN_KEYWORD, "NULL"))))
			and !(OPERATOR_PRECEDENCE.dotCast) > prevOpPrecedence
		then
			!!(EAT_NEXT_TOKEN) -- '.'

			local cast      = astNewNode(AstCast, tok, parent)
			cast.targetType = expr

			tok = eatNextTok(state) -- '{' or 'NULL' hopefully

			if !!(IS_TOK(TOKEN_PUNCTUATION, "{")) then
				!SET_OR_RETURN_NIL `cast.expression = parseTable(state, cast)`
			elseif !!(IS_TOK(TOKEN_KEYWORD, "NULL")) then
				cast.expression = astNewNode(AstNull, tok, cast)
			else -- :TokenAfterDot
				!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected an identifier after '.'.")`
			end

			expr.parent = cast
			expr        = cast

		-- Conditional.
		elseif tokValue == "?" and !(OPERATOR_PRECEDENCE.conditional) > prevOpPrecedence then
			!!(EAT_NEXT_TOKEN) -- '?'

			local conditional = astNewNode(AstConditional, tok, parent)

			!SET_OR_RETURN_NIL `conditional.condition = expr`
			tok                                       = peekNextTok(state, 1)

			if !!(IS_TOK(TOKEN_PUNCTUATION, ":")) then
				conditional.conditionAndBranchTrue = conditional.condition
			else
				!SET_OR_RETURN_NIL `conditional.branchTrue = parseExpression(state, conditional, OPERATOR_PRECEDENCE.conditional-1)` -- The -1 makes this right-associative.
			end

			tok = eatNextTok(state)
			if not !!(IS_TOK(TOKEN_PUNCTUATION, ":")) then
				!ERROR_OR_RETURN_NIL `errorParsingLast(state, "Expected ':' in ternary conditional.")`
			end

			!SET_OR_RETURN_NIL `conditional.branchFalse = parseExpression(state, conditional, OPERATOR_PRECEDENCE.conditional-1)` -- The -1 makes this right-associative.

			expr.parent = conditional
			expr        = conditional

		else
			break
		end
	end

	if expectLvalue then
		if expr.nodeType == !(AST_IDENTIFIER) then
			if startsWithParenthesis then
				!ERROR_OR_RETURN_NIL `errorParsing(state, exprStartTok, "Unexpected parentheses around identifier.")` -- :ParenthesesAmbiguityError
			end
		elseif expr.nodeType == !(AST_ACCESS) then
			-- void
		else
			tok        = peekNextTok(state, 1)
			local tok2 = peekNextTok(state, 2)

			if tok and isTokenAssigning(tok) then
				!ERROR_OR_RETURN_NIL `errorParsingAfterLast(state, "Expected an assignment target to the left of '%s'. Ambiguous statement.", tok.value)`
			elseif !!(IS_TOK(TOKEN_KEYWORD, "and","or")) and !!(IS_TOK(2, TOKEN_PUNCTUATION, "=")) then
				!ERROR_OR_RETURN_NIL `errorParsingAfterLast(state, "Expected an assignment target to the left of '%s='. Ambiguous statement.", tok.value)`
			else
				!ERROR_OR_RETURN_NIL `errorParsing(state, exprStartTok, "Ambiguous part of statement.")`
			end
		end
	end

	return expr
end



-- errorParsing( compilationState, token|tok|node, formatString, ... )
function _G.errorParsing(state, tokenOrTokOrNode, s, ...)
	if type(tokenOrTokOrNode) == "table" then
		local tokOrNode = tokenOrTokOrNode
		!TRACE(2)
		errorInFile(tokOrNode.source.string, tokOrNode.source.path, (tokOrNode.position or tokOrNode.position1), "Parser", s, ...)
	end

	local token  = tokenOrTokOrNode
	local tokens = state.tokens
	local tok    = tokens[token]
	local tok1   = tokens[1] or errorInternal("No tokens.")

	local buffer = (tok or tok1).source.string -- The fallback is not great, but better than crashing.
	local path   = (tok or tok1).source.path

	local ptr
		=  tok        and tok.position1
		or token <= 1 and 1
		or tokens[tokens.n].position2+1

	!if 1==0 then
		for token = math.max(state.nextToken-20, 1), math.min(state.nextToken+5, tokens.n) do
			print(
				(token == state.nextToken and "*"..token or token),
				TOKEN_TITLES[tokens[token].type],
				tokens[token].value
			)
		end
	!end

	!TRACE(2)
	!ifDEBUG `s = "(tok=" .. TOKEN_TITLES[(tok or tok1).type] .. ") " .. s`
	errorInFile(buffer, path, ptr, "Parser", s, ...)
end

-- parserMessage     ( [ outputFile=io.stdout, ] compilationState, tok|node, label, formatString, ... )
-- parserMessageAfter( [ outputFile=io.stdout, ] compilationState, tok,      label, formatString, ... )
-- parserMessageLine ( [ outputFile=io.stdout, ] compilationState, tok|node, label, formatString, ... )
function _G.parserMessage(file, state, tokOrNode, label, s, ...)
	if type(file) ~= "userdata" then  return parserMessage(io.stdout, file, state, tokOrNode, label, s, ...)  end
	reportMessageInFile(file, tokOrNode.source.string, tokOrNode.source.path, (tokOrNode.position1 or tokOrNode.position), label, "Parser", s, ...)
end
function _G.parserMessageAfter(file, state, tok, label, s, ...)
	if type(file) ~= "userdata" then  return parserMessageAfter(io.stdout, file, state, tok, label, s, ...)  end
	reportMessageInFile(file, tok.source.string, tok.source.path, tok.position2+1, label, "Parser", s, ...)
end
function _G.parserMessageLine(file, state, tokOrNode, label, s, ...)
	if type(file) ~= "userdata" then  return parserMessageLine(io.stdout, file, state, tokOrNode, label, s, ...)  end
	reportMessageOnLine(file, tokOrNode.source.path, (tokOrNode.line1 or tokOrNode.line), label, "Parser", s, ...)
end

-- errorParsingAfter( compilationState, token, formatString, ... )
function _G.errorParsingAfter(state, token, s, ...)
	local tokens = state.tokens
	local tok    = tokens[token]
	local tok1   = tokens[1] or errorInternal("No tokens.")

	local buffer = (tok or tok1).source.string -- The fallback is not great, but better than crashing.
	local path   = (tok or tok1).source.path

	local ptr
		=  tok        and tok.position2+1
		or token <= 1 and 1
		or tokens[tokens.n].position2+1

	!TRACE(2)
	errorInFile(buffer, path, ptr, "Parser", s, ...)
end

function _G.errorParsingLast(state, ...)
	errorParsing(state, state.nextToken-1, ...)
end
function _G.errorParsingNext(state, ...)
	errorParsing(state, state.nextToken, ...)
end

function _G.errorParsingAfterPrevious(state, ...)
	errorParsingAfter(state, state.nextToken-2, ...)
end
function _G.errorParsingAfterLast(state, ...)
	errorParsingAfter(state, state.nextToken-1, ...)
end



function _G.errorUnhandledNodeType(state, node)
	!if DEBUG then
		printerr()
		astPrintTree(io.stderr, node)
		-- !ifDEBUG `astPrintTree(io.stderr, state.globalScope)`
	!end

	local funcName = debug.getinfo(2, "n").name
	if funcName == "" then  funcName = "?"  end

	nodeError(
		state, node, "Debug",
		"Internal compiler error: Incomplete: Unhandled node type '%s'. (%s)",
		AST_NAMES[node.nodeType] or node.nodeType,
		funcName
	)
end

function _G.errorUnhandledType(state, node, typeInfo)
	!if DEBUG then
		printerr()
		astPrintTree(io.stderr, node)
	!end

	local funcName = debug.getinfo(2, "n").name
	if funcName == "" then  funcName = "?"  end

	nodeError(
		state, node, "Debug",
		"Internal compiler error: Incomplete: Unhandled type '%s'. (%s)",
		getFriendlyTypeInfoName(typeInfo),
		funcName
	)
end



-- nodeError( compilationState, node, agent, formatString, ... )
function _G.nodeError(state, node, agent, s, ...)
	!TRACE(2)
	!ifDEBUG `astPrint(node)`
	errorInFile(node.source.string, node.source.path, node.position, agent, s, ...)
end

-- nodeMessage( [ outputFile=io.stdout, ] compilationState, node, label, agent, formatString, ... )
function _G.nodeMessage(file, state, node, label, agent, s, ...)
	if type(file) ~= "userdata" then  return nodeMessage(io.stdout, file, state, node, label, agent, s, ...)  end
	reportMessageInFile(file, node.source.string, node.source.path, node.position, label, agent, s, ...)
end

-- where( state, node [, messageValue ] )
function _G.where(state, node, messageValue)
	!ASSERT `node` -- I keep forgetting the state argument...
	nodeMessage(io.stdout, state, node, "Debug", nil, "Here!%s", (messageValue ~= nil and F(" (%s)", tostring(messageValue)) or ""))
end

-- printLocation( [ outputFile=io.stdout, ] state, node )
-- Note: Does not print any newline!
function _G.printLocation(file, state, node)
	if type(file) ~= "userdata" then  file, state, node = io.stdout, file, state  end
	file:write(node.source.path, ":", node.line, ": ")
end



-- astPrint    ( [ outputFile=io.stdout, ] node )
-- astPrintTree( [ outputFile=io.stdout, ] node )
do
	local file
	local printNode -- Forward declaration.

	local function write(...)
		file:write(...)
	end

	local function printNodeList(list, indent, printed, printChildren, keyPrefix)
		for i, node in ipairs(list) do
			printNode(node, indent, printed, printChildren, (keyPrefix and keyPrefix..i))
		end
	end

	function printNode(node, indent, printed, printChildren, keyName)
		!local INDENT            = "    "
		!local CHILD_PRINT_START = "if not printChildren then write('\\n') else write('" .. (PRINT_NODE_BRACKETS and " {" or "") .. "\\n')"
		!local CHILD_PRINT_END   = (PRINT_NODE_BRACKETS and "write(indentStr, '}\\n') " or "") .. "end"

		local indentStr = (!(INDENT)):rep(indent)

		assert(node.s)

		write(indentStr)
		if keyName then  write(keyName, " ")  end
		write(AST_NAMES[node.nodeType] or "?")
		write(" @", node.s)
		if node.parent then  write(" ^", node.parent.s)  end

		local queued = node.queued

		if not queued then
			-- void

		elseif queued.unqueued then
			write(" uq:", PIPE_TITLES[queued.pipe])

		else
			write(" p:", PIPE_TITLES[queued.pipe])

			local dependency = queued.waitingOn

			if dependency then
				write(" w:", DEPEND_TITLES[dependency.dependType])

				if !!(CONST_SET{ DEPEND_HAS_DECLARATION, DEPEND_NODE_INFERRED, DEPEND_NODE_PASSED_INFER, DEPEND_NODE_PASSED_EMIT })[dependency.dependType] then
					local node = dependency.dependOn.node
					write(":", node.s)

				elseif dependency.dependType == !(DEPEND_TYPE_READY) or dependency.dependType == !(DEPEND_TYPE_MEMBERS_READY) then
					local typeInfo = dependency.dependOn
					write(":", getFriendlyTypeInfoName(typeInfo))

				elseif dependency.dependType == !(DEPEND_CONSTANT_READY) then
					local const = dependency.dependOn
					write(":", CONST_KIND_TITLES[const.kind])
					if const.name ~= "" then  write("/", getFriendlyTypeInfoName(const.name))  end
				end
			end
		end

		if printed[node] then
			write("  !!! ERROR: RECURSION DETECTED !!!\n")
		else
			printed[node] = true

			if node.inferredType then  write(" (type=", getFriendlyTypeInfoName(node.inferredType), ")")  end

			if node.nodeType == !(AST_IDENTIFIER) then
				local ident = node
				write(" (", (ident.name ~= "" and ident.name or "<unnamed>"), ", kind=", (IDENT_KIND_TITLES[ident.kind] or "?"))
				if ident.inferredType and getTypeRepresentedByExpression(ident) then  write(", typeRepresented=", getFriendlyTypeInfoName(getTypeRepresentedByExpression(ident)))  end
				if ident.declaration  then  write(", decl=", ident.declaration.s)  end
				write(")\n")

			elseif node.nodeType == !(AST_UNARY) then
				local unary = node
				write(" (", unary.operation, ")")
				!!(CHILD_PRINT_START)
				if unary.expression then  printNode(unary.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_BINARY) then
				local binary = node
				write(" (", binary.operation, ")")
				!!(CHILD_PRINT_START)
				if binary.left  then  printNode(binary.left,  indent+1, printed, printChildren)  end
				write(indentStr, !(INDENT.."op "), binary.operation, "\n")
				if binary.right then  printNode(binary.right, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_ACCESS) then
				local access = node
				write(" (")
				write(
					access.object and access.object.inferredType and getFriendlyTypeInfoName(
						getTypeRepresentedByExpression(access.object)
						or access.object.inferredType
					)
					or "?"
				)
				write(".")
				write(
					access.member and (
						(access.member.nodeType == !(AST_LITERAL) and tostring(access.member.value))
						or (access.member.inferredType and getFriendlyTypeInfoName(access.member.inferredType))
					)
					or "?"
				)
				write(")")
				!!(CHILD_PRINT_START)
				if access.object then  printNode(access.object, indent+1, printed, printChildren)  end
				if access.member then  printNode(access.member, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_DECLARATION) then
				local decl = node
				if decl.addedByPolymorph then  write(" (addedByPolymorph)")  end
				if decl.assignment       then  write(" (assignment ", decl.assignment.s, " i=", decl.assignmentIndex, ")")  end
				write(" (", (DECL_KIND_TITLES[decl.kind] or "?"))
				if decl.valueTypeInfo    then  write(", typeRepresented=", getFriendlyTypeInfoName(decl.valueTypeInfo))  end
				if decl.overloadOf then
					for i, declOverload in ipairs(decl.overloadOf.overloads) do
						write(i == 1 and ", overloads=" or "+")
						write(declOverload.s)
					end
				end
				write(")")

				!!(CHILD_PRINT_START)
				if decl.name  then  printNode(decl.name,  indent+1, printed, printChildren)           end
				if decl.type  then  printNode(decl.type,  indent+1, printed, printChildren, "TYPE")   end
				if decl.value then  printNode(decl.value, indent+1, printed, printChildren, "VALUE")  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_TABLE) then
				local tableNode = node
				!!(CHILD_PRINT_START)
				for i, tableField in ipairs(tableNode.fields) do
					if tableField.key   then  printNode(tableField.key,   indent+1, printed, printChildren, i.."K")  end
					if tableField.value then  printNode(tableField.value, indent+1, printed, printChildren, i.."V")  end
				end
				if tableNode.trailingExpression then  printNode(tableNode.trailingExpression, indent+1, printed, printChildren, "...")  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_CALL) then
				local call = node
				if call.isMethod                then  write(" (method)")         end
				if call.surroundedByParentheses then  write(" (adjustArgsTo1)")  end
				!!(CHILD_PRINT_START)
				if call.callee then  printNode(call.callee, indent+1, printed, printChildren)  end
				printNodeList(call.arguments, indent+1, printed, printChildren, "ARG")
				for i, argNamed in ipairs(call.argumentsNamed) do
					if argNamed.key   then  printNode(argNamed.key,   indent+1, printed, printChildren, i.."K")  end
					if argNamed.value then  printNode(argNamed.value, indent+1, printed, printChildren, i.."V")  end
				end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_ARGUMENTS) then
				local args = node
				!!(CHILD_PRINT_START)
				printNodeList(args.arguments, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_ARGUMENT) then
				local arg = node
				if arg.autobake == !(AUTOBAKE_ENABLED)  then  write(" (autobake=may)")   end
				if arg.autobake == !(AUTOBAKE_REQUIRED) then  write(" (autobake=must)")  end
				!!(CHILD_PRINT_START)
				if arg.declaration then  printNode(arg.declaration, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_TYPE) then
				local typeNode = node
				write(" (", TYPE_KIND_TITLES[typeNode.kind])
				if typeNode.representedType then
					write(", typeRepresented=", getFriendlyTypeInfoName(typeNode.representedType))
				elseif typeNode.typeName ~= "" then
					write(", name=", typeNode.typeName)
				end
				write(")")
				!!(CHILD_PRINT_START)
				if typeNode.kind == !(TYPE_KIND_FUNCTION) then
					if typeNode.functionHeader then  printNode(typeNode.functionHeader, indent+1, printed, printChildren)  end
				elseif typeNode.kind == !(TYPE_KIND_ARRAY) then
					if typeNode.arrayItemType then  printNode(typeNode.arrayItemType, indent+1, printed, printChildren)  end
				elseif typeNode.kind == !(TYPE_KIND_COMPOUND) then
					if typeNode.components then  printNodeList(typeNode.components, indent+1, printed, printChildren)  end
				end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_TYPE_OF) then
				local typeOf = node
				!!(CHILD_PRINT_START)
				if typeOf.expression then  printNode(typeOf.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_VARIANT_OF) then
				local variant = node
				!!(CHILD_PRINT_START)
				if variant.call then  printNode(variant.call, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_ASSIGNMENT) then
				local assignment = node
				if assignment.forDeclaration then
					write(" (forDeclaration")
					for i = 1, #assignment.targets do
						local decl = assignment.declarations[i]
						if decl then  write(" ", i, "=", decl.s)  end
					end
					write(")")
				end
				write(" (", assignment.binaryOperation, "=)")
				!!(CHILD_PRINT_START)
				printNodeList(assignment.targets, indent+1, printed, printChildren)
				write(indentStr, !(INDENT.."op "), assignment.binaryOperation, "=\n")
				printNodeList(assignment.values, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_CAST) then
				local cast = node
				!!(CHILD_PRINT_START)
				if cast.targetType then  printNode(cast.targetType, indent+1, printed, printChildren)  end
				if cast.expression then  printNode(cast.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_IF) or node.nodeType == !(AST_STATIC_IF) then
				local ifBranch = node
				!!(CHILD_PRINT_START)
				if ifBranch.condition   then  printNode(ifBranch.condition,   indent+1, printed, printChildren)           end
				if ifBranch.branchTrue  then  printNode(ifBranch.branchTrue,  indent+1, printed, printChildren, "TRUE")   end
				if ifBranch.branchFalse then  printNode(ifBranch.branchFalse, indent+1, printed, printChildren, "FALSE")  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_CONDITIONAL) then
				local conditional = node
				!!(CHILD_PRINT_START)
				if conditional.condition   then  printNode(conditional.condition,   indent+1, printed, printChildren)           end
				if conditional.branchTrue  then  printNode(conditional.branchTrue,  indent+1, printed, printChildren, "TRUE")   end
				if conditional.branchFalse then  printNode(conditional.branchFalse, indent+1, printed, printChildren, "FALSE")  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_WHILE) then
				local whileLoop = node
				!!(CHILD_PRINT_START)
				if whileLoop.condition then  printNode(whileLoop.condition, indent+1, printed, printChildren)  end
				if whileLoop.body      then  printNode(whileLoop.body,      indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_FOR) then
				local forLoop = node
				write(" (", FOR_TITLES[forLoop.forType])
				if forLoop.reverse then  write(", reverse")  end
				write(")")
				!!(CHILD_PRINT_START)
				printNodeList(forLoop.names,             indent+1, printed, printChildren, "NAME")
				printNodeList(forLoop.expressions,       indent+1, printed, printChildren, "EXPR")
				printNodeList(forLoop.statementsStatic,  indent+1, printed, printChildren, "STATIC")
				printNodeList(forLoop.statementsDynamic, indent+1, printed, printChildren, "DYNAMIC")
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_RETURN) then
				local returnNode = node
				if returnNode.runDirective then  write(" (runDirective ", returnNode.runDirective.s, ")")  end
				!!(CHILD_PRINT_START)
				printNodeList(returnNode.values, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif !!(CONST_SET{ AST_BREAK, AST_CONTINUE })[node.nodeType] then
				local breakOrContinue = node
				if breakOrContinue.loopName then  write(" (", breakOrContinue.loopName.name, ")")  end
				write("\n")

			elseif node.nodeType == !(AST_DEFER) then
				local defer = node
				!!(CHILD_PRINT_START)
				if defer.body then  printNode(defer.body, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_IMPORT) then
				local import = node
				write(" (", (import.isLoad and "load " or "import "), import.importName)
				if import.exported then  write(", exported")  end
				write(")")
				write("\n")

			elseif node.nodeType == !(AST_FOREIGN) then
				local foreign = node
				write(" (", foreign.foreignSource, ")")
				!!(CHILD_PRINT_START)
				if foreign.foreignSourceName then  printNode(foreign.foreignSourceName, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_USING) then
				local using = node
				!!(CHILD_PRINT_START)
				if using.expression then  printNode(using.expression, indent+1, printed, printChildren)  end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_VARARG) then
				local vararg = node
				if vararg.surroundedByParentheses then  write(" (adjustTo1)")  end
				write("\n")

			elseif node.nodeType == !(AST_DEBUG) then
				local debugNode = node
				write(" (", debugNode.action, ")")
				!!(CHILD_PRINT_START)
				printNode(debugNode.expression, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_BAKE) then
				local bake = node
				!!(CHILD_PRINT_START)
				printNode(bake.name, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_RUN) then
				local runNode = node
				!!(CHILD_PRINT_START)
				printNode(runNode.lambda, indent+1, printed, printChildren)
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_SWITCH) then
				local switch = node
				if switch.complete then  write(" (complete)")  end
				!!(CHILD_PRINT_START)
				if switch.value then  printNode(switch.value, indent+1, printed, printChildren)  end
				for _, case in ipairs(switch.cases) do
					if case.value then  printNode(case.value, indent+1, printed, printChildren)  end
					if case.body  then  printNode(case.body,  indent+1, printed, printChildren)  end
				end
				!!(CHILD_PRINT_END)

			elseif node.nodeType == !(AST_LITERAL) then
				local literal = node
				write(" (")

				if !!(CONST_SET{ LITERAL_BOOLEAN, LITERAL_NIL })[literal.literalType] then
					write(tostring(literal.value))

				else
					write(LITERAL_TITLES[literal.literalType])

					if literal.literalType == !(LITERAL_STRING) then
						write("(", #literal.value, ")")
					end

					local vStr = valueToStringForMessage(literal.value)
					if vStr ~= "" then  write(": ", vStr)  end
				end

				write(")\n")

			elseif node.declarations then -- AstScope and substructs.
				if node.nodeType == !(AST_LAMBDA) then
					local lambda     = node
					local assignment = astFindParent1(lambda, !(AST_ASSIGNMENT))
					local i          = assignment and assignment.forDeclaration and indexOf(assignment.values, lambda)
					if lambda.polymorphs then  write(" (polymorphs=", #lambda.polymorphs, ")")  end
					if i                 then  write(" (", assignment.targets[i].name,     ")")  end

				elseif node.nodeType == !(AST_FILE_SCOPE) then
					local fileScope = node
					write(" (", fileScope.path, ")")

				elseif node.nodeType == !(AST_NAMESPACE) then
					local namespace = node
					if not namespace.inferredType and namespace.namespaceReferenceNode then
						write(" (reference=", namespace.namespaceReferenceNode.s, ")")
					end

				elseif !!(CONST_SET{ AST_STRUCT, AST_ENUM })[node.nodeType] then
					local structOrEnum = node
					local typeInfo     = structOrEnum.representedType
					if typeInfo and typeInfo.name ~= "" then  write(" (", typeInfo.name, ")")  end
				end

				!!(CHILD_PRINT_START)
				if node.nodeType == !(AST_STRUCT) then
					if node.keyType   then  printNode(node.keyType,   indent+1, printed, printChildren, "K")  end
					if node.valueType then  printNode(node.valueType, indent+1, printed, printChildren, "V")  end
				end
				printNodeList(node.statementsStatic,  indent+1, printed, printChildren, "STATIC")
				printNodeList(node.statementsDynamic, indent+1, printed, printChildren, "DYNAMIC")
				if node.nodeType == !(AST_FILE_SCOPE) then
					if node.valueToExport then  printNode(node.valueToExport, indent+1, printed, printChildren, "EXPORT")  end
				end
				!!(CHILD_PRINT_END)

			else
				write("\n")
			end
		end
	end

	function _G.astPrintTree(_file, node)
		if type(_file) ~= "userdata" then  _file, node = io.stdout, _file  end
		!ASSERT `node`
		file = _file
		printNode(node, 0, {}, true)
	end

	function _G.astPrint(_file, node)
		if type(_file) ~= "userdata" then  _file, node = io.stdout, _file  end
		!ASSERT `node`
		file = _file
		printNode(node, 0, {}, false)
	end
end



-- parent, childClosestToParent = astFindParent ( node, parentNodeTypeSet )
-- parent, childClosestToParent = astFindParent1( node, parentNodeType    )
function _G.astFindParent(node, nodeTypeSet)
	while true do
		local lastNode = node
		node           = node.parent
		if not node                   then  return nil,  nil       end
		if nodeTypeSet[node.nodeType] then  return node, lastNode  end
	end
end
function _G.astFindParent1(node, parentNodeType)
	while true do
		local lastNode = node
		node           = node.parent
		if not node                        then  return nil,  nil       end
		if node.nodeType == parentNodeType then  return node, lastNode  end
	end
end
-- scope, statement = astFindParentScope( node )
function _G.astFindParentScope(node)
	while true do
		local lastNode = node
		node           = node.parent
		if not node                                     then  return nil,  nil       end
		if !!(CONST_SET(scopeNodeTypes))[node.nodeType] then  return node, lastNode  end
	end
end

function _G.astFindCommonParent(node1, node2)
	while true do
		node1 = node1.parent
		if not node1                  then  return nil    end
		if astHasParent(node2, node1) then  return node1  end
	end
end

function _G.astHasParent(node, parent)
	while true do
		node = node.parent
		if not node       then  return false  end
		if node == parent then  return true   end
	end
end

--[[ @Unused
-- Note: The returned node may be topNode.
function _G.astFindInTree(topNode, nodeTypeSet)
	local nodeToReturn = nil

	astVisitAllNodes(topNode, function(node)
		if nodeTypeSet[node.nodeType] then
			nodeToReturn = node
			return !(VISIT_BREAK)
		end
	end)

	return nodeToReturn
end
--]]

-- Note: The returned node may be topNode.
function _G.astFindInUnit(topNode, nodeTypeSet)
	local nodeToReturn = nil

	local function astFindInUnit_onVisit(node)
		if nodeTypeSet[node.nodeType] then
			nodeToReturn = node
			return !(VISIT_BREAK)
		end
	end

	astVisitAllNodesInUnit(topNode, true, astFindInUnit_onVisit)
	return nodeToReturn
end

-- Note: The returned node may be topNode.
function _G.astFindInUnit1(topNode, nodeType)
	local nodeToReturn = nil

	local function astFindInUnit_onVisit(node)
		if node.nodeType == nodeType then
			nodeToReturn = node
			return !(VISIT_BREAK)
		end
	end

	astVisitAllNodesInUnit(topNode, true, astFindInUnit_onVisit)
	return nodeToReturn
end



function _G.astFindTokenAtNode(state, node)
	local sourceInfo = node.source
	local pos        = node.position

	-- We assume it's a late token, thus reverse iteration.
	for token, tok in ipairsr(state.tokens) do
		if tok.position1 == pos and tok.source == sourceInfo then -- It's probably ok to check 'source' instead of 'source.path'.
			return token
		end
	end

	return nil
end



function _G.astIsOrIsInModule(node)
	local fileScope = (node.nodeType == !(AST_FILE_SCOPE) and node or astFindParent1(node, !(AST_FILE_SCOPE)))
	return fileScope ~= nil and fileScope.isModule
end



-- astVisitAllNodes           ( topNode, callback [, parentContainer, parentKey ] )
-- astVisitAllNodesLeavesFirst( topNode, callback [, parentContainer, parentKey ] )
-- astVisitAllNodesInUnit     ( topNode, visitLambdaNodes, callback )  -- Does not visit the contents of e.g. lambdas and types.
-- [ controlValue = ] callback( node, container, key )  -- Not return anything is the same as returning VISIT_CONTINUE.
-- controlValue = VISIT_CONTINUE|VISIT_BREAK|VISIT_IGNORE_CHILDREN
-- Note: VISIT_IGNORE_CHILDREN triggers an error in astVisitAllNodesLeavesFirst().
do
	local visit -- Forward declaration.

	local VISITORS = {
		!(
		local TEMPLATE_FUNCTION_HEADER, TEMPLATE_FUNCTION_FOOTER = `
			[$nodeType--[[$name]]] = function(visited, cb, leavesFirst, node)
				`,`
			end,
		`

		local TEMPLATE_TRAVERSE_NODE_IF_SET = `
			if node.$field and visit(visited, cb, leavesFirst, node, "$field", node.$field) then  return true  end
		`
		local TEMPLATE_TRAVERSE_ARRAY = `
			local arr = node.$field
			for i = 1, #arr do
				if visit(visited, cb, leavesFirst, arr, i, arr[i]) then  return true  end
			end
		`
		local TEMPLATE_TRAVERSE_ARRAY_IF_SET = `
			local arr = node.$field
			if arr then  for i = 1, #arr do
				if visit(visited, cb, leavesFirst, arr, i, arr[i]) then  return true  end
			end end
		`
		local TEMPLATE_TRAVERSE_FIELDS = `
			local tableFields = node.$field
			for i = 1, #tableFields do
				local tableField = tableFields[i]
				if tableField.key   and visit(visited, cb, leavesFirst, tableField, "key",   tableField.key  ) then  return true  end
				if tableField.value and visit(visited, cb, leavesFirst, tableField, "value", tableField.value) then  return true  end
			end
		`
		local TEMPLATE_TRAVERSE_CASES = `
			local cases = node.$field
			for i = 1, #cases do
				local case = cases[i]
				if case.value and visit(visited, cb, leavesFirst, case, "value", case.value) then  return true  end
				if case.body  and visit(visited, cb, leavesFirst, case, "body",  case.body ) then  return true  end
			end
		`

		local first = true

		for nodeType, name in ipairs(astTypeToStructName) do
			local fields       = structs[name] or error(name)
			local luaForFields = {}

			for _, field in ipairs(fields) do
				local k = field[1]

				if field.ast == "node" then
					table.insert(luaForFields, templateToLua(TEMPLATE_TRAVERSE_NODE_IF_SET, {field=k}))

				elseif field.ast == "array" then
					if field[2] then
						table.insert(luaForFields, templateToLua(TEMPLATE_TRAVERSE_ARRAY, {field=k}))
					else
						table.insert(luaForFields, templateToLua(TEMPLATE_TRAVERSE_ARRAY_IF_SET, {field=k}))
					end

				elseif field.ast == "fields" then
					table.insert(luaForFields, templateToLua(TEMPLATE_TRAVERSE_FIELDS, {field=k}))

				elseif field.ast == "cases" then
					table.insert(luaForFields, templateToLua(TEMPLATE_TRAVERSE_CASES, {field=k}))

				elseif field.ast then
					error(field.ast)
				end
			end

			if luaForFields[1] then
				__LUA(templateToLua(TEMPLATE_FUNCTION_HEADER, {nodeType=nodeType, name=name}, (first and -3 or -1)))
				first = false

				-- if STATIC_PROFILER then
				-- 	__LUA(templateToLua(
				-- 		`staticProfilerPush($name)
				-- 		`,
				-- 		{name=toLua("VISITOR_"..name)}
				-- 	))
				-- end

				__LUA(unpack(luaForFields))

				-- if STATIC_PROFILER then
				-- 	__LUA(templateToLua(
				-- 		`staticProfilerPop($name)
				-- 		`,
				-- 		{name=toLua("VISITOR_"..name)}
				-- 	))
				-- end

				__LUA(templateToLua(TEMPLATE_FUNCTION_FOOTER, {}, -1))
			end
		end
		)
	}

	function visit(visited, cb, leavesFirst, container, key, node)
		-- Note: We return true from this function if we want to break.

		!if CHECK_FOR_VISITED_NODES then
			if visited[node] then
				!ifDEBUG `astPrintTree(node)`
				errorInternal("Node already visited.")
			end
			visited[node] = true
		!end

		if not leavesFirst then
			-- !if STATIC_PROFILER then  __LUA `staticProfilerPush("visit_cb")`  end
			local controlValue = cb(node, container, key) or !(VISIT_CONTINUE)
			-- !if STATIC_PROFILER then  __LUA `staticProfilerPop("visit_cb")`  end

			if controlValue == !(VISIT_CONTINUE) then
				-- void
			elseif controlValue == !(VISIT_BREAK) then
				return true
			elseif controlValue == !(VISIT_IGNORE_CHILDREN) then
				return false
			end
		end

		local visitor = VISITORS[node.nodeType]
		if visitor and visitor(visited, cb, leavesFirst, node) then  return true  end

		if leavesFirst then
			-- !if STATIC_PROFILER then  __LUA `staticProfilerPush("visit_cb")`  end
			local controlValue = cb(node, container, key) or !(VISIT_CONTINUE)
			-- !if STATIC_PROFILER then  __LUA `staticProfilerPop("visit_cb")`  end

			if controlValue == !(VISIT_CONTINUE) then
				-- void
			elseif controlValue == !(VISIT_BREAK) then
				return true
			elseif controlValue == !(VISIT_IGNORE_CHILDREN) then
				errorInternal("VISIT_IGNORE_CHILDREN does not work when visiting leaves first.")
			end
		end

		return false
	end

	function _G.astVisitAllNodes(node, cb, container, key)
		return visit(!!(CHECK_FOR_VISITED_NODES and `{}` or `nil`), cb, false, container, key, node)
	end

	function _G.astVisitAllNodesLeavesFirst(node, cb, container, key)
		return visit(!!(CHECK_FOR_VISITED_NODES and `{}` or `nil`), cb, true,  container, key, node)
	end

	function _G.astVisitAllNodesInUnit(topNode, visitLambdas, cb)
		local function astVisitAllNodesInUnit_onVisit(node, container, key)
			local visitNode     = true
			local visitChildren = true

			if node.nodeType == !(AST_TYPE) then
				visitChildren = false
			elseif node.nodeType == !(AST_LAMBDA) --[[and not (node.captures or node.captureAll) ]]then -- Do we care about captures here?
				visitNode     = visitLambdas
				visitChildren = node == topNode
			end

			local controlValue = !(VISIT_CONTINUE)
			if visitNode then
				controlValue = cb(node, container, key) or !(VISIT_CONTINUE)
			end

			if visitChildren then
				return controlValue
			else
				return controlValue == !(VISIT_BREAK) and !(VISIT_BREAK) or !(VISIT_IGNORE_CHILDREN)
			end
		end
		astVisitAllNodes(topNode, astVisitAllNodesInUnit_onVisit)
	end
end



do
	local copyTree -- Forward declaration.

	local COPIERS = {
		!(
		local TEMPLATE_FUNCTION_HEADER, TEMPLATE_FUNCTION_FOOTER = `
			[$nodeType--[[$name]]] = function(node, tokOrSourceNode, parent, copies)
				local copy   = astNewNode($name, (tokOrSourceNode or node), parent)
				copies[node] = copy
				`,`
				return copy
			end,
		`

		local TEMPLATE_COPY_VALUE = `
			copy.$field = node.$field
		`
		local TEMPLATE_COPY_VALUE_ARRAY = `
			copyToArray(node.$field, copy.$field)
		`
		local TEMPLATE_COPY_VALUE_ARRAY_IF_SET = `
			copy.$field = node.$field and {unpack(node.$field)}
		`
		local TEMPLATE_COPY_VALUE_NAMES = `
			local arr     = node.$field
			local arrCopy = copy.$field
			for i, name in ipairs(arr) do
				local subNode    = arr[name]
				arrCopy[i]       = name
				arrCopy[name]    = subNode
				arrCopy[subNode] = i
			end
		`
		local TEMPLATE_COPY_NODE_IF_SET = `
			copy.$field = node.$field and copyTree(node.$field, tokOrSourceNode, copy, copies)
		`
		local TEMPLATE_COPY_ARRAY = `
			local arrCopy = copy.$field
			for i, subNode in ipairs(node.$field) do
				arrCopy[i] = copyTree(subNode, tokOrSourceNode, copy, copies)
			end
		`
		local TEMPLATE_COPY_ARRAY_IF_SET = `
			if node.$field then
				local arrCopy = copy.$field or {}
				copy.$field   = arrCopy
				for i, subNode in ipairs(node.$field) do
					arrCopy[i] = copyTree(subNode, tokOrSourceNode, copy, copies)
				end
			end
		`
		local TEMPLATE_COPY_FIELDS = `
			local fieldsCopy = copy.$field
			for i, tableField in ipairs(node.$field) do
				local tableFieldCopy          = KeyValuePair()
				tableFieldCopy.key            = tableField.key   and copyTree(tableField.key,   tokOrSourceNode, copy, copies)
				tableFieldCopy.value          = tableField.value and copyTree(tableField.value, tokOrSourceNode, copy, copies)
				tableFieldCopy.keyIsGenerated = tableField.keyIsGenerated
				tableFieldCopy.argumentIndex  = tableField.argumentIndex
				fieldsCopy[i]                 = tableFieldCopy
			end
		`
		local TEMPLATE_COPY_CASES = `
			local casesCopy = copy.$field
			for i, case in ipairs(node.$field) do
				local caseCopy       = SwitchCase()
				caseCopy.value       = case.value and copyTree(case.value, tokOrSourceNode, copy, copies)
				caseCopy.body        = case.body  and copyTree(case.body,  tokOrSourceNode, copy, copies)
				caseCopy.fallThrough = case.fallThrough
				casesCopy[i]         = caseCopy
			end
		`

		local fieldsToIgnore = {}
		for _, field in ipairs(structs._AstNode) do
			fieldsToIgnore[field[1]] = true
		end

		for nodeType, name in ipairs(astTypeToStructName) do
			local fields = structs[name] or error(name)

			__LUA(templateToLua(TEMPLATE_FUNCTION_HEADER, {nodeType=nodeType, name=name}, (nodeType == 1 and -3 or -1), -1))

			for _, field in ipairs(fields) do
				local k = field[1]

				if fieldsToIgnore[k] or field.doNotCopy then
					-- void

				elseif field.ast == "node" then
					__LUA(templateToLua(TEMPLATE_COPY_NODE_IF_SET, {field=k}))

				elseif field.ast == "array" then
					if field[2] then
						__LUA(templateToLua(TEMPLATE_COPY_ARRAY, {field=k}))
					else
						__LUA(templateToLua(TEMPLATE_COPY_ARRAY_IF_SET, {field=k}))
					end

				elseif field.ast == "fields" then
					__LUA(templateToLua(TEMPLATE_COPY_FIELDS, {field=k}))

				elseif field.ast == "cases" then
					__LUA(templateToLua(TEMPLATE_COPY_CASES, {field=k}))

				elseif field.ast then
					error(field.ast)

				else
					if field.astRef == "names" then
						__LUA(templateToLua(TEMPLATE_COPY_VALUE_NAMES, {field=k}))
					elseif field.astRef ~= "array" then
						__LUA(templateToLua(TEMPLATE_COPY_VALUE, {field=k}))
					elseif field[2] then
						__LUA(templateToLua(TEMPLATE_COPY_VALUE_ARRAY, {field=k}))
					else
						__LUA(templateToLua(TEMPLATE_COPY_VALUE_ARRAY_IF_SET, {field=k}))
					end
				end
			end

			__LUA(templateToLua(TEMPLATE_FUNCTION_FOOTER, {}, -1, -1))
		end
		)
	}

	function copyTree(node, tokOrSourceNode, parent, copies)
		!ASSERT `not copies[node]`
		local copier = COPIERS[node.nodeType] or errorInternal(state, node)

		!if STATIC_PROFILER then
			local copy = copier(node, tokOrSourceNode, (parent or node.parent), copies)
			return copy
		!else
			return copier(node, tokOrSourceNode, (parent or node.parent), copies)
		!end
	end

	local FIXERS = {
		!(
		local TEMPLATE_FUNCTION_HEADER, TEMPLATE_FUNCTION_FOOTER = `
			[$nodeType--[[$name]]] = function(copy, copies)
				`,`
			end,
		`

		local TEMPLATE_FIX_NODE = `
			copy.$field = copies[copy.$field] or copy.$field
		`
		local TEMPLATE_FIX_ARRAY = `
			local arrCopy = copy.$field
			for i, subCopy in ipairs(arrCopy) do
				arrCopy[i] = copies[subCopy] or subCopy
			end
		`
		local TEMPLATE_FIX_ARRAY_IF_SET = `
			local arrCopy = copy.$field
			if arrCopy then
				for i, subCopy in ipairs(arrCopy) do
					arrCopy[i] = copies[subCopy] or subCopy
				end
			end
		`
		local TEMPLATE_FIX_NAMES = `
			local arrCopy = copy.$field
			for i, name in ipairs(arrCopy) do
				local node    = arrCopy[name]
				local subCopy = copies[node]
				if subCopy then
					arrCopy[node]    = nil
					arrCopy[name]    = subCopy
					arrCopy[subCopy] = i
				end
			end
		`

		local first = true

		for nodeType, name in ipairs(astTypeToStructName) do
			local fields       = structs[name] or error(name)
			local luaForFields = {}

			for _, field in ipairs(fields) do
				local k = field[1]

				if not field.astRef then
					-- void
				elseif field.astRef == "node" then
					table.insert(luaForFields, templateToLua(TEMPLATE_FIX_NODE, {field=k}))
				elseif field.astRef == "array" then
					if field[2] then
						table.insert(luaForFields, templateToLua(TEMPLATE_FIX_ARRAY, {field=k}))
					else
						table.insert(luaForFields, templateToLua(TEMPLATE_FIX_ARRAY_IF_SET, {field=k}))
					end
				elseif field.astRef == "names" then
					table.insert(luaForFields, templateToLua(TEMPLATE_FIX_NAMES, {field=k}))
				else
					error(field.astRef)
				end
			end

			if luaForFields[1] then
				__LUA(templateToLua(TEMPLATE_FUNCTION_HEADER, {nodeType=nodeType, name=name}, (first and -3 or -1), -1))
				first = false

				-- if STATIC_PROFILER then
				-- 	__LUA(templateToLua(
				-- 		`staticProfilerPush($name)
				-- 		`,
				-- 		{name=toLua("FIXER_"..name)}
				-- 	))
				-- end

				__LUA(unpack(luaForFields))

				-- if STATIC_PROFILER then
				-- 	__LUA(templateToLua(
				-- 		`staticProfilerPop($name)
				-- 		`,
				-- 		{name=toLua("FIXER_"..name)}
				-- 	))
				-- end

				__LUA(templateToLua(TEMPLATE_FUNCTION_FOOTER, {}, -1, -1))
			end
		end
		)
	}

	-- copy, copies = astCopy( node [, tokOrSourceNode=auto, parent=node.parent ] )
	-- copies = { [node1]=copy1, ... }
	-- Note: Copies the whole tree. We also don't touch any queued.
	function _G.astCopy(node, tokOrSourceNode, parent)
		local copies = {}
		local copy   = copyTree(node, tokOrSourceNode, parent, copies)

		local function astCopy_onVisit(copy)
			local fixer = FIXERS[copy.nodeType]
			if fixer then  fixer(copy, copies)  end
		end

		astVisitAllNodes(copy, astCopy_onVisit)
		return copy, copies
	end

	local DUMMY = {}

	-- copy = astCopyIdentifier( identifier [, tokOrSourceNode=auto, parent=identifier.parent, identKind=identifier.kind ] )
	function _G.astCopyIdentifier(ident, tokOrSourceNode, parent, identKind)
		local copy = COPIERS[!(AST_IDENTIFIER)](ident, tokOrSourceNode, (parent or ident.parent), DUMMY)

		FIXERS[!(AST_IDENTIFIER)](copy, EMPTY_TABLE) -- Not sure if needed for identifiers. @Speed

		if identKind then  copy.kind = identKind  end
		return copy
	end
end



-- expression = astGetExpressionVisuallyFurthestToTheLeft( expression [, onlyFollowCalls=false ] )
function _G.astGetExpressionVisuallyFurthestToTheLeft(expr, onlyFollowCalls)
	while expr.replacing do  expr = expr.replacing  end

	if expr.nodeType == !(AST_CALL) then
		local call = expr
		return astGetExpressionVisuallyFurthestToTheLeft(call.callee, onlyFollowCalls)

	elseif onlyFollowCalls then
		return expr

	elseif expr.nodeType == !(AST_BINARY) then
		local binary = expr
		return astGetExpressionVisuallyFurthestToTheLeft(binary.left, false)

	elseif expr.nodeType == !(AST_ACCESS) then
		local access = expr
		return astGetExpressionVisuallyFurthestToTheLeft(access.object, false)

	elseif expr.nodeType == !(AST_CONDITIONAL) then
		local conditional = expr
		return astGetExpressionVisuallyFurthestToTheLeft(conditional.condition, false)

	else
		return expr
	end
end

-- expression = astGetCalleeVisuallyFurthestToTheLeft( call )
function _G.astGetCalleeVisuallyFurthestToTheLeft(call)
	return astGetExpressionVisuallyFurthestToTheLeft(call, true)
end



function _G.astGetDepth(node)
	local depth = 1
	node        = node.parent

	while node do
		node  = node.parent
		depth = depth+1
	end

	return depth
end



--[[ isNodeAt( state, node, filePath [, lineNumber=any ] )
function _G.isNodeAt(state, node, targetPath, targetLn)
	return node.source.path == targetPath and (not targetLn or node.line == targetLn)
end
--]]



function _G.isLiteral(node, literalType)
	return node.nodeType == !(AST_LITERAL) and node.literalType == literalType
end



-- literal = newLiteral( parent, tokOrSourceNode, literalType, value [, typeInfo ] )
function _G.newLiteral(parent, tokOrSourceNode, literalType, value, typeInfo)
	local literal        = astNewNode(AstLiteral, tokOrSourceNode, parent)
	literal.literalType  = literalType
	literal.value        = value
	literal.inferredType = typeInfo
	return literal
end

-- identifier = newIdentifier( parent, tokOrSourceNode, kind, name [, declaration, typeInfo ] )
function _G.newIdentifier(parent, tokOrSourceNode, identKind, name, decl, typeInfo)
	local ident        = astNewNode(AstIdentifier, tokOrSourceNode, parent)
	ident.kind         = identKind
	ident.name         = name
	ident.declaration  = decl
	ident.inferredType = typeInfo
	return ident
end



function _G.astGetOriginal(node)
	while node.replacing do
		node = node.replacing
	end
	return node
end

function _G.astGetReplacement(node)
	while node.replacedBy do
		node = node.replacedBy
	end
	return node
end



function _G.addDeclarationToNames(scope, decl)
	local name = decl.name.name

	local declarationsByName = scope.declarationsByName
	local declExisting       = declarationsByName[name]

	if declExisting then
		-- Assume this is/will be an overloaded function. Error checking must happen by the caller.
		declarationsByName = scope.declarationsByName2
		declExisting       = declarationsByName[name]
		if declExisting then  return  end
	end

	local i                  = #declarationsByName+1
	declarationsByName[i]    = name
	declarationsByName[name] = decl
	declarationsByName[decl] = i
end


