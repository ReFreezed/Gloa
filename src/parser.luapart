--[[============================================================
--=
--=  Parser
--=
--=-------------------------------------------------------------
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--==============================================================

	astFindParent
	astNewNode
	astPrint
	errorParsing*
	parse*

--============================================================]]

!(
local PRINT_NODE_BRACKETS = false

local function ERROR_OR_RETURN(errCode)
	__LUA("if state.soft then return nil end ")
	__LUA(errCode)
end

local function SET_OR_RETURN(assignmentCode)
	local preCode, sufCode = assignmentCode:match"^([^=]+)=(.*)$"
	if not preCode then  error(assignmentCode)  end

	-- local x = ...
	if preCode:find"^%s*local%s" then
		local var = preCode:match"^%s*local%s+([%w_]+)" or error(preCode)
		__LUA(assignmentCode)
		__LUA(" if not ",var," then return nil end ")

	-- x = ...
	elseif preCode:find"^%s*[%w_]+%s*$" then
		local var = preCode:match"[%w_]+" or error(preCode)
		__LUA(assignmentCode)
		__LUA(" if not ",var," then return nil end ")

	-- x.y = ...
	else
		__LUA("local __value__ =",sufCode)
		__LUA(" if not __value__ then return nil end ")
		__LUA(preCode,"= __value__")
	end
end

local function DO_OR_RETURN(exprCode)
	__LUA("if not (",exprCode,") then return nil end")
end
)



_G.!struct"ParseState"{
	fileBuffers = {},
	tokens      = {},
	nextToken   = 1,
	soft        = false, -- Enabling this will make parsing functions return nil on error instead of triggering an actual error.
}



!(
_G.nodeTypes        = {}
local nodeTypeN     = 0
local nodeTypeNames = {}

local function structAst(nameAndParent)
	return function(fields)
		local name = nameAndParent:match"^[%w_]+"

		if not name:find"^_" then
			nodeTypeN         = nodeTypeN+1
			fields._overrides = {nodeType=nodeTypeN}

			nodeTypes[name]          = nodeTypeN
			nodeTypeNames[nodeTypeN] = name
		end

		struct(nameAndParent)(fields)
	end
end
)

!struct"_AstNode"{
	nodeType = 0,
	s        = 0, -- Serial number.
	parent   = NIL,
	token    = 1,
}
_G.!structAst"AstTypeDefinition:_AstNode"{
	-- Type phase:
	name     = NIL, -- AstIdentifier|AstVararg
	scope    = NIL, -- AstFileScope|AstBlock|AstStruct|AstFor|AstLambda|AstEnum (This should be the same as the parent.)
	typeInfo = NIL,
}

!structAst"_AstExpression:_AstNode"{
	-- Type phase:
	inferredType = NIL, -- TypeInfo
}
local !structAst"AstIdentifier:_AstExpression"{
	name = "",
	-- Type phase:
	placeDeclared = NIL, -- AstDeclaration|AstStruct|AstFor|AstLambda (Can/should this be moved to AstTypeDefinition?)
}
local !structAst"AstVararg:_AstExpression"{
	surroundedByParenthesis = false,
}
local !structAst"AstLiteral:_AstExpression"{
	literalType = 0,
	value       = NIL, -- The value depends on what literalType is. Could be a number, string or whatever.
}
local !structAst"AstType:_AstExpression"{
	isUserType        = false,
	typeName          = "",
	functionSignature = NIL, -- AstLambda without a body.
	arguments         = NIL, -- []AstExpression (Is set for parameterized structs.)
	-- Type phase:
	typeInfo          = NIL,
}
local !structAst"AstUnary:_AstExpression"{
	operation  = "",
	expression = NIL,
}
local !structAst"AstBinary:_AstExpression"{
	operation = "",
	left      = NIL,
	right     = NIL,
}
local !structAst"AstTable:_AstExpression"{
	-- [1]=field1, ...
}
local !structAst"AstCall:_AstExpression"{
	couldBeTypeWithParameters = false,
	isMethod                  = false,
	surroundedByParenthesis   = false,
	callee                    = NIL, -- AstExpression
	arguments                 = {},  -- []AstExpression
}
local !structAst"AstArgument:_AstNode"{
	declaration = NIL, -- AstDeclaration
	group       = 0,   -- Arguments in the same group have the same type. This is a small optimization for the typer.
	autobake    = 0,   -- 0=disabled, 1=enabled, 2=required  @Incomplete

	-- For an in arg, this indicates optionality.
	-- For an out arg, if there's a !must then it must not be adjusted away by the caller.
	isRequired  = false,
}
local !structAst"AstArguments:_AstExpression"{ -- @Cleanup: Move this into an array in the parent (like expression lists).
	-- [1]=argument1, ...
}
local !structAst"AstLambda:_AstExpression"{
	argumentsIn  = NIL, -- AstArguments
	argumentsOut = NIL, -- AstArguments
	body         = NIL, -- AstBlock (If this is nil then the lambda is a function signature.)
	-- Type phase:
	definitions = {},  -- []AstTypeDefinition (Note that the body has it's own definitions.)
}
local !structAst"AstTypeOf:_AstExpression"{
	expression = NIL,
}
local !structAst"AstCast:_AstExpression"{
	targetType = NIL, -- AstType
	expression = NIL,
}

local !structAst"AstStatement:_AstNode"{ -- Needed? I think so?
	what = NIL,
}

local !structAst"AstDeclaration:_AstNode"{
	names      = {},  -- [](AstIdentifier|AstVararg)
	isLocal    = true,
	types      = {},  -- No value here means the types are inferred.
	values     = {},  -- Nil for the corresponding name means default value, which depends on the value type.
	isConstant = false,
	tags       = {},  -- @Incomplete
	-- Type phase:
	inferredTypes = {}, -- []TypeInfo (One for each name.)
}

local !structAst"AstAssignment:_AstNode"{
	operation = "",
	targets   = {}, -- []AstExpression
	values    = {}, -- []AstExpression
}

!structAst"_AstJump:_AstNode"{}
local !structAst"AstReturn:_AstJump"{
	values = {}, -- []AstExpression
}
local !structAst"AstBreak:_AstJump"{
	loopName = NIL, -- AstIdentifier
}
local !structAst"AstContinue:_AstJump"{
	loopName = NIL, -- AstIdentifier
}

local !structAst"AstDefer:_AstNode"{
	body = NIL,
}

local !structAst"AstImport:_AstNode"{
	isLoad = false,
	name   = "",
}

!structAst"_AstControlStructure:_AstNode"{}
local !structAst"AstIf:_AstControlStructure"{
	condition   = NIL,
	branchTrue  = NIL,
	branchFalse = NIL,
}
local !structAst"AstWhile:_AstControlStructure"{
	condition = NIL,
	body      = NIL,
}
local !structAst"AstFor:_AstControlStructure"{
	forType     = FOR_NUMERIC,
	names       = {},  -- []AstIdentifier
	expressions = {},  -- []AstExpression
	body        = NIL, -- AstBlock|AstNode
	-- Type phase:
	definitions = {},  -- []AstTypeDefinition (Note that the body has it's own definitions.)
}

!structAst"_AstDeclarativeScope:_AstNode"{
	declarations       = {},
	includedNamespaces = {},
	-- Type phase:
	definitions        = {}, -- []AstTypeDefinition
}
local !structAst"AstStruct:_AstDeclarativeScope"{
	arguments = NIL, -- AstArguments
}
local !structAst"AstEnum:_AstDeclarativeScope"{ -- Should this be a DeclarativeScope?
	memberType = NIL, -- AstType
}
local !structAst"AstBlock:_AstDeclarativeScope"{
	-- [1]=statement1, ...
}
local !structAst"AstFileScope:_AstDeclarativeScope"{
	path = "",
}

_G.AST_NODE_TYPE_NAMES = !(nodeTypeNames)



local !struct"TableField"{
	key   = NIL,
	value = NIL,
}



local TOKEN_TYPE_TO_LITERAL_TYPE = !({
	[TOKEN_NUMBER]  = LITERAL_NUMBER,
	[TOKEN_INTEGER] = LITERAL_INTEGER,
	[TOKEN_STRING]  = LITERAL_STRING,
})



-- node:AstNodeType = astNewNode( AstNodeType, token [, parentNode ] )
do
	local serialN = 0

	function _G.astNewNode(AstNodeType, token, parentNode)
		if not AstNodeType then  error("No AstNodeType specified.", 2)  end

		if not parentNode and AstNodeType ~= AstFileScope then
			error("No parent.", 2)
		end

		serialN = serialN+1

		local node  = AstNodeType()
		node.s      = serialN
		node.parent = parentNode
		node.token  = token

		--[[
		if
			false
			-- or serialN == 22
			or parentNode and parentNode.s == 21
		then
			error("DEBUG")
		end
		--]]

		return node
	end
end



-- identifier = parseIdentifier( state, parentNode [, placeDeclared ] )
--
-- placeDeclared should be set when they are declared, i.e. in declarations or
-- function argument lists (loose identifiers should have it be nil as we figure
-- it out during type inference (or maybe not?)).
--
function _G.parseIdentifier(state, parentNode, placeDeclared)
	local tokType, tokValue, token = consumeNextToken(state)
	if tokType ~= !(TOKEN_IDENTIFIER) then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected an identifier.")`
	end

	local ident         = astNewNode(AstIdentifier, token, parentNode)
	ident.name          = tokValue
	ident.placeDeclared = placeDeclared

	return ident
end

function _G.parseType(state, parentNode)
	local tokType, tokValue, token = consumeNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"typeOf") then
		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '('.")`
		end

		local typeOf                      = astNewNode(AstTypeOf, token, parentNode)
		!SET_OR_RETURN `typeOf.expression = parseExpression(state, typeOf)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		return typeOf

	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[") then
		local tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"]") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ']'.")`
		end

		local literal                 = astNewNode(AstLiteral, token, parentNode)
		literal.literalType           = !(LITERAL_ARRAY)
		!SET_OR_RETURN `literal.value = parseType(state, literal)` -- Not sure if it's good that literal.value can be an AstNode along other literals.

		return literal
	end

	local isBuiltinType = isTokenBuiltinType(tokType, tokValue)
	local identType

	if isBuiltinType or tokType == !(TOKEN_IDENTIFIER) then
		identType            = astNewNode(AstType, token, parentNode)
		identType.isUserType = not isBuiltinType
		identType.typeName   = tokValue
	else
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected a type.")`
	end

	-- User type parameters.
	tokType2, tokValue2 = peekNextToken(state)

	if isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"(") then
		consumeNextToken(state)

		if isBuiltinType then
			!ERROR_OR_RETURN `errorParsingLast(state, "Built-in types have no parameters.")`
		end

		identType.arguments = {}
		!DO_OR_RETURN `parseExpressionList(state, identType, identType.arguments)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end
	end

	return identType
end

-- success = parsePipeSeparatedTypes( state, parentNode, identifierTypes )
function _G.parsePipeSeparatedTypes(state, parentNode, identTypes)
	while true do
		local identType = parseType(state, parentNode)
		if not identType then  return false  end

		table.insert(identTypes, identType)
		local tokType, tokValue, token = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"|") then
			consumeNextToken(state)
			tokType, tokValue, token = peekNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"nil") then
				consumeNextToken(state)

				local identType    = astNewNode(AstType, parentNode)
				identType.typeName = "nil"

				table.insert(identTypes, identType)
				break

			else
				-- Continue the loop.
			end

		else
			break
		end
	end

	return true
end

function _G.parseTable(state, parentNode)
	-- Note: We assume the '{' has been consumed already.

	local tableStartToken = state.nextToken-1
	local tableNode       = astNewNode(AstTable, tableStartToken, parentNode)
	local listIndex       = 0

	while true do
		local tokType, tokValue = peekNextToken(state)

		if not tokType then
			!ERROR_OR_RETURN `errorParsing(state, tableStartToken, "Unfinished table.")`
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			consumeNextToken(state)
			break
		end

		local tokType2, tokValue2, token = peekNextToken(state, 2)
		local tableField                 = TableField()
		local tableKey

		-- [k]=v
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[") then
			consumeNextToken(state)

			!SET_OR_RETURN `tableKey = parseExpression(state, tableNode)`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"]") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ']'.")`
			end

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '='.")`
			end

		-- k=v
		elseif
			tokType == !(TOKEN_IDENTIFIER)
			and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"=")
		then
			consumeNextToken(state)
			local literal       = astNewNode(AstLiteral, token, tableNode)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = tokValue
			tableKey            = literal
			consumeNextToken(state) -- The equal sign.

		-- v
		elseif
			tokType == !(TOKEN_IDENTIFIER)
			or isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
			or isTokenLiteral(tokType, tokValue)
		then
			listIndex           = listIndex+1
			local literal       = astNewNode(AstLiteral, token, tableNode) -- Note: The token position of the key and value will be the same.
			literal.literalType = !(LITERAL_INTEGER)
			literal.value       = listIndex
			tableKey            = literal

		else
			!ERROR_OR_RETURN `errorParsingNext(state, "Expected a table field.")`
		end

		assert(tableKey)

		tableField.key                   = tableKey
		!SET_OR_RETURN `tableField.value = parseExpression(state, tableNode)`

		table.insert(tableNode, tableField)

		tokType, tokValue = consumeNextToken(state)
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			break
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",",";") then
			-- void
			-- Note: A trailing comma or semicolon at the end of the arg list is permitted.
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ','.")`
		end
	end

	return tableNode
end

-- Parse comma-separated expressions. Used for function calls and struct parameters.
-- success = parseExpressionList( state, parentNode, expressions )
function _G.parseExpressionList(state, parentNode, expressions)
	while true do
		local expr = parseExpression(state, parentNode)
		if not expr then  return false  end
		table.insert(expressions, expr)

		local tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			consumeNextToken(state)
			-- Continue the loop.
		else
			break
		end
	end

	return true
end

-- parseArguments( state, parentNode, isInput, placeDeclared )
-- placeDeclared = AstLambda|AstStruct
function _G.parseArguments(state, parentNode, isInput, placeDeclared)
	local args      = astNewNode(AstArguments, state.nextToken, parentNode)
	local gotVararg = false
	local tokType, tokValue, token

	for groupN = 1, math.huge do
		-- Argument name(s).
		local argGroup = {}

		while true do
			tokType, tokValue, token = consumeNextToken(state)
			if not (tokType == !(TOKEN_IDENTIFIER) or isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"...")) then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected an identifier.")`
			end

			local arg = astNewNode(AstArgument, token, args)
			arg.group = groupN

			table.insert(args,     arg)
			table.insert(argGroup, arg)

			local decl      = astNewNode(AstDeclaration, token, arg)
			arg.declaration = decl

			local nameNode

			if tokType == !(TOKEN_IDENTIFIER) then
				local ident         = astNewNode(AstIdentifier, token, decl)
				ident.name          = tokValue
				ident.placeDeclared = placeDeclared
				nameNode            = ident
			else
				gotVararg   = true
				nameNode    = astNewNode(AstVararg, token, decl)
			end

			decl.names[1] = nameNode

			tokType, tokValue = consumeNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
				break
			elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
				-- Continue the loop.
			else
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ':'.")`
			end

			if gotVararg then
				!ERROR_OR_RETURN `errorParsingLast(state, "Vararg must be the last argument.")`
			end
		end

		-- Type(s).
		token = state.nextToken
		for _, arg in ipairs(argGroup) do
			state.nextToken = token
			local decl      = arg.declaration
			!DO_OR_RETURN `parsePipeSeparatedTypes(state, decl, decl.types)` -- @Speed: Parse once then just copy the first one.
		end

		-- Default value.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
			consumeNextToken(state)
			if not isInput then
				!ERROR_OR_RETURN `errorParsingLast(state, "Output arguments cannot have default values.")`
			end

			token = state.nextToken
			for i, arg in ipairs(argGroup) do
				state.nextToken = token
				local decl      = arg.declaration

				!SET_OR_RETURN `local expr = parseExpression(state, decl)` -- @Speed: Parse once then just copy the first one.
				decl.values[1]             = expr

				-- If the value is nil then we make sure 'nil' is one of the types.
				if
					i == 1
					and expr.nodeType == !(nodeTypes.AstLiteral)
					and expr.literalType == !(LITERAL_NIL)
					and not itemWith1(decl.types, "typeName", "nil")
				then
					local identType    = astNewNode(AstType, expr.token, decl)
					identType.typeName = "nil"
					table.insert(decl.types, identType)
				end
			end
		end

		-- @Incomplete: Set arg.isRequired.
		-- if isInput then
		-- 	arg.isRequired = (arg.declaration.values[1] == nil)
		-- else
		-- 	-- @Incomplete: Set arg.isRequired if there's a !must somewhere closeby.
		-- end

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			consumeNextToken(state)
			-- Continue the loop.
		else
			break
		end

		if gotVararg then
			!ERROR_OR_RETURN `errorParsingLast(state, "Vararg must be the last argument.")`
		end
	end

	return args
end

function _G.parseStruct(state, parentNode)
	local struct            = astNewNode(AstStruct, state.nextToken-1, parentNode) -- The token should be the 'struct' keyword.
	local tokType, tokValue = consumeNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
		!SET_OR_RETURN `struct.arguments = parseArguments(state, struct, true, struct)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		tokType, tokValue = consumeNextToken(state)
	end

	if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '{'.")`
	end

	tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
		consumeNextToken(state)

	else
		-- Note: We allow a trailing comma/semicolon after the members.
		while true do
			local declType             = !(DECLARATION_STRUCT)
			!SET_OR_RETURN `local decl = parseDeclaration(state, struct, declType)`

			table.insert(struct.declarations, decl)
			tokType, tokValue = consumeNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",",";") then
				-- Continue the loop.
			elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
				break
			else
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '}'.")`
			end

			tokType, tokValue = peekNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
				consumeNextToken(state)
				break
			end
		end
	end

	return struct
end

function _G.parseEnum(state, parentNode)
	local enum              = astNewNode(AstEnum, state.nextToken-1, parentNode) -- The token should be the 'enum' keyword.
	local tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"number","int","string","bool","type") then -- We don't allow 'table' or '*'.
		!SET_OR_RETURN `enum.memberType = parseType(state, enum)`
	end

	tokType, tokValue = consumeNextToken(state)

	if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		local tokType2, tokValue2 = peekNextToken(state)
		if
			(tokType == !(TOKEN_IDENTIFIER) or isTokenBuiltinType(tokType, tokValue))
			and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"{")
		then
			!ERROR_OR_RETURN `errorParsingLast(state, "Supported enum member types are: int, string, type, bool, number")`
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '{'.")`
		end
	end

	tokType, tokValue = peekNextToken(state)

	-- Note: We allow a trailing comma/semicolon after the members.
	while true do
		local declType             = !(DECLARATION_ENUM)
		!SET_OR_RETURN `local decl = parseDeclaration(state, enum, declType)`

		table.insert(enum.declarations, decl)
		tokType, tokValue = consumeNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",",";") then
			-- Continue the loop.
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			break
		else
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '}'.")`
		end

		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			consumeNextToken(state)
			break
		end
	end

	return enum
end

-- declaration = parseDeclaration( state, parentNode [, declarationType=DECLARATION_NORMAL ] )
function _G.parseDeclaration(state, parentNode, declType)
	--[[
	local a = 0         -- Variable, inferred type.
	local b:number = 0  -- Variable, explicit type.
	local c:number      -- Variable, getting a default value.
	local A :: 0        -- Constant, inferred type.
	local B:number : 0  -- Constant, explicit type.
	local a,b,c = 0,f() -- Multiples always have either inferred type...
	local a,b:int : 1,2 -- ...or the same type.
	-- No multiples allowed:
	local a :: struct {}
	local a :: enum   {}
	local a :: !import "foo"
	local a :: !load   "foo.gloa"
	-- @Incomplete: Limit function declarations to a single.
	]]

	declType   = declType or !(DECLARATION_NORMAL)
	local decl = astNewNode(AstDeclaration, state.nextToken, parentNode)

	if declType == !(DECLARATION_NORMAL) then
		local tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_KEYWORD),"local","global") then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected 'local'.")`
		end
		decl.isLocal = (tokValue == "local")
	end

	local nameListStartToken = state.nextToken
	if declType == !(DECLARATION_NORMAL) then
		!DO_OR_RETURN `parseNameList(state, decl, decl.names, decl)`
	else
		!SET_OR_RETURN `local ident = parseIdentifier(state, decl, decl)`
		table.insert(decl.names, ident)
	end

	local typesStartToken   = state.nextToken -- Dummy position, kinda.
	local tokType, tokValue = peekNextToken(state)

	-- Type is specified and/or we have a constant.
	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
		consumeNextToken(state)

		typesStartToken   = state.nextToken
		tokType, tokValue = peekNextToken(state)

		-- Inferred type.
		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
			-- void

			-- @Robustness: Mark the declaration to have it's type inferred instead of just
			-- leaving decl.types empty? Or should we have an AstTypeInferred node?

		-- Specified type.
		else
			if declType == !(DECLARATION_ENUM) then
				!ERROR_OR_RETURN `errorParsingAfterLast(state, "The type of the members must be specified after the 'enum' keyword.")`
			else
				!DO_OR_RETURN `parsePipeSeparatedTypes(state, decl, decl.types)`
			end
		end

	-- We must have = or : after the identifier, for specified or inferred type.
	elseif not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
		!ERROR_OR_RETURN `errorParsingAfterLast(state, "Expected ':' or '='.")`
	end

	tokType, tokValue = peekNextToken(state)

	-- Variable.
	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
		consumeNextToken(state)

		if declType == !(DECLARATION_ENUM) then
			!ERROR_OR_RETURN `errorParsingLast(state, "Enum members must be constant.")`
		elseif declType == !(DECLARATION_STRUCT) then
			!SET_OR_RETURN `local expr = parseExpression(state, decl)`
			table.insert(decl.values, expr)
		else
			!DO_OR_RETURN `parseExpressionList(state, decl, decl.values)`
		end

	-- Constant.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
		consumeNextToken(state)
		decl.isConstant = true

		if decl.types[2] then
			!ERROR_OR_RETURN `errorParsing(state, decl.types[2].token-1, "Constants can only be of one type.")`
		end

		tokType, tokValue = peekNextToken(state)

		-- Struct.
		if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"struct") then
			if decl.names[2] then
				!ERROR_OR_RETURN `errorParsing(state, nameListStartToken+2, "Struct declaration statements must have only one name.")`
			end
			consumeNextToken(state)
			!SET_OR_RETURN `local struct = parseStruct(state, decl)`
			table.insert(decl.values, struct)

		-- Enum.
		elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"enum") then
			if decl.names[2] then
				!ERROR_OR_RETURN `errorParsing(state, nameListStartToken+2, "Enum declaration statements must have only one name.")`
			end
			consumeNextToken(state)
			!SET_OR_RETURN `local enum = parseEnum(state, decl)`
			table.insert(decl.values, enum)

		-- Import/load.
		elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import","load") then
			if declType ~= !(DECLARATION_NORMAL) or astFindParent(decl, !(nodeTypes.AstLambda)) then
				!ERROR_OR_RETURN `errorParsingNext(state, "!%s must be in file scope.", tokValue)`
			elseif decl.names[2] then
				!ERROR_OR_RETURN `errorParsing(state, nameListStartToken+2, "!%s statements must have only one name.", tokValue)`
			elseif decl.types[1] then
				!ERROR_OR_RETURN `errorParsing(state, typesStartToken, "Namespaces don't have a type.")`
			end
			!SET_OR_RETURN `local import = parseImportOrLoad(state, decl)`
			table.insert(decl.values, import) -- @Incomplete: Add this to block.includedNamespaces somewhere somehow?

		-- Normal values.
		else
			if declType == !(DECLARATION_NORMAL) then
				!DO_OR_RETURN `parseExpressionList(state, decl, decl.values)`
			else
				!SET_OR_RETURN `local expr = parseExpression(state, decl)`
				table.insert(decl.values, expr)
			end
		end

	elseif decl.types[2] then
		!ERROR_OR_RETURN `errorParsingAfterLast(state, "Initial values are required if multiple types are specified.")`
	end

	-- Quickly check if there are obviously too many values.
	if #decl.values > #decl.names then
		!ERROR_OR_RETURN `errorParsing(state, decl.values[#decl.names+1].token-1, "There are more values than names being declared.")`
	end

	return decl
end

local function isAtAssignment(state, parentNode)
	local startToken = state.nextToken

	state.soft       = true
	local exprListOk = parseExpressionList(state, parentNode, {})
	state.soft       = false

	if not exprListOk then
		state.nextToken = startToken
		return false
	end

	local tokType, tokValue = consumeNextToken(state)
	if not isTokenAssigning(tokType, tokValue) then
		state.nextToken = startToken
		return false
	end

	state.nextToken = startToken
	return true
end

function _G.parseAssignment(state, parentNode)
	local assignmentStartToken = state.nextToken
	local assignment           = astNewNode(AstAssignment, assignmentStartToken, parentNode)

	!DO_OR_RETURN `parseExpressionList(state, assignment, assignment.targets)`

	for i, expr in ipairs(assignment.targets) do
		if not (
			expr.nodeType == !(nodeTypes.AstIdentifier)
			or (expr.nodeType == !(nodeTypes.AstBinary) and expr.operation == ".")
		) then
			!ERROR_OR_RETURN `errorParsing(state, expr.token, "Expected assignment expression to resolve into a variable or table field.")`
			-- -- Navigate back to the actual error position.
			-- state.nextToken = assignmentStartToken
			-- for i = 1, i-1 do
			-- 	parseExpression(state, assignment)
			-- 	consumeNextToken(state) -- ","
			-- end
			-- !ERROR_OR_RETURN `errorParsingNext(state, "Expected assignment expression to resolve into a variable or table field.")`
		end
	end

	local tokType, tokValue = consumeNextToken(state)
	if not isTokenAssigning(tokType, tokValue) then
		!ERROR_OR_RETURN `errorParsingNext(state, "Expected '='.")`
	end
	assignment.operation = tokValue

	!DO_OR_RETURN `parseExpressionList(state, assignment, assignment.values)`

	-- Quickly check if there are obviously too many values.
	if #assignment.values > #assignment.targets then
		!ERROR_OR_RETURN `errorParsing(state, assignment.values[#assignment.targets+1].token-1, "There are more values than assignment targets.")`
	end

	return assignment
end

-- Add the names to the 'names' array.
-- success = parseNameList( state, parentNode, names [, placeDeclared ] )
function _G.parseNameList(state, parentNode, names, placeDeclared)
	while true do
		local ident = parseIdentifier(state, parentNode, placeDeclared)
		if not ident then  return false  end

		table.insert(names, ident)
		local tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
			consumeNextToken(state)
			-- Continue the loop.
		else
			break
		end
	end

	return true
end

function _G.parseStatementInImperativeScope(state, parentNode)
	local statement = astNewNode(AstStatement, state.nextToken, parentNode)

	local tokType,  tokValue  = peekNextToken(state, 1)
	local tokType2, tokValue2 = peekNextToken(state, 2)
	local tokType3, tokValue3 = peekNextToken(state, 3)
	local tokType4, tokValue4 = peekNextToken(state, 4)
	local token

	if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"local") then
		!SET_OR_RETURN `statement.what = parseDeclaration(state, statement)`
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"global") then
		!ERROR_OR_RETURN `errorParsingNext(state, "Globals can only be declared in file scope.")`

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"return") then
		consumeNextToken(state)

		local returnNode = astNewNode(AstReturn, statement.token, statement)

		--
		-- Note: Considering this following ambigous situation we have to check whether any values should be returned.
		-- As a bonus we also figure if we're even inside a function, though I'm not sure this'll work when we have static code. @Robustness
		--
		--     if x return
		--     func() -- Returned expression, or separate statement after 'if'?
		--
		local lambda = astFindParent(statement, !(nodeTypes.AstLambda))
		if not lambda then
			-- This shouldn't happen as parseStatementInImperativeScope() shouldn't be
			-- called by parseFileScope(), which is the highest top-level thing.
			!ERROR_OR_RETURN `errorParsingNext(state, "Not inside a function.")`
		end

		if lambda.argumentsOut and lambda.argumentsOut[1] then
			!DO_OR_RETURN `parseExpressionList(state, returnNode, returnNode.values)`
		end

		statement.what = returnNode

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"break","continue") then
		consumeNextToken(state)

		local keyword         = tokValue
		local breakOrContinue = astNewNode((keyword == "break" and AstBreak or AstContinue), statement.token, statement)

		tokType, tokValue = peekNextToken(state)

		if tokType == !(TOKEN_IDENTIFIER) then
			local loop = astFindParent(breakOrContinue, !(nodeTypes.AstFor), !(nodeTypes.AstWhile))
			if not loop then
				!ERROR_OR_RETURN `errorParsingNext(state, "Not inside a loop.")`
			end

			repeat
				if loop.nodeType == !(nodeTypes.AstFor) and itemWith1(loop.names, "name", tokValue) then
					!SET_OR_RETURN `breakOrContinue.loopName = parseIdentifier(state, breakOrContinue)`
					break
				end

				loop = astFindParent(loop, !(nodeTypes.AstFor), !(nodeTypes.AstWhile))
			until not loop
		end

		statement.what = breakOrContinue

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"do") then
		consumeNextToken(state)
		!SET_OR_RETURN `statement.what = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, statement)`

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"defer") then
		consumeNextToken(state)

		local defer                = astNewNode(AstDefer, statement.token, statement)
		!SET_OR_RETURN `defer.body = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, defer)`

		statement.what = defer

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"if") and (
		isToken(tokType2,tokValue2, !(TOKEN_DIRECTIVE),"complete")
		or (
			isToken(tokType2,tokValue2, !(TOKEN_IDENTIFIER))
			and isToken(tokType3,tokValue3, !(TOKEN_PUNCTUATION),"==")
			and isToken(tokType4,tokValue4, !(TOKEN_PUNCTUATION),"{")
		)
	) then
		!ERROR_OR_RETURN `errorParsingNext(state, "@Incomplete: if x == {case...}")`

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"if") then
		consumeNextToken(state)

		local ifBranch                      = astNewNode(AstIf, statement.token, statement)
		!SET_OR_RETURN `ifBranch.condition  = parseExpression(state, ifBranch)`
		!SET_OR_RETURN `ifBranch.branchTrue = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, ifBranch)`
		statement.what                      = ifBranch

		while true do
			tokType, tokValue, token = peekNextToken(state)

			if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"elseif") then
				consumeNextToken(state)
				-- Continue.
			else
				break
			end

			local ifBranchElse                      = astNewNode(AstIf, token, ifBranch)
			!SET_OR_RETURN `ifBranchElse.condition  = parseExpression(state, ifBranchElse)`
			!SET_OR_RETURN `ifBranchElse.branchTrue = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, ifBranchElse)`

			ifBranch.branchFalse = ifBranchElse
			ifBranch             = ifBranchElse
		end

		if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"else") then
			consumeNextToken(state)
			!SET_OR_RETURN `ifBranch.branchFalse = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, ifBranch)`
		end

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"while") then
		consumeNextToken(state)

		local whileLoop                     = astNewNode(AstWhile, statement.token, statement)
		!SET_OR_RETURN `whileLoop.condition = parseExpression(state, whileLoop)`
		!SET_OR_RETURN `whileLoop.body      = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, whileLoop)`
		statement.what                      = whileLoop

	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"for") then
		consumeNextToken(state)

		local forStartIndex = state.nextToken
		local forLoop       = astNewNode(AstFor, statement.token, statement)

		local exprListWeMayOrMayNotUse = {}
		!DO_OR_RETURN `parseExpressionList(state, forLoop, exprListWeMayOrMayNotUse)`

		tokType, tokValue = peekNextToken(state)
		local twoParter

		-- FOR_ITERATOR  for v1, ... in iter [, state [, init ] ]
		if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"in") then
			forLoop.forType = !(FOR_ITERATOR)
		-- FOR_SHORT  for v1, ... : obj
		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":") then
			forLoop.forType = !(FOR_SHORT)
			twoParter       = true
		-- FOR_NUMERIC  for start, end [, step ]
		elseif #exprListWeMayOrMayNotUse >= 2 then -- If more than 3 arguments are specified then we'll get an error later.
			forLoop.forType = !(FOR_NUMERIC)
			twoParter       = false
		-- FOR_NUMERIC  for i = start, end [, step ]
		elseif #exprListWeMayOrMayNotUse == 1 and isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"=") then
			forLoop.forType = !(FOR_NUMERIC)
			twoParter       = true
		-- FOR_SHORT  for obj
		elseif #exprListWeMayOrMayNotUse == 1 then
			forLoop.forType = !(FOR_SHORT)
			twoParter       = false
		else
			state.nextToken = forStartIndex
			!ERROR_OR_RETURN `errorParsingNext(state, "Could not determine what kind of 'for' statement this is.")`
		end

		if forLoop.forType == !(FOR_NUMERIC) then
			-- for i = start, end [, step ]
			if twoParter then
				state.nextToken = forStartIndex
				!DO_OR_RETURN `parseNameList(state, forLoop, forLoop.names)`

				assert(#forLoop.names == 1)

				tokType, tokValue = consumeNextToken(state) -- Should eat the '='.
				assert(isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"="))

				!DO_OR_RETURN `parseExpressionList(state, forLoop, forLoop.expressions)`

			-- for start, end [, step ]
			else
				forLoop.expressions = exprListWeMayOrMayNotUse

				-- Is this name generation really necessay? For the other 'for' loop paths we don't generate names (yet).
				local ident         = astNewNode(AstIdentifier, statement.token, forLoop)
				ident.name          = "it"
				ident.placeDeclared = forLoop
				table.insert(forLoop.names, ident)
			end

			if #forLoop.expressions < 2 then
				!ERROR_OR_RETURN `errorParsingAfterLast(state, "Expected 2 or 3 parameters for the numeric 'for' loop.")`

			elseif #forLoop.expressions > 3 then
				!ERROR_OR_RETURN `errorParsing(state, forLoop.expressions[4].token-1, "Expected 2 or 3 parameters for the numeric 'for' loop.")`
			end

		elseif forLoop.forType == !(FOR_SHORT) then
			-- for v1, ... : obj
			if twoParter then
				state.nextToken = forStartIndex
				!DO_OR_RETURN `parseNameList(state, forLoop, forLoop.names)`

				tokType, tokValue = consumeNextToken(state) -- Should eat the ':'.
				assert(isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),":"))

				!DO_OR_RETURN `parseExpressionList(state, forLoop, forLoop.expressions)`

				if forLoop.expressions[2] then
					!ERROR_OR_RETURN `errorParsing(state, forLoop.expressions[2].token-1, "Expected a single parameter for the short-form 'for' loop.")`
				end

				-- @Incomplete: Generate 'itIndex' name for arrays (and more?) if necessary (when types are figured out).

			-- for obj
			else
				forLoop.expressions = exprListWeMayOrMayNotUse
				assert(#forLoop.expressions == 1)

				-- @Incomplete: Generate 'it' and 'itIndex' names for arrays (and more?) if necessary (when types are figured out).
			end

		-- for v1, ... in iter [, state [, init ] ]
		else
			state.nextToken = forStartIndex
			!DO_OR_RETURN `parseNameList(state, forLoop, forLoop.names)`

			tokType, tokValue = consumeNextToken(state) -- Should eat the 'in'.
			assert(isToken(tokType,tokValue, !(TOKEN_KEYWORD),"in"))

			!DO_OR_RETURN `parseExpressionList(state, forLoop, forLoop.expressions)`
		end

		!SET_OR_RETURN `forLoop.body = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, forLoop, true)`
		statement.what               = forLoop

	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import","load") then
		!ERROR_OR_RETURN `errorParsingNext(state, "!import/!load must be in file scope.")`

	elseif isAtAssignment(state, statement) then
		!SET_OR_RETURN `statement.what = parseAssignment(state, statement)`

	elseif tokType == !(TOKEN_IDENTIFIER) and (
			isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"(")
			-- or isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"{")
			-- or tokType2 == !(TOKEN_STRING)
		)
	then
		!SET_OR_RETURN `statement.what = parseCall(state, statement, false)`

	-- Table lookup ending in a function call.
	-- Note: We must detect assignments before this!
	elseif
		(
			tokType == !(TOKEN_IDENTIFIER)
			and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),".")
		)
		or isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
	then
		!SET_OR_RETURN `local expr = parseExpression(state, statement)`

		if not (expr.nodeType == !(nodeTypes.AstCall)) then
			!ERROR_OR_RETURN `errorParsing(state, statement.token, "Expected the statement to end in a function call.")`
		end

		statement.what = expr

	else
		!ERROR_OR_RETURN `errorParsingNext(state, "Unexpected token at the start of a new statement.")`
	end

	tokType, tokValue = peekNextToken(state)
	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),";") then
		consumeNextToken(state)
	end

	return statement
end

function _G.parseBlock(state, parentNode)
	-- Note: We assume the '{' has been consumed already.

	local blockStartToken     = state.nextToken
	local block               = astNewNode(AstBlock, blockStartToken, parentNode)

	local statementStartToken = blockStartToken
	local lastNodeType        = 0

	while true do
		local tokType, tokValue = peekNextToken(state)

		if not tokType then
			!ERROR_OR_RETURN `errorParsing(state, blockStartToken, "Unfinished block.")`

		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"}") then
			consumeNextToken(state)
			break

		elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),";") then
			!ERROR_OR_RETURN `errorParsingNext(state, "Statement is empty.")`

		else
			if isAny(lastNodeType, !(nodeTypes.AstReturn),!(nodeTypes.AstBreak),!(nodeTypes.AstContinue)) then
				local nodeTitle
					=  lastNodeType == !(nodeTypes.AstReturn)   and "Return"
					or lastNodeType == !(nodeTypes.AstBreak)    and "Break"
					or lastNodeType == !(nodeTypes.AstContinue) and "Continue"
					or assert(lastNodeType)

				!ERROR_OR_RETURN `errorParsing(state, statementStartToken, "%s statements must be at the end of the scope.", nodeTitle)`
			end

			statementStartToken             = state.nextToken
			!SET_OR_RETURN `local statement = parseStatementInImperativeScope(state, block)`

			table.insert(block, statement)
			lastNodeType = statement.what.nodeType

			if lastNodeType == !(nodeTypes.AstDeclaration) then
				local decl = statement.what
				table.insert(block.declarations, decl) -- Is this declarations array that useful?
			end
		end
	end

	return block
end

-- node = parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement( state, parentNode [, requireBlock=false ] )
function _G.parseBlockOrScopedStatementOrUnwrappedNonPolutingStatement(state, parentNode, requireBlock)
	local tokType, tokValue = peekNextToken(state)

	if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		consumeNextToken(state)
		return parseBlock(state, parentNode) -- May return nil.
	end

	!SET_OR_RETURN `local statement = parseStatementInImperativeScope(state, parentNode)`

	-- We only need to wrap declarations and 'for' bodies in a block (I think).
	if requireBlock or isAny(statement.what.nodeType, !(nodeTypes.AstDeclaration),!(nodeTypes.AstReturn),!(nodeTypes.AstBreak),!(nodeTypes.AstContinue)) then
		local block = astNewNode(AstBlock, statement.token, parentNode)
		table.insert(block, statement)

		if statement.what.nodeType == !(nodeTypes.AstDeclaration) then
			local decl = statement.what
			table.insert(block.declarations, decl) -- Is this declarations array that useful?
		end

		statement.parent = block
		return block
	end

	-- Is it ok to strip the statement like this? @Robustness?
	statement.what.parent = parentNode
	return statement.what
end

function _G.parseImportOrLoad(state, parentNode)
	local import = astNewNode(AstImport, state.nextToken, parentNode)

	local tokType, tokValue = consumeNextToken(state)
	if isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import") then
		-- void
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"load") then
		import.isLoad = true
	else
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected '!load' or '!import'.")`
	end

	local tokType, tokValue = consumeNextToken(state)
	if tokType ~= !(TOKEN_STRING) then
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected a string.")`
	end
	import.name = tokValue

	return import
end

function _G.parseFileScope(state, path, parentNode)
	local fileScope = astNewNode(AstFileScope, state.nextToken, parentNode)
	fileScope.path  = path

	while true do
		local tokType, tokValue = peekNextToken(state)

		if not tokType then
			break

		elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"local","global") then
			!SET_OR_RETURN `local decl = parseDeclaration(state, fileScope)`
			table.insert(fileScope.declarations, decl)

		elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"import","load") then
			!SET_OR_RETURN `local import = parseImportOrLoad(state, fileScope)`
			table.insert(fileScope.includedNamespaces, import)

			tokType, tokValue = peekNextToken(state)
			if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),";") then
				consumeNextToken(state)
			end

		elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"export","use") then
			!ERROR_OR_RETURN `errorParsingNext(state, "@Incomplete: Handle '%s'.", tokValue)`

		else
			!ERROR_OR_RETURN `errorParsingNext(state, "Expected file level declaration.")`
		end
	end

	return fileScope
end

-- call = parseCall( state, parentNode, couldBeType [, callee=theFollowingIdentifier, isMethod=false ] )
function _G.parseCall(state, parentNode, couldBeType, callee, isMethod)
	assert(type(couldBeType) == "boolean")

	if not callee then
		!SET_OR_RETURN `callee = parseIdentifier(state, parentNode)` -- We'll update the parent later.
	end

	isMethod = isMethod or false
	local call

	while true do
		local tokType, tokValue, token = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingLast(state, "Expected '('.")`
		end

		call              = astNewNode(AstCall, token, parentNode)
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			consumeNextToken(state)

			-- Should struct arguments be able to have default values, allowing foo()
			-- to possibly be a type?
			couldBeType = false

		else
			!DO_OR_RETURN `parseExpressionList(state, call, call.arguments)`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')' or ','.")`
			end
		end

		call.couldBeTypeWithParameters = couldBeType

		callee.parent = call
		call.callee   = callee
		call.isMethod = isMethod

		tokType, tokValue = peekNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then  break  end

		call.couldBeTypeWithParameters = false
		callee   = call
		isMethod = false
	end

	return call
end



-- expression = parseExpression( state, parentNode [, minOperatorPrecedence ] )
function _G.parseExpression(state, parentNode, minOpPrecedence)
	-- @Robustness: Check that parents are set correctly everywhere in here.

	minOpPrecedence = minOpPrecedence or 0

	local tokType,  tokValue, exprStartToken = consumeNextToken(state)
	local tokType2, tokValue2                = peekNextToken(state, 1)
	local tokType3, tokValue3                = peekNextToken(state, 2)
	local expr, token

	-- Function call or type with parameters.
	--
	-- Note: We also detect function calls later by the binary operations.
	-- The difference is that here we may have a type.
	--
	if
		tokType == !(TOKEN_IDENTIFIER)
		and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"(")
	then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseCall(state, parentNode, true)`

	-- Built-in type.
	elseif isTokenBuiltinType(tokType, tokValue) then
		local identType    = astNewNode(AstType, exprStartToken, parentNode)
		identType.typeName = tokValue
		expr               = identType

		-- @Incomplete: Check if there's a '(' after this and give error early.

	-- Identifier or literal.
	elseif tokType == !(TOKEN_IDENTIFIER) or isTokenLiteral(tokType, tokValue) then
		if tokType == !(TOKEN_IDENTIFIER) then
			local ident = astNewNode(AstIdentifier, exprStartToken, parentNode)
			ident.name  = tokValue
			expr        = ident

		elseif tokType == !(TOKEN_KEYWORD) then
			local literal = astNewNode(AstLiteral, exprStartToken, parentNode)

			if tokValue == "nil" then
				literal.literalType = !(LITERAL_NIL)
				literal.value       = nil
			else
				literal.literalType = !(LITERAL_BOOLEAN)
				literal.value       = tokValue == "true"
			end

			expr = literal

		else
			local literal       = astNewNode(AstLiteral, exprStartToken, parentNode)
			literal.literalType = TOKEN_TYPE_TO_LITERAL_TYPE[tokType]
			literal.value       = tokValue
			expr                = literal
		end

	-- Vararg.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"...") then
		expr = astNewNode(AstVararg, exprStartToken, parentNode)

	-- Table constructor.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
		!SET_OR_RETURN `expr = parseTable(state, parentNode)`

	-- Unary operation.
	elseif
		isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"+","-","#") or
		isToken(tokType,tokValue, !(TOKEN_KEYWORD),"not")
	then
		local unaryOp                      = astNewNode(AstUnary, exprStartToken, parentNode)
		unaryOp.operation                  = tokValue
		!SET_OR_RETURN `unaryOp.expression = parseExpression(state, unaryOp, OPERATOR_PRECEDENCE.unary)`
		expr                               = unaryOp

	-- Function signature (type) or lambda.
	--
	--     inArgs [-> outArgs] [body]
	--
	--     inArgs  = ( [ inArg1, ... ] )
	--     inArg   = name1 [, ... ] : type [ = defaultValue ]
	--     outArgs = void
	--     outArgs = type1 [, ... ]
	--     outArgs = ( outArg1 [, ... ] )
	--     outArg  = name1 [, ... ] : type
	--     body    = { ... }
	--
	elseif
		isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
		and (
			isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),")")
			or (
				(
					isToken(tokType2,tokValue2, !(TOKEN_IDENTIFIER))
					or isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"...")
				)
				and isToken(tokType3,tokValue3, !(TOKEN_PUNCTUATION),":",",")
			)
		)
	then
		local lambda = astNewNode(AstLambda, exprStartToken, parentNode)

		-- In args.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			consumeNextToken(state)

		else
			!SET_OR_RETURN `lambda.argumentsIn = parseArguments(state, lambda, true, lambda)`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
				!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
			end
		end

		-- Out args.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"->") then
			consumeNextToken(state)

			tokType, tokValue = peekNextToken(state)

			-- () -> void
			if isToken(tokType,tokValue, !(TOKEN_KEYWORD),"void") then
				consumeNextToken(state)

				tokType, tokValue = peekNextToken(state)
				if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
					!ERROR_OR_RETURN `errorParsingNext(state, "Argument list with 'void' cannot have other arguments.")`
				end

			-- () -> (name:type, ...)
			elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
				consumeNextToken(state)

				!SET_OR_RETURN `lambda.argumentsOut = parseArguments(state, lambda, false, lambda)`

				tokType, tokValue = consumeNextToken(state)
				if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
					!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
				end

			-- () -> type, ...
			else
				local args          = astNewNode(AstArguments, state.nextToken, lambda)
				lambda.argumentsOut = args

				for groupN = 1, math.huge do
					local arg = astNewNode(AstArgument, state.nextToken, args)
					arg.group = groupN
					table.insert(args, arg)

					local decl      = astNewNode(AstDeclaration, arg.token, arg)
					arg.declaration = decl
					!DO_OR_RETURN `parsePipeSeparatedTypes(state, decl, decl.types)`

					local ident   = astNewNode(AstIdentifier, decl.token, parentNode)
					ident.name    = "__UNNAMED_"..groupN.."__"
					decl.names[1] = ident

					tokType, tokValue = peekNextToken(state)

					if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),",") then
						consumeNextToken(state)
					else
						break
					end
				end
			end
		end

		-- Body.
		tokType, tokValue = peekNextToken(state)

		if isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"{") then
			consumeNextToken(state)

			!SET_OR_RETURN `lambda.body = parseBlock(state, lambda)`
			expr                        = lambda

		else
			local identType             = astNewNode(AstType, lambda.token, lambda)
			identType.isUserType        = true
			identType.functionSignature = lambda
			expr                        = identType
		end

	-- Parenthesis.
	elseif isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
		!SET_OR_RETURN `expr = parseExpression(state, parentNode)`

		if isAny(expr.nodeType, !(nodeTypes.AstCall), !(nodeTypes.AstVararg)) then
			-- This is so we know whether to adjust the return values to one or not in certain situations.
			-- Note: Functions with a return argument after the first one marked as #must cannot have their
			-- return arguments adjusted to one.
			expr.surroundedByParenthesis = true
		end

		tokType, tokValue = consumeNextToken(state)

		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

	-- Cast.
	elseif isToken(tokType,tokValue, !(TOKEN_KEYWORD),"cast") then
		tokType, tokValue, token = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected '('.")`
		end

		local cast                      = astNewNode(AstCast, token-1, parentNode)
		!SET_OR_RETURN `cast.targetType = parseType(state, cast)`

		tokType, tokValue = consumeNextToken(state)
		if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),")") then
			!ERROR_OR_RETURN `errorParsingAfterPrevious(state, "Expected ')'.")`
		end

		!SET_OR_RETURN `cast.expression = parseExpression(state, cast, math.huge)` -- @Incomplete: Give casting an operator precedence.
		expr                            = cast

	-- Type.
	elseif isToken(tokType,tokValue, !(TOKEN_DIRECTIVE),"type") then
		-- Note: parseType() does not recognize !type which is why you can't put
		-- the directive anywhere a type is expected. Should we change this?
		!SET_OR_RETURN `expr = parseType(state, parentNode)`

	elseif
		isToken(tokType,tokValue, !(TOKEN_KEYWORD),"typeOf") or
		isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[")
	then
		putBackLastToken(state)
		!SET_OR_RETURN `expr = parseType(state, parentNode)`

	else
		!ERROR_OR_RETURN `errorParsingLast(state, "Expected a value.")`
	end

	-- Binary operations.
	local nextCanBeMethodCall = false

	while true do
		tokType,  tokValue, token = peekNextToken(state, 1)
		tokType2, tokValue2       = peekNextToken(state, 2)

		local thisCanBeMethodCall = nextCanBeMethodCall
		nextCanBeMethodCall       = false

		if not tokType then
			break

		-- Arithmetic opration, comparison or string concatination.
		-- @Incomplete: Combine string concatinations in some way?
		elseif (
			isToken(tokType,tokValue, !(TOKEN_KEYWORD),"and","or")
			or isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),
				"+","-","*","/","//","^","%","<",">","<=",">=","==","~=",".."
			)
		) and OPERATOR_PRECEDENCE[tokValue] >= minOpPrecedence then
			consumeNextToken(state)

			local binOp                 = astNewNode(AstBinary, token, parentNode)
			binOp.operation             = tokValue
			binOp.left                  = expr
			!SET_OR_RETURN `binOp.right = parseExpression(state, binOp, OPERATOR_PRECEDENCE[tokValue])`
			expr.parent                 = binOp
			expr                        = binOp

		-- Table lookup or similar using '.'.
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),".")
			and OPERATOR_PRECEDENCE["."] > minOpPrecedence -- Note: Not using >= here.
		then
			consumeNextToken(state)

			local binOp     = astNewNode(AstBinary, token, parentNode)
			binOp.operation = "."

			tokType, tokValue, token = consumeNextToken(state)
			if tokType ~= !(TOKEN_IDENTIFIER) then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected an identifier.")`
			end

			local literal       = astNewNode(AstLiteral, token, binOp)
			literal.literalType = !(LITERAL_STRING)
			literal.value       = tokValue

			binOp.left          = expr
			binOp.right         = literal

			expr.parent         = binOp
			expr                = binOp

			nextCanBeMethodCall = true

		-- Table lookup or similar using '['.
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"[")
			and OPERATOR_PRECEDENCE["."] > minOpPrecedence -- Note: Not using >= here.
		then
			consumeNextToken(state)

			local binOp                 = astNewNode(AstBinary, token, parentNode)
			binOp.operation             = "."
			binOp.left                  = expr
			!SET_OR_RETURN `binOp.right = parseExpression(state, binOp, OPERATOR_PRECEDENCE[tokValue])`

			tokType, tokValue = consumeNextToken(state)
			if not isToken(tokType,tokValue, !(TOKEN_PUNCTUATION), "]") then
				!ERROR_OR_RETURN `errorParsingLast(state, "Expected ']'.")`
			end

			expr.parent = binOp
			expr        = binOp

		-- Function call.
		elseif
			isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"(")
			and OPERATOR_PRECEDENCE.call >= minOpPrecedence
		then
			!SET_OR_RETURN `expr = parseCall(state, parentNode, false, expr, false)`

		-- Method call.
		elseif
			(
				isToken(tokType,tokValue, !(TOKEN_PUNCTUATION),"!")
				and isToken(tokType2,tokValue2, !(TOKEN_PUNCTUATION),"(")
			)
			and OPERATOR_PRECEDENCE.call >= minOpPrecedence
		then
			tokType, tokValue = peekLastToken(state)

			if not isToken(tokType,tokValue, !(TOKEN_IDENTIFIER)) then
				!ERROR_OR_RETURN `errorParsingNext(state, "Expected a method name before this.")`
			elseif not thisCanBeMethodCall then
				putBackLastToken(state)
				!ERROR_OR_RETURN `errorParsingNext(state, "Expected an object to call a method on.")`
			end

			consumeNextToken(state)
			!SET_OR_RETURN `expr = parseCall(state, parentNode, false, expr, true)`

		else
			break
		end
	end

	return expr
end



-- tokenType, tokenValue, tokenIndex = consumeNextToken( parseState )
function _G.consumeNextToken(state)
	local i         = state.nextToken
	state.nextToken = i+1
	local tokType, tokValue = getToken(state.tokens, i)
	return tokType, tokValue, i
end

-- tokenType, tokenValue = peekNextToken( state [, steps=1 ] )
function _G.peekNextToken(state, steps)
	steps   = steps or 1
	local i = state.nextToken+steps-1
	return getToken(state.tokens, i)
end

function _G.peekLastToken(state)
	return getToken(state.tokens, state.nextToken-1)
end

function _G.putBackLastToken(state)
	state.nextToken = state.nextToken-1
	assert(state.nextToken >= 1)
end



-- errorParsing( parseState, tokenIndex, formatString, ... )
function _G.errorParsing(state, i, s, ...)
	local tokens = state.tokens

	local path
		=  tokens.file[i]
		or tokens.file[1] -- Not great, but better than crashing.
		or errorInternal(2, "No tokens.")

	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)

	local ptr
		=  tokens.position1[i]
		or i <= 1 and 1
		or tokens.count > 0 and tokens.position2[tokens.count]+1
		or #buffer

	errorInFile(buffer, path, ptr, "Parser", s, ...)
end

-- errorParsingAfter( parseState, tokenIndex, formatString, ... )
function _G.errorParsingAfter(state, i, s, ...)
	local tokens = state.tokens

	local path
		=  tokens.file[i]
		or tokens.file[1] -- Not great, but better than crashing.
		or errorInternal(2, "No tokens.")

	local buffer = state.fileBuffers[path] or errorInternal("No file buffer for '%s'.", path)

	local ptr
		=  tokens.position2[i] and tokens.position2[i]+1
		or i <= 1 and 1
		or tokens.count > 0 and tokens.position2[tokens.count]+1
		or #buffer

	errorInFile(buffer, path, ptr, "Parser", s, ...)
end

function _G.errorParsingLast(state, ...)
	errorParsing(state, state.nextToken-1, ...)
end
function _G.errorParsingNext(state, ...)
	errorParsing(state, state.nextToken, ...)
end

function _G.errorParsingAfterPrevious(state, ...)
	errorParsingAfter(state, state.nextToken-2, ...)
end
function _G.errorParsingAfterLast(state, ...)
	errorParsingAfter(state, state.nextToken-1, ...)
end



-- astPrint( node [, fileToPrintTo=io.stdout ] )
do
	local file
	local printNode -- Forward declaration.

	local function write(...)
		file:write(...)
	end

	local function printNodeList(list, indent, printed, keyPrefix)
		for i, node in ipairs(list) do
			printNode(node, indent, printed, (keyPrefix and keyPrefix..i))
		end
	end

	function printNode(node, indent, printed, keyName)
		!local BLOCK_START = PRINT_NODE_BRACKETS and `write(" {")`             or ``
		!local BLOCK_END   = PRINT_NODE_BRACKETS and `write(indentStr, "}\n")` or ``

		local indentStr = ("\t"):rep(indent)

		write(indentStr)
		if keyName then  write(keyName, " ")  end
		write(AST_NODE_TYPE_NAMES[node.nodeType] or "?")
		write(" @", node.s)
		if node.parent then  write(" ^", node.parent.s)  end

		if printed[node] then
			write("  !!! ERROR: RECURSION DETECTED !!!\n")
		else
			printed[node] = true

			if node.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = node
				write(" (", ident.name, ")\n")

			elseif node.nodeType == !(nodeTypes.AstBinary) then
				local binOp = node
				write(" (", binOp.operation, ")")
				!!(BLOCK_START)
				write("\n")
				if binOp.left  then  printNode(binOp.left,  indent+1, printed)  end
				write(indentStr, "\top ", binOp.operation, "\n")
				if binOp.right then  printNode(binOp.right, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstUnary) then
				local unaryOp = node
				write(" (", unaryOp.operation, ")")
				!!(BLOCK_START)
				write("\n")
				if unaryOp.expression then  printNode(unaryOp.expression, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstDeclaration) then
				local decl = node
				if decl.isConstant and not decl.isLocal then
					write(" (global const)")
				elseif decl.isConstant then
					write(" (const)")
				elseif not decl.isLocal then
					write(" (global)")
				end
				!!(BLOCK_START)
				write("\n")
				printNodeList(decl.names,  indent+1, printed, "NAME")
				printNodeList(decl.types,  indent+1, printed, "TYPE")
				printNodeList(decl.values, indent+1, printed, "VAL")
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstTable) then
				local tableNode = node
				!!(BLOCK_START)
				write("\n")
				for i, tableField in ipairs(tableNode) do
					if tableField.key   then  printNode(tableField.key,   indent+1, printed, i.."K")  end
					if tableField.value then  printNode(tableField.value, indent+1, printed, i.."V")  end
				end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstCall) then
				local call = node
				assert(not (call.couldBeTypeWithParameters and call.isMethod))
				if call.couldBeTypeWithParameters then  write(" (couldBeType)")    end
				if call.isMethod                  then  write(" (method)")         end
				if call.surroundedByParenthesis   then  write(" (adjustArgsTo1)")  end
				!!(BLOCK_START)
				write("\n")
				if call.callee then  printNode(call.callee, indent+1, printed)  end
				printNodeList(call.arguments, indent+1, printed, "ARG")
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstLambda) then
				local lambda = node
				!!(BLOCK_START)
				write("\n")
				if lambda.argumentsIn then
					printNode(lambda.argumentsIn, indent+1, printed, "IN")
					-- printNodeList(lambda.argumentsIn, indent+1, printed, "IN")
				end
				if lambda.argumentsOut then
					printNode(lambda.argumentsOut, indent+1, printed, "OUT")
					-- printNodeList(lambda.argumentsOut, indent+1, printed, "OUT")
				end
				if lambda.body then  printNode(lambda.body, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstArguments) then
				local args = node
				!!(BLOCK_START)
				write("\n")
				printNodeList(args, indent+1, printed)
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstArgument) then
				local arg = node
				!!(BLOCK_START)
				write("\n")
				if arg.declaration then  printNode(arg.declaration, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstBlock) then
				-- @Incomplete: We don't print blocks.declarations as they already exist among the statements.
				local block = node
				!!(BLOCK_START)
				write("\n")
				printNodeList(block, indent+1, printed)
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstStatement) then
				local statement = node
				!!(BLOCK_START)
				write("\n")
				if statement.what then  printNode(statement.what, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstType) then
				local identType = node
				if identType.typeName ~= "" then  write(" (", identType.typeName, ")")  end
				!!(BLOCK_START)
				write("\n")
				if identType.functionSignature then
					printNode(identType.functionSignature, indent+1, printed)
				elseif identType.arguments then
					printNodeList(identType.arguments, indent+1, printed, "ARG")
				end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstTypeOf) then
				local typeOf = node
				!!(BLOCK_START)
				write("\n")
				if typeOf.expression then  printNode(typeOf.expression, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstAssignment) then
				local assignment = node
				write(" (", assignment.operation, ")")
				!!(BLOCK_START)
				write("\n")
				printNodeList(assignment.targets, indent+1, printed)
				write(indentStr, "\top ", assignment.operation, "\n")
				printNodeList(assignment.values, indent+1, printed)
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstCast) then
				local cast = node
				!!(BLOCK_START)
				write("\n")
				if cast.targetType then  printNode(cast.targetType, indent+1, printed)  end
				if cast.expression then  printNode(cast.expression, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstIf) then
				local ifBranch = node
				!!(BLOCK_START)
				write("\n")
				if ifBranch.condition   then  printNode(ifBranch.condition,   indent+1, printed)           end
				if ifBranch.branchTrue  then  printNode(ifBranch.branchTrue,  indent+1, printed, "TRUE")   end
				if ifBranch.branchFalse then  printNode(ifBranch.branchFalse, indent+1, printed, "FALSE")  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstWhile) then
				local whileLoop = node
				!!(BLOCK_START)
				write("\n")
				if whileLoop.condition then  printNode(whileLoop.condition, indent+1, printed)  end
				if whileLoop.body      then  printNode(whileLoop.body,      indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstFor) then
				local forLoop = node
				write(" (", FOR_TITLES[forLoop.forType], ")")
				!!(BLOCK_START)
				write("\n")
				printNodeList(forLoop.names,       indent+1, printed, "NAME")
				printNodeList(forLoop.expressions, indent+1, printed, "EXPR")
				if forLoop.body then  printNode(forLoop.body, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstReturn) then
				local returnNode = node
				!!(BLOCK_START)
				write("\n")
				printNodeList(returnNode.values, indent+1, printed)
				!!(BLOCK_END)

			elseif isAny(node.nodeType, !(nodeTypes.AstBreak), !(nodeTypes.AstContinue)) then
				local breakOrContinue = node
				if breakOrContinue.loopName then  write(" (", breakOrContinue.loopName.name, ")")  end
				write("\n")

			elseif node.nodeType == !(nodeTypes.AstDefer) then
				local defer = node
				!!(BLOCK_START)
				write("\n")
				if defer.body then  printNode(defer.body, indent+1, printed)  end
				!!(BLOCK_END)

			elseif node.nodeType == !(nodeTypes.AstImport) then
				local import = node
				write(" (", (import.isLoad and "load " or "import "), import.name, ")\n")

			elseif node.nodeType == !(nodeTypes.AstVararg) then
				local vararg = node
				if vararg.surroundedByParenthesis then  write(" (adjustTo1)")  end
				write("\n")

			elseif node.nodeType == !(nodeTypes.AstLiteral) then
				local literal = node

				if literal.literalType == !(LITERAL_ARRAY) then
					write(" (array)")
					!!(BLOCK_START)
					write("\n")
					printNode(literal.value, indent+1, printed)
					!!(BLOCK_END)

				else
					write(" (")

					if isAny(literal.literalType, !(LITERAL_BOOLEAN),!(LITERAL_NIL)) then
						write(tostring(literal.value))

					else
						!local MAX_CHARS = 100
						local vStr = tostring(literal.value):sub(1, !(MAX_CHARS))

						vStr = vStr:gsub(".", function(c)
							local byte = c:byte()
							return
								byte == !(("\n"):byte())   and "{NL}"  or
								byte == !(("\r"):byte())   and "{CR}"  or
								byte == !(("\t"):byte())   and "{TAB}" or
								byte >= 32 and byte <= 126 and c       or -- Printable ASCII characters.
								"?"
						end)

						write(LITERAL_TITLES[literal.literalType])

						if literal.literalType == !(LITERAL_STRING) then
							write("(", #literal.value, ")")
						end

						if vStr ~= "" then  write(": ", vStr:sub(1, !(MAX_CHARS)))  end
					end

					write(")\n")
				end

			elseif node.declarations then
				if node.nodeType == !(nodeTypes.AstFileScope) then
					local fileScope = node
					write(" (", fileScope.path, ")")
				end

				!!(BLOCK_START)
				write("\n")
				if node.nodeType == !(nodeTypes.AstStruct) and node.arguments then
					printNodeList(node.arguments, indent+1, printed)
				end
				printNodeList(node.includedNamespaces, indent+1, printed)
				printNodeList(node.declarations,       indent+1, printed)
				!!(BLOCK_END)

			else
				write("\n")
			end
		end
	end

	function _G.astPrint(node, _file)
		file = _file or io.stdout
		printNode(node, 0, {})
	end
end



-- parent = astFindParent( node, nodeType1, ... )
function _G.astFindParent(node, ...)
	while true do
		node = node.parent
		if not node then  return nil  end

		if isAny(node.nodeType, ...) then  return node  end
	end
end


