#!/bin/sh
_=[[
exec lua "$0" "$@"
]]
--[[============================================================
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--=  Language points:
--=  - Strict types (as far as Lua allows).
--=  - In file/declarative scopes, order of things doesn't matter.
--=  - No name shadowing.
--=
--============================================================]]

local compilationStartTime = os.clock()

io.stdout:setvbuf("no") -- Note: This slows down printAst().
io.stderr:setvbuf("no")



!-- We want the resulting Glóa compiler to be a single file, so we use @insert instead of requiring modules here.
do !(do) @insert "preprocessorStuffAndGlobals.luapart" !(end) end
do !(do) @insert "functions.luapart" !(end) end
do !(do) @insert "lexer.luapart"     !(end) end
do !(do) @insert "parser.luapart"    !(end) end



-- Parse arguments.
local function printHelpAndExit()
	print("Glóa")
	print()
	print("Synopsis:")
	print("    lua gloa.lua [options] myProgram.gloa [myOtherProgram.gloa ...]")
	print()
	print("Options:")
	print("    --help    Display this help.")
	print("    --nogc    Disable garbage collection during compilation. This may decrease compilation time.")
	print("    --silent  Only print errors to the console.")
	print("    --        Stop parsing options.")
	print()
	exit(0)
end

local args = {...}
if not args[1] then  printHelpAndExit()  end

local parseOptions   = true
local pathsToCompile = {}
local disableGc      = false
local silent         = false
local i              = 1

while args[i] do
	local arg = args[i]

	if not (parseOptions and arg:find"^%-") then
		table.insert(pathsToCompile, arg)
		i = i+1

	elseif arg == "--" then
		parseOptions = false
		i            = i+1

	elseif arg == "--help" or arg == "-help" or arg == "-?" or arg == "/help" or arg == "/?" then
		printHelpAndExit()

	elseif arg == "--nogc" then
		disableGc = true
		i = i+1

	elseif arg == "--silent" then
		silent = true
		i = i+1

	else
		errorLine(nil, "Unknown option '%s'.", arg)
	end
end



!if DEBUG then
	print(os.date"%Y-%m-%d %H:%M:%S")
!else
	if not silent then
		print()
		print("-------- Glóa --------")
		print('Args:  "'..table.concat(args, '" "')..'"')
		print("Files: "..table.concat(pathsToCompile, ", "))
		print(os.date"Date:  %Y-%m-%d %H:%M:%S")
		if disableGc then  print("Garbage collection disabled.")  end
		print()
	end
!end

if disableGc then  collectgarbage("stop")  end

local duplicates = {}
for _, path in ipairs(pathsToCompile) do
	if duplicates[path] then
		errorLine(nil, "Duplicate path in arguments: %s", path)
	end
	duplicates[path] = true
end

if not pathsToCompile[1] then
	errorLine(nil, "No files to compile.")
end



-- Tokenize file.
-- @Incomplete: Handle multiple files to compile.
if pathsToCompile[2] then
	errorLine(nil, "Can only compile one file at a time right now. (%d files were given.)", #pathsToCompile)
end

local path = pathsToCompile[1]
local s    = assert(getFileContents(path, true))

if not silent then  print("Compiling "..path:gsub("^.*/", ""))  end

s = s:gsub("\r\n?", "\n") -- Normalize line endings.  @Robustness: Handle the uncommon occurrence of \n\r.

local tokens = tokenize(s, path)



-- Quickly check for stray/unmatched brackets.
-- Note: Sometimes an error message here isn't very helpful, so we sometimes continue with parsing despite getting an error here.

local BRACKETS            = {["("]=")", ["{"]="}", ["["]="]"}
local bracketTokenIndices = {}

for i = 1, tokens.count do
	if isToken(tokens.type[i],tokens.value[i], !(TOKEN_TYPE_PUNCTUATION),"(","{","[") then
		table.insert(bracketTokenIndices, i)

	elseif isToken(tokens.type[i],tokens.value[i], !(TOKEN_TYPE_PUNCTUATION),")","}","]") then
		local iStart   = table.remove(bracketTokenIndices)
		local expected = BRACKETS[tokens.value[iStart]]

		if not iStart then
			reportMessageInFile(s, path, tokens.position1[i], "Error", "BracketChecker", "Stray bracket.")
			bracketTokenIndices[1] = nil
			break

		elseif tokens.value[i] ~= expected then
			reportMessageInFile(s, path, tokens.position1[i],      "Error", "BracketChecker", "Expected '%s'.", expected)
			reportMessageInFile(s, path, tokens.position1[iStart], "Info",  "BracketChecker", "... here is the unmatched bracket.")
			exitFailure()
			-- bracketTokenIndices[1] = nil
			-- break
		end
	end
end

if bracketTokenIndices[1] then
	local i = bracketTokenIndices[1]
	errorInFile(s, path, tokens.position1[i], "BracketChecker", "Missing end bracket.", BRACKETS[tokens.value[i]])
	-- reportMessageInFile(s, path, tokens.position1[i], "Error", "BracketChecker", "Missing end bracket.", BRACKETS[tokens.value[i]])
end



-- Parse!
local state             = ParseState()
state.fileBuffers[path] = s
state.tokens            = tokens

local topNode = parseFileScope(state, path)

if peekNextToken(state) then
	errorParsingNext(state, "Expected the end of the file.")
end



-- All done!

!if DEBUG then
	printf("Compilation completed in %.3f seconds", os.clock()-compilationStartTime)
	printAst(topNode)--, io.stderr)
!else
	if not silent then
		printf("Compilation completed in %.3f seconds", os.clock()-compilationStartTime)
		if disableGc then
			printf("Memory usage: %d bytes", collectgarbage("count")*1024)
		end
		print()
	end
!end

exit()


