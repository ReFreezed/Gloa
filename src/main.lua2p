#!/bin/sh
_=[[
exec lua "$0" "$@"
]] and nil
--[[============================================================
--=
--=  Glóa compiler
--=  by Marcus 'ReFreezed' Thunström
--=
--=  Note: The compiler (this file) is preprocessed. The original
--=  source can be found at https://github.com/ReFreezed/Gloa
--=
--=  Language points:
--=  - Strong static type system.
--=  - Compile-time execution (eventually).
--=  - The order of declarations doesn't matter in non-imperative scopes. (No forward declarations needed.)
--=
--============================================================]]
!(
local VERSION = "0.1.0"

local HELP_TEXT = [[
Synopsis:
    lua gloa.lua [compilerOptions] myProgram.gloa [myOtherProgram.gloa ...] [-- metaprogramArgument1 ...]

Options:
    --debug    Output debug information into compiled program.
    --help     Display this help.
    --nogc     Disable garbage collection during compilation. This may decrease compilation time.
    --nostrip  Disable automatic removal of dead code.
    --silent   Disable output to stdout. (Errors and warnings are still printed to stderr.)
    --         Start of arguments for metaprogram.]]
)

local args = {...}

local defaultGlobals = {}
for k, v in pairs(_G) do
	defaultGlobals[k] = v
end
_G.DEFAULT_GLOBALS = defaultGlobals

xpcall(function()
	local timeStartInitial = os.clock()

	!if DEBUG then
		-- This fixes a Sublime Text 2 stdout/stderr desync in build system results. Sigh... :SublimeText2Desync
		io.stdout = io.stderr
		io.output(io.stdout)

		io.stdout:setvbuf("no") -- Note: This slows down all printing.
	!end



	!-- We want the resulting Glóa compiler to be a single file, so we use @insert instead of requiring modules here.
	do !(do) @insert "preprocessorStuffAndGlobals.luapart" !(end) end
	do !(do) @insert "functions.luapart"     !(end) end
	do !(do) @insert "lexer.luapart"         !(end) end
	do !(do) @insert "parser.luapart"        !(end) end
	do !(do) @insert "pipes.luapart"         !(end) end
	do !(do) @insert "typer.luapart"         !(end) end
	do !(do) @insert "bytecode.luapart"      !(end) end -- @Cleanup: Rename to something better.
	do !(do) @insert "runner.luapart"        !(end) end
	do !(do) @insert "programWriter.luapart" !(end) end



	-- Parse arguments.
	local pathsToCompile    = {}
	local disableGc         = false
	local silent            = false
	local outputDebugInfo   = false
	local keepDeadCode      = false
	_G.compilerArguments    = {}
	_G.metaprogramArguments = {}

	!if DEBUG then
	_G.debug_onlyParse      = false
	_G.debug_onlyInferTypes = false
	!end

	do
		local function printHelpAndExit()
			print(!("Gloa v"..VERSION..os.date" (built %Y-%m-%d)")) -- No "Glóa" because we don't know the code page. :(
			print()
			print(!(HELP_TEXT))
			print()
			exit(0)
		end

		if not args[1] then  printHelpAndExit()  end

		local forCompiler = true
		local i           = 1

		while args[i] do
			local arg = args[i]

			if not forCompiler then
				table.insert(metaprogramArguments, arg)
				i = i+1
			elseif arg == "--" then
				forCompiler = false
				i           = i+1
			elseif not arg:find"^%-" then
				local path = arg:gsub("\\", "/")
				table.insert(pathsToCompile,    path)
				table.insert(compilerArguments, path)
				i = i+1

			elseif arg == "--help" or arg == "-help" or arg == "-?" or arg == "/help" or arg == "/?" then
				printHelpAndExit()
			elseif arg == "--nogc" then
				disableGc = true
				table.insert(compilerArguments, arg)
				i = i+1
			elseif arg == "--silent" then
				silent = true
				table.insert(compilerArguments, arg)
				i = i+1
			elseif arg == "--debug" then
				outputDebugInfo = true
				table.insert(compilerArguments, arg)
				i = i+1
			elseif arg == "--nostrip" then
				keepDeadCode = true
				table.insert(compilerArguments, arg)
				i = i+1

			!if DEBUG then
			elseif arg == "--debug:onlyparse" then
				_G.debug_onlyParse = true
				table.insert(compilerArguments, arg)
				i = i+1
			elseif arg == "--debug:onlyinfer" then
				_G.debug_onlyInferTypes = true
				table.insert(compilerArguments, arg)
				i = i+1
			!end

			else
				errorLine(nil, "Unknown option '%s'.", arg)
			end
		end
	end



	!if DEBUG then
		print(os.date"%Y-%m-%d %H:%M:%S")
	!else
		if not silent then
			print()
			print("-------- Gloa --------")
			print('Args:  "'..table.concat(args, '" "')..'"')
			print("Files: "..table.concat(pathsToCompile, ", "))
			print(os.date"Date:  %Y-%m-%d %H:%M:%S")
			if disableGc then  print("Garbage collection disabled.")  end
			print()
		end
	!end

	if disableGc then  collectgarbage("stop")  end

	do
		local duplicates = {}
		for _, path in ipairs(pathsToCompile) do
			if duplicates[path] then
				errorLine(nil, "Duplicate path in arguments: %s", path)
			end
			duplicates[path] = true
		end
	end

	if not pathsToCompile[1] then
		errorLine(nil, "No files to compile.")
	end



	local !struct"CompilationSettings"{
		-- BuildOptions:
		{`outputFile`,      true},
		{`outputFilePath`,  ""},
		{`entryPointName`,  "main"},
		-- Other:
		{`outputDebugInfo`, false},
		{`keepDeadCode`,    false},
	}

	local !struct"CompilationState"{
		{`fileBuffers`,       {}},
		{`tokens`,            nil},   -- Tokens (struct)
		{`settings`,          nil},   -- CompilationSettings

		{`projectDirectory`,  ""},

		-- Parser:
		{`globalScope`,       nil},   -- AstGlobalScope
		{`nextToken`,         1},
		{`soft`,              false}, -- Enabling this will make parsing functions return nil on error instead of triggering an actual error.

		-- Typer:
		{`lastTypeId`,        0},
		{`allTypeInfos`,      {}},
		{`queue`,             {}},
		{`dependencies`,      {}},

		-- Bytecode:
		{`constants`,         {}},
		{`constantN`,         0},
		{`functionN`,         0},     -- Same as constantN, but for function constants.
		{`topScopeNames`,     Set{"_FOREIGN","_MATH_MODF","_MATH_FLOOR","_MATH_HUGE","_IPAIRS","_PAIRS","_IPAIRSR","_CONDITION","_BREAK","_STATE","_COMPILER","_SWITCH","_TYPE_INFO","_SELECT"}},
		{`bytecodes`,         {}},    -- Code for the interpreter to run.

		-- Runner:
		{`runnerEnvironment`,    {}},
		{`runnerWriter`,         nil}, -- WriterState
		{`runnerWrittenObjects`, {}},
	}

	local timeDoingSubCompilations = 0

	function _G.compileProgram(pathToFirstFile)
		local timeStartCompiling            = os.clock()
		local timeDoingSubCompilationsStart = timeDoingSubCompilations

		local state  = CompilationState()
		state.tokens = Tokens()

		-- Project directory result examples:
		--   C:/app/main.gloa > C:/app
		--   ../main.gloa     > ..
		--   main.gloa        > .
		state.projectDirectory = pathToFirstFile:gsub("/?[^/]+$", ""):gsub("^$", ".")

		local settings           = CompilationSettings()
		settings.outputDebugInfo = outputDebugInfo
		settings.keepDeadCode    = keepDeadCode
		settings.outputFilePath  = pathToFirstFile:gsub("%.gloa$", "")..".lua"
		state.settings           = settings



		-- Start compiling.
		if not silent then  print("Compiling "..pathToFirstFile:gsub("^.*/", ""))  end

		insertToken(state.tokens, !(TOKEN_DIRECTIVE), "import",  pathToFirstFile)
		insertToken(state.tokens, !(TOKEN_STRING),    "preload", pathToFirstFile)

		local timeStartLexing, timeEndLexing = readAndTokenizeFile(state, pathToFirstFile)

		local timeStartParsing = os.clock()
		local globalScope      = parseGlobalScope(state, pathToFirstFile)
		local timeEndParsing   = os.clock()

		if peekNextToken(state) then
			errorParsingNext(state, "Expected the end of the file.")
		end



		-- Run pipes.
		!ifDEBUG `profilerStart()`
		local timeStartPipes = os.clock()

		!if DEBUG then
		local queuedUpdates  = 0
		local pipeCycles     = 0
		local maxQueueSize   = 0
		!end

		!ifDEBUG`if not debug_onlyParse then`
			local queue     = state.queue
			local finalPipe = !(PIPE_DONE-1)

			!if DEBUG then
				if debug_onlyInferTypes then  finalPipe = !(PIPE_INFER)  end
			!end

			addToQueueRecursively(state, globalScope)

			for cycle = 1, math.huge do
				-- print("cycle", cycle)
				!if DEBUG then
					pipeCycles   = pipeCycles+1
					maxQueueSize = math.max(maxQueueSize, #queue)
				!end

				local waitCount    = 0
				local didSomething = false
				local i            = 1

				while true do
					local queued

					while true do
						queued = queue[i]
						if not (queued and queued.unqueued) then  break  end
						removeUnordered(queue, i)
					end
					if not queued then  break  end

					!if DEBUG then
						queuedUpdates = queuedUpdates+1
					!end

					if queued.waitingOn then
						waitCount = waitCount+1

					!if DEBUG then
					elseif queued.pipe > finalPipe then
						-- void
					!end

					else
						if queued.pipe == !(PIPE_INFER) then
							didSomething = true
							inferNode(state, queued.node)
						elseif queued.pipe == !(PIPE_BYTECODE) then
							didSomething = true
							bcEmit(state, queued.node)
						end

						if queued.waitingOn then
							waitCount = waitCount+1
						end
					end

					i = i+1
				end

				if waitCount == 0 then
					-- Pipes may have completed.
					local allDone = true

					for _, queued in ipairs(queue) do
						if queued.unqueued then
							-- void
						elseif queued.pipe <= finalPipe then
							allDone = false
							break
						end
					end

					if allDone then  break  end

				elseif not didSomething then
					errorPipesAreStuck(state)
				end

				for _, queued in ipairs(queue) do
					local dependencyCurrent = not queued.unqueued and queued.waitingOn

					while dependencyCurrent do
						local dependency  = dependencyCurrent
						dependencyCurrent = nil

						!local DEPENDENCY_FULFILLED = `
							dependencyCurrent = dependency.next
							queued.waitingOn  = dependencyCurrent
						`

						if dependency.dependType == !(DEPEND_DECLARATION) then
							local name = dependency.dependOn
							-- @Speed: Only call findDeclaration*() if it's reported that a declaration with the awaited name has been added to the tree.
							if dependency.extraData then
								if findDeclarationInScope(state, dependency.extraData, name, true) then
									!!(DEPENDENCY_FULFILLED)
								end
							else
								if findDeclaration(state, queued.node, name) then
									!!(DEPENDENCY_FULFILLED)
								end
							end

						elseif dependency.dependType == !(DEPEND_NODE_INFERRED) then
							-- Note: dependOn.node is not necessarily an expression which is why we also check the pipe.
							if dependency.dependOn.node.inferredType or dependency.dependOn.pipe > !(PIPE_INFER) then
								!!(DEPENDENCY_FULFILLED)
							end

						elseif dependency.dependType == !(DEPEND_STRUCT_MEMBERS_READY) then
							if dependency.dependOn.hasMembers then
								!!(DEPENDENCY_FULFILLED)
							end

						elseif dependency.dependType == !(DEPEND_NODE_EMITTED) then
							if dependency.dependOn.pipe > !(PIPE_BYTECODE) then
								!!(DEPENDENCY_FULFILLED)
							end

						elseif dependency.dependType == !(DEPEND_CONSTANT_READY) then
							if dependency.dependOn.isReady then
								!!(DEPENDENCY_FULFILLED)
							end

						else
							errorInternal("%d", dependency.dependType)
						end
					end
				end

				!if DEBUG then
					-- Guard against an infinite loop.
					if cycle == 100 then
						local printCount = 0
						printerr()

						for _, queued in ipairs(queue) do
							if not queued.unqueued and queued.pipe <= finalPipe then
								printCount = printCount+1

								if printCount > 10 then
									printerr("(...)")
									break
								end

								local dependency = queued.waitingOn

								astPrint(queued.node)
								nodeMessage(
									io.stderr, state, queued.node, "Debug", nil,
									"pipe=%s%s",
									PIPE_TITLES[queued.pipe],
									dependency and ", waiting" or ""
								)

								if dependency and !!(anyV(`dependency.dependType`, DEPEND_NODE_INFERRED,DEPEND_NODE_EMITTED)) then
									astPrint(dependency.dependOn.node)
									nodeMessage(
										io.stderr, state, dependency.dependOn.node, "Debug", nil,
										"...waiting on this."
									)
								end
							end
						end

						errorInternal("[DEBUG] Pipes ran for too long. (waiting:%d)", waitCount)
					end
				!end
			end--for cycle
		!ifDEBUG`end`

		local timeEndPipes = os.clock()
		!ifDEBUG `profilerStop()`



		-- Write program.
		if settings.outputFilePath == pathToFirstFile then
			errorLine(nil, "The input path is the same as the output path. (%s)", pathToFirstFile)
		end

		local timeStartOutput = os.clock()

		!ifDEBUG`if not (debug_onlyParse or debug_onlyInferTypes) then`
			if settings.outputFile then
				local writer         = WriterState()
				writer.file          = assert(io.open(settings.outputFilePath, "w"))
				writer.outputRuntime = true
				writeProgram(state, writer)
			end
		!ifDEBUG`end`

		local timeEndOutput = os.clock()



		-- All done!
		local timeEndCompilation = os.clock()

		!ifNotDEBUG`if not silent then`
			!ifDEBUG`if debug_onlyParse then  astPrintTree(globalScope)  end`

			local subTime = timeDoingSubCompilations-timeDoingSubCompilationsStart

			!local OK = {
				"██████████████████████ ",
				"███▀    ▀███  ███▀  ██ ",
				"██  ▄██▄  ██  █▀  ▄███ ",
				"██  ████  ██     █████ ",
				"██  ▀██▀  ██  █▄  ▀███ ",
				"███▄    ▄███  ███▄  ██ ",
				"██████████████████████ ",
			}

			printf(!((DEBUG and OK[1] or "Successfully compiled ").."%s"), pathToFirstFile)

			if subTime > 0 then
			printf(!((DEBUG and OK[2] or "").."Total:   %.3f (+%.3f) sec"), timeEndCompilation-timeStartCompiling-subTime, subTime)
			else
			printf(!((DEBUG and OK[2] or "").."Total:   %.3f sec"        ), timeEndCompilation-timeStartCompiling-subTime)
			end
			printf(!((DEBUG and OK[3] or "").."Lexing:  %.3f sec"), timeEndLexing  - timeStartLexing)
			printf(!((DEBUG and OK[4] or "").."Parsing: %.3f sec"), timeEndParsing - timeStartParsing)
			printf(!((DEBUG and OK[5] or "").."Pipes:   %.3f sec"), timeEndPipes   - timeStartPipes - subTime)
			printf(!((DEBUG and OK[6] or "").."Output:  %.3f sec"), timeEndOutput  - timeStartOutput)

			!if DEBUG then
				local dependencyCount = {}
				for _, dependency in ipairs(state.dependencies) do
					dependencyCount[dependency.dependType] = (dependencyCount[dependency.dependType] or 0)+1
				end

				local depencyCountTexts = {}
				for dependType, title in ipairs(DEPEND_TITLES) do
					depencyCountTexts[dependType] = F("%s:%d", title, (dependencyCount[dependType] or 0))
				end

				printf(!((DEBUG and OK[7] or "").."Updates:%d Cycles:%d Queue:%d Deps:%d (%s)"), queuedUpdates, pipeCycles, maxQueueSize, #state.dependencies, table.concat(depencyCountTexts, " "))
			!end

			print()
		!ifNotDEBUG`end`

		timeDoingSubCompilations = timeDoingSubCompilationsStart + timeEndCompilation - timeStartCompiling
	end

	for _, path in ipairs(pathsToCompile) do
		compileProgram(path)
	end

	!ifNotDEBUG`if not silent then`
		if pathsToCompile[2] then
			printf("Compiled all %d programs in %.3f sec", #pathsToCompile, os.clock()-timeStartInitial)
		end
		if disableGc then
			printf("Memory usage: %s bytes", formatNumber(collectgarbage"count"*1024))
		end
	!ifNotDEBUG`end`

	!ifDEBUG `profilerPrint()`

	exit()

end, function(err)
	errorInternal(2, "Critical Lua error: %s", (tostring(err):gsub("^[%w/.]+:%d+: ", "")))
end)
