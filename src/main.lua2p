#!/bin/sh
_=[[
exec lua "$0" "$@"
]] and nil
--[[============================================================
--=
--=  Glóa - a language that compiles into Lua
--=  by Marcus 'ReFreezed' Thunström
--=
--=  Language points:
--=  - Strict types (as far as Lua allows).
--=  - In file/declarative scopes, order of things doesn't matter.
--=  - No name shadowing.
--=
--============================================================]]

local compilationStartTime = os.clock()

io.stdout:setvbuf("no") -- Note: This slows down astPrint().
io.stderr:setvbuf("no")

!if DEBUG then
	io.stderr = io.stdout -- Kinda solves stdout/stderr buffering seemingly still being enabled for Sublime Text 2 build systems for some reason. Sigh...
!end



!-- We want the resulting Glóa compiler to be a single file, so we use @insert instead of requiring modules here.
do !(do) @insert "preprocessorStuffAndGlobals.luapart" !(end) end
do !(do) @insert "functions.luapart" !(end) end
do !(do) @insert "lexer.luapart"     !(end) end
do !(do) @insert "parser.luapart"    !(end) end
do !(do) @insert "typer.luapart"     !(end) end
do !(do) @insert "bytecode.luapart"  !(end) end



-- Parse arguments.
local function printHelpAndExit()
	print("Glóa")
	print()
	print("Synopsis:")
	print("    lua gloa.lua [options] myProgram.gloa [myOtherProgram.gloa ...]")
	print()
	print("Options:")
	print("    --help    Display this help.")
	print("    --nogc    Disable garbage collection during compilation. This may decrease compilation time.")
	print("    --silent  Disable output to stdout. (Errors are still printed to stderr.)")
	print("    --        Stop parsing options.")
	print()
	exit(0)
end

local args = {...}
if not args[1] then  printHelpAndExit()  end

local parseOptions   = true
local pathsToCompile = {}
local disableGc      = false
local silent         = false
local i              = 1

!if DEBUG then
_G.debug_onlyParse      = false
_G.debug_onlyInferTypes = false
!end

while args[i] do
	local arg = args[i]

	if not (parseOptions and arg:find"^%-") then
		table.insert(pathsToCompile, arg)
		i = i+1

	elseif arg == "--" then
		parseOptions = false
		i            = i+1

	elseif arg == "--help" or arg == "-help" or arg == "-?" or arg == "/help" or arg == "/?" then
		printHelpAndExit()

	elseif arg == "--nogc" then
		disableGc = true
		i = i+1

	elseif arg == "--silent" then
		silent = true
		i = i+1

	!if DEBUG then
	elseif arg == "--debug:onlyparse" then
		_G.debug_onlyParse = true
		i = i+1

	elseif arg == "--debug:onlyinfer" then
		_G.debug_onlyInferTypes = true
		i = i+1
	!end

	else
		errorLine(nil, "Unknown option '%s'.", arg)
	end
end



!if DEBUG then
	print(os.date"%Y-%m-%d %H:%M:%S")
!else
	if not silent then
		print()
		print("-------- Glóa --------")
		print('Args:  "'..table.concat(args, '" "')..'"')
		print("Files: "..table.concat(pathsToCompile, ", "))
		print(os.date"Date:  %Y-%m-%d %H:%M:%S")
		if disableGc then  print("Garbage collection disabled.")  end
		print()
	end
!end

if disableGc then  collectgarbage("stop")  end

local duplicates = {}
for _, path in ipairs(pathsToCompile) do
	if duplicates[path] then
		errorLine(nil, "Duplicate path in arguments: %s", path)
	end
	duplicates[path] = true
end

if not pathsToCompile[1] then
	errorLine(nil, "No files to compile.")
end



-- Tokenize file.
-- @Incomplete: Handle multiple files to compile.
if pathsToCompile[2] then
	errorLine(nil, "Can only compile one file at a time right now. (%d files were given.)", #pathsToCompile)
end

local path = pathsToCompile[1]
local s    = assert(getFileContents(path, true))

if not silent then  print("Compiling "..path:gsub("^.*/", ""))  end

s = s:gsub("\r\n?", "\n") -- Normalize line endings.  @Robustness: Handle the uncommon occurrence of \n\r.

local tokens = tokenize(s, path)



-- Quickly check for stray/unmatched brackets.
-- Note: Sometimes an error message here isn't very helpful, so we sometimes continue with parsing despite getting an error here.

local BRACKETS            = {["("]=")", ["{"]="}", ["["]="]"}
local bracketTokenIndices = {}

for i = 1, tokens.count do
	if isToken(tokens.type[i],tokens.value[i], !(TOKEN_PUNCTUATION),"(","{","[") then
		table.insert(bracketTokenIndices, i)

	elseif isToken(tokens.type[i],tokens.value[i], !(TOKEN_PUNCTUATION),")","}","]") then
		local iStart   = table.remove(bracketTokenIndices)
		local expected = BRACKETS[tokens.value[iStart]]

		if not iStart then
			reportMessageInFile(io.stderr, s, path, tokens.position1[i], "Error", "BracketChecker", "Stray bracket.")
			bracketTokenIndices[1] = nil
			break

		elseif tokens.value[i] ~= expected then
			printerr()
			reportMessageInFile(io.stderr, s, path, tokens.position1[i],      "Error", "BracketChecker", "Expected '%s'.", expected)
			reportMessageInFile(io.stderr, s, path, tokens.position1[iStart], "Info",  "BracketChecker", "...here is the unmatched bracket.")
			exitFailure()
		end
	end
end

if bracketTokenIndices[1] then
	local i = bracketTokenIndices[1]
	errorInFile(s, path, tokens.position1[i], "BracketChecker", "Missing end bracket.", BRACKETS[tokens.value[i]])
end



-- Parse.
local state             = ParseState()
state.fileBuffers[path] = s
state.tokens            = tokens

local topNode = parseFileScope(state, path)

if peekNextToken(state) then
	errorParsingNext(state, "Expected the end of the file.")
end



-- Run pipes.
!if DEBUG then
local pipeCycles = 0
!end

!ifDEBUG`if not debug_onlyParse then`
	local state             = TyperState()
	state.fileBuffers[path] = s
	state.tokens            = tokens

	local function getDeclaredIdentifierWaitingToBeDefinedWithName(name, queuedToIgnore)
		for _, queued in ipairs(state, queue) do
			if queued ~= queuedToIgnore and queued.waitingOn and queued.node.nodeType == !(nodeTypes.AstIdentifier) then
				local ident = queued.node
				if ident.parent == ident.declaration and ident.name == name then  return queued  end
			end
		end
		return nil
	end

	v2_addToQueueRecursively(state, topNode)

	for cycle = 1, math.huge do
		!if DEBUG then
			pipeCycles = pipeCycles+1
		!end

		local waitCount    = 0
		local didSomething = false

		for _, queued in ipairs(state.queue) do -- Should we use ipairs() or ipairsr()?
			if queued.waitingOn then
				local dependency = queued.waitingOn

				if dependency.dependType == !(DEPEND_DEFINITION) then
					local name = dependency.dependOn
					-- @Speed: Only call findDefinition() if it's reported that a definition with the awaited name has been defined.
					if findDefinition(state, queued.node, name) then
						queued.waitingOn = nil
					end

				elseif dependency.dependType == !(DEPEND_NODE_INFERRED) then
					if dependency.dependOn.queued.pipe > !(PIPE_INFER) then
					-- if dependency.dependOn.inferredType then -- Invalid! dependOn is not necessarily an expression.
						queued.waitingOn = nil
					end

				else
					errorInternal("%d", dependency.dependType)
				end
			end

			if queued.waitingOn then
				waitCount = waitCount+1

			elseif queued.pipe == !(PIPE_INFER) then
				didSomething = true
				v2_inferNode(state, queued.node)

			elseif queued.pipe == !(PIPE_BYTECODE) then
				-- @Incomplete: Bytecode.

			else
				-- @Incomplete: More pipes?
			end
		end

		-- Pipes may have completed.
		if waitCount == 0 then
			local allDone = true

			for _, queued in ipairs(state.queue) do
				if queued.pipe <= !(PIPE_INFER) then -- TEMP
				-- if queued.pipe < !(PIPE_DONE) then
					allDone = false
					break
				end
			end

			if allDone then  break  end

		-- Pipes are stuck.
		elseif not didSomething then
			-- [[ Report undefined identifier.
			for _, queued in ipairs(state.queue) do
				local dependency = queued.waitingOn

				if dependency and dependency.dependType == !(DEPEND_DEFINITION) then
					local name = dependency.dependOn
					print('wait', name)

					if not getDeclaredIdentifierWaitingToBeDefinedWithName(name, queued) then
						typeError(state, queued.node, "Undefined identifier '%s'.", name)
					end
				end
			end
			--]]

			-- [[ Report identifier waiting for definition to be defined.
			for _, queued in ipairs(state.queue) do
				local dependency = queued.waitingOn

				if
					dependency
					and dependency.dependType        == !(DEPEND_NODE_INFERRED)
					and queued.node.nodeType         == !(nodeTypes.AstIdentifier)
					and dependency.dependOn.nodeType == !(nodeTypes.AstTypeDefinition)
				then
					local defn = dependency.dependOn

					printerr()
					typeMessage(io.stderr, state, defn,        "Error", "Failed inferring the type of this definition.")
					typeMessage(io.stderr, state, queued.node, "Info",  "...this identifier is waiting for the above to finish.")
					exitFailure()
				end
			end
			--]]

			-- [[ Report about-to-be-declared identifier waiting for something.
			for _, queued in ipairs(state.queue) do
				local dependency = queued.waitingOn

				if
					dependency
					and dependency.dependType == !(DEPEND_NODE_INFERRED)
					and queued.node.nodeType  == !(nodeTypes.AstIdentifier)
					and queued.node.parent    == queued.node.declaration
				then
					local expr = dependency.dependOn

					printerr()
					typeMessage(io.stderr, state, expr,        "Error", "Failed inferring the type of this expression.")
					typeMessage(io.stderr, state, queued.node, "Info",  "...this identifier is waiting for the above to finish.")
					exitFailure()
				end
			end
			--]]

			-- [[ Report something waiting for something else.
			for _, queued in ipairsr(state.queue) do
				local dependency = queued.waitingOn

				if dependency and dependency.dependType == !(DEPEND_NODE_INFERRED) then
					local expr = dependency.dependOn

					printerr()
					typeMessage(io.stderr, state, expr,        "Error", "Failed inferring the type of this expression.")
					typeMessage(io.stderr, state, queued.node, "Info",  "...this thing is waiting for the above to finish.")
					exitFailure()
				end
			end
			--]]

			errorInternal("Pipes are stuck. Also failed to figure out where the issue actually is. Oops...")
		end

		-- Guard against an infinite loop.
		if cycle == 100 then
			errorInternal("The pipes ran for too long. (waiting:%d)", waitCount)
		end
	end
!ifDEBUG`end`

--[[ OLD:
-- Infer types.
!ifDEBUG`if not debug_onlyParse then`
	local state             = TyperState()
	state.fileBuffers[path] = s
	state.tokens            = tokens

	for i = 1, math.huge do
		state.progress      = 0
		state.waiting       = 0
		state.waitingSilent = 0

		inferFileScope(state, topNode)

		if state.waiting+state.waitingSilent == 0 then
			break

		elseif state.progress == 0 then
			state.mustInfer = true
			state.errorStep = state.waiting
			inferFileScope(state, topNode) -- This should trigger an error somewhere.
			errorInternal("Type inference loop is stuck. Also failed to report where the issue actually is. Oops...")
		end

		-- Guard against an infinite loop.
		if i == 100 then
			errorInternal("Type inference loop went on for too long. (waiting:%d, progress:%d)", state.waiting+state.waitingSilent, state.progress)
		end
	end
!ifDEBUG`end`
]]



-- -- Generate bytecode.
-- !ifDEBUG`if not (debug_onlyParse or debug_onlyInferTypes) then`
-- 	local state = BytecodeState()
-- 	bcGenerate(state, topNode)
-- !ifDEBUG`end`



-- All done!

!if DEBUG then
	printf("Compilation completed in %.3f seconds in %d cycles", os.clock()-compilationStartTime, pipeCycles)
	if debug_onlyParse then
		astPrintTree(topNode)--, io.stderr)
	end
	print("██████████████████████")
	print("████    ████  ████  ██")
	print("██  ████  ██  ██  ████")
	print("██  ████  ██    ██████")
	print("██  ████  ██  ██  ████")
	print("████    ████  ████  ██")
	print("██████████████████████")
!else
	if not silent then
		printf("Compilation completed in %.3f seconds", os.clock()-compilationStartTime)
		if disableGc then
			printf("Memory usage: %d bytes", collectgarbage("count")*1024)
		end
		print()
	end
!end

exit()


