#!/bin/sh
_=[[
exec lua "$0" "$@"
]] and nil
--[[============================================================
--=
--=  Glóa compiler
--=  by Marcus 'ReFreezed' Thunström
--=
--=  Note: The compiler (this file) is preprocessed. The original
--=  source can be found at https://github.com/ReFreezed/Gloa
--=
--=  Language points:
--=  - Strong static type system.
--=  - Compile-time execution (eventually).
--=  - The order of declarations doesn't matter in non-imperative scopes. (No forward declarations needed.)
--=
--============================================================]]
!(
local VERSION = "0.1.0"

local HELP_TEXT = [[
Synopsis:
    lua gloa.lua [compilerOptions] myProgram.gloa [myOtherProgram.gloa ...] [-- metaprogramArgument1 ...]

Options:
    --debug   Output debug information into compiled program.
    --help    Display this help.
    --nogc    Disable garbage collection during compilation. This may decrease compilation time.
    --silent  Disable output to stdout. (Errors and warnings are still printed to stderr.)
    --        Start of arguments for metaprogram.]]
)

local args = {...}

local defaultGlobals = {}
for k, v in pairs(_G) do
	defaultGlobals[k] = v
end
_G.DEFAULT_GLOBALS = defaultGlobals

xpcall(function()
	local timeStartCompiling = os.clock()

	!if DEBUG then
		-- This fixes a Sublime Text 2 stdout/stderr desync in build system results. Sigh... :SublimeText2Desync
		io.stdout = io.stderr
		io.output(io.stdout)

		io.stdout:setvbuf("no") -- Note: This slows down all printing.
	!end



	!-- We want the resulting Glóa compiler to be a single file, so we use @insert instead of requiring modules here.
	do !(do) @insert "preprocessorStuffAndGlobals.luapart" !(end) end
	do !(do) @insert "functions.luapart"     !(end) end
	do !(do) @insert "lexer.luapart"         !(end) end
	do !(do) @insert "parser.luapart"        !(end) end
	do !(do) @insert "pipes.luapart"         !(end) end
	do !(do) @insert "typer.luapart"         !(end) end
	do !(do) @insert "bytecode.luapart"      !(end) end -- @Cleanup: Rename to something better.
	do !(do) @insert "runner.luapart"        !(end) end
	do !(do) @insert "programWriter.luapart" !(end) end



	-- Parse arguments.
	local pathsToCompile    = {}
	local disableGc         = false
	local silent            = false
	local outputDebugInfo   = false
	local metaprogramArgs   = {}

	!if DEBUG then
	_G.debug_onlyParse      = false
	_G.debug_onlyInferTypes = false
	!end

	do
		local function printHelpAndExit()
			print(!("Gloa v"..VERSION..os.date" (built %Y-%m-%d)")) -- No "Glóa" because we don't know the code page. :(
			print()
			print(!(HELP_TEXT))
			print()
			exit(0)
		end

		if not args[1] then  printHelpAndExit()  end

		local forCompiler = true
		local i           = 1

		while args[i] do
			local arg = args[i]

			if not forCompiler then
				table.insert(metaprogramArgs, arg)
				i = i+1
			elseif not arg:find"^%-" then
				table.insert(pathsToCompile, (arg:gsub("\\", "/")))
				i = i+1
			elseif arg == "--" then
				forCompiler = false
				i           = i+1

			elseif arg == "--help" or arg == "-help" or arg == "-?" or arg == "/help" or arg == "/?" then
				printHelpAndExit()
			elseif arg == "--nogc" then
				disableGc = true
				i = i+1
			elseif arg == "--silent" then
				silent = true
				i = i+1
			elseif arg == "--debug" then
				outputDebugInfo = true
				i = i+1

			!if DEBUG then
			elseif arg == "--debug:onlyparse" then
				_G.debug_onlyParse = true
				i = i+1
			elseif arg == "--debug:onlyinfer" then
				_G.debug_onlyInferTypes = true
				i = i+1
			!end

			else
				errorLine(nil, "Unknown option '%s'.", arg)
			end
		end
	end



	!if DEBUG then
		print(os.date"%Y-%m-%d %H:%M:%S")
	!else
		if not silent then
			print()
			print("-------- Gloa --------")
			print('Args:  "'..table.concat(args, '" "')..'"')
			print("Files: "..table.concat(pathsToCompile, ", "))
			print(os.date"Date:  %Y-%m-%d %H:%M:%S")
			if disableGc then  print("Garbage collection disabled.")  end
			print()
		end
	!end

	if disableGc then  collectgarbage("stop")  end

	do
		local duplicates = {}
		for _, path in ipairs(pathsToCompile) do
			if duplicates[path] then
				errorLine(nil, "Duplicate path in arguments: %s", path)
			end
			duplicates[path] = true
		end
	end

	if not pathsToCompile[1] then
		errorLine(nil, "No files to compile.")
	end



	local !struct"CompilationSettings"{
		{`doOutputFile`,    true},
		{`outputFilePath`,  ""},
		{`outputDebugInfo`, false},
		{`entryPointName`,  "main"},
	}

	local !struct"CompilationState"{
		{`fileBuffers`,       {}},
		{`tokens`,            nil},   -- Tokens (struct)
		{`settings`,          nil},   -- CompilationSettings

		{`projectDirectory`,  ""},    -- (Won't work when we support compiling multiple files at a time.)

		-- Parser:
		{`globalScope`,       nil},   -- AstGlobalScope
		{`nextToken`,         1},
		{`soft`,              false}, -- Enabling this will make parsing functions return nil on error instead of triggering an actual error.

		-- Typer:
		{`allTypeInfos`,      {}},
		{`queue`,             {}},
		{`dependencies`,      {}},

		-- Bytecode:
		{`constants`,         {}},
		{`constantN`,         0},
		{`functionN`,         0},     -- Same as constantN, but for function constants.
		{`topScopeNames`,     Set{"_FOREIGN","_MATH_MODF","_MATH_FLOOR","_IPAIRS","_PAIRS","_CONDITION","_BREAK"}},
		{`bytecodes`,         {}},    -- Code for the interpreter to run.

		-- Runner:
		{`runnerEnvironment`,    {}},
		{`runnerWriter`,         nil}, -- WriterState
		{`runnerWrittenObjects`, {}},
	}

	local settings           = CompilationSettings()
	settings.outputDebugInfo = outputDebugInfo

	local state       = CompilationState()
	state.tokens      = Tokens()
	state.settings    = settings



	-- Tokenize file.
	function _G.readAndTokenizeFile(state, path)
		assert(not state.fileBuffers[path], path)

		local s, err = getFileContents(path, true)
		if not s then
			errorLine(nil, "Could not read file '%s'. (%s)", path, err)
		end
		s = s:gsub("\r\n?", "\n") -- Normalize line endings.  @Robustness: Handle the uncommon occurrence of \n\r.

		state.fileBuffers[path] = s

		local tokens     = state.tokens
		local startToken = tokens.count+1

		local startTime = os.clock()
		tokenize(s, path, tokens)
		local endTime = os.clock()

		-- Quickly check for stray/unmatched brackets.

		-- Note: Sometimes an error message here isn't very helpful, so we
		-- sometimes continue with parsing despite getting an error here.

		local BRACKETS            = {["("]=")", ["{"]="}", ["["]="]"}
		local bracketTokenIndices = {}

		for i = startToken, tokens.count do
			if isToken(tokens.type[i],tokens.value[i], !(TOKEN_PUNCTUATION),"(","{","[") then
				table.insert(bracketTokenIndices, i)

			elseif isToken(tokens.type[i],tokens.value[i], !(TOKEN_PUNCTUATION),")","}","]") then
				local iStart   = table.remove(bracketTokenIndices)
				local expected = BRACKETS[tokens.value[iStart]]

				if not iStart then
					reportMessageInFile(io.stderr, s, path, tokens.position1[i], "Error", "BracketChecker", "Stray bracket.")
					bracketTokenIndices[1] = nil
					break

				elseif tokens.value[i] ~= expected then
					printerr()
					reportMessageInFile(io.stderr, s, path, tokens.position1[i],      "Error", "BracketChecker", "Expected '%s'.", expected)
					reportMessageInFile(io.stderr, s, path, tokens.position1[iStart], "Info",  "BracketChecker", "...here is the unmatched bracket.")
					exitFailure()
				end
			end
		end

		if bracketTokenIndices[1] then
			local i = bracketTokenIndices[1]
			errorInFile(s, path, tokens.position1[i], "BracketChecker", "Missing end bracket.", BRACKETS[tokens.value[i]])
		end

		return startTime, endTime
	end

	-- @Incomplete: Handle multiple files to compile.
	if pathsToCompile[2] then
		errorLine(nil, "Can only compile one file at a time right now. (%d files were given.)", #pathsToCompile)
	end

	local thePath                 = pathsToCompile[1]
	state.settings.outputFilePath = thePath:gsub("%.gloa", "")..".lua"

	-- Project directory result examples:
	--   C:/app/main.gloa > C:/app
	--   ../main.gloa     > ..
	--   main.gloa        > .
	state.projectDirectory = thePath:gsub("/?[^/]+$", ""):gsub("^$", ".")

	if not silent then  print("Compiling "..thePath:gsub("^.*/", ""))  end

	local timeStartLexing, timeEndLexing = readAndTokenizeFile(state, thePath)



	-- Parse first file.
	local timeStartParsing = os.clock()
	local globalScope      = parseGlobalScope(state, thePath)
	local timeEndParsing   = os.clock()

	if peekNextToken(state) then
		errorParsingNext(state, "Expected the end of the file.")
	end



	-- Run pipes.
	local timeStartPipes = os.clock()

	!if DEBUG then
	local pipeCycles   = 0
	local maxQueueSize = 0
	!end

	!ifDEBUG`if not debug_onlyParse then`
		local queue     = state.queue
		local finalPipe = !(PIPE_DONE-1)

		!if DEBUG then
			if debug_onlyInferTypes then  finalPipe = !(PIPE_INFER)  end
		!end

		addToQueueRecursively(state, globalScope)

		for cycle = 1, math.huge do
			!if DEBUG then
				-- print("cycle", cycle)
				pipeCycles   = pipeCycles+1
				maxQueueSize = math.max(maxQueueSize, #queue)
			!end

			local waitCount    = 0
			local didSomething = false
			local i            = 1

			while true do
				local queued

				while true do
					queued = queue[i]
					if not (queued and queued.unqueued) then  break  end
					removeUnordered(queue, i)
				end
				if not queued then  break  end

				if queued.waitingOn then
					waitCount = waitCount+1

				!if DEBUG then
				elseif queued.pipe > finalPipe then
					-- void
				!end

				else
					if queued.pipe == !(PIPE_INFER) then
						didSomething = true
						inferNode(state, queued.node)
					elseif queued.pipe == !(PIPE_BYTECODE) then
						didSomething = true
						bcEmit(state, queued.node)
					end

					if queued.waitingOn then
						waitCount = waitCount+1
					end
				end

				i = i+1
			end

			if waitCount == 0 then
				-- Pipes may have completed.
				local allDone = true

				for _, queued in ipairs(queue) do
					if queued.unqueued then
						-- void
					elseif queued.pipe <= finalPipe then
						allDone = false
						break
					end
				end

				if allDone then  break  end

			elseif not didSomething then
				errorPipesAreStuck(state)
			end

			for _, queued in ipairs(queue) do
				local dependencyCurrent = not queued.unqueued and queued.waitingOn

				while dependencyCurrent do
					local dependency  = dependencyCurrent
					dependencyCurrent = nil

					!local DEPENDENCY_FULFILLED = `
						dependencyCurrent = dependency.next
						queued.waitingOn  = dependencyCurrent
					`

					if dependency.dependType == !(DEPEND_DECLARATION) then
						local name = dependency.dependOn
						-- @Speed: Only call findDeclaration*() if it's reported that a declaration with the awaited name has been added to the tree.
						if dependency.extraData then
							if findDeclarationInScope(state, dependency.extraData, name, true) then
								!!(DEPENDENCY_FULFILLED)
							end
						else
							if findDeclaration(state, queued.node, name) then
								!!(DEPENDENCY_FULFILLED)
							end
						end

					elseif dependency.dependType == !(DEPEND_NODE_INFERRED) then
						-- Note: dependOn.node is not necessarily an expression which is why we also check the pipe.
						if dependency.dependOn.node.inferredType or dependency.dependOn.pipe > !(PIPE_INFER) then
							!!(DEPENDENCY_FULFILLED)
						end

					elseif dependency.dependType == !(DEPEND_STRUCT_MEMBERS_READY) then
						if dependency.dependOn.hasMembers then
							!!(DEPENDENCY_FULFILLED)
						end

					elseif dependency.dependType == !(DEPEND_NODE_EMITTED) then
						if dependency.dependOn.pipe > !(PIPE_BYTECODE) then
							!!(DEPENDENCY_FULFILLED)
						end

					else
						errorInternal("%d", dependency.dependType)
					end
				end
			end

			!if DEBUG then
				-- Guard against an infinite loop.
				if cycle == 100 then
					local printCount = 0
					printerr()

					for _, queued in ipairs(queue) do
						if not queued.unqueued and queued.pipe <= finalPipe then
							printCount = printCount+1

							if printCount > 10 then
								printerr("(...)")
								break
							end

							local dependency = queued.waitingOn

							astPrint(queued.node)
							nodeMessage(
								io.stderr, state, queued.node, "Debug", nil,
								"pipe=%s, exited=%s%s",
								PIPE_TITLES[queued.pipe],
								PIPE_TITLES[queued.pipeHighestExited],
								dependency and ", waiting" or ""
							)

							if dependency and isAny(dependency.dependType, !(DEPEND_NODE_INFERRED),!(DEPEND_NODE_EMITTED)) then
								astPrint(dependency.dependOn.node)
								nodeMessage(
									io.stderr, state, dependency.dependOn.node, "Debug", nil,
									"...waiting on this."
								)
							end
						end
					end

					errorInternal("[DEBUG] Pipes ran for too long. (waiting:%d)", waitCount)
				end
			!end
		end--for cycle
	!ifDEBUG`end`

	local timeEndPipes = os.clock()



	-- Write program.
	if state.settings.outputFilePath == thePath then
		errorLine(nil, "The input path is the same as the output path. (%s)", thePath)
	end

	local timeStartOutput = os.clock()

	!ifDEBUG`if not (debug_onlyParse or debug_onlyInferTypes) then`
		if state.settings.doOutputFile then
			local writer = WriterState()
			writer.file  = assert(io.open(state.settings.outputFilePath, "w"))
			writeProgram(state, writer)
		end
	!ifDEBUG`end`

	local timeEndOutput = os.clock()



	-- All done!
	local timeEndCompilation = os.clock()

	!if DEBUG then
		if debug_onlyParse then  astPrintTree(globalScope)  end
		printf("██████████████████████ Total:   %.3f sec", timeEndCompilation - timeStartCompiling)
		printf("████    ████  ████  ██ Lexing:  %.3f sec", timeEndLexing      - timeStartLexing)
		printf("██  ████  ██  ██  ████ Parsing: %.3f sec", timeEndParsing     - timeStartParsing)
		printf("██  ████  ██    ██████ Pipes:   %.3f sec", timeEndPipes       - timeStartPipes)
		printf("██  ████  ██  ██  ████ Output:  %.3f sec", timeEndOutput      - timeStartOutput)
		printf("████    ████  ████  ██ Queue:   %d",       maxQueueSize)
		printf("██████████████████████ Cycles:  %d",       pipeCycles)
	!else
		if not silent then
			printf("Compilation completed in %.3f seconds", timeEndCompilation-timeStartCompiling)
			if disableGc then
				printf("Memory usage: %.0f bytes", collectgarbage"count"*1024)
			end
			print()
		end
	!end

	exit()

end, function(err)
	errorInternal(2, "Critical Lua error: %s", (tostring(err):gsub("^[%w/.]+:%d+: ", "")))
end)
