--[[============================================================
--=
--=  LÃ–VE bindings (love2d.org)
--=
--=  Supported versions: 11.3
--=
--============================================================]]

export Filename      :: string
export Variant       :: string|int|float|bool|table|Object -- Functions and Lua userdata are not supported. Tables have to be "simple".
export Color         :: []float
export Pointer       :: !foreign struct {}
export LightUserdata :: !foreign struct {} -- Actually a value (int) representing a pointer, but for the sake of type safety it's probably better to say it's its own type.

export ObjectName :: enum {
	DROPPED_FILE          :: "DroppedFile",
	GLYPH_DATA            :: "GlyphData",
	RASTERIZER            :: "Rasterizer",
	RECORDING_DEVICE      :: "RecordingDevice",
	SOURCE                :: "Source",
	FILE                  :: "File",
	FILE_DATA             :: "FileData",
	CANVAS                :: "Canvas",
	FONT                  :: "Font",
	IMAGE                 :: "Image",
	MESH                  :: "Mesh",
	PARTICLE_SYSTEM       :: "ParticleSystem",
	QUAD                  :: "Quad",
	SHADER                :: "Shader",
	SPRITE_BATCH          :: "SpriteBatch",
	TEXT                  :: "Text",
	TEXTURE               :: "Texture",
	VIDEO                 :: "Video",
	COMPRESSED_IMAGE_DATA :: "CompressedImageData",
	IMAGE_DATA            :: "ImageData",
	JOYSTICK              :: "Joystick",
	BEZIER_CURVE          :: "BezierCurve",
	COMPRESSED_DATA       :: "CompressedData",
	RANDOM_GENERATOR      :: "RandomGenerator",
	TRANSFORM             :: "Transform",
	CURSOR                :: "Cursor",
	BODY                  :: "Body",
	CHAIN_SHAPE           :: "ChainShape",
	CIRCLE_SHAPE          :: "CircleShape",
	CONTACT               :: "Contact",
	DISTANCE_JOINT        :: "DistanceJoint",
	EDGE_SHAPE            :: "EdgeShape",
	FIXTURE               :: "Fixture",
	FRICTION_JOINT        :: "FrictionJoint",
	GEAR_JOINT            :: "GearJoint",
	JOINT                 :: "Joint",
	MOTOR_JOINT           :: "MotorJoint",
	MOUSE_JOINT           :: "MouseJoint",
	POLYGON_SHAPE         :: "PolygonShape",
	PRISMATIC_JOINT       :: "PrismaticJoint",
	PULLEY_JOINT          :: "PulleyJoint",
	REVOLUTE_JOINT        :: "RevoluteJoint",
	ROPE_JOINT            :: "RopeJoint",
	SHAPE                 :: "Shape",
	WELD_JOINT            :: "WeldJoint",
	WHEEL_JOINT           :: "WheelJoint",
	WORLD                 :: "World",
	DECODER               :: "Decoder",
	SOUND_DATA            :: "SoundData",
	CHANNEL               :: "Channel",
	THREAD                :: "Thread",
	VIDEO_STREAM          :: "VideoStream",
	BYTE_DATA             :: "ByteData",
	DATA                  :: "Data",
	DRAWABLE              :: "Drawable",
	OBJECT                :: "Object",
}
export Data :: !foreign struct {
	using Object,
	clone         :: (self:Data) -> Data               !foreign method "clone",
	getFFIPointer :: (self:Data) -> !import"ffi".Cdata !foreign method "getFFIPointer",
	getPointer    :: (self:Data) -> Pointer            !foreign method "getPointer",
	getSize       :: (self:Data) -> int                !foreign method "getSize",
	getString     :: (self:Data) -> string             !foreign method "getString",
}
export Object :: !foreign struct {
	release :: (self:Object) -> (success:bool)                 !foreign method "release",
	type    :: (self:Object) -> (name:ObjectName)              !foreign method "type",
	typeOf  :: (self:Object, name:ObjectName) -> (isType:bool) !foreign method "typeOf",
}
export getVersion           :: () -> (major:int, minor:int, revision:int, codename:string) !foreign lua "love.getVersion"
export hasDeprecationOutput :: () -> (enabled:bool) !foreign lua "love.hasDeprecationOutput"
export setDeprecationOutput :: (enable:bool) !foreign lua "love.setDeprecationOutput"
export audio :: namespace {
	export DistanceModel :: enum {
		NONE             :: "none",
		INVERSE          :: "inverse",
		INVERSE_CLAMPED  :: "inverseclamped",
		LINEAR           :: "linear",
		LINEAR_CLAMPED   :: "linearclamped",
		EXPONENT         :: "exponent",
		EXPONENT_CLAMPED :: "exponentclamped",
	}
	export EffectType :: enum {
		CHORUS         :: "chorus",
		COMPRESSOR     :: "compressor",
		DISTORTION     :: "distortion",
		ECHO           :: "echo",
		EQUALIZER      :: "equalizer",
		FLANGER        :: "flanger",
		REVERB         :: "reverb",
		RING_MODULATOR :: "ringmodulator",
	}
	export EffectWaveform :: enum {
		SAWTOOTH :: "sawtooth",
		SINE     :: "sine",
		SQUARE   :: "square",
		TRIANGLE :: "triangle",
	}
	export FilterType :: enum {
		LOWPASS  :: "lowpass",
		HIGHPASS :: "highpass",
		BANDPASS :: "bandpass",
	}
	export SourceType :: enum {
		STATIC :: "static",
		STREAM :: "stream",
		QUEUE  :: "queue",
	}
	export TimeUnit :: enum {
		SECONDS :: "seconds",
		SAMPLES :: "samples",
	}
	export RecordingDevice :: !foreign struct {
		using Object,
		getChannelCount :: (self:RecordingDevice) -> (channels:int) !foreign method "getChannelCount",
		getData         :: (self:RecordingDevice) -> (data:sound.SoundData) !foreign method "getData",
		getName         :: (self:RecordingDevice) -> (name:string) !foreign method "getName",
		getSampleCount  :: (self:RecordingDevice) -> (samples:int) !foreign method "getSampleCount",
		getSampleRate   :: (self:RecordingDevice) -> (rate:int--[[Correct?]]) !foreign method "getSampleRate",
		isRecording     :: (self:RecordingDevice) -> (recording:bool) !foreign method "isRecording",
		start           :: (self:RecordingDevice, samplecount:int, samplerate:int=8000, bitdepth:int=16, channels:int=1) -> (success:bool) !foreign method "start",
		stop            :: (self:RecordingDevice) -> (data:sound.SoundData) !foreign method "stop",
		getBitDepth :: (self:RecordingDevice) -> (bits:int) !foreign method "getBitDepth",
	}
	export Source :: !foreign struct {
		using Object,
		clone                   :: (self:Source) -> (source:Source) !foreign method "clone",
		getActiveEffects        :: (self:Source) -> (effects:[]string) !foreign method "getActiveEffects",
		getAirAbsorption        :: (self:Source) -> (amount:float) !foreign method "getAirAbsorption",
		getAttenuationDistances :: (self:Source) -> (ref:float, max:float) !foreign method "getAttenuationDistances",
		getChannelCount         :: (self:Source) -> (channels:int) !foreign method "getChannelCount",
		getCone                 :: (self:Source) -> (innerAngle,outerAngle:float, outerVolume:float) !foreign method "getCone",
		getDirection            :: (self:Source) -> (x,y,z:float) !foreign method "getDirection",
		getDuration             :: (self:Source, unit:TimeUnit=cast(TimeUnit)"seconds") -> (duration:float) !foreign method "getDuration",
		getFilter               :: (self:Source) -> (settings:FilterSettings|none) !foreign method "getFilter",
		getFreeBufferCount      :: (self:Source) -> (buffers:int) !foreign method "getFreeBufferCount",
		getPitch                :: (self:Source) -> (pitch:float) !foreign method "getPitch",
		getPosition             :: (self:Source) -> (x,y,z:float) !foreign method "getPosition",
		getRolloff              :: (self:Source) -> (rolloff:float) !foreign method "getRolloff",
		getType                 :: (self:Source) -> (sourcetype:SourceType) !foreign method "getType",
		getVelocity             :: (self:Source) -> (x,y,z:float) !foreign method "getVelocity",
		getVolume               :: (self:Source) -> (volume:float) !foreign method "getVolume",
		getVolumeLimits         :: (self:Source) -> (min,max:float) !foreign method "getVolumeLimits",
		isLooping               :: (self:Source) -> (loop:bool) !foreign method "isLooping",
		isPlaying               :: (self:Source) -> (playing:bool) !foreign method "isPlaying",
		isRelative              :: (self:Source) -> (relative:bool) !foreign method "isRelative",
		pause                   :: (self:Source) !foreign method "pause",
		play                    :: (self:Source) -> (success:bool) !foreign method "play",
		queue                   :: (self:Source, sounddata:sound.SoundData) -> (success:bool) !foreign method "queue",
		seek                    :: (self:Source, offset:float, unit:TimeUnit=cast(TimeUnit)"seconds") !foreign method "seek",
		setAirAbsorption        :: (self:Source, amount:float) !foreign method "setAirAbsorption",
		setAttenuationDistances :: (self:Source, ref:float, max:float) !foreign method "setAttenuationDistances",
		setCone                 :: (self:Source, innerAngle,outerAngle:float, outerVolume:float=0) !foreign method "setCone",
		setDirection            :: (self:Source, x,y,z:float) !foreign method "setDirection",
		setEffect               :: (self:Source, name:string, enable:bool=true) -> (success:bool) !foreign method "setEffect",
		setEffect               :: (self:Source, name:string, filtersettings:FilterSettings) -> (success:bool) !foreign method "setEffect",
		setFilter               :: (self:Source, settings:FilterSettings) -> (success:bool) !foreign method "setFilter",
		setFilter               :: (self:Source) !foreign method "setFilter",
		setLooping              :: (self:Source, loop:bool) !foreign method "setLooping",
		setPitch                :: (self:Source, pitch:float) !foreign method "setPitch",
		setPosition             :: (self:Source, x,y,z:float) !foreign method "setPosition",
		setRelative             :: (self:Source, enable:bool=false) !foreign method "setRelative",
		setRolloff              :: (self:Source, rolloff:float) !foreign method "setRolloff",
		setVelocity             :: (self:Source, x,y,z:float) !foreign method "setVelocity",
		setVolume               :: (self:Source, volume:float) !foreign method "setVolume",
		setVolumeLimits         :: (self:Source, min,max:float) !foreign method "setVolumeLimits",
		stop                    :: (self:Source) !foreign method "stop",
		tell                    :: (self:Source, unit:TimeUnit=cast(TimeUnit)"seconds") -> (position:float) !foreign method "tell",
		getEffect :: (self:Source, name:string)                                -> (filtersettings:FilterSettings|none) !foreign method "getEffect",
		getEffect :: (self:Source, name:string, filtersettings:FilterSettings) -> (filtersettings:FilterSettings|none) !foreign method "getEffect",
	}
	export getActiveEffects     :: () -> (effects:[]string) !foreign lua "love.audio.getActiveEffects"
	export getActiveSourceCount :: () -> (count:int) !foreign lua "love.audio.getActiveSourceCount"
	export getDistanceModel     :: () -> (model:DistanceModel) !foreign lua "love.audio.getDistanceModel"
	export getDopplerScale      :: () -> (scale:float) !foreign lua "love.audio.getDopplerScale"
	export getEffect            :: (name:string) -> (settings:EffectSettings) !foreign lua "love.audio.getEffect"
	export getMaxSceneEffects   :: () -> (maximum:int) !foreign lua "love.audio.getMaxSceneEffects"
	export getMaxSourceEffects  :: () -> (maximum:int) !foreign lua "love.audio.getMaxSourceEffects"
	export getOrientation       :: () -> (fx,fy,fz:float, ux,uy,uz:float) !foreign lua "love.audio.getOrientation"
	export getPosition          :: () -> (x,y,z:float) !foreign lua "love.audio.getPosition"
	export getRecordingDevices  :: () -> (devices:[]RecordingDevice) !foreign lua "love.audio.getRecordingDevices"
	export getSourceCount       :: () -> (numSources:int) !foreign lua "love.audio.getSourceCount"
	export getVelocity          :: () -> (x,y,z:float) !foreign lua "love.audio.getVelocity"
	export getVolume            :: () -> (volume:float) !foreign lua "love.audio.getVolume"
	export isEffectsSupported   :: () -> (supported:bool) !foreign lua "love.audio.isEffectsSupported"
	export newQueueableSource   :: (samplerate:int, bitdepth:int, channels:int, buffercount:int=0) -> (source:Source) !foreign lua "love.audio.newQueueableSource"
	export newSource            :: (filename:string, type:SourceType) -> (source:Source) !foreign lua "love.audio.newSource"
	export newSource            :: (file:filesystem.File, type:SourceType) -> (source:Source) !foreign lua "love.audio.newSource"
	export newSource            :: (decoder:sound.Decoder, type:SourceType) -> (source:Source) !foreign lua "love.audio.newSource"
	export newSource            :: (data:filesystem.FileData, type:SourceType) -> (source:Source) !foreign lua "love.audio.newSource"
	export newSource            :: (data:sound.SoundData) -> (source:Source) !foreign lua "love.audio.newSource"
	export setDistanceModel     :: (model:DistanceModel) !foreign lua "love.audio.setDistanceModel"
	export setDopplerScale      :: (scale:float) !foreign lua "love.audio.setDopplerScale"
	export setEffect            :: (name:string, settings:EffectSettings) -> (success:bool) !foreign lua "love.audio.setEffect"
	export setEffect            :: (name:string, enabled:bool=true) -> (success:bool) !foreign lua "love.audio.setEffect"
	export setMixWithSystem     :: (mix:bool) -> (success:bool) !foreign lua "love.audio.setMixWithSystem"
	export setOrientation       :: (fx,fy,fz:float, ux,uy,uz:float) !foreign lua "love.audio.setOrientation"
	export setPosition          :: (x,y,z:float) !foreign lua "love.audio.setPosition"
	export setVelocity          :: (x,y,z:float) !foreign lua "love.audio.setVelocity"
	export setVolume            :: (volume:float) !foreign lua "love.audio.setVolume"
	export pause :: () -> (sources:[]Source)    !foreign lua "love.audio.pause"
	export pause :: (source:Source, ...:Source) !foreign lua "love.audio.pause"
	export pause :: (sources:[]Source)          !foreign lua "love.audio.pause"
	export play :: (source,...:Source) !foreign lua "love.audio.play"
	export play :: (sources:[]Source)  !foreign lua "love.audio.play"
	export stop :: (...:Source)       !foreign lua "love.audio.stop"
	export stop :: (sources:[]Source) !foreign lua "love.audio.stop"
	export FilterSettings :: struct {
		type = FilterType.LOWPASS,
		volume:   float,
		highgain: float,
		lowgain:  float,
	}
	export EffectSettings :: struct {
		type   = EffectType.REVERB,
		volume = 1.0,
	
		-- Chorus...
		waveform:EffectWaveform|none = nil,
		phase:            float|none = nil,
		rate:             float|none = nil,
		depth:            float|none = nil,
		feedback:         float|none = nil,
		delay:            float|none = nil,
	
		-- Compressor...
		enable:            bool|none = nil,
	
		-- Distortion...
		gain:             float|none = nil,
		edge:             float|none = nil,
		lowcut:           float|none = nil,
		center:           float|none = nil,
		bandwidth:        float|none = nil,
	
		-- Echo...
		--delay
		tapdelay:         float|none = nil,
		damping:          float|none = nil,
		--feedback
		spread:           float|none = nil,
	
		-- Equalizer...
		lowgain:          float|none = nil,
		--lowcut
		lowmidgain:       float|none = nil,
		lowmidfrequency:  float|none = nil,
		lowmidbandwidth:  float|none = nil,
		highmidgain:      float|none = nil,
		highmidfrequency: float|none = nil,
		highmidbandwidth: float|none = nil,
		highgain:         float|none = nil,
		highcut:          float|none = nil,
	
		-- Flanger...
		--waveform
		--phase
		--rate
		--depth
		--feedback
		--delay
	
		-- Reverb...
		--gain
		--highgain
		density:          float|none = nil,
		diffusion:        float|none = nil,
		decaytime:        float|none = nil,
		decayhighratio:   float|none = nil,
		earlygain:        float|none = nil,
		earlydelay:       float|none = nil,
		lategain:         float|none = nil,
		latedelay:        float|none = nil,
		roomrolloff:      float|none = nil,
		airabsorption:    float|none = nil,
		highlimit:         bool|none = nil,
	
		-- Ringmodulator...
		--waveform
		frequency:        float|none = nil,
		--highcut
	}
}
export data :: namespace {
	export ContainerType :: enum {
		DATA   :: "data",
		STRING :: "string",
	}
	export EncodeFormat :: enum {
		BASE64 :: "base64",
		HEX    :: "hex",
	}
	export HashFunction :: enum {
		MD5    :: "md5",
		SHA1   :: "sha1",
		SHA224 :: "sha224",
		SHA256 :: "sha256",
		SHA384 :: "sha384",
		SHA512 :: "sha512",
	}
	export ByteData :: !foreign struct {
		using Data,
	}
	export getPackedSize :: (format:string) -> (size:int) !foreign lua "love.data.getPackedSize"
	export hash          :: (hashFunction:HashFunction, \string:string) -> (rawdigest:string) !foreign lua "love.data.hash"
	export hash          :: (hashFunction:HashFunction, data:Data) -> (rawdigest:string) !foreign lua "love.data.hash"
	export newDataView   :: (data:Data, offset:int, size:int) -> (view:Data) !foreign lua "love.data.newDataView"
	export compress   :: (container:ContainerType, format:math.CompressedDataFormat, data:string|Data, level:int=-1) -> (compressedData:string|math.CompressedData) !foreign lua "love.data.compress"
	export decompress :: (container:ContainerType, compressedData:math.CompressedData)                 -> (decompressedData:string|Data) !foreign lua "love.data.decompress"
	export decompress :: (container:ContainerType, format:math.CompressedDataFormat, data:string|Data) -> (decompressedData:string|Data) !foreign lua "love.data.decompress"
	export encode :: (container:ContainerType, format:EncodeFormat, data:string|Data, linelength:int=0) -> (encoded:string|ByteData) !foreign lua "love.data.encode"
	export decode :: (container:ContainerType, format:EncodeFormat, data:string|Data) -> (decoded:string|ByteData) !foreign lua "love.data.decode"
	export pack   :: (container:ContainerType, format:string, v1,...:int|float|bool|string) -> (data:string|Data) !foreign lua "love.data.pack"
	export unpack :: (format:string, data:string|Data, pos:int=1) -> (v1,...:int|float|bool|string--[[last value is index:int]]) !foreign lua "love.data.unpack"
	export newByteData :: (dataString:string)                                -> (byteData:ByteData) !foreign lua "love.data.newByteData"
	export newByteData :: (data:Data, offset=0, size=0--[[data.getSize!()]]) -> (byteData:ByteData) !foreign lua "love.data.newByteData"
	export newByteData :: (size:int)                                         -> (byteData:ByteData) !foreign lua "love.data.newByteData"
}
export event :: namespace {
	export Event :: enum {
		FOCUS             :: "focus",
		JOYSTICK_PRESSED  :: "joystickpressed",
		JOYSTICK_RELEASED :: "joystickreleased",
		KEY_PRESSED       :: "keypressed",
		KEY_RELEASED      :: "keyreleased",
		MOUSE_PRESSED     :: "mousepressed",
		MOUSE_RELEASED    :: "mousereleased",
		QUIT              :: "quit",
		RESIZE            :: "resize",
		VISIBLE           :: "visible",
		MOUSE_FOCUS       :: "mousefocus",
		THREAD_ERROR      :: "threaderror",
		JOYSTICK_ADDED    :: "joystickadded",
		JOYSTICK_REMOVED  :: "joystickremoved",
		JOYSTICK_AXIS     :: "joystickaxis",
		JOYSTICK_HAT      :: "joystickhat",
		GAMEPAD_PRESSED   :: "gamepadpressed",
		GAMEPAD_RELEASED  :: "gamepadreleased",
		GAMEPAD_AXIS      :: "gamepadaxis",
		TEXT_INPUT        :: "textinput",
		MOUSE_MOVED       :: "mousemoved",
		LOW_MEMORY        :: "lowmemory",
		TEXT_EDITED       :: "textedited",
		WHEEL_MOVED       :: "wheelmoved",
		TOUCH_PRESSED     :: "touchpressed",
		TOUCH_RELEASED    :: "touchreleased",
		TOUCH_MOVED       :: "touchmoved",
		DIRECTORY_DROPPED :: "directorydropped",
		FILE_DROPPED      :: "filedropped",
	}
	export clear :: () !foreign lua "love.event.clear"
	export pump  :: () !foreign lua "love.event.pump"
	export wait  :: () -> (n:Event, a:Variant, b:Variant, c:Variant, d:Variant, e:Variant, f:Variant, ...:Variant) !foreign lua "love.event.wait"
	export poll :: () -> (iter:(_1,_2:none)->(n:event.Event|none, a,b,c,d,e,f:Variant), _1:none, _2:none) !foreign lua "love.event.poll"
	export push :: (n:Event, ...:Variant) !foreign lua "love.event.push"
	export quit :: (exitstatus:int=0) !foreign lua "love.event.quit"
	export restart :: () !foreign lua "function() love.event.quit'restart' end"
}
export filesystem :: namespace {
	export BufferMode :: enum {
		NONE :: "none",
		LINE :: "line",
		FULL :: "full",
	}
	export FileDecoder :: enum {
		FILE   :: "file",
		BASE64 :: "base64",
	}
	export FileMode :: enum {
		READ   :: "r",
		WRITE  :: "w",
		APPEND :: "a",
		CLOSED :: "c",
	}
	export FileType :: enum {
		FILE      :: "file",
		DIRECTORY :: "directory",
		SYMLINK   :: "symlink",
		OTHER     :: "other",
	}
	export File :: !foreign struct {
		using Object,
		close       :: (self:File) -> (success:bool) !foreign method "close",
		flush       :: (self:File) -> (success:bool, err:string) !foreign method "flush",
		getBuffer   :: (self:File) -> (mode:BufferMode, size:int) !foreign method "getBuffer",
		getFilename :: (self:File) -> (filename:string) !foreign method "getFilename",
		getMode     :: (self:File) -> (mode:FileMode) !foreign method "getMode",
		getSize     :: (self:File) -> (size:int) !foreign method "getSize",
		isEOF       :: (self:File) -> (eof:bool) !foreign method "isEOF",
		isOpen      :: (self:File) -> (open:bool) !foreign method "isOpen",
		open        :: (self:File, mode:FileMode) -> (ok:bool, err:string) !foreign method "open",
		seek        :: (self:File, pos:int) -> (success:bool) !foreign method "seek",
		setBuffer   :: (self:File, mode:BufferMode, size:int=0) -> (success:bool, errorstr:string) !foreign method "setBuffer",
		tell        :: (self:File) -> (pos:int) !foreign method "tell",
		lines :: (self:File) -> (iterator:(_1,_2:none)->(line:string|none), _1,_2:none) !foreign method "lines",
		read :: (self:File)            -> (contents:string|none, sizeOrError:int|string) !foreign method "read",
		read :: (self:File, bytes:int) -> (contents:string|none, sizeOrError:int|string) !foreign method "read",
		read :: (self:File, container:data.ContainerType)            -> (contents:string|FileData|none, sizeOrError:int|string) !foreign method "read",
		read :: (self:File, container:data.ContainerType, bytes:int) -> (contents:string|FileData|none, sizeOrError:int|string) !foreign method "read",
		write :: (self:File, data:string|Data)           -> (success:bool, err:string) !foreign method "write",
		write :: (self:File, data:string|Data, size:int) -> (success:bool, err:string) !foreign method "write",
	}
	export FileData :: !foreign struct {
		using Data,
		getExtension :: (self:FileData) -> (ext:string) !foreign method "getExtension",
		getFilename  :: (self:FileData) -> (name:string) !foreign method "getFilename",
	}
	export areSymlinksEnabled     :: () -> (enable:bool) !foreign lua "love.filesystem.areSymlinksEnabled"
	export createDirectory        :: (name:string) -> (success:bool) !foreign lua "love.filesystem.createDirectory"
	export getAppdataDirectory    :: () -> (path:string) !foreign lua "love.filesystem.getAppdataDirectory"
	export getCRequirePath        :: () -> (paths:string) !foreign lua "love.filesystem.getCRequirePath"
	export getIdentity            :: () -> (name:string) !foreign lua "love.filesystem.getIdentity"
	export getRealDirectory       :: (filepath:string) -> (realdir:string) !foreign lua "love.filesystem.getRealDirectory"
	export getRequirePath         :: () -> (paths:string) !foreign lua "love.filesystem.getRequirePath"
	export getSaveDirectory       :: () -> (dir:string) !foreign lua "love.filesystem.getSaveDirectory"
	export getSource              :: () -> (path:string) !foreign lua "love.filesystem.getSource"
	export getSourceBaseDirectory :: () -> (path:string) !foreign lua "love.filesystem.getSourceBaseDirectory"
	export getUserDirectory       :: () -> (path:string) !foreign lua "love.filesystem.getUserDirectory"
	export getWorkingDirectory    :: () -> (cwd:string) !foreign lua "love.filesystem.getWorkingDirectory"
	export init                   :: (appname:string) !foreign lua "love.filesystem.init"
	export isFused                :: () -> (fused:bool) !foreign lua "love.filesystem.isFused"
	export mount                  :: (archive:string, mountpoint:string, appendToPath:bool=false) -> (success:bool) !foreign lua "love.filesystem.mount"
	export mount                  :: (filedata:FileData, mountpoint:string, appendToPath:bool=false) -> (success:bool) !foreign lua "love.filesystem.mount"
	export mount                  :: (data:Data, archivename:string, mountpoint:string, appendToPath:bool=false) -> (success:bool) !foreign lua "love.filesystem.mount"
	export newFileData            :: (contents:string, name:string) -> (data:FileData) !foreign lua "love.filesystem.newFileData"
	export newFileData            :: (filepath:string) -> (data:FileData, err:string) !foreign lua "love.filesystem.newFileData"
	export remove                 :: (name:string) -> (success:bool) !foreign lua "love.filesystem.remove"
	export setCRequirePath        :: (paths:string) !foreign lua "love.filesystem.setCRequirePath"
	export setRequirePath         :: (paths:string) !foreign lua "love.filesystem.setRequirePath"
	export setSource              :: (path:string) !foreign lua "love.filesystem.setSource"
	export setSymlinksEnabled     :: (enable:bool) !foreign lua "love.filesystem.setSymlinksEnabled"
	export unmount                :: (archive:string) -> (success:bool) !foreign lua "love.filesystem.unmount"
	export DroppedFile :: !foreign struct { using File }
	export append :: (name:Filename, data:string|Data)           -> (success:bool, errormsg:string) !foreign lua "love.filesystem.append"
	export append :: (name:Filename, data:string|Data, size:int) -> (success:bool, errormsg:string) !foreign lua "love.filesystem.append"
	export getDirectoryItems :: (dir:Filename)                               -> (files:[]Filename) !foreign lua "love.filesystem.getDirectoryItems"
	export getDirectoryItems :: (dir:Filename, callback:(filename:Filename)) -> (files:[]Filename) !foreign lua "love.filesystem.getDirectoryItems"
	export FileInfo :: struct { type=FileType.FILE, size:int|none=nil, modtime:int|none=nil }
	export getInfo :: (path:Filename)                                   -> (info:FileInfo|none) !foreign lua "love.filesystem.getInfo"
	export getInfo :: (path:Filename, fileType:FileType)                -> (info:FileInfo|none) !foreign lua "love.filesystem.getInfo"
	export getInfo :: (path:Filename, info:FileInfo)                    -> (info:FileInfo|none) !foreign lua "love.filesystem.getInfo"
	export getInfo :: (path:Filename, fileType:FileType, info:FileInfo) -> (info:FileInfo|none) !foreign lua "love.filesystem.getInfo"
	export lines :: (name:Filename) -> (iterator:(_1,_2:none)->(line:string|none), _1,_2:none) !foreign lua "love.filesystem.lines"
	export load :: (name:Filename, $FunctionSignature:Type) -> (chunk:FunctionSignature, errormsg:string) !foreign lua "love.filesystem.load"
	export read :: (name:Filename)           -> (contents:string|none, sizeOrError:int|string) !foreign lua "love.filesystem.read"
	export read :: (name:Filename, size:int) -> (contents:string|none, sizeOrError:int|string) !foreign lua "love.filesystem.read"
	export read :: (container:data.ContainerType, name:Filename)           -> (contents:string|FileData|none, sizeOrError:int|string) !foreign lua "love.filesystem.read"
	export read :: (container:data.ContainerType, name:Filename, size:int) -> (contents:string|FileData|none, sizeOrError:int|string) !foreign lua "love.filesystem.read"
	export write :: (name:Filename, data:string|Data)           -> (success:bool, message:string) !foreign lua "love.filesystem.write"
	export write :: (name:Filename, data:string|Data, size:int) -> (success:bool, message:string) !foreign lua "love.filesystem.write"
	export newFile :: (filename:Filename)                -> (file:File)                       !foreign lua "love.filesystem.newFile"
	export newFile :: (filename:Filename, mode:FileMode) -> (file:File|none, err:none|string) !foreign lua "love.filesystem.newFile"
	export setIdentity :: (name:Filename, appendToPath=false) !foreign lua "love.filesystem.setIdentity"
}
export graphics :: namespace {
	export AlignMode :: enum {
		CENTER  :: "center",
		LEFT    :: "left",
		RIGHT   :: "right",
		JUSTIFY :: "justify",
	}
	export ArcType :: enum {
		PIE    :: "pie",
		OPEN   :: "open",
		CLOSED :: "closed",
	}
	export AreaSpreadDistribution :: enum {
		UNIFORM          :: "uniform",
		NORMAL           :: "normal",
		ELLIPSE          :: "ellipse",
		BORDER_ELLIPSE   :: "borderellipse",
		BORDER_RECTANGLE :: "borderrectangle",
		NONE             :: "none",
	}
	export BlendAlphaMode :: enum {
		ALPHAMULTIPLY :: "alphamultiply",
		PREMULTIPLIED :: "premultiplied",
	}
	export BlendMode :: enum {
		ALPHA    :: "alpha",
		REPLACE  :: "replace",
		SCREEN   :: "screen",
		ADD      :: "add",
		SUBTRACT :: "subtract",
		MULTIPLY :: "multiply",
		LIGHTEN  :: "lighten",
		DARKEN   :: "darken",
	}
	export CanvasMipmapMode :: enum {
		NONE   :: "none",
		AUTO   :: "auto",
		MANUAL :: "manual",
	}
	export CompareMode :: enum {
		NEVER  :: "never",
		ALWAYS :: "always",
	}
	export CullMode :: enum {
		BACK  :: "back",
		FRONT :: "front",
		NONE  :: "none",
	}
	export DrawMode :: enum {
		FILL :: "fill",
		LINE :: "line",
	}
	export FilterMode :: enum {
		LINEAR  :: "linear",
		NEAREST :: "nearest",
	}
	export GraphicsFeature :: enum {
		CLAMP_ZERO           :: "clampzero",
		LIGHTEN              :: "lighten",
		MULTI_CANVAS_FORMATS :: "multicanvasformats",
		GLSL3                :: "glsl3",
		INSTANCING           :: "instancing",
		FULL_NPOT            :: "fullnpot",
		PIXEL_SHADER_HIGH_P  :: "pixelshaderhighp",
		SHADER_DERIVATIVES   :: "shaderderivatives",
		CANVAS               :: "canvas",
		NPOT                 :: "npot",
		SUBTRACTIVE          :: "subtractive",
		SHADER               :: "shader",
		HDR_CANVAS           :: "hdrcanvas",
		MULTI_CANVAS         :: "multicanvas",
		MIPMAP               :: "mipmap",
		DXT                  :: "dxt",
		BC5                  :: "bc5",
		SRGB                 :: "srgb",
		PIXEL_EFFECT         :: "pixeleffect",
	}
	export GraphicsLimit :: enum {
		POINT_SIZE          :: "pointsize",
		TEXTURE_SIZE        :: "texturesize",
		MULTI_CANVAS        :: "multicanvas",
		CANVAS_MSAA         :: "canvasmsaa",
		TEXTURE_LAYERS      :: "texturelayers",
		VOLUME_TEXTURE_SIZE :: "volumetexturesize",
		CUBE_TEXTURE_SIZE   :: "cubetexturesize",
		ANISOTROPY          :: "anisotropy",
		CANVAS_FSAA         :: "canvasfsaa",
	}
	export LineJoin :: enum {
		MITER :: "miter",
		NONE  :: "none",
		BEVEL :: "bevel",
	}
	export LineStyle :: enum {
		ROUGH  :: "rough",
		SMOOTH :: "smooth",
	}
	export MeshDrawMode :: enum {
		FAN       :: "fan",
		STRIP     :: "strip",
		TRIANGLES :: "triangles",
		POINTS    :: "points",
	}
	export ParticleInsertMode :: enum {
		TOP    :: "top",
		BOTTOM :: "bottom",
		RANDOM :: "random",
	}
	export SpriteBatchUsage :: enum {
		DYNAMIC :: "dynamic",
		STATIC  :: "static",
		STREAM  :: "stream",
	}
	export StackType :: enum {
		TRANSFORM :: "transform",
		ALL       :: "all",
	}
	export StencilAction :: enum {
		REPLACE       :: "replace",
		INCREMENT     :: "increment",
		DECREMENT     :: "decrement",
		INCREMENTWRAP :: "incrementwrap",
		DECREMENTWRAP :: "decrementwrap",
		INVERT        :: "invert",
	}
	export TextureType :: enum {
		TWOD   :: "2d",
		ARRAY  :: "array",
		CUBE   :: "cube",
		VOLUME :: "volume",
	}
	export WrapMode :: enum {
		CLAMP           :: "clamp",
		REPEAT          :: "repeat",
		MIRRORED_REPEAT :: "mirroredrepeat",
		CLAMP_ZERO      :: "clampzero",
	}
	export Canvas :: !foreign struct {
		using Texture,
		generateMipmaps :: (self:Canvas) !foreign method "generateMipmaps",
		getDimensions   :: (self:Canvas) -> (width,height:int) !foreign method "getDimensions",
		getHeight       :: (self:Canvas) -> (height:int) !foreign method "getHeight",
		getMSAA         :: (self:Canvas) -> (samples:int) !foreign method "getMSAA",
		getMipmapMode   :: (self:Canvas) -> (mode:MipmapMode) !foreign method "getMipmapMode",
		getWidth        :: (self:Canvas) -> (width:int) !foreign method "getWidth",
		getWrap         :: (self:Canvas) -> (horiz,vert:WrapMode) !foreign method "getWrap",
		setWrap         :: (self:Canvas, horiz,vert:WrapMode) !foreign method "setWrap",
		newImageData :: (self:Canvas)                                                   -> (data:image.ImageData) !foreign method "newImageData",
		newImageData :: (self:Canvas, slice:int, mipmap:int, x,y:int, width,height:int) -> (data:image.ImageData) !foreign method "newImageData",
		renderTo :: (self:Canvas, func:()) !foreign method "renderTo",
		getFilter :: (self:Canvas) -> (min,mag:FilterMode, anisotropy:int) !foreign method "getFilter",
		setFilter :: (self:Canvas, min,mag:FilterMode, anisotropy:int=1)   !foreign method "setFilter",
	}
	export Drawable :: !foreign struct {
		using Object,
	}
	export Font :: !foreign struct {
		using Object,
		getAscent     :: (self:Font) -> (ascent:int) !foreign method "getAscent",
		getBaseline   :: (self:Font) -> (baseline:int) !foreign method "getBaseline",
		getDPIScale   :: (self:Font) -> (dpiscale:int--[[Correct?]]) !foreign method "getDPIScale",
		getDescent    :: (self:Font) -> (descent:int) !foreign method "getDescent",
		getFilter     :: (self:Font) -> (min,mag:FilterMode, anisotropy:int) !foreign method "getFilter",
		getHeight     :: (self:Font) -> (height:int) !foreign method "getHeight",
		getLineHeight :: (self:Font) -> (height:float) !foreign method "getLineHeight",
		getWidth      :: (self:Font, text:string) -> (width:int) !foreign method "getWidth",
		getWrap       :: (self:Font, text:string, wraplimit:int) -> (width:int, wrappedtext:[]string) !foreign method "getWrap",
		hasGlyphs     :: (self:Font, text:string) -> (hasglyph:bool) !foreign method "hasGlyphs",
		hasGlyphs     :: (self:Font, character1:string, character2:string) -> (hasglyph:bool) !foreign method "hasGlyphs",
		hasGlyphs     :: (self:Font, codepoint1:int, codepoint2:int) -> (hasglyph:bool) !foreign method "hasGlyphs",
		setFallbacks  :: (self:Font, fallbackfont1:Font, ...:Font) !foreign method "setFallbacks",
		setFilter     :: (self:Font, min,mag:FilterMode, anisotropy:int=1) !foreign method "setFilter",
		setLineHeight :: (self:Font, height:float) !foreign method "setLineHeight",
	}
	export Image :: !foreign struct {
		using Texture,
		getDimensions :: (self:Image) -> (width,height:int) !foreign method "getDimensions",
		getFlags      :: (self:Image) -> (flags:ImageFlags) !foreign method "getFlags",
		getHeight     :: (self:Image) -> (height:int) !foreign method "getHeight",
		getWidth      :: (self:Image) -> (width:int) !foreign method "getWidth",
		getWrap       :: (self:Image) -> (horiz,vert:WrapMode) !foreign method "getWrap",
		setWrap       :: (self:Image, horiz,vert:WrapMode) !foreign method "setWrap",
		getFilter :: (self:Image) -> (min,mag:FilterMode, anisotropy:int) !foreign method "getFilter",
		setFilter :: (self:Image, min,mag:FilterMode, anisotropy:int=1)   !foreign method "setFilter",
		replacePixels :: (self:Image, data:image.ImageData, slice:int, mipmap:int=1, x:int=0, y:int=0, reloadMipmaps:bool=false--[[true if image was created with mipmaps]]) !foreign method "replacePixels",
	}
	export Mesh :: !foreign struct {
		using Drawable,
		detachAttribute     :: (self:Mesh, name:string) -> (success:bool) !foreign method "detachAttribute",
		getDrawMode         :: (self:Mesh) -> (mode:MeshDrawMode) !foreign method "getDrawMode",
		getDrawRange        :: (self:Mesh) -> (min,max:int) !foreign method "getDrawRange",
		getTexture          :: (self:Mesh) -> (texture:Texture) !foreign method "getTexture",
		getVertexCount      :: (self:Mesh) -> (count:int) !foreign method "getVertexCount",
		getVertexFormat     :: (self:Mesh) -> (format:[]VertexAttribute) !foreign method "getVertexFormat",
		getVertexMap        :: (self:Mesh) -> (map:([]int)|none) !foreign method "getVertexMap",
		isAttributeEnabled  :: (self:Mesh, name:string) -> (enabled:bool) !foreign method "isAttributeEnabled",
		setAttributeEnabled :: (self:Mesh, name:string, enable:bool) !foreign method "setAttributeEnabled",
		setDrawMode         :: (self:Mesh, mode:MeshDrawMode) !foreign method "setDrawMode",
		setDrawRange        :: (self:Mesh, start:int, count:int) !foreign method "setDrawRange",
		setDrawRange        :: (self:Mesh) !foreign method "setDrawRange",
		setTexture          :: (self:Mesh, texture:Texture) !foreign method "setTexture",
		setTexture          :: (self:Mesh) !foreign method "setTexture",
		getCustomVertex   :: (self:Mesh, index:int) -> (attributeComponent,...:float) !foreign method "getVertex",
		getStandardVertex :: (self:Mesh, index:int) -> (x,y,u,v:float, r,g,b,a:float) !foreign method "getVertex",
		setVertices :: (self:Mesh, vertices:[]Vertex, startVertex=1) !foreign method "setVertices",
		setVertices :: (self:Mesh, data:Data,         startvertex=1) !foreign method "setVertices",
		getVertexAttribute :: (self:Mesh, vertexIndex:int, attributeIndex:int) -> (value1,...:float) !foreign method "getVertexAttribute",
		setVertexAttribute :: (self:Mesh, vertexIndex:int, attributeIndex:int, value1,...:float)     !foreign method "setVertexAttribute",
		attachAttribute :: (self:Mesh, name:string, mesh:Mesh, step=VertexAttributeStep.PER_VERTEX, attachName:string=name) !foreign method "attachAttribute",
	}
	export ParticleSystem :: !foreign struct {
		using Drawable,
		clone                     :: (self:ParticleSystem) -> (particlesystem:ParticleSystem) !foreign method "clone",
		emit                      :: (self:ParticleSystem, numparticles:int) !foreign method "emit",
		getBufferSize             :: (self:ParticleSystem) -> (size:int) !foreign method "getBufferSize",
		getCount                  :: (self:ParticleSystem) -> (count:int) !foreign method "getCount",
		getDirection              :: (self:ParticleSystem) -> (direction:float) !foreign method "getDirection",
		getEmissionArea           :: (self:ParticleSystem) -> (distribution:AreaSpreadDistribution, dx,dy:float, angle:float, directionRelativeToCenter:bool) !foreign method "getEmissionArea",
		getEmissionRate           :: (self:ParticleSystem) -> (rate:float) !foreign method "getEmissionRate",
		getEmitterLifetime        :: (self:ParticleSystem) -> (life:float) !foreign method "getEmitterLifetime",
		getInsertMode             :: (self:ParticleSystem) -> (mode:ParticleInsertMode) !foreign method "getInsertMode",
		getLinearAcceleration     :: (self:ParticleSystem) -> (xmin,ymin:float, xmax,ymax:float) !foreign method "getLinearAcceleration",
		getLinearDamping          :: (self:ParticleSystem) -> (min,max:float) !foreign method "getLinearDamping",
		getOffset                 :: (self:ParticleSystem) -> (ox,oy:float) !foreign method "getOffset",
		getParticleLifetime       :: (self:ParticleSystem) -> (min,max:float) !foreign method "getParticleLifetime",
		getPosition               :: (self:ParticleSystem) -> (x,y:float) !foreign method "getPosition",
		getQuads                  :: (self:ParticleSystem) -> (quads:[]Quad) !foreign method "getQuads",
		getRadialAcceleration     :: (self:ParticleSystem) -> (min,max:float) !foreign method "getRadialAcceleration",
		getRotation               :: (self:ParticleSystem) -> (min,max:float) !foreign method "getRotation",
		getSizeVariation          :: (self:ParticleSystem) -> (variation:float) !foreign method "getSizeVariation",
		getSpeed                  :: (self:ParticleSystem) -> (min,max:float) !foreign method "getSpeed",
		getSpin                   :: (self:ParticleSystem) -> (min,max:float, variation:float) !foreign method "getSpin",
		getSpinVariation          :: (self:ParticleSystem) -> (variation:float) !foreign method "getSpinVariation",
		getSpread                 :: (self:ParticleSystem) -> (spread:float) !foreign method "getSpread",
		getTangentialAcceleration :: (self:ParticleSystem) -> (min,max:float) !foreign method "getTangentialAcceleration",
		getTexture                :: (self:ParticleSystem) -> (texture:Texture) !foreign method "getTexture",
		hasRelativeRotation       :: (self:ParticleSystem) -> (enable:bool) !foreign method "hasRelativeRotation",
		isActive                  :: (self:ParticleSystem) -> (active:bool) !foreign method "isActive",
		isPaused                  :: (self:ParticleSystem) -> (paused:bool) !foreign method "isPaused",
		isStopped                 :: (self:ParticleSystem) -> (stopped:bool) !foreign method "isStopped",
		moveTo                    :: (self:ParticleSystem, x,y:float) !foreign method "moveTo",
		pause                     :: (self:ParticleSystem) !foreign method "pause",
		reset                     :: (self:ParticleSystem) !foreign method "reset",
		setBufferSize             :: (self:ParticleSystem, size:int) !foreign method "setBufferSize",
		setDirection              :: (self:ParticleSystem, direction:float) !foreign method "setDirection",
		setEmissionArea           :: (self:ParticleSystem, distribution:AreaSpreadDistribution, dx,dy:float, angle:float=0, directionRelativeToCenter:bool=false) !foreign method "setEmissionArea",
		setEmissionRate           :: (self:ParticleSystem, rate:float) !foreign method "setEmissionRate",
		setEmitterLifetime        :: (self:ParticleSystem, life:float) !foreign method "setEmitterLifetime",
		setInsertMode             :: (self:ParticleSystem, mode:ParticleInsertMode) !foreign method "setInsertMode",
		setLinearAcceleration     :: (self:ParticleSystem, xmin,ymin:float, xmax:float=xmin, ymax:float=ymin) !foreign method "setLinearAcceleration",
		setLinearDamping          :: (self:ParticleSystem, min:float, max:float=min) !foreign method "setLinearDamping",
		setOffset                 :: (self:ParticleSystem, x,y:float) !foreign method "setOffset",
		setParticleLifetime       :: (self:ParticleSystem, min:float, max:float=min) !foreign method "setParticleLifetime",
		setPosition               :: (self:ParticleSystem, x,y:float) !foreign method "setPosition",
		setRadialAcceleration     :: (self:ParticleSystem, min:float, max:float=min) !foreign method "setRadialAcceleration",
		setRelativeRotation       :: (self:ParticleSystem, enable:bool) !foreign method "setRelativeRotation",
		setRotation               :: (self:ParticleSystem, min:float, max:float=min) !foreign method "setRotation",
		setSizeVariation          :: (self:ParticleSystem, variation:float) !foreign method "setSizeVariation",
		setSpeed                  :: (self:ParticleSystem, min:float, max:float=min) !foreign method "setSpeed",
		setSpin                   :: (self:ParticleSystem, min:float, max:float=min) !foreign method "setSpin",
		setSpinVariation          :: (self:ParticleSystem, variation:float) !foreign method "setSpinVariation",
		setSpread                 :: (self:ParticleSystem, spread:float) !foreign method "setSpread",
		setTangentialAcceleration :: (self:ParticleSystem, min:float, max:float=min) !foreign method "setTangentialAcceleration",
		setTexture                :: (self:ParticleSystem, texture:Texture) !foreign method "setTexture",
		start                     :: (self:ParticleSystem) !foreign method "start",
		stop                      :: (self:ParticleSystem) !foreign method "stop",
		update                    :: (self:ParticleSystem, dt:float) !foreign method "update",
		setQuads :: (self:ParticleSystem, quads:[]Quad) !foreign method "setQuads",
		setQuads :: (self:ParticleSystem, ...:Quad)     !foreign method "setQuads",
		getColors :: (self:ParticleSystem) -> (r1,g1,b1,a1:float, r2,g2,b2,a2,r3,g3,b3,a3,r4,g4,b4,a4,r5,g5,b5,a5,r6,g6,b6,a6,r7,g7,b7,a7,r8,g8,b8,a8:float|none) !foreign method "getColors",
		getColorsAsVararg :: (self:ParticleSystem) -> (r1,g1,b1,a1,...:float) !foreign method "getColors",
		setColors :: (self:ParticleSystem, r1,g1,b1,a1:float)                                                                                     !foreign method "setColors",
		setColors :: (self:ParticleSystem, r1,g1,b1,a1,r2,g2,b2,a2:float)                                                                         !foreign method "setColors",
		setColors :: (self:ParticleSystem, r1,g1,b1,a1,r2,g2,b2,a2,r3,g3,b3,a3:float)                                                             !foreign method "setColors",
		setColors :: (self:ParticleSystem, r1,g1,b1,a1,r2,g2,b2,a2,r3,g3,b3,a3,r4,g4,b4,a4:float)                                                 !foreign method "setColors",
		setColors :: (self:ParticleSystem, r1,g1,b1,a1,r2,g2,b2,a2,r3,g3,b3,a3,r4,g4,b4,a4,r5,g5,b5,a5:float)                                     !foreign method "setColors",
		setColors :: (self:ParticleSystem, r1,g1,b1,a1,r2,g2,b2,a2,r3,g3,b3,a3,r4,g4,b4,a4,r5,g5,b5,a5,r6,g6,b6,a6:float)                         !foreign method "setColors",
		setColors :: (self:ParticleSystem, r1,g1,b1,a1,r2,g2,b2,a2,r3,g3,b3,a3,r4,g4,b4,a4,r5,g5,b5,a5,r6,g6,b6,a6,r7,g7,b7,a7:float)             !foreign method "setColors",
		setColors :: (self:ParticleSystem, r1,g1,b1,a1,r2,g2,b2,a2,r3,g3,b3,a3,r4,g4,b4,a4,r5,g5,b5,a5,r6,g6,b6,a6,r7,g7,b7,a7,r8,g8,b8,a8:float) !foreign method "setColors",
		setColors :: (self:ParticleSystem, colors:[]float) {
			local _setColors :: (self:ParticleSystem, ...:float) !foreign method "setColors"
			local unpack     :: (arr:[]$T) -> ...T !foreign lua "unpack"
			_setColors(self, unpack(colors))
		},
		getSizes :: (self:ParticleSystem) -> (size1:float, size2,size3,size4,size5,size6,size7,size8:float|none) !foreign method "getSizes",
		getSizesAsVararg :: (self:ParticleSystem) -> (size1,...:float) !foreign method "getSizes",
		setSizes :: (self:ParticleSystem, size1:float)                                           !foreign method "setSizes",
		setSizes :: (self:ParticleSystem, size1,size2:float)                                     !foreign method "setSizes",
		setSizes :: (self:ParticleSystem, size1,size2,size3:float)                               !foreign method "setSizes",
		setSizes :: (self:ParticleSystem, size1,size2,size3,size4:float)                         !foreign method "setSizes",
		setSizes :: (self:ParticleSystem, size1,size2,size3,size4,size5:float)                   !foreign method "setSizes",
		setSizes :: (self:ParticleSystem, size1,size2,size3,size4,size5,size6:float)             !foreign method "setSizes",
		setSizes :: (self:ParticleSystem, size1,size2,size3,size4,size5,size6,size7:float)       !foreign method "setSizes",
		setSizes :: (self:ParticleSystem, size1,size2,size3,size4,size5,size6,size7,size8:float) !foreign method "setSizes",
		setSizes :: (self:ParticleSystem, sizes:[]float) {
			local _setSizes :: (self:ParticleSystem, ...:float) !foreign method "setSizes"
			local unpack    :: (arr:[]$T) -> ...T !foreign lua "unpack"
			_setSizes(self, unpack(sizes))
		},
	}
	export Quad :: !foreign struct {
		using Object,
		getTextureDimensions :: (self:Quad) -> (sw,sh:float) !foreign method "getTextureDimensions",
		getViewport          :: (self:Quad) -> (x,y:float, w,h:float) !foreign method "getViewport",
		setViewport          :: (self:Quad, x,y:float, w,h:float, sw,sh:float) !foreign method "setViewport",
		setViewport :: (self:Quad, x,y:float, w,h:float) !foreign method "setViewport",
	}
	export Shader :: !foreign struct {
		using Object,
		getWarnings :: (self:Shader) -> (warnings:string) !foreign method "getWarnings",
		hasUniform  :: (self:Shader, name:string) -> (hasuniform:bool) !foreign method "hasUniform",
		sendColor :: (self:Shader, name:string, color,...:[]float) !foreign method "sendColor",
		send :: (self:Shader, name:string, number,...:int)             !foreign method "send",
		send :: (self:Shader, name:string, number,...:float)           !foreign method "send",
		send :: (self:Shader, name:string, vectorOrMatrix,...:[]float) !foreign method "send",
		send :: (self:Shader, name:string, matrix,...:[][]float)       !foreign method "send",
		send :: (self:Shader, name:string, texture:Texture)            !foreign method "send",
		send :: (self:Shader, name:string, boolean,...:bool)           !foreign method "send",
		send :: (self:Shader, name:string, layout:math.MatrixLayout, matrix,...:[][]float) !foreign method "send",
		send :: (self:Shader, name:string, layout:math.MatrixLayout, matrix,...:[]float)   !foreign method "send",
		send :: (self:Shader, name:string, data:Data, offset:int=0)         !foreign method "send",
		send :: (self:Shader, name:string, data:Data, offset:int, size:int) !foreign method "send",
		send :: (self:Shader, name:string, data:Data, layout:math.MatrixLayout, offset:int=0)         !foreign method "send",
		send :: (self:Shader, name:string, data:Data, layout:math.MatrixLayout, offset:int, size:int) !foreign method "send",
	}
	export SpriteBatch :: !foreign struct {
		using Drawable,
		add             :: (self:SpriteBatch, x,y:float, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) -> (id:int) !foreign method "add",
		add             :: (self:SpriteBatch, quad:Quad, x,y:float, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) -> (id:int) !foreign method "add",
		addLayer        :: (self:SpriteBatch, layerindex:int, x,y:float=0, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) -> (spriteindex:int) !foreign method "addLayer",
		addLayer        :: (self:SpriteBatch, layerindex:int, quad:Quad, x,y:float=0, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) -> (spriteindex:int) !foreign method "addLayer",
		addLayer        :: (self:SpriteBatch, layerindex:int, transform:math.Transform) -> (spriteindex:int) !foreign method "addLayer",
		addLayer        :: (self:SpriteBatch, layerindex:int, quad:Quad, transform:math.Transform) -> (spriteindex:int) !foreign method "addLayer",
		attachAttribute :: (self:SpriteBatch, name:string, mesh:Mesh) !foreign method "attachAttribute",
		clear           :: (self:SpriteBatch) !foreign method "clear",
		flush           :: (self:SpriteBatch) !foreign method "flush",
		getBufferSize   :: (self:SpriteBatch) -> (size:int) !foreign method "getBufferSize",
		getColor        :: (self:SpriteBatch) -> (r,g,b,a:float) !foreign method "getColor",
		getCount        :: (self:SpriteBatch) -> (count:int) !foreign method "getCount",
		getTexture      :: (self:SpriteBatch) -> (texture:Texture) !foreign method "getTexture",
		set             :: (self:SpriteBatch, spriteindex:int, x,y:float, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign method "set",
		set             :: (self:SpriteBatch, spriteindex:int, quad:Quad, x,y:float, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign method "set",
		setColor        :: (self:SpriteBatch, r,g,b:float, a:float=1) !foreign method "setColor",
		setColor        :: (self:SpriteBatch) !foreign method "setColor",
		setDrawRange    :: (self:SpriteBatch, start:int, count:int) !foreign method "setDrawRange",
		setDrawRange    :: (self:SpriteBatch) !foreign method "setDrawRange",
		setLayer        :: (self:SpriteBatch, spriteindex,layerindex:int, x,y:float=0, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign method "setLayer",
		setLayer        :: (self:SpriteBatch, spriteindex,layerindex:int, quad:Quad, x,y:float=0, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign method "setLayer",
		setLayer        :: (self:SpriteBatch, spriteindex,layerindex:int, transform:math.Transform) !foreign method "setLayer",
		setLayer        :: (self:SpriteBatch, spriteindex,layerindex:int, quad:Quad, transform:math.Transform) !foreign method "setLayer",
		setTexture      :: (self:SpriteBatch, texture:Texture) !foreign method "setTexture",
	}
	export Text :: !foreign struct {
		using Drawable,
		add           :: (self:Text, textstring:string, x,y:float=0, angle:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) -> (index:int) !foreign method "add",
		add           :: (self:Text, coloredtext:[](string|Color), x,y:float=0, angle:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) -> (index:int) !foreign method "add",
		addf          :: (self:Text, textstring:string, wraplimit:int, align:AlignMode, x,y:float, angle:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) -> (index:int) !foreign method "addf",
		addf          :: (self:Text, coloredtext:[](string|Color), wraplimit:int, align:AlignMode, x,y:float, angle:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) -> (index:int) !foreign method "addf",
		clear         :: (self:Text) !foreign method "clear",
		getDimensions :: (self:Text) -> (width,height:int) !foreign method "getDimensions",
		getDimensions :: (self:Text, index:int) -> (width,height:int) !foreign method "getDimensions",
		getFont       :: (self:Text) -> (font:Font) !foreign method "getFont",
		getHeight     :: (self:Text) -> (height:int) !foreign method "getHeight",
		getHeight     :: (self:Text, index:int) -> (height:int) !foreign method "getHeight",
		getWidth      :: (self:Text) -> (width:int) !foreign method "getWidth",
		getWidth      :: (self:Text, index:int) -> (width:int) !foreign method "getWidth",
		set           :: (self:Text, textstring:string) !foreign method "set",
		set           :: (self:Text, coloredtext:[](string|Color)) !foreign method "set",
		setFont       :: (self:Text, font:Font) !foreign method "setFont",
		setf          :: (self:Text, textstring:string, wraplimit:int, align:AlignMode) !foreign method "setf",
		setf          :: (self:Text, coloredtext:[](string|Color), wraplimit:int, align:AlignMode) !foreign method "setf",
	}
	export Texture :: !foreign struct {
		using Drawable,
		getDPIScale     :: (self:Texture) -> (dpiscale:int--[[Correct?]]) !foreign method "getDPIScale",
		getDepth        :: (self:Texture) -> (depth:int) !foreign method "getDepth",
		getFormat       :: (self:Texture) -> (format:PixelFormat) !foreign method "getFormat",
		getLayerCount   :: (self:Texture) -> (layers:int) !foreign method "getLayerCount",
		getMipmapCount  :: (self:Texture) -> (mipmaps:int) !foreign method "getMipmapCount",
		getMipmapFilter :: (self:Texture) -> (mode:FilterMode, sharpness:float--[[Correct?]]) !foreign method "getMipmapFilter",
		getPixelHeight  :: (self:Texture) -> (pixelheight:int) !foreign method "getPixelHeight",
		getPixelWidth   :: (self:Texture) -> (pixelwidth:int) !foreign method "getPixelWidth",
		getTextureType  :: (self:Texture) -> (texturetype:TextureType) !foreign method "getTextureType",
		isReadable      :: (self:Texture) -> (readable:bool) !foreign method "isReadable",
		setMipmapFilter :: (self:Texture, filtermode:FilterMode, sharpness:float--[[Correct?]]=0) !foreign method "setMipmapFilter",
		setMipmapFilter :: (self:Texture) !foreign method "setMipmapFilter",
	}
	export Video :: !foreign struct {
		using Drawable,
		getDimensions :: (self:Video) -> (width,height:int) !foreign method "getDimensions",
		getFilter     :: (self:Video) -> (min,mag:FilterMode, anisotropy:int) !foreign method "getFilter",
		getHeight     :: (self:Video) -> (height:int) !foreign method "getHeight",
		getSource     :: (self:Video) -> (source:audio.Source) !foreign method "getSource",
		getStream     :: (self:Video) -> (stream:video.VideoStream) !foreign method "getStream",
		getWidth      :: (self:Video) -> (width:int) !foreign method "getWidth",
		isPlaying     :: (self:Video) -> (playing:bool) !foreign method "isPlaying",
		pause         :: (self:Video) !foreign method "pause",
		play          :: (self:Video) !foreign method "play",
		rewind        :: (self:Video) !foreign method "rewind",
		seek          :: (self:Video, offset:float) !foreign method "seek",
		setFilter     :: (self:Video, min,mag:FilterMode, anisotropy:int=1) !foreign method "setFilter",
		tell          :: (self:Video) -> (seconds:float) !foreign method "tell",
		setSource :: (self:Video)                      !foreign method "setSource",
		setSource :: (self:Video, source:audio.Source) !foreign method "setSource",
	}
	export applyTransform        :: (transform:math.Transform) !foreign lua "love.graphics.applyTransform"
	export arc                   :: (drawmode:DrawMode, x,y:float, radius:float, angle1:float, angle2:float, segments:int=10) !foreign lua "love.graphics.arc"
	export arc                   :: (drawmode:DrawMode, arctype:ArcType, x,y:float, radius:float, angle1:float, angle2:float, segments:int=10) !foreign lua "love.graphics.arc"
	export circle                :: (mode:DrawMode, x,y:float, radius:float) !foreign lua "love.graphics.circle"
	export circle                :: (mode:DrawMode, x,y:float, radius:float, segments:int) !foreign lua "love.graphics.circle"
	export discard               :: (discardcolor:bool=true, discardstencil:bool=true) !foreign lua "love.graphics.discard"
	export discard               :: (discardcolors:[]bool, discardstencil:bool=true) !foreign lua "love.graphics.discard"
	export draw                  :: (drawable:Drawable, x,y:float=0, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.draw"
	export draw                  :: (texture:Texture, quad:Quad, x,y:float, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.draw"
	export draw                  :: (drawable:Drawable, transform:math.Transform) !foreign lua "love.graphics.draw"
	export draw                  :: (texture:Texture, quad:Quad, transform:math.Transform) !foreign lua "love.graphics.draw"
	export drawInstanced         :: (mesh:Mesh, instancecount:int, x,y:float=0, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.drawInstanced"
	export drawInstanced         :: (mesh:Mesh, instancecount:int, transform:math.Transform) !foreign lua "love.graphics.drawInstanced"
	export drawLayer             :: (texture:Texture, layerindex:int, x,y:float=0, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.drawLayer"
	export drawLayer             :: (texture:Texture, layerindex:int, quad:Quad, x,y:float=0, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.drawLayer"
	export drawLayer             :: (texture:Texture, layerindex:int, transform:math.Transform) !foreign lua "love.graphics.drawLayer"
	export drawLayer             :: (texture:Texture, layerindex:int, quad:Quad, transform:math.Transform) !foreign lua "love.graphics.drawLayer"
	export ellipse               :: (mode:DrawMode, x,y:float, radiusx:float, radiusy:float) !foreign lua "love.graphics.ellipse"
	export ellipse               :: (mode:DrawMode, x,y:float, radiusx:float, radiusy:float, segments:int) !foreign lua "love.graphics.ellipse"
	export flushBatch            :: () !foreign lua "love.graphics.flushBatch"
	export getBackgroundColor    :: () -> (r,g,b,a:float) !foreign lua "love.graphics.getBackgroundColor"
	export getBlendMode          :: () -> (mode:BlendMode, alphamode:BlendAlphaMode) !foreign lua "love.graphics.getBlendMode"
	export getCanvas             :: () -> (canvas:Canvas) !foreign lua "love.graphics.getCanvas"
	export getCanvasFormats      :: () -> (formats:SupportedCanvasFormats) !foreign lua "love.graphics.getCanvasFormats"
	export getCanvasFormats      :: (readable:bool) -> (formats:SupportedCanvasFormats) !foreign lua "love.graphics.getCanvasFormats"
	export getColor              :: () -> (r,g,b,a:float) !foreign lua "love.graphics.getColor"
	export getColorMask          :: () -> (r,g,b,a:bool) !foreign lua "love.graphics.getColorMask"
	export getDPIScale           :: () -> (scale:int--[[Correct?]]) !foreign lua "love.graphics.getDPIScale"
	export getDefaultFilter      :: () -> (min,mag:FilterMode, anisotropy:int) !foreign lua "love.graphics.getDefaultFilter"
	export getDepthMode          :: () -> (comparemode:CompareMode, write:bool) !foreign lua "love.graphics.getDepthMode"
	export getDimensions         :: () -> (width,height:int) !foreign lua "love.graphics.getDimensions"
	export getFont               :: () -> (font:Font) !foreign lua "love.graphics.getFont"
	export getFrontFaceWinding   :: () -> (winding:VertexWinding) !foreign lua "love.graphics.getFrontFaceWinding"
	export getHeight             :: () -> (height:int) !foreign lua "love.graphics.getHeight"
	export getImageFormats       :: () -> (formats:SupportedPixelFormats) !foreign lua "love.graphics.getImageFormats"
	export getLineJoin           :: () -> (join:LineJoin) !foreign lua "love.graphics.getLineJoin"
	export getLineStyle          :: () -> (style:LineStyle) !foreign lua "love.graphics.getLineStyle"
	export getLineWidth          :: () -> (width:float) !foreign lua "love.graphics.getLineWidth"
	export getMeshCullMode       :: () -> (mode:CullMode) !foreign lua "love.graphics.getMeshCullMode"
	export getPixelHeight        :: () -> (pixelheight:int) !foreign lua "love.graphics.getPixelHeight"
	export getPixelWidth         :: () -> (pixelwidth:int) !foreign lua "love.graphics.getPixelWidth"
	export getPointSize          :: () -> (size:int) !foreign lua "love.graphics.getPointSize"
	export getRendererInfo       :: () -> (name:string, version:string, vendor:string, device:string) !foreign lua "love.graphics.getRendererInfo"
	export getScissor            :: () -> (x,y:float, width,height:float) !foreign lua "love.graphics.getScissor"
	export getShader             :: () -> (shader:Shader) !foreign lua "love.graphics.getShader"
	export getStackDepth         :: () -> (depth:int) !foreign lua "love.graphics.getStackDepth"
	export getStats              :: () -> (stats:Stats) !foreign lua "love.graphics.getStats"
	export getStats              :: (stats:Stats) -> (stats:Stats) !foreign lua "love.graphics.getStats"
	export getStencilTest        :: () -> (comparemode:CompareMode, comparevalue:int) !foreign lua "love.graphics.getStencilTest"
	export getSupported          :: () -> (features:SupportedGraphicsFeatures) !foreign lua "love.graphics.getSupported"
	export getSystemLimits       :: () -> (limits:SystemLimits) !foreign lua "love.graphics.getSystemLimits"
	export getTextureTypes       :: () -> (texturetypes:SupportedTextureTypes) !foreign lua "love.graphics.getTextureTypes"
	export getWidth              :: () -> (width:int) !foreign lua "love.graphics.getWidth"
	export intersectScissor      :: (x,y:float, width,height:float) !foreign lua "love.graphics.intersectScissor"
	export inverseTransformPoint :: (screenX:float, screenY:float) -> (globalX,globalY:float) !foreign lua "love.graphics.inverseTransformPoint"
	export isActive              :: () -> (active:bool) !foreign lua "love.graphics.isActive"
	export isGammaCorrect        :: () -> (gammacorrect:bool) !foreign lua "love.graphics.isGammaCorrect"
	export isWireframe           :: () -> (wireframe:bool) !foreign lua "love.graphics.isWireframe"
	export line                  :: (x1,y1:float, x2,y2:float, ...:float) !foreign lua "love.graphics.line"
	export line                  :: (points:[]float) !foreign lua "love.graphics.line"
	export newFont               :: (filename:string) -> (font:Font) !foreign lua "love.graphics.newFont"
	export newFont               :: (filename:string, size:int, hinting:font.HintingMode=cast(font.HintingMode)"normal") -> (font:Font) !foreign lua "love.graphics.newFont"
	export newFont               :: (filename:string, imagefilename:string) -> (font:Font) !foreign lua "love.graphics.newFont"
	export newFont               :: (size:int=12, hinting:font.HintingMode=cast(font.HintingMode)"normal") -> (font:Font) !foreign lua "love.graphics.newFont"
	export newImageFont          :: (filename:string, glyphs:string) -> (font:Font) !foreign lua "love.graphics.newImageFont"
	export newImageFont          :: (imageData:image.ImageData, glyphs:string) -> (font:Font) !foreign lua "love.graphics.newImageFont"
	export newImageFont          :: (filename:string, glyphs:string, extraspacing:int) -> (font:Font) !foreign lua "love.graphics.newImageFont"
	export newParticleSystem     :: (image:Image, buffer:int=1000) -> (system:ParticleSystem) !foreign lua "love.graphics.newParticleSystem"
	export newParticleSystem     :: (texture:Texture, buffer:int=1000) -> (system:ParticleSystem) !foreign lua "love.graphics.newParticleSystem"
	export newQuad               :: (x,y:float, width,height:float, sw,sh:float) -> (quad:Quad) !foreign lua "love.graphics.newQuad"
	export origin                :: () !foreign lua "love.graphics.origin"
	export polygon               :: (mode:DrawMode, ...:float) !foreign lua "love.graphics.polygon"
	export polygon               :: (mode:DrawMode, vertices:[]float) !foreign lua "love.graphics.polygon"
	export pop                   :: () !foreign lua "love.graphics.pop"
	export present               :: () !foreign lua "love.graphics.present"
	export print                 :: (text:string, x,y:float=0, r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.print"
	export print                 :: (coloredtext:[](string|Color), x,y:float=0, angle:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.print"
	export print                 :: (text:string, transform:math.Transform) !foreign lua "love.graphics.print"
	export print                 :: (coloredtext:[](string|Color), transform:math.Transform) !foreign lua "love.graphics.print"
	export print                 :: (text:string, font:Font, transform:math.Transform) !foreign lua "love.graphics.print"
	export print                 :: (coloredtext:[](string|Color), font:Font, transform:math.Transform) !foreign lua "love.graphics.print"
	export printf                :: (text:string, x,y:float, limit:int, align:AlignMode=cast(AlignMode)"left", r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.printf"
	export printf                :: (text:string, font:Font, x,y:float, limit:int, align:AlignMode=cast(AlignMode)"left", r:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.printf"
	export printf                :: (text:string, transform:math.Transform, limit:int, align:AlignMode=cast(AlignMode)"left") !foreign lua "love.graphics.printf"
	export printf                :: (text:string, font:Font, transform:math.Transform, limit:int, align:AlignMode=cast(AlignMode)"left") !foreign lua "love.graphics.printf"
	export printf                :: (coloredtext:[](string|Color), x,y:float, limit:int, align:AlignMode, angle:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.printf"
	export printf                :: (coloredtext:[](string|Color), font:Font, x,y:float, limit:int, align:AlignMode=cast(AlignMode)"left", angle:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) !foreign lua "love.graphics.printf"
	export printf                :: (coloredtext:[](string|Color), transform:math.Transform, limit:int, align:AlignMode=cast(AlignMode)"left") !foreign lua "love.graphics.printf"
	export printf                :: (coloredtext:[](string|Color), font:Font, transform:math.Transform, limit:int, align:AlignMode=cast(AlignMode)"left") !foreign lua "love.graphics.printf"
	export push                  :: () !foreign lua "love.graphics.push"
	export push                  :: (stack:StackType) !foreign lua "love.graphics.push"
	export replaceTransform      :: (transform:math.Transform) !foreign lua "love.graphics.replaceTransform"
	export reset                 :: () !foreign lua "love.graphics.reset"
	export rotate                :: (angle:float) !foreign lua "love.graphics.rotate"
	export scale                 :: (sx:float, sy:float=sx) !foreign lua "love.graphics.scale"
	export setColorMask          :: (red:bool, green:bool, blue:bool, alpha:bool) !foreign lua "love.graphics.setColorMask"
	export setColorMask          :: () !foreign lua "love.graphics.setColorMask"
	export setDefaultFilter      :: (min,mag:FilterMode, anisotropy:int=1) !foreign lua "love.graphics.setDefaultFilter"
	export setDepthMode          :: (comparemode:CompareMode, write:bool) !foreign lua "love.graphics.setDepthMode"
	export setDepthMode          :: () !foreign lua "love.graphics.setDepthMode"
	export setFont               :: (font:Font) !foreign lua "love.graphics.setFont"
	export setFrontFaceWinding   :: (winding:VertexWinding) !foreign lua "love.graphics.setFrontFaceWinding"
	export setLineJoin           :: (join:LineJoin) !foreign lua "love.graphics.setLineJoin"
	export setLineStyle          :: (style:LineStyle) !foreign lua "love.graphics.setLineStyle"
	export setLineWidth          :: (width:float) !foreign lua "love.graphics.setLineWidth"
	export setMeshCullMode       :: (mode:CullMode) !foreign lua "love.graphics.setMeshCullMode"
	export setNewFont            :: (size:int=12) -> (font:Font) !foreign lua "love.graphics.setNewFont"
	export setNewFont            :: (filename:string, size:int=12) -> (font:Font) !foreign lua "love.graphics.setNewFont"
	export setNewFont            :: (file:filesystem.File, size:int=12) -> (font:Font) !foreign lua "love.graphics.setNewFont"
	export setNewFont            :: (data:Data, size:int=12) -> (font:Font) !foreign lua "love.graphics.setNewFont"
	export setNewFont            :: (rasterizer:font.Rasterizer) -> (font:Font) !foreign lua "love.graphics.setNewFont"
	export setPointSize          :: (size:int) !foreign lua "love.graphics.setPointSize"
	export setScissor            :: (x,y:float, width,height:float) !foreign lua "love.graphics.setScissor"
	export setScissor            :: () !foreign lua "love.graphics.setScissor"
	export setShader             :: (shader:Shader) !foreign lua "love.graphics.setShader"
	export setShader             :: () !foreign lua "love.graphics.setShader"
	export setStencilTest        :: (comparemode:CompareMode, comparevalue:int) !foreign lua "love.graphics.setStencilTest"
	export setStencilTest        :: () !foreign lua "love.graphics.setStencilTest"
	export setWireframe          :: (enable:bool) !foreign lua "love.graphics.setWireframe"
	export shear                 :: (kx,ky:float) !foreign lua "love.graphics.shear"
	export transformPoint        :: (globalX,globalY:float) -> (screenX:float, screenY:float) !foreign lua "love.graphics.transformPoint"
	export translate             :: (dx,dy:float) !foreign lua "love.graphics.translate"
	export validateShader        :: (gles:bool, code:string) -> (status:bool, message:string) !foreign lua "love.graphics.validateShader"
	export validateShader        :: (gles:bool, pixelcode,vertexcode:string) -> (status:bool, message:string) !foreign lua "love.graphics.validateShader"
	export IndexDataType :: enum {
		UINT16 :: "uint16",
		UINT32 :: "uint32",
	}
	export MipmapMode :: enum {
		NONE   :: "none",
		MANUAL :: "manual",
		AUTO   :: "auto",
	}
	export PixelFormat :: enum {
		-- Normal color formats.
		NORMAL           :: "normal",
		R8               :: "r8",
		RG8              :: "rg8",
		RGBA8            :: "rgba8",
		SRGBA8           :: "srgba8",
		RGBA16           :: "rgba16",
		R16F             :: "r16f",
		RG16F            :: "rg16f",
		RGBA16F          :: "rgba16f",
		R32F             :: "r32f",
		RG32F            :: "rg32f",
		RGBA32F          :: "rgba32f",
		RGBA4            :: "rgba4",
		RGB5A1           :: "rgb5a1",
		RGB565           :: "rgb565",
		RGB10A2          :: "rgb10a2",
		RG11B10F         :: "rg11b10f",
		-- Depth/stencil formats.
		STENCIL8         :: "stencil8",
		DEPTH16          :: "depth16",
		DEPTH24          :: "depth24",
		DEPTH32F         :: "depth32f",
		DEPTH24STENCIL8  :: "depth24stencil8",
		DEPTH32FSTENCIL8 :: "depth32fstencil8",
		-- Compressed formats, desktop GPUs.
		DXT1             :: "DXT1",
		DXT3             :: "DXT3",
		DXT5             :: "DXT5",
		BC4              :: "BC4",
		BC4S             :: "BC4s",
		BC5              :: "BC5",
		BC5S             :: "BC5s",
		BC6H             :: "BC6h",
		BC6HS            :: "BC6hs",
		BC7              :: "BC7",
		-- Compressed formats, mobile GPUs.
		ETC1             :: "ETC1",
		ETC2RGB          :: "ETC2rgb",
		ETC2RGBA         :: "ETC2rgba",
		ETC2RGBA1        :: "ETC2rgba1",
		EACR             :: "EACr",
		EACRS            :: "EACrs",
		EACRG            :: "EACrg",
		EACRGS           :: "EACrgs",
		PVR1RGB2         :: "PVR1rgb2",
		PVR1RGB4         :: "PVR1rgb4",
		PVR1RGBA2        :: "PVR1rgba2",
		PVR1RGBA4        :: "PVR1rgba4",
		ASTC4X4          :: "ASTC4x4",
		ASTC5X4          :: "ASTC5x4",
		ASTC5X5          :: "ASTC5x5",
		ASTC6X5          :: "ASTC6x5",
		ASTC6X6          :: "ASTC6x6",
		ASTC8X5          :: "ASTC8x5",
		ASTC8X6          :: "ASTC8x6",
		ASTC8X8          :: "ASTC8x8",
		ASTC10X5         :: "ASTC10x5",
		ASTC10X6         :: "ASTC10x6",
		ASTC10X8         :: "ASTC10x8",
		ASTC10X10        :: "ASTC10x10",
		ASTC12X10        :: "ASTC12x10",
		ASTC12X12        :: "ASTC12x12",
	}
	export CanvasFormat  :: PixelFormat
	export TextureFormat :: CanvasFormat -- Is this correct? The wiki may be messed up.
	export VertexAttributeStep :: enum {
		PER_VERTEX   :: "pervertex",
		PER_INSTANCE :: "perinstance",
	}
	export VertexWinding :: enum {
		CLOCKWISE         :: "cw",
		COUNTER_CLOCKWISE :: "ccw",
	}
	export captureScreenshot :: (filename:Filename)               !foreign lua "love.graphics.captureScreenshot"
	export captureScreenshot :: (callback:(data:image.ImageData)) !foreign lua "love.graphics.captureScreenshot"
	export captureScreenshot :: (channel:thread.Channel)          !foreign lua "love.graphics.captureScreenshot"
	export clear :: ()                                                                               !foreign lua "love.graphics.clear"
	export clear :: (r,g,b:float, a:float=1, clearStencil:bool|int=true, clearDepth:bool|float=true) !foreign lua "love.graphics.clear"
	export clear :: (clearColor:bool,        clearStencil:bool|int,      clearDepth:bool|float     ) !foreign lua "love.graphics.clear"
	export CanvasSettings :: struct { type=TextureType.TWOD, format=PixelFormat.NORMAL, readable:bool|none=nil, msaa=0, dpiscale:int--[[Correct?]]|none=nil, mipmaps=CanvasMipmapMode.NONE }
	export newCanvas :: ()                                                      -> (canvas:Canvas) !foreign lua "love.graphics.newCanvas"
	export newCanvas :: (width,height:int)                                      -> (canvas:Canvas) !foreign lua "love.graphics.newCanvas"
	export newCanvas :: (width,height:int,             settings:CanvasSettings) -> (canvas:Canvas) !foreign lua "love.graphics.newCanvas"
	export newCanvas :: (width,height:int, layers:int, settings:CanvasSettings) -> (canvas:Canvas) !foreign lua "love.graphics.newCanvas"
	export newShader :: (codeOrFilename:string)       -> (shader:Shader) !foreign lua "love.graphics.newShader"
	export newShader :: (pixelCode,vertexCode:string) -> (shader:Shader) !foreign lua "love.graphics.newShader"
	export stencil :: (stencilfunction:(), action:StencilAction=cast(StencilAction)"replace", value:int=1, keepvalues:bool=false) !foreign lua "love.graphics.stencil"
	local ImageFile           :: Filename|filesystem.FileData|image.ImageData|image.CompressedImageData
	local ImageFileOrByteData :: Filename|filesystem.FileData|image.ImageData|image.CompressedImageData|data.ByteData
	local ImageFileOrFile     :: Filename|filesystem.FileData|image.ImageData|image.CompressedImageData|filesystem.File
	export ImageFlags :: struct { linear=false, mipmaps:bool|[]ImageFileOrByteData=false }
	export newImage :: (filename:Filename)                              -> (image:Image) !foreign lua "love.graphics.newImage"
	export newImage :: (imageData:image.ImageData)                      -> (image:Image) !foreign lua "love.graphics.newImage"
	export newImage :: (compressedImageData:image.CompressedImageData)  -> (image:Image) !foreign lua "love.graphics.newImage"
	export newImage :: (filename:ImageFileOrByteData, flags:ImageFlags) -> (image:Image) !foreign lua "love.graphics.newImage"
	export newImage :: (filename:ImageFile, format:TextureFormat)       -> (image:Image) !foreign lua "love.graphics.newImage"
	export ArrayImageSettings :: struct { mipmaps=false, linear=false, dpiscale:int--[[Correct?]]=1 }
	export ArrayImageSlices   :: ([]ImageFileOrFile) | ([][]ImageFileOrFile)
	export newArrayImage :: (slices:ArrayImageSlices)                              -> (image:Image) !foreign lua "love.graphics.newArrayImage"
	export newArrayImage :: (slices:ArrayImageSlices, settings:ArrayImageSettings) -> (image:Image) !foreign lua "love.graphics.newArrayImage"
	export CubeImageSettings :: struct { mipmaps=false, linear=false }
	export newCubeImage :: (file:ImageFileOrFile)                                -> (image:Image) !foreign lua "love.graphics.newCubeImage"
	export newCubeImage :: (file:ImageFileOrFile, settings:CubeImageSettings)    -> (image:Image) !foreign lua "love.graphics.newCubeImage"
	export newCubeImage :: (faces:[]ImageFileOrFile)                             -> (image:Image) !foreign lua "love.graphics.newCubeImage"
	export newCubeImage :: (faces:[]ImageFileOrFile, settings:CubeImageSettings) -> (image:Image) !foreign lua "love.graphics.newCubeImage"
	export VolumeImageSettings :: struct { mipmaps=false, linear=false }
	export VolumeImageLayers   :: ([]ImageFileOrFile) | ([][]ImageFileOrFile)
	export newVolumeImage :: (layers:VolumeImageLayers)                               -> (image:Image) !foreign lua "love.graphics.newVolumeImage"
	export newVolumeImage :: (layers:VolumeImageLayers, settings:VolumeImageSettings) -> (image:Image) !foreign lua "love.graphics.newVolumeImage"
	export VertexAttribute :: [](string|int) -- Expected format: {name:string, dataType:string, components:int}
	export Vertex          :: []float
	export StandardVertex  :: Vertex -- Expected format: {x,y[,u=0,v=0,r=1,g=1,b=1,a=1]}
	export CustomVertex    :: Vertex -- Expected format: {attributeComponent1, ...}
	export newMesh :: (vertices:[]StandardVertex,                               mode=MeshDrawMode.FAN, usage=SpriteBatchUsage.DYNAMIC) -> (mesh:Mesh) !foreign lua "love.graphics.newMesh"
	export newMesh :: (vertexCount:int,                                         mode=MeshDrawMode.FAN, usage=SpriteBatchUsage.DYNAMIC) -> (mesh:Mesh) !foreign lua "love.graphics.newMesh"
	export newMesh :: (vertexFormat:[]VertexAttribute, vertices:[]CustomVertex, mode=MeshDrawMode.FAN, usage=SpriteBatchUsage.DYNAMIC) -> (mesh:Mesh) !foreign lua "love.graphics.newMesh"
	export newMesh :: (vertexFormat:[]VertexAttribute, vertexCount:int,         mode=MeshDrawMode.FAN, usage=SpriteBatchUsage.DYNAMIC) -> (mesh:Mesh) !foreign lua "love.graphics.newMesh"
	export newMesh :: (vertexCount:int, texture:Texture|none,                   mode=MeshDrawMode.FAN)                                 -> (mesh:Mesh) !foreign lua "love.graphics.newMesh"
	export newText :: (font:Font)              -> (text:Text) !foreign lua "love.graphics.newText"
	export newText :: (font:Font, text:string) -> (text:Text) !foreign lua "love.graphics.newText"
	export VideoSettings :: struct { audio:bool|none=nil, dpiscale:int--[[Correct?]]|none=nil--[[love.graphics.getDPIScale()]] }
	export newVideo :: (filename:Filename)                               -> (video:Video) !foreign lua "love.graphics.newVideo"
	export newVideo :: (filename:Filename, settings:VideoSettings)       -> (video:Video) !foreign lua "love.graphics.newVideo"
	export newVideo :: (filename:Filename, loadAudio:bool)               -> (video:Video) !foreign lua "love.graphics.newVideo"
	export newVideo :: (videoStream:video.VideoStream)                   -> (video:Video) !foreign lua "love.graphics.newVideo"
	export newVideo :: (videoStream:video.VideoStream, loadAudio:bool)   -> (video:Video) !foreign lua "love.graphics.newVideo"
	export rectangle :: (mode:DrawMode, x,y:float, width,height:float)                                  !foreign lua "love.graphics.rectangle"
	export rectangle :: (mode:DrawMode, x,y:float, width,height:float, rx:float,ry:float=rx)            !foreign lua "love.graphics.rectangle"
	export rectangle :: (mode:DrawMode, x,y:float, width,height:float, rx:float,ry:float, segments:int) !foreign lua "love.graphics.rectangle"
	export newSpriteBatch :: (texture:Texture, maxsprites=1000, usage=SpriteBatchUsage.DYNAMIC) -> (spriteBatch:SpriteBatch) !foreign lua "love.graphics.newSpriteBatch"
	export Point :: []float -- Expected format: {x,y[,r,g,b,a]}
	export points :: (x,y:float, ...:float) !foreign lua "love.graphics.points"
	export points :: (points:[]float) !foreign lua "love.graphics.points"
	export points :: (points:[]Point) !foreign lua "love.graphics.points"
	export setColor           :: (red,green,blue:float, alpha=1.0) !foreign lua "love.graphics.setColor"
	export setColor           :: (color:Color)                     !foreign lua "love.graphics.setColor"
	export setBackgroundColor :: (red,green,blue:float, alpha=1.0) !foreign lua "love.graphics.setBackgroundColor"
	export setBackgroundColor :: (color:Color)                     !foreign lua "love.graphics.setBackgroundColor"
	export setBlendMode :: (mode:BlendMode, alphaMode=BlendAlphaMode.ALPHAMULTIPLY) !foreign lua "love.graphics.setBlendMode"
	export CanvasSetup :: struct { stencil=false, depth=false, depthstencil:Canvas|none=nil, !value:Canvas }
	export setCanvas :: ()                                     !foreign lua "love.graphics.setCanvas"
	export setCanvas :: (canvas:Canvas, mipmap=1)              !foreign lua "love.graphics.setCanvas"
	export setCanvas :: (canvas:Canvas, slice:int, mipmap:int) !foreign lua "love.graphics.setCanvas"
	export setCanvas :: (canvas1,canvas2,...:Canvas)           !foreign lua "love.graphics.setCanvas"
	export setCanvas :: (setup:CanvasSetup)                    !foreign lua "love.graphics.setCanvas"
	export SupportedCanvasFormats    :: !foreign struct { !key: CanvasFormat,    !value: bool }
	export SupportedPixelFormats     :: !foreign struct { !key: PixelFormat,     !value: bool }
	export SupportedGraphicsFeatures :: !foreign struct { !key: GraphicsFeature, !value: bool }
	export SupportedTextureTypes     :: !foreign struct { !key: TextureType,     !value: bool }
	export SystemLimits              :: !foreign struct { !key: GraphicsLimit,   !value: int  }
	export Stats :: struct { drawcalls:int, canvasswitches:int, texturememory:int, images:int, canvases:int, fonts:int, shaderswitches:int, drawcallsbatched:int }
	export pushAll :: () { push(StackType.ALL) }
}
export image :: namespace {
	export CompressedImageFormat :: enum {
		DXT1      :: "DXT1",
		DXT3      :: "DXT3",
		DXT5      :: "DXT5",
		BC4       :: "BC4",
		BC4S      :: "BC4s",
		BC5       :: "BC5",
		BC5S      :: "BC5s",
		BC6H      :: "BC6h",
		BC6HS     :: "BC6hs",
		BC7       :: "BC7",
		ETC1      :: "ETC1",
		ETC2RGB   :: "ETC2rgb",
		ETC2RGBA  :: "ETC2rgba",
		ETC2RGBA1 :: "ETC2rgba1",
		EACR      :: "EACr",
		EACRS     :: "EACrs",
		EACRG     :: "EACrg",
		EACRGS    :: "EACrgs",
		PVR1RGB2  :: "PVR1rgb2",
		PVR1RGB4  :: "PVR1rgb4",
		PVR1RGBA2 :: "PVR1rgba2",
		PVR1RGBA4 :: "PVR1rgba4",
		ASTC4X4   :: "ASTC4x4",
		ASTC5X4   :: "ASTC5x4",
		ASTC5X5   :: "ASTC5x5",
		ASTC6X5   :: "ASTC6x5",
		ASTC6X6   :: "ASTC6x6",
		ASTC8X5   :: "ASTC8x5",
		ASTC8X6   :: "ASTC8x6",
		ASTC8X8   :: "ASTC8x8",
		ASTC10X5  :: "ASTC10x5",
		ASTC10X6  :: "ASTC10x6",
		ASTC10X8  :: "ASTC10x8",
		ASTC10X10 :: "ASTC10x10",
		ASTC12X10 :: "ASTC12x10",
		ASTC12X12 :: "ASTC12x12",
	}
	export ImageFormat :: enum {
		TGA :: "tga",
		PNG :: "png",
		JPG :: "jpg",
		BMP :: "bmp",
	}
	export CompressedImageData :: !foreign struct {
		using Data,
		getDimensions  :: (self:CompressedImageData) -> (width,height:int) !foreign method "getDimensions",
		getDimensions  :: (self:CompressedImageData, level:int) -> (width,height:int) !foreign method "getDimensions",
		getFormat      :: (self:CompressedImageData) -> (format:CompressedImageFormat) !foreign method "getFormat",
		getHeight      :: (self:CompressedImageData) -> (height:int) !foreign method "getHeight",
		getHeight      :: (self:CompressedImageData, level:int) -> (height:int) !foreign method "getHeight",
		getMipmapCount :: (self:CompressedImageData) -> (mipmaps:int) !foreign method "getMipmapCount",
		getWidth       :: (self:CompressedImageData) -> (width:int) !foreign method "getWidth",
		getWidth       :: (self:CompressedImageData, level:int) -> (width:int) !foreign method "getWidth",
	}
	export ImageData :: !foreign struct {
		using Data,
		getDimensions :: (self:ImageData) -> (width,height:int) !foreign method "getDimensions",
		getHeight     :: (self:ImageData) -> (height:int) !foreign method "getHeight",
		getPixel      :: (self:ImageData, x,y:int) -> (r,g,b,a:float) !foreign method "getPixel",
		getWidth      :: (self:ImageData) -> (width:int) !foreign method "getWidth",
		paste         :: (self:ImageData, source:ImageData, dx,dy:int, sx,sy:int, sw,sh:int) !foreign method "paste",
		setPixel      :: (self:ImageData, x,y:int, r,g,b,a:float) !foreign method "setPixel",
		encode :: (self:ImageData, format:ImageFormat)                    -> (filedata:filesystem.FileData) !foreign method "encode",
		encode :: (self:ImageData, format:ImageFormat, filename:Filename) -> (filedata:filesystem.FileData) !foreign method "encode",
		encode :: (self:ImageData, outFile:Filename)                     !foreign method "encode",
		encode :: (self:ImageData, outFile:Filename, format:ImageFormat) !foreign method "encode",
		_PixelFunction :: (x,y:int, r,g,b,a:float),
		mapPixel :: (self:ImageData, pixelFunction:_PixelFunction, x:int=0, y:int=0, width:int=0--[[ImageData:getWidth()]], height:int=0--[[ImageData:getHeight()]]) !foreign method "mapPixel",
		mapPixel :: (self:ImageData, x,y:int, width,height:int, pixelFunction:_PixelFunction) { self.mapPixel!(pixelFunction, x, y, width, height) },
	}
	export isCompressed      :: (filename:string) -> (compressed:bool) !foreign lua "love.image.isCompressed"
	export isCompressed      :: (fileData:filesystem.FileData) -> (compressed:bool) !foreign lua "love.image.isCompressed"
	export newCompressedData :: (filename:string) -> (compressedImageData:CompressedImageData) !foreign lua "love.image.newCompressedData"
	export newCompressedData :: (fileData:filesystem.FileData) -> (compressedImageData:CompressedImageData) !foreign lua "love.image.newCompressedData"
	export newImageData :: (width,height:int, format=graphics.PixelFormat.RGBA8)        -> (imageData:ImageData) !foreign lua "love.image.newImageData"
	export newImageData :: (width,height:int, format:graphics.PixelFormat, data:string) -> (imageData:ImageData) !foreign lua "love.image.newImageData"
	export newImageData :: (width,height:int, data:string)                              -> (imageData:ImageData) !foreign lua "love.image.newImageData"
	export newImageData :: (file:Filename|filesystem.FileData)                          -> (imageData:ImageData) !foreign lua "love.image.newImageData"
}
export joystick :: namespace {
	export GamepadAxis :: enum {
		LEFT_X        :: "leftx",
		LEFT_Y        :: "lefty",
		RIGHT_X       :: "rightx",
		RIGHT_Y       :: "righty",
		TRIGGER_LEFT  :: "triggerleft",
		TRIGGER_RIGHT :: "triggerright",
	}
	export GamepadButton :: enum {
		A              :: "a",
		B              :: "b",
		X              :: "x",
		Y              :: "y",
		BACK           :: "back",
		GUIDE          :: "guide",
		START          :: "start",
		LEFT_STICK     :: "leftstick",
		RIGHT_STICK    :: "rightstick",
		LEFT_SHOULDER  :: "leftshoulder",
		RIGHT_SHOULDER :: "rightshoulder",
		DPAD_UP        :: "dpup",
		DPAD_DOWN      :: "dpdown",
		DPAD_LEFT      :: "dpleft",
		DPAD_RIGHT     :: "dpright",
	}
	export JoystickHat :: enum {
		CENTER     :: "c",
		DOWN       :: "d",
		LEFT       :: "l",
		LEFT_DOWN  :: "ld",
		LEFT_UP    :: "lu",
		RIGHT      :: "r",
		RIGHT_DOWN :: "rd",
		RIGHT_UP   :: "ru",
		UP         :: "u",
	}
	export JoystickInputType :: enum {
		AXIS   :: "axis",
		BUTTON :: "button",
		HAT    :: "hat",
	}
	export Joystick :: !foreign struct {
		using Object,
		getAxis                 :: (self:Joystick, axis:int) -> (direction:float) !foreign method "getAxis",
		getAxisCount            :: (self:Joystick) -> (axes:int) !foreign method "getAxisCount",
		getButtonCount          :: (self:Joystick) -> (buttons:int) !foreign method "getButtonCount",
		getDeviceInfo           :: (self:Joystick) -> (vendorID:int, productID:int, productVersion:int) !foreign method "getDeviceInfo",
		getGUID                 :: (self:Joystick) -> (guid:string) !foreign method "getGUID",
		getGamepadAxis          :: (self:Joystick, axis:GamepadAxis) -> (direction:float) !foreign method "getGamepadAxis",
		getGamepadMapping       :: (self:Joystick, axis:GamepadAxis) -> (inputtype:JoystickInputType, inputindex:int, hatdirection:JoystickHat) !foreign method "getGamepadMapping",
		getGamepadMapping       :: (self:Joystick, button:GamepadButton) -> (inputtype:JoystickInputType, inputindex:int, hatdirection:JoystickHat) !foreign method "getGamepadMapping",
		getGamepadMappingString :: (self:Joystick) -> (mappingstring:string) !foreign method "getGamepadMappingString",
		getHat                  :: (self:Joystick, hat:int) -> (direction:JoystickHat) !foreign method "getHat",
		getHatCount             :: (self:Joystick) -> (hats:int) !foreign method "getHatCount",
		getID                   :: (self:Joystick) -> (id:int, instanceid:int) !foreign method "getID",
		getName                 :: (self:Joystick) -> (name:string) !foreign method "getName",
		getVibration            :: (self:Joystick) -> (left,right:float) !foreign method "getVibration",
		isConnected             :: (self:Joystick) -> (connected:bool) !foreign method "isConnected",
		isDown                  :: (self:Joystick, buttonN:int) -> (anyDown:bool) !foreign method "isDown",
		isGamepad               :: (self:Joystick) -> (isgamepad:bool) !foreign method "isGamepad",
		isGamepadDown           :: (self:Joystick, buttonN:GamepadButton) -> (anyDown:bool) !foreign method "isGamepadDown",
		isVibrationSupported    :: (self:Joystick) -> (supported:bool) !foreign method "isVibrationSupported",
		setVibration :: (self:Joystick)                                  -> (success:bool) !foreign method "setVibration",
		setVibration :: (self:Joystick, left,right:float, duration=-1.0) -> (success:bool) !foreign method "setVibration",
		getAxes :: (self:Joystick) -> (...--[[axisDir1,...]]:float) !foreign method "getAxes",
	}
	export getGamepadMappingString :: (guid:string) -> (mappingstring:string) !foreign lua "love.joystick.getGamepadMappingString"
	export getJoystickCount        :: () -> (joystickcount:int) !foreign lua "love.joystick.getJoystickCount"
	export getJoysticks            :: () -> (joysticks:[]Joystick) !foreign lua "love.joystick.getJoysticks"
	export saveGamepadMappings     :: (filename:string) -> (mappings:string) !foreign lua "love.joystick.saveGamepadMappings"
	export saveGamepadMappings     :: () -> (mappings:string) !foreign lua "love.joystick.saveGamepadMappings"
	export setGamepadMapping :: (guid:string, button:GamepadButton, inputType:JoystickInputType, inputIndex:int, hatDir:JoystickHat|none=nil) -> (success:bool) !foreign lua "love.joystick.setGamepadMapping"
	export setGamepadMapping :: (guid:string, axis:GamepadAxis,     inputType:JoystickInputType, inputIndex:int, hatDir:JoystickHat|none=nil) -> (success:bool) !foreign lua "love.joystick.setGamepadMapping"
	export loadGamepadMappings :: (filenameOrMappings:string) !foreign lua "love.joystick.loadGamepadMappings"
}
export keyboard :: namespace {
	export KeyConstant :: string
	export Scancode :: string
	export getKeyFromScancode :: (scancode:Scancode) -> (key:KeyConstant) !foreign lua "love.keyboard.getKeyFromScancode"
	export getScancodeFromKey :: (key:KeyConstant) -> (scancode:Scancode) !foreign lua "love.keyboard.getScancodeFromKey"
	export hasKeyRepeat       :: () -> (enabled:bool) !foreign lua "love.keyboard.hasKeyRepeat"
	export hasTextInput       :: () -> (enabled:bool) !foreign lua "love.keyboard.hasTextInput"
	export isScancodeDown     :: (scancode:Scancode, ...:Scancode) -> (down:bool) !foreign lua "love.keyboard.isScancodeDown"
	export setKeyRepeat       :: (enable:bool) !foreign lua "love.keyboard.setKeyRepeat"
	export setTextInput       :: (enable:bool) !foreign lua "love.keyboard.setTextInput"
	export setTextInput       :: (enable:bool, x,y:int, w,h:int) !foreign lua "love.keyboard.setTextInput"
	export isDown :: (key,...:KeyConstant) -> (anyDown:bool) !foreign lua "love.keyboard.isDown"
}
export math :: namespace {
	export CompressedDataFormat :: enum {
		LZ4     :: "lz4",
		ZLIB    :: "zlib",
		GZIP    :: "gzip",
		DEFLATE :: "deflate",
	}
	export MatrixLayout :: enum {
		ROW    :: "row",
		COLUMN :: "column",
	}
	export BezierCurve :: !foreign struct {
		using Object,
		evaluate             :: (self:BezierCurve, t:float) -> (x,y:float) !foreign method "evaluate",
		getControlPoint      :: (self:BezierCurve, i:int) -> (x,y:float) !foreign method "getControlPoint",
		getControlPointCount :: (self:BezierCurve) -> (count:int) !foreign method "getControlPointCount",
		getDegree            :: (self:BezierCurve) -> (degree:float) !foreign method "getDegree",
		getDerivative        :: (self:BezierCurve) -> (derivative:BezierCurve) !foreign method "getDerivative",
		getSegment           :: (self:BezierCurve, startpoint,endpoint:int) -> (curve:BezierCurve) !foreign method "getSegment",
		insertControlPoint   :: (self:BezierCurve, x,y:float, i:int=-1) !foreign method "insertControlPoint",
		removeControlPoint   :: (self:BezierCurve, index:int) !foreign method "removeControlPoint",
		render               :: (self:BezierCurve, depth:int=5) -> (coordinates:[]float) !foreign method "render",
		renderSegment        :: (self:BezierCurve, startpoint,endpoint:int, depth:int=5) -> (coordinates:[]float) !foreign method "renderSegment",
		rotate               :: (self:BezierCurve, angle:float, ox,oy:float=0) !foreign method "rotate",
		scale                :: (self:BezierCurve, s:float, ox,oy:float=0) !foreign method "scale",
		setControlPoint      :: (self:BezierCurve, i:int, x,y:float) !foreign method "setControlPoint",
		translate            :: (self:BezierCurve, dx,dy:float) !foreign method "translate",
	}
	export CompressedData :: !foreign struct {
		using Data,
		getFormat :: (self:CompressedData) -> (format:CompressedDataFormat) !foreign method "getFormat",
	}
	export RandomGenerator :: !foreign struct {
		using Object,
		getSeed      :: (self:RandomGenerator) -> (low,high:int) !foreign method "getSeed",
		getState     :: (self:RandomGenerator) -> (state:string) !foreign method "getState",
		randomNormal :: (self:RandomGenerator, stddev:float=1, mean:float=0) -> (number:float) !foreign method "randomNormal",
		setSeed      :: (self:RandomGenerator, seed:int) !foreign method "setSeed",
		setSeed      :: (self:RandomGenerator, low,high:int) !foreign method "setSeed",
		setState     :: (self:RandomGenerator, state:string) !foreign method "setState",
		random :: (self:RandomGenerator             ) -> (number:float) !foreign method "random",
		random :: (self:RandomGenerator,     max:int) -> (number:int)   !foreign method "random",
		random :: (self:RandomGenerator, min,max:int) -> (number:int)   !foreign method "random",
	}
	export Transform :: !foreign struct {
		using Object,
		apply                 :: (self:Transform, other:Transform) -> (transform:Transform) !foreign method "apply",
		clone                 :: (self:Transform) -> (clone:Transform) !foreign method "clone",
		inverse               :: (self:Transform) -> (inverse:Transform) !foreign method "inverse",
		inverseTransformPoint :: (self:Transform, localX,localY:float) -> (globalX,globalY:float) !foreign method "inverseTransformPoint",
		isAffine              :: (self:Transform) -> (affine:bool) !foreign method "isAffine",
		reset                 :: (self:Transform) -> (transform:Transform) !foreign method "reset",
		rotate                :: (self:Transform, angle:float) -> (transform:Transform) !foreign method "rotate",
		scale                 :: (self:Transform, sx:float, sy:float=sx) -> (transform:Transform) !foreign method "scale",
		setTransformation     :: (self:Transform, x,y:float, angle:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) -> (transform:Transform) !foreign method "setTransformation",
		shear                 :: (self:Transform, kx,ky:float) -> (transform:Transform) !foreign method "shear",
		transformPoint        :: (self:Transform, globalX,globalY:float) -> (localX,localY:float) !foreign method "transformPoint",
		translate             :: (self:Transform, dx,dy:float) -> (transform:Transform) !foreign method "translate",
		getMatrix :: (self:Transform) -> (e11,e12,e13,e14,e21,e22,e23,e24,e31,e32,e33,e34,e41,e42,e43,e44:float) !foreign method "getMatrix",
		setMatrix :: (self:Transform,                           e11,e12,e13,e14,e21,e22,e23,e24,e31,e32,e33,e34,e41,e42,e43,e44:float) -> (transform:Transform) !foreign method "setMatrix",
		setMatrix :: (self:Transform, layout:math.MatrixLayout, e11,e12,e13,e14,e21,e22,e23,e24,e31,e32,e33,e34,e41,e42,e43,e44:float) -> (transform:Transform) !foreign method "setMatrix",
		setMatrix :: (self:Transform, layout:math.MatrixLayout, matrix:([]float)|([][]float))                                          -> (transform:Transform) !foreign method "setMatrix",
	}
	export compress           :: (rawstring:string, format:CompressedDataFormat=cast(CompressedDataFormat)"lz4", level:int=-1) -> (compressedData:CompressedData) !foreign lua "love.math.compress"
	export compress           :: (data:Data, format:CompressedDataFormat=cast(CompressedDataFormat)"lz4", level:int=-1) -> (compressedData:CompressedData) !foreign lua "love.math.compress"
	export decompress         :: (compressedData:CompressedData) -> (rawstring:string) !foreign lua "love.math.decompress"
	export decompress         :: (compressedstring:string, format:CompressedDataFormat) -> (rawstring:string) !foreign lua "love.math.decompress"
	export decompress         :: (data:Data, format:CompressedDataFormat) -> (rawstring:string) !foreign lua "love.math.decompress"
	export gammaToLinear      :: (r,g,b:float) -> (lr,lg,lb:float) !foreign lua "love.math.gammaToLinear"
	export gammaToLinear      :: (color:Color) -> (lr,lg,lb:float) !foreign lua "love.math.gammaToLinear"
	export gammaToLinear      :: (c:float) -> (lc:float) !foreign lua "love.math.gammaToLinear"
	export getRandomSeed      :: () -> (low,high:int) !foreign lua "love.math.getRandomSeed"
	export getRandomState     :: () -> (state:string) !foreign lua "love.math.getRandomState"
	export isConvex           :: (vertices:[]float) -> (convex:bool) !foreign lua "love.math.isConvex"
	export isConvex           :: (x1,y1:float, x2,y2:float, x3,y3:float) -> (convex:bool) !foreign lua "love.math.isConvex"
	export linearToGamma      :: (lr,lg,lb:float) -> (cr,cg,cb:float) !foreign lua "love.math.linearToGamma"
	export linearToGamma      :: (color:Color) -> (cr,cg,cb:float) !foreign lua "love.math.linearToGamma"
	export linearToGamma      :: (lc:float) -> (c:float) !foreign lua "love.math.linearToGamma"
	export newBezierCurve     :: (vertices:[]float) -> (curve:BezierCurve) !foreign lua "love.math.newBezierCurve"
	export newBezierCurve     :: (x1,y1:float, x2,y2:float, x3,y3:float) -> (curve:BezierCurve) !foreign lua "love.math.newBezierCurve"
	export newRandomGenerator :: () -> (rng:RandomGenerator) !foreign lua "love.math.newRandomGenerator"
	export newRandomGenerator :: (seed:int) -> (rng:RandomGenerator) !foreign lua "love.math.newRandomGenerator"
	export newRandomGenerator :: (low,high:int) -> (rng:RandomGenerator) !foreign lua "love.math.newRandomGenerator"
	export newTransform       :: () -> (transform:Transform) !foreign lua "love.math.newTransform"
	export newTransform       :: (x,y:float, angle:float=0, sx:float=1, sy:float=sx, ox,oy:float=0, kx,ky:float=0) -> (transform:Transform) !foreign lua "love.math.newTransform"
	export noise              :: (x:float) -> (value:float) !foreign lua "love.math.noise"
	export noise              :: (x,y:float) -> (value:float) !foreign lua "love.math.noise"
	export noise              :: (x,y,z:float) -> (value:float) !foreign lua "love.math.noise"
	export noise              :: (x,y,z,w:float) -> (value:float) !foreign lua "love.math.noise"
	export randomNormal       :: (stddev:float=1, mean:float=0) -> (number:float) !foreign lua "love.math.randomNormal"
	export setRandomSeed      :: (seed:int) !foreign lua "love.math.setRandomSeed"
	export setRandomSeed      :: (low,high:int) !foreign lua "love.math.setRandomSeed"
	export setRandomState     :: (state:string) !foreign lua "love.math.setRandomState"
	export triangulate        :: (polygon:[]float--[[Correct?]]) -> (triangles:[][]float) !foreign lua "love.math.triangulate"
	export triangulate        :: (x1,y1:float, x2,y2:float, x3,y3:float) -> (triangles:[][]float) !foreign lua "love.math.triangulate"
	export colorFromBytes :: (rb,gb,bb:int)    -> (r,g,b:float)   !foreign lua "love.math.colorFromBytes"
	export colorFromBytes :: (rb,gb,bb,ab:int) -> (r,g,b,a:float) !foreign lua "love.math.colorFromBytes"
	export colorToBytes   :: (r,g,b:float)   -> (rb,gb,bb:int)    !foreign lua "love.math.colorToBytes"
	export colorToBytes   :: (r,g,b,a:float) -> (rb,gb,bb,ab:int) !foreign lua "love.math.colorToBytes"
	export random :: (           ) -> (number:float) !foreign lua "love.math.random"
	export random :: (    max:int) -> (number:int)   !foreign lua "love.math.random"
	export random :: (min,max:int) -> (number:int)   !foreign lua "love.math.random"
}
export mouse :: namespace {
	export CursorType :: enum {
		IMAGE           :: "image",
		ARROW           :: "arrow",
		I_BEAM          :: "ibeam",
		WAIT            :: "wait",
		WAIT_ARROW      :: "waitarrow",
		CROSSHAIR       :: "crosshair",
		SIZE_NW_SE      :: "sizenwse",
		SIZE_NE_SW      :: "sizenesw",
		SIZE_HORIZONTAL :: "sizewe",
		SIZE_VERTICAL   :: "sizens",
		SIZE_ALL        :: "sizeall",
		NO              :: "no",
		HAND            :: "hand",
	}
	export Cursor :: !foreign struct {
		using Object,
		getType :: (self:Cursor) -> (ctype:CursorType) !foreign method "getType",
	}
	export getCursor         :: () -> (cursor:Cursor) !foreign lua "love.mouse.getCursor"
	export getPosition       :: () -> (x,y:int) !foreign lua "love.mouse.getPosition"
	export getRelativeMode   :: () -> (enabled:bool) !foreign lua "love.mouse.getRelativeMode"
	export getSystemCursor   :: (ctype:CursorType) -> (cursor:Cursor) !foreign lua "love.mouse.getSystemCursor"
	export getX              :: () -> (x:int) !foreign lua "love.mouse.getX"
	export getY              :: () -> (y:int) !foreign lua "love.mouse.getY"
	export hasCursor         :: () -> (hascursor:bool) !foreign lua "love.mouse.hasCursor"
	export isCursorSupported :: () -> (supported:bool) !foreign lua "love.mouse.isCursorSupported"
	export isGrabbed         :: () -> (grabbed:bool) !foreign lua "love.mouse.isGrabbed"
	export isVisible         :: () -> (visible:bool) !foreign lua "love.mouse.isVisible"
	export newCursor         :: (imageData:image.ImageData, hotx,hoty:int=0) -> (cursor:Cursor) !foreign lua "love.mouse.newCursor"
	export newCursor         :: (filename:string, hotx,hoty:int=0) -> (cursor:Cursor) !foreign lua "love.mouse.newCursor"
	export newCursor         :: (fileData:filesystem.FileData, hotx,hoty:int=0) -> (cursor:Cursor) !foreign lua "love.mouse.newCursor"
	export setCursor         :: (cursor:Cursor) !foreign lua "love.mouse.setCursor"
	export setCursor         :: () !foreign lua "love.mouse.setCursor"
	export setGrabbed        :: (grab:bool) !foreign lua "love.mouse.setGrabbed"
	export setPosition       :: (x,y:int) !foreign lua "love.mouse.setPosition"
	export setRelativeMode   :: (enable:bool) !foreign lua "love.mouse.setRelativeMode"
	export setVisible        :: (visible:bool) !foreign lua "love.mouse.setVisible"
	export setX              :: (x:int) !foreign lua "love.mouse.setX"
	export setY              :: (y:int) !foreign lua "love.mouse.setY"
	export isDown :: (button,...:int) -> (anyDown:bool) !foreign lua "love.mouse.isDown"
}
export physics :: namespace {
	export BodyType :: enum {
		STATIC    :: "static",
		DYNAMIC   :: "dynamic",
		KINEMATIC :: "kinematic",
	}
	export JointType :: enum {
		DISTANCE  :: "distance",
		FRICTION  :: "friction",
		GEAR      :: "gear",
		MOUSE     :: "mouse",
		PRISMATIC :: "prismatic",
		PULLEY    :: "pulley",
		REVOLUTE  :: "revolute",
		ROPE      :: "rope",
		WELD      :: "weld",
	}
	export ShapeType :: enum {
		CIRCLE  :: "circle",
		POLYGON :: "polygon",
		EDGE    :: "edge",
		CHAIN   :: "chain",
	}
	export Body :: !foreign struct {
		using Object,
		applyAngularImpulse             :: (self:Body, impulse:float) !foreign method "applyAngularImpulse",
		applyForce                      :: (self:Body, fx,fy:float) !foreign method "applyForce",
		applyForce                      :: (self:Body, fx,fy:float, x,y:float) !foreign method "applyForce",
		applyLinearImpulse              :: (self:Body, ix,iy:float) !foreign method "applyLinearImpulse",
		applyLinearImpulse              :: (self:Body, ix,iy:float, x,y:float) !foreign method "applyLinearImpulse",
		applyTorque                     :: (self:Body, torque:float) !foreign method "applyTorque",
		destroy                         :: (self:Body) !foreign method "destroy",
		getAngle                        :: (self:Body) -> (angle:float) !foreign method "getAngle",
		getAngularDamping               :: (self:Body) -> (damping:float) !foreign method "getAngularDamping",
		getAngularVelocity              :: (self:Body) -> (w:float) !foreign method "getAngularVelocity",
		getContacts                     :: (self:Body) -> (contacts:[]Contact) !foreign method "getContacts",
		getFixtures                     :: (self:Body) -> (fixtures:[]Fixture) !foreign method "getFixtures",
		getGravityScale                 :: (self:Body) -> (scale:float) !foreign method "getGravityScale",
		getInertia                      :: (self:Body) -> (inertia:float) !foreign method "getInertia",
		getJoints                       :: (self:Body) -> (joints:[]Joint) !foreign method "getJoints",
		getLinearDamping                :: (self:Body) -> (damping:float) !foreign method "getLinearDamping",
		getLinearVelocity               :: (self:Body) -> (x,y:float) !foreign method "getLinearVelocity",
		getLinearVelocityFromLocalPoint :: (self:Body, x,y:float) -> (vx,vy:float) !foreign method "getLinearVelocityFromLocalPoint",
		getLinearVelocityFromWorldPoint :: (self:Body, x,y:float) -> (vx,vy:float) !foreign method "getLinearVelocityFromWorldPoint",
		getLocalCenter                  :: (self:Body) -> (x,y:float) !foreign method "getLocalCenter",
		getLocalPoint                   :: (self:Body, worldX,worldY:float) -> (localX,localY:float) !foreign method "getLocalPoint",
		getLocalVector                  :: (self:Body, worldX,worldY:float) -> (localX,localY:float) !foreign method "getLocalVector",
		getMass                         :: (self:Body) -> (mass:float) !foreign method "getMass",
		getMassData                     :: (self:Body) -> (x,y:float, mass:float, inertia:float) !foreign method "getMassData",
		getPosition                     :: (self:Body) -> (x,y:float) !foreign method "getPosition",
		getTransform                    :: (self:Body) -> (x,y:float, angle:float) !foreign method "getTransform",
		getType                         :: (self:Body) -> (type:BodyType) !foreign method "getType",
		getUserData                     :: (self:Body) -> (value:any) !foreign method "getUserData",
		getWorld                        :: (self:Body) -> (world:World) !foreign method "getWorld",
		getWorldCenter                  :: (self:Body) -> (x,y:float) !foreign method "getWorldCenter",
		getWorldPoint                   :: (self:Body, localX,localY:float) -> (worldX,worldY:float) !foreign method "getWorldPoint",
		getWorldPoints                  :: (self:Body, x1,y1:float, x2,y2:float) -> (x1,y1:float, x2,y2:float) !foreign method "getWorldPoints",
		getWorldVector                  :: (self:Body, localX,localY:float) -> (worldX,worldY:float) !foreign method "getWorldVector",
		getX                            :: (self:Body) -> (x:float) !foreign method "getX",
		getY                            :: (self:Body) -> (y:float) !foreign method "getY",
		isActive                        :: (self:Body) -> (status:bool) !foreign method "isActive",
		isAwake                         :: (self:Body) -> (status:bool) !foreign method "isAwake",
		isBullet                        :: (self:Body) -> (status:bool) !foreign method "isBullet",
		isDestroyed                     :: (self:Body) -> (destroyed:bool) !foreign method "isDestroyed",
		isFixedRotation                 :: (self:Body) -> (fixed:bool) !foreign method "isFixedRotation",
		isSleepingAllowed               :: (self:Body) -> (allowed:bool) !foreign method "isSleepingAllowed",
		isTouching                      :: (self:Body, otherbody:Body) -> (touching:bool) !foreign method "isTouching",
		resetMassData                   :: (self:Body) !foreign method "resetMassData",
		setActive                       :: (self:Body, active:bool) !foreign method "setActive",
		setAngle                        :: (self:Body, angle:float) !foreign method "setAngle",
		setAngularDamping               :: (self:Body, damping:float) !foreign method "setAngularDamping",
		setAngularVelocity              :: (self:Body, w:float) !foreign method "setAngularVelocity",
		setAwake                        :: (self:Body, awake:bool) !foreign method "setAwake",
		setBullet                       :: (self:Body, status:bool) !foreign method "setBullet",
		setFixedRotation                :: (self:Body, isFixed:bool) !foreign method "setFixedRotation",
		setGravityScale                 :: (self:Body, scale:float) !foreign method "setGravityScale",
		setInertia                      :: (self:Body, inertia:float) !foreign method "setInertia",
		setLinearDamping                :: (self:Body, ld:float) !foreign method "setLinearDamping",
		setLinearVelocity               :: (self:Body, x,y:float) !foreign method "setLinearVelocity",
		setMass                         :: (self:Body, mass:float) !foreign method "setMass",
		setMassData                     :: (self:Body, x,y:float, mass:float, inertia:float) !foreign method "setMassData",
		setPosition                     :: (self:Body, x,y:float) !foreign method "setPosition",
		setSleepingAllowed              :: (self:Body, allowed:bool) !foreign method "setSleepingAllowed",
		setTransform                    :: (self:Body, x,y:float, angle:float) !foreign method "setTransform",
		setType                         :: (self:Body, type:BodyType) !foreign method "setType",
		setUserData                     :: (self:Body, value:any) !foreign method "setUserData",
		setX                            :: (self:Body, x:float) !foreign method "setX",
		setY                            :: (self:Body, y:float) !foreign method "setY",
	}
	export ChainShape :: !foreign struct {
		using Shape,
		getChildEdge      :: (self:ChainShape, index:int) -> (shape:EdgeShape) !foreign method "getChildEdge",
		getNextVertex     :: (self:ChainShape) -> (x,y:float) !foreign method "getNextVertex",
		getPoint          :: (self:ChainShape, index:int) -> (x,y:float) !foreign method "getPoint",
		getPoints         :: (self:ChainShape) -> (x1,y1:float, x2,y2:float) !foreign method "getPoints",
		getPreviousVertex :: (self:ChainShape) -> (x,y:float) !foreign method "getPreviousVertex",
		getVertexCount    :: (self:ChainShape) -> (count:int) !foreign method "getVertexCount",
		setNextVertex     :: (self:ChainShape, x,y:float) !foreign method "setNextVertex",
		setPreviousVertex :: (self:ChainShape, x,y:float) !foreign method "setPreviousVertex",
	}
	export CircleShape :: !foreign struct {
		using Shape,
		getPoint  :: (self:CircleShape) -> (x,y:float) !foreign method "getPoint",
		getRadius :: (self:CircleShape) -> (radius:float) !foreign method "getRadius",
		setPoint  :: (self:CircleShape, x,y:float) !foreign method "setPoint",
		setRadius :: (self:CircleShape, radius:float) !foreign method "setRadius",
	}
	export Contact :: !foreign struct {
		using Object,
		getFixtures      :: (self:Contact) -> (fixtureA:Fixture, fixtureB:Fixture) !foreign method "getFixtures",
		getFriction      :: (self:Contact) -> (friction:float) !foreign method "getFriction",
		getNormal        :: (self:Contact) -> (nx,ny:float) !foreign method "getNormal",
		getPositions     :: (self:Contact) -> (x1,y1:float, x2,y2:float) !foreign method "getPositions",
		getRestitution   :: (self:Contact) -> (restitution:float) !foreign method "getRestitution",
		isEnabled        :: (self:Contact) -> (enabled:bool) !foreign method "isEnabled",
		isTouching       :: (self:Contact) -> (touching:bool) !foreign method "isTouching",
		resetFriction    :: (self:Contact) !foreign method "resetFriction",
		resetRestitution :: (self:Contact) !foreign method "resetRestitution",
		setEnabled       :: (self:Contact, enabled:bool) !foreign method "setEnabled",
		setFriction      :: (self:Contact, friction:float) !foreign method "setFriction",
		setRestitution   :: (self:Contact, restitution:float) !foreign method "setRestitution",
	}
	export DistanceJoint :: !foreign struct {
		using Joint,
		getDampingRatio :: (self:DistanceJoint) -> (ratio:float) !foreign method "getDampingRatio",
		getFrequency    :: (self:DistanceJoint) -> (Hz:float) !foreign method "getFrequency",
		getLength       :: (self:DistanceJoint) -> (l:float) !foreign method "getLength",
		setDampingRatio :: (self:DistanceJoint, ratio:float) !foreign method "setDampingRatio",
		setFrequency    :: (self:DistanceJoint, Hz:float) !foreign method "setFrequency",
		setLength       :: (self:DistanceJoint, l:float) !foreign method "setLength",
	}
	export EdgeShape :: !foreign struct {
		using Shape,
		getNextVertex     :: (self:EdgeShape) -> (x,y:float) !foreign method "getNextVertex",
		getPoints         :: (self:EdgeShape) -> (x1,y1:float, x2,y2:float) !foreign method "getPoints",
		getPreviousVertex :: (self:EdgeShape) -> (x,y:float) !foreign method "getPreviousVertex",
		setNextVertex     :: (self:EdgeShape, x,y:float) !foreign method "setNextVertex",
		setPreviousVertex :: (self:EdgeShape, x,y:float) !foreign method "setPreviousVertex",
	}
	export Fixture :: !foreign struct {
		using Object,
		destroy        :: (self:Fixture) !foreign method "destroy",
		getBody        :: (self:Fixture) -> (body:Body) !foreign method "getBody",
		getBoundingBox :: (self:Fixture, index:int=1) -> (topLeftX,topLeftY:float, bottomRightX,bottomRightY:float) !foreign method "getBoundingBox",
		getCategory    :: (self:Fixture) -> (category1:int, category2:int) !foreign method "getCategory",
		getDensity     :: (self:Fixture) -> (density:float) !foreign method "getDensity",
		getFilterData  :: (self:Fixture) -> (categories:int, mask:int, group:int) !foreign method "getFilterData",
		getFriction    :: (self:Fixture) -> (friction:float) !foreign method "getFriction",
		getGroupIndex  :: (self:Fixture) -> (group:int) !foreign method "getGroupIndex",
		getMask        :: (self:Fixture) -> (mask1:int, mask2:int) !foreign method "getMask",
		getMassData    :: (self:Fixture) -> (x,y:float, mass:float, inertia:float) !foreign method "getMassData",
		getRestitution :: (self:Fixture) -> (restitution:float) !foreign method "getRestitution",
		getShape       :: (self:Fixture) -> (shape:Shape) !foreign method "getShape",
		getUserData    :: (self:Fixture) -> (value:any) !foreign method "getUserData",
		isDestroyed    :: (self:Fixture) -> (destroyed:bool) !foreign method "isDestroyed",
		isSensor       :: (self:Fixture) -> (sensor:bool) !foreign method "isSensor",
		rayCast        :: (self:Fixture, x1,y1:float, x2,y2:float, maxFraction:float, childIndex:float=1) -> (xn,yn:float, fraction:float) !foreign method "rayCast",
		setCategory    :: (self:Fixture, category1:int, category2:int) !foreign method "setCategory",
		setDensity     :: (self:Fixture, density:float) !foreign method "setDensity",
		setFilterData  :: (self:Fixture, categories:int, mask:int, group:int) !foreign method "setFilterData",
		setFriction    :: (self:Fixture, friction:float) !foreign method "setFriction",
		setGroupIndex  :: (self:Fixture, group:int) !foreign method "setGroupIndex",
		setMask        :: (self:Fixture, mask1:int, mask2:int) !foreign method "setMask",
		setRestitution :: (self:Fixture, restitution:float) !foreign method "setRestitution",
		setSensor      :: (self:Fixture, sensor:bool) !foreign method "setSensor",
		setUserData    :: (self:Fixture, value:any) !foreign method "setUserData",
		testPoint      :: (self:Fixture, x,y:float) -> (isInside:bool) !foreign method "testPoint",
	}
	export FrictionJoint :: !foreign struct {
		using Joint,
		getMaxForce  :: (self:FrictionJoint) -> (force:float) !foreign method "getMaxForce",
		getMaxTorque :: (self:FrictionJoint) -> (torque:float) !foreign method "getMaxTorque",
		setMaxForce  :: (self:FrictionJoint, maxForce:float) !foreign method "setMaxForce",
		setMaxTorque :: (self:FrictionJoint, torque:float) !foreign method "setMaxTorque",
	}
	export GearJoint :: !foreign struct {
		using Joint,
		getJoints :: (self:GearJoint) -> (joint1,joint2:Joint) !foreign method "getJoints",
		getRatio  :: (self:GearJoint) -> (ratio:float) !foreign method "getRatio",
		setRatio  :: (self:GearJoint, ratio:float) !foreign method "setRatio",
	}
	export Joint :: !foreign struct {
		using Object,
		destroy             :: (self:Joint) !foreign method "destroy",
		getAnchors          :: (self:Joint) -> (x1,y1:float, x2,y2:float) !foreign method "getAnchors",
		getBodies           :: (self:Joint) -> (bodyA:Body, bodyB:Body) !foreign method "getBodies",
		getCollideConnected :: (self:Joint) -> (c:bool) !foreign method "getCollideConnected",
		getReactionForce    :: (self:Joint, x:float) -> (x,y:float) !foreign method "getReactionForce",
		getReactionTorque   :: (self:Joint, invdt:float) -> (torque:float) !foreign method "getReactionTorque",
		getType             :: (self:Joint) -> (type:JointType) !foreign method "getType",
		getUserData         :: (self:Joint) -> (value:any) !foreign method "getUserData",
		isDestroyed         :: (self:Joint) -> (destroyed:bool) !foreign method "isDestroyed",
		setUserData         :: (self:Joint, value:any) !foreign method "setUserData",
	}
	export MotorJoint :: !foreign struct {
		using Joint,
		getAngularOffset :: (self:MotorJoint) -> (angleoffset:float) !foreign method "getAngularOffset",
		getLinearOffset  :: (self:MotorJoint) -> (x,y:float) !foreign method "getLinearOffset",
		setAngularOffset :: (self:MotorJoint, angleoffset:float) !foreign method "setAngularOffset",
		setLinearOffset  :: (self:MotorJoint, x,y:float) !foreign method "setLinearOffset",
	}
	export MouseJoint :: !foreign struct {
		using Joint,
		getDampingRatio :: (self:MouseJoint) -> (ratio:float) !foreign method "getDampingRatio",
		getFrequency    :: (self:MouseJoint) -> (freq:float) !foreign method "getFrequency",
		getMaxForce     :: (self:MouseJoint) -> (f:float) !foreign method "getMaxForce",
		getTarget       :: (self:MouseJoint) -> (x,y:float) !foreign method "getTarget",
		setDampingRatio :: (self:MouseJoint, ratio:float) !foreign method "setDampingRatio",
		setFrequency    :: (self:MouseJoint, freq:float) !foreign method "setFrequency",
		setMaxForce     :: (self:MouseJoint, f:float) !foreign method "setMaxForce",
		setTarget       :: (self:MouseJoint, x,y:float) !foreign method "setTarget",
	}
	export PolygonShape :: !foreign struct {
		using Shape,
		getPoints :: (self:PolygonShape) -> (x1,y1:float, x2,y2:float) !foreign method "getPoints",
	}
	export PrismaticJoint :: !foreign struct {
		using Joint,
		areLimitsEnabled    :: (self:PrismaticJoint) -> (enabled:bool) !foreign method "areLimitsEnabled",
		getAxis             :: (self:PrismaticJoint) -> (x,y:float) !foreign method "getAxis",
		getJointSpeed       :: (self:PrismaticJoint) -> (s:float) !foreign method "getJointSpeed",
		getJointTranslation :: (self:PrismaticJoint) -> (t:float) !foreign method "getJointTranslation",
		getLimits           :: (self:PrismaticJoint) -> (lower,upper:float) !foreign method "getLimits",
		getLowerLimit       :: (self:PrismaticJoint) -> (lower:float) !foreign method "getLowerLimit",
		getMaxMotorForce    :: (self:PrismaticJoint) -> (f:float) !foreign method "getMaxMotorForce",
		getMotorForce       :: (self:PrismaticJoint, invdt:float) -> (force:float) !foreign method "getMotorForce",
		getMotorSpeed       :: (self:PrismaticJoint) -> (s:float) !foreign method "getMotorSpeed",
		getUpperLimit       :: (self:PrismaticJoint) -> (upper:float) !foreign method "getUpperLimit",
		isMotorEnabled      :: (self:PrismaticJoint) -> (enabled:bool) !foreign method "isMotorEnabled",
		setLimits           :: (self:PrismaticJoint, lower,upper:float) !foreign method "setLimits",
		setLimitsEnabled    :: (self:PrismaticJoint) -> (enable:bool) !foreign method "setLimitsEnabled",
		setLowerLimit       :: (self:PrismaticJoint, lower:float) !foreign method "setLowerLimit",
		setMaxMotorForce    :: (self:PrismaticJoint, f:float) !foreign method "setMaxMotorForce",
		setMotorEnabled     :: (self:PrismaticJoint, enable:bool) !foreign method "setMotorEnabled",
		setMotorSpeed       :: (self:PrismaticJoint, s:float) !foreign method "setMotorSpeed",
		setUpperLimit       :: (self:PrismaticJoint, upper:float) !foreign method "setUpperLimit",
	}
	export PulleyJoint :: !foreign struct {
		using Joint,
		getConstant      :: (self:PulleyJoint) -> (length:float) !foreign method "getConstant",
		getGroundAnchors :: (self:PulleyJoint) -> (a1x,a1y:float, a2x,a2y:float) !foreign method "getGroundAnchors",
		getLengthA       :: (self:PulleyJoint) -> (length:float) !foreign method "getLengthA",
		getLengthB       :: (self:PulleyJoint) -> (length:float) !foreign method "getLengthB",
		getMaxLengths    :: (self:PulleyJoint) -> (len1,len2:float) !foreign method "getMaxLengths",
		getRatio         :: (self:PulleyJoint) -> (ratio:float) !foreign method "getRatio",
		setConstant      :: (self:PulleyJoint, length:float) !foreign method "setConstant",
		setMaxLengths    :: (self:PulleyJoint, max1,max2:float) !foreign method "setMaxLengths",
		setRatio         :: (self:PulleyJoint, ratio:float) !foreign method "setRatio",
	}
	export RevoluteJoint :: !foreign struct {
		using Joint,
		areLimitsEnabled  :: (self:RevoluteJoint) -> (enabled:bool) !foreign method "areLimitsEnabled",
		getJointAngle     :: (self:RevoluteJoint) -> (angle:float) !foreign method "getJointAngle",
		getJointSpeed     :: (self:RevoluteJoint) -> (s:float) !foreign method "getJointSpeed",
		getLimits         :: (self:RevoluteJoint) -> (lower,upper:float) !foreign method "getLimits",
		getLowerLimit     :: (self:RevoluteJoint) -> (lower:float) !foreign method "getLowerLimit",
		getMaxMotorTorque :: (self:RevoluteJoint) -> (f:float) !foreign method "getMaxMotorTorque",
		getMotorSpeed     :: (self:RevoluteJoint) -> (s:float) !foreign method "getMotorSpeed",
		getMotorTorque    :: (self:RevoluteJoint) -> (f:float) !foreign method "getMotorTorque",
		getUpperLimit     :: (self:RevoluteJoint) -> (upper:float) !foreign method "getUpperLimit",
		hasLimitsEnabled  :: (self:RevoluteJoint) -> (enabled:bool) !foreign method "hasLimitsEnabled",
		isMotorEnabled    :: (self:RevoluteJoint) -> (enabled:bool) !foreign method "isMotorEnabled",
		setLimits         :: (self:RevoluteJoint, lower,upper:float) !foreign method "setLimits",
		setLimitsEnabled  :: (self:RevoluteJoint, enable:bool) !foreign method "setLimitsEnabled",
		setLowerLimit     :: (self:RevoluteJoint, lower:float) !foreign method "setLowerLimit",
		setMaxMotorTorque :: (self:RevoluteJoint, f:float) !foreign method "setMaxMotorTorque",
		setMotorEnabled   :: (self:RevoluteJoint, enable:bool) !foreign method "setMotorEnabled",
		setMotorSpeed     :: (self:RevoluteJoint, s:float) !foreign method "setMotorSpeed",
		setUpperLimit     :: (self:RevoluteJoint, upper:float) !foreign method "setUpperLimit",
	}
	export RopeJoint :: !foreign struct {
		using Joint,
		getMaxLength :: (self:RopeJoint) -> (maxLength:float) !foreign method "getMaxLength",
		setMaxLength :: (self:RopeJoint, maxLength:float) !foreign method "setMaxLength",
	}
	export Shape :: !foreign struct {
		using Object,
		computeAABB   :: (self:Shape, tx,ty:float, tr:float, childIndex:int=1) -> (topLeftX,topLeftY:float, bottomRightX,bottomRightY:float) !foreign method "computeAABB",
		computeMass   :: (self:Shape, density:float) -> (x,y:float, mass:float, inertia:float) !foreign method "computeMass",
		getChildCount :: (self:Shape) -> (count:int) !foreign method "getChildCount",
		getRadius     :: (self:Shape) -> (radius:float) !foreign method "getRadius",
		getType       :: (self:Shape) -> (type:ShapeType) !foreign method "getType",
		rayCast       :: (self:Shape, x1,y1:float, x2,y2:float, maxFraction:float, tx,ty:float, tr:float, childIndex:float=1) -> (xn,yn:float, fraction:float) !foreign method "rayCast",
		testPoint     :: (self:Shape, tx,ty:float, tr:float, x,y:float) -> (hit:bool) !foreign method "testPoint",
	}
	export WeldJoint :: !foreign struct {
		using Joint,
		getDampingRatio :: (self:WeldJoint) -> (ratio:float) !foreign method "getDampingRatio",
		getFrequency    :: (self:WeldJoint) -> (freq:float) !foreign method "getFrequency",
		setDampingRatio :: (self:WeldJoint, ratio:float) !foreign method "setDampingRatio",
		setFrequency    :: (self:WeldJoint, freq:float) !foreign method "setFrequency",
	}
	export WheelJoint :: !foreign struct {
		using Joint,
		getAxis               :: (self:WheelJoint) -> (x,y:float) !foreign method "getAxis",
		getJointSpeed         :: (self:WheelJoint) -> (speed:float) !foreign method "getJointSpeed",
		getJointTranslation   :: (self:WheelJoint) -> (position:float) !foreign method "getJointTranslation",
		getMaxMotorTorque     :: (self:WheelJoint) -> (maxTorque:float) !foreign method "getMaxMotorTorque",
		getMotorSpeed         :: (self:WheelJoint) -> (speed:float) !foreign method "getMotorSpeed",
		getMotorTorque        :: (self:WheelJoint, invdt:float) -> (torque:float) !foreign method "getMotorTorque",
		getSpringDampingRatio :: (self:WheelJoint) -> (ratio:float) !foreign method "getSpringDampingRatio",
		getSpringFrequency    :: (self:WheelJoint) -> (freq:float) !foreign method "getSpringFrequency",
		setMaxMotorTorque     :: (self:WheelJoint, maxTorque:float) !foreign method "setMaxMotorTorque",
		setMotorEnabled       :: (self:WheelJoint, enable:bool) !foreign method "setMotorEnabled",
		setMotorSpeed         :: (self:WheelJoint, speed:float) !foreign method "setMotorSpeed",
		setSpringDampingRatio :: (self:WheelJoint, ratio:float) !foreign method "setSpringDampingRatio",
		setSpringFrequency    :: (self:WheelJoint, freq:float) !foreign method "setSpringFrequency",
	}
	export World :: !foreign struct {
		using Object,
		destroy            :: (self:World) !foreign method "destroy",
		getBodies          :: (self:World) -> (bodies:[]Body) !foreign method "getBodies",
		getBodyCount       :: (self:World) -> (n:int) !foreign method "getBodyCount",
		getContactCount    :: (self:World) -> (n:int) !foreign method "getContactCount",
		getContacts        :: (self:World) -> (contacts:[]Contact) !foreign method "getContacts",
		getGravity         :: (self:World) -> (x,y:float) !foreign method "getGravity",
		getJointCount      :: (self:World) -> (n:int) !foreign method "getJointCount",
		getJoints          :: (self:World) -> (joints:[]Joint) !foreign method "getJoints",
		isDestroyed        :: (self:World) -> (destroyed:bool) !foreign method "isDestroyed",
		isLocked           :: (self:World) -> (locked:bool) !foreign method "isLocked",
		isSleepingAllowed  :: (self:World) -> (allow:bool) !foreign method "isSleepingAllowed",
		rayCast            :: (self:World, fixture:Fixture, x,y:float, xn,yn:float, fraction:float) -> (control:float) !foreign method "rayCast",
		setGravity         :: (self:World, x,y:float) !foreign method "setGravity",
		setSleepingAllowed :: (self:World, allow:bool) !foreign method "setSleepingAllowed",
		translateOrigin    :: (self:World, x,y:float) !foreign method "translateOrigin",
		update             :: (self:World, dt:float, velocityiterations:int=8, positioniterations:int=3) !foreign method "update",
		_Callback          :: (fixture1,fixture2:Fixture, contact:Contact),
		_CallbackPostSolve :: (fixture1,fixture2:Fixture, contact:Contact, ...--[[ normalImpulse1,tangentImpulse1, normalImpulse2,tangentImpulse2, ... ]]:float),
		getCallbacks :: (self:World) -> (beginContact,endContact,preSolve:_Callback|none, postSolve:_CallbackPostSolve|none) !foreign method "getCallbacks",
		setCallbacks :: (self:World, beginContact,endContact,preSolve:_Callback|none, postSolve:_CallbackPostSolve|none)     !foreign method "setCallbacks",
		_ContactFilter :: (fixture1,fixture2:Fixture) -> (doCollide:bool),
		getContactFilter :: (self:World) -> (filter:_ContactFilter|none) !foreign method "getContactFilter",
		setContactFilter :: (self:World, filter:_ContactFilter|none)     !foreign method "setContactFilter",
		queryBoundingBox :: (self:World, topLeftX,topLeftY,bottomRightX,bottomRightY:float, callback:(fixture:Fixture)->(continueSearch:bool)) !foreign method "queryBoundingBox",
	}
	export getDistance       :: (fixture1:Fixture, fixture2:Fixture) -> (distance:float, x1,y1:float, x2,y2:float) !foreign lua "love.physics.getDistance"
	export getMeter          :: () -> (scale:float) !foreign lua "love.physics.getMeter"
	export newBody           :: (world:World, x,y:float=0, type:BodyType=cast(BodyType)"static") -> (body:Body) !foreign lua "love.physics.newBody"
	export newChainShape     :: (loop:bool, x1,y1:float, x2,y2:float, ...:float) -> (shape:ChainShape) !foreign lua "love.physics.newChainShape"
	export newChainShape     :: (loop:bool, points:[]float) -> (shape:ChainShape) !foreign lua "love.physics.newChainShape"
	export newCircleShape    :: (radius:float) -> (shape:CircleShape) !foreign lua "love.physics.newCircleShape"
	export newCircleShape    :: (x,y:float, radius:float) -> (shape:CircleShape) !foreign lua "love.physics.newCircleShape"
	export newDistanceJoint  :: (body1,body2:Body, x1,y1:float, x2,y2:float, collideConnected:bool=false) -> (joint:DistanceJoint) !foreign lua "love.physics.newDistanceJoint"
	export newEdgeShape      :: (x1,y1:float, x2,y2:float) -> (shape:EdgeShape) !foreign lua "love.physics.newEdgeShape"
	export newFixture        :: (body:Body, shape:Shape, density:float=1) -> (fixture:Fixture) !foreign lua "love.physics.newFixture"
	export newFrictionJoint  :: (body1,body2:Body, x,y:float, collideConnected:bool=false) -> (joint:FrictionJoint) !foreign lua "love.physics.newFrictionJoint"
	export newFrictionJoint  :: (body1,body2:Body, x1,y1:float, x2,y2:float, collideConnected:bool=false) -> (joint:FrictionJoint) !foreign lua "love.physics.newFrictionJoint"
	export newGearJoint      :: (joint1,joint2:Joint, ratio:float=1, collideConnected:bool=false) -> (joint:GearJoint) !foreign lua "love.physics.newGearJoint"
	export newMouseJoint     :: (body:Body, x,y:float) -> (joint:MouseJoint) !foreign lua "love.physics.newMouseJoint"
	export newPolygonShape   :: (x1,y1:float, x2,y2:float, x3,y3:float, ...:float) -> (shape:PolygonShape) !foreign lua "love.physics.newPolygonShape"
	export newPolygonShape   :: (vertices:[]float) -> (shape:PolygonShape) !foreign lua "love.physics.newPolygonShape"
	export newPulleyJoint    :: (body1,body2:Body, gx1,gy1:float, gx2,gy2:float, x1,y1:float, x2,y2:float, ratio:float=1, collideConnected:bool=true) -> (joint:PulleyJoint) !foreign lua "love.physics.newPulleyJoint"
	export newRectangleShape :: (width,height:float) -> (shape:PolygonShape) !foreign lua "love.physics.newRectangleShape"
	export newRectangleShape :: (x,y:float, width,height:float, angle:float=0) -> (shape:PolygonShape) !foreign lua "love.physics.newRectangleShape"
	export newRevoluteJoint  :: (body1,body2:Body, x,y:float, collideConnected:bool=false) -> (joint:RevoluteJoint) !foreign lua "love.physics.newRevoluteJoint"
	export newRevoluteJoint  :: (body1,body2:Body, x1,y1:float, x2,y2:float, collideConnected:bool=false, referenceAngle:float=0) -> (joint:RevoluteJoint) !foreign lua "love.physics.newRevoluteJoint"
	export newRopeJoint      :: (body1,body2:Body, x1,y1:float, x2,y2:float, maxLength:float, collideConnected:bool=false) -> (joint:RopeJoint) !foreign lua "love.physics.newRopeJoint"
	export newWheelJoint     :: (body1,body2:Body, x,y:float, ax,ay:float, collideConnected:bool=false) -> (joint:WheelJoint) !foreign lua "love.physics.newWheelJoint"
	export newWheelJoint     :: (body1,body2:Body, x1,y1:float, x2,y2:float, ax,ay:float, collideConnected:bool=false) -> (joint:WheelJoint) !foreign lua "love.physics.newWheelJoint"
	export newWorld          :: (xg:float=0, yg:float=0, sleep:bool=true) -> (world:World) !foreign lua "love.physics.newWorld"
	export setMeter          :: (scale:float) !foreign lua "love.physics.setMeter"
	export newMotorJoint :: (body1,body2:Body, correctionFactor=0.3, collideConnected=false) -> (joint:MotorJoint) !foreign lua "love.physics.newMotorJoint"
	export newPrismaticJoint :: (body1,body2:Body, x,y:float,         ax,ay:float, collideConnected=false)                     -> (joint:PrismaticJoint) !foreign lua "love.physics.newPrismaticJoint"
	export newPrismaticJoint :: (body1,body2:Body, x1,y1,x2,y2:float, ax,ay:float, collideConnected=false, referenceAngle=0.0) -> (joint:PrismaticJoint) !foreign lua "love.physics.newPrismaticJoint"
	export newWeldJoint :: (body1,body2:Body, x,y:float,         collideConnected=false)                     -> (joint:WeldJoint) !foreign lua "love.physics.newWeldJoint"
	export newWeldJoint :: (body1,body2:Body, x1,y1,x2,y2:float, collideConnected=false, referenceAngle=0.0) -> (joint:WeldJoint) !foreign lua "love.physics.newWeldJoint"
}
export sound :: namespace {
	export Decoder :: !foreign struct {
		using Object,
		clone           :: (self:Decoder) -> (decoder:Decoder) !foreign method "clone",
		getBitDepth     :: (self:Decoder) -> (bitDepth:int) !foreign method "getBitDepth",
		getChannelCount :: (self:Decoder) -> (channels:int) !foreign method "getChannelCount",
		getDuration     :: (self:Decoder) -> (duration:float) !foreign method "getDuration",
		getSampleRate   :: (self:Decoder) -> (rate:int) !foreign method "getSampleRate",
	}
	export SoundData :: !foreign struct {
		using Data,
		getBitDepth     :: (self:SoundData) -> (bitdepth:int) !foreign method "getBitDepth",
		getChannelCount :: (self:SoundData) -> (channels:int) !foreign method "getChannelCount",
		getDuration     :: (self:SoundData) -> (duration:float) !foreign method "getDuration",
		getSample       :: (self:SoundData, i:int) -> (sample:float) !foreign method "getSample",
		getSample       :: (self:SoundData, i:int, channel:int) -> (sample:float) !foreign method "getSample",
		getSampleCount  :: (self:SoundData) -> (count:int) !foreign method "getSampleCount",
		getSampleRate   :: (self:SoundData) -> (rate:int) !foreign method "getSampleRate",
		setSample       :: (self:SoundData, i:int, sample:float) !foreign method "setSample",
		setSample       :: (self:SoundData, i:int, channel:int, sample:float) !foreign method "setSample",
	}
	export newDecoder   :: (file:filesystem.File, buffer:int=2048) -> (decoder:Decoder) !foreign lua "love.sound.newDecoder"
	export newDecoder   :: (filename:string, buffer:int=2048) -> (decoder:Decoder) !foreign lua "love.sound.newDecoder"
	export newSoundData :: (filename:string) -> (soundData:SoundData) !foreign lua "love.sound.newSoundData"
	export newSoundData :: (file:filesystem.File) -> (soundData:SoundData) !foreign lua "love.sound.newSoundData"
	export newSoundData :: (decoder:Decoder) -> (soundData:SoundData) !foreign lua "love.sound.newSoundData"
	export newSoundData :: (samples:int, rate:int=44100, bits:int=16, channels:int=2) -> (soundData:SoundData) !foreign lua "love.sound.newSoundData"
}
export system :: namespace {
	export PowerState :: enum {
		UNKNOWN    :: "unknown",
		BATTERY    :: "battery",
		NO_BATTERY :: "nobattery",
		CHARGING   :: "charging",
		CHARGED    :: "charged",
	}
	export getClipboardText   :: () -> (text:string) !foreign lua "love.system.getClipboardText"
	export getOS              :: () -> (osString:string) !foreign lua "love.system.getOS"
	export getProcessorCount  :: () -> (processorCount:int) !foreign lua "love.system.getProcessorCount"
	export hasBackgroundMusic :: () -> (backgroundmusic:bool) !foreign lua "love.system.hasBackgroundMusic"
	export openURL            :: (url:string) -> (success:bool) !foreign lua "love.system.openURL"
	export setClipboardText   :: (text:string) !foreign lua "love.system.setClipboardText"
	export vibrate :: (seconds=0.5) !foreign lua "love.system.vibrate"
	export getPowerInfo :: () -> (state:PowerState, percent:int|none, seconds:float|none) !foreign lua "love.system.getPowerInfo"
}
export thread :: namespace {
	export Channel :: !foreign struct {
		using Object,
		clear    :: (self:Channel) !foreign method "clear",
		demand   :: (self:Channel) -> (value:Variant) !foreign method "demand",
		demand   :: (self:Channel, timeout:float) -> (value:Variant) !foreign method "demand",
		getCount :: (self:Channel) -> (count:int) !foreign method "getCount",
		hasRead  :: (self:Channel, id:int) -> (hasread:bool) !foreign method "hasRead",
		peek     :: (self:Channel) -> (value:Variant) !foreign method "peek",
		pop      :: (self:Channel) -> (value:Variant) !foreign method "pop",
		push     :: (self:Channel, value:Variant) -> (id:int) !foreign method "push",
		supply   :: (self:Channel, value:Variant) -> (success:bool) !foreign method "supply",
		supply   :: (self:Channel, value:Variant, timeout:float) -> (success:bool) !foreign method "supply",
		_Function         :: (channel:Channel),
		_FunctionArgs     :: (channel:Channel, ...--[[args]]:any),
		_FunctionRets     :: (channel:Channel)                    -> (ret1,...:any),
		_FunctionArgsRets :: (channel:Channel, ...--[[args]]:any) -> (ret1,...:any),
		performAtomic :: (self:Channel, func:_Function)                                              !foreign method "performAtomic",
		performAtomic :: (self:Channel, func:_FunctionArgs,     ...--[[args]]:any)                   !foreign method "performAtomic",
		performAtomic :: (self:Channel, func:_FunctionRets)                        -> (ret1,...:any) !foreign method "performAtomic",
		performAtomic :: (self:Channel, func:_FunctionArgsRets, ...--[[args]]:any) -> (ret1,...:any) !foreign method "performAtomic",
	}
	export Thread :: !foreign struct {
		using Object,
		getError  :: (self:Thread) -> (err:string) !foreign method "getError",
		isRunning :: (self:Thread) -> (value:bool) !foreign method "isRunning",
		wait      :: (self:Thread) !foreign method "wait",
		start :: (self:Thread, ...--[[args]]:Variant) !foreign method "start",
	}
	export getChannel :: (name:string) -> (channel:Channel) !foreign lua "love.thread.getChannel"
	export newChannel :: () -> (channel:Channel) !foreign lua "love.thread.newChannel"
	export newThread :: (filenameOrLuaCode:string)     -> (thread:Thread) !foreign lua "love.thread.newThread"
	export newThread :: (fileData:filesystem.FileData) -> (thread:Thread) !foreign lua "love.thread.newThread"
}
export timer :: namespace {
	export getAverageDelta :: () -> (delta:float) !foreign lua "love.timer.getAverageDelta"
	export getDelta        :: () -> (dt:float) !foreign lua "love.timer.getDelta"
	export getFPS          :: () -> (fps:float--[[Correct?]]) !foreign lua "love.timer.getFPS"
	export getTime         :: () -> (time:float) !foreign lua "love.timer.getTime"
	export sleep           :: (s:float) !foreign lua "love.timer.sleep"
	export step            :: () -> (dt:float) !foreign lua "love.timer.step"
}
export touch :: namespace {
	export getPosition :: (id:LightUserdata) -> (x,y:int) !foreign lua "love.touch.getPosition"
	export getPressure :: (id:LightUserdata) -> (pressure:float) !foreign lua "love.touch.getPressure"
	export getTouches  :: () -> (touches:[]LightUserdata) !foreign lua "love.touch.getTouches"
}
export video :: namespace {
	export VideoStream :: !foreign struct {
		using Object,
	}
	export newVideoStream :: (filename:string) -> (videostream:VideoStream) !foreign lua "love.video.newVideoStream"
	export newVideoStream :: (file:filesystem.File) -> (videostream:VideoStream) !foreign lua "love.video.newVideoStream"
}
export window :: namespace {
	export FullscreenType :: enum {
		DESKTOP   :: "desktop",
		EXCLUSIVE :: "exclusive",
		NORMAL    :: "normal",
	}
	export MessageBoxType :: enum {
		INFO    :: "info",
		WARNING :: "warning",
		ERROR   :: "error",
	}
	export close                  :: () !foreign lua "love.window.close"
	export fromPixels             :: (pixelvalue:int--[[Correct?]]) -> (value:float) !foreign lua "love.window.fromPixels"
	export fromPixels             :: (px,py:int--[[Correct?]]) -> (x,y:float) !foreign lua "love.window.fromPixels"
	export getDPIScale            :: () -> (scale:int--[[Correct?]]) !foreign lua "love.window.getDPIScale"
	export getDisplayName         :: (displayindex:int=1) -> (name:string) !foreign lua "love.window.getDisplayName"
	export getFullscreen          :: () -> (fullscreen:bool, fstype:FullscreenType) !foreign lua "love.window.getFullscreen"
	export getFullscreenModes     :: (display:int=1) -> (modes:[]FullscreenMode) !foreign lua "love.window.getFullscreenModes"
	export getIcon                :: () -> (imagedata:image.ImageData) !foreign lua "love.window.getIcon"
	export getMode                :: () -> (width,height:int, flags:WindowFlags) !foreign lua "love.window.getMode"
	export getPosition            :: () -> (x,y:int, display:int) !foreign lua "love.window.getPosition"
	export getSafeArea            :: () -> (x,y:int, w,h:int) !foreign lua "love.window.getSafeArea"
	export getTitle               :: () -> (title:string) !foreign lua "love.window.getTitle"
	export getVSync               :: () -> (vsync:int) !foreign lua "love.window.getVSync"
	export hasFocus               :: () -> (focus:bool) !foreign lua "love.window.hasFocus"
	export hasMouseFocus          :: () -> (focus:bool) !foreign lua "love.window.hasMouseFocus"
	export isDisplaySleepEnabled  :: () -> (enabled:bool) !foreign lua "love.window.isDisplaySleepEnabled"
	export isMaximized            :: () -> (maximized:bool) !foreign lua "love.window.isMaximized"
	export isMinimized            :: () -> (minimized:bool) !foreign lua "love.window.isMinimized"
	export isOpen                 :: () -> (open:bool) !foreign lua "love.window.isOpen"
	export isVisible              :: () -> (visible:bool) !foreign lua "love.window.isVisible"
	export maximize               :: () !foreign lua "love.window.maximize"
	export minimize               :: () !foreign lua "love.window.minimize"
	export requestAttention       :: (continuous:bool=false) !foreign lua "love.window.requestAttention"
	export restore                :: () !foreign lua "love.window.restore"
	export setDisplaySleepEnabled :: (enable:bool) !foreign lua "love.window.setDisplaySleepEnabled"
	export setFullscreen          :: (fullscreen:bool) -> (success:bool) !foreign lua "love.window.setFullscreen"
	export setFullscreen          :: (fullscreen:bool, fstype:FullscreenType) -> (success:bool) !foreign lua "love.window.setFullscreen"
	export setIcon                :: (imagedata:image.ImageData) -> (success:bool) !foreign lua "love.window.setIcon"
	export setMode                :: (width,height:int, flags:WindowFlags) -> (success:bool) !foreign lua "love.window.setMode"
	export setPosition            :: (x,y:int, display:int=1) !foreign lua "love.window.setPosition"
	export setTitle               :: (title:string) !foreign lua "love.window.setTitle"
	export setVSync               :: (vsync:int) !foreign lua "love.window.setVSync"
	export showMessageBox         :: (title:string, message:string, type:MessageBoxType=cast(MessageBoxType)"info", attachtowindow:bool=true) -> (success:bool) !foreign lua "love.window.showMessageBox"
	export showMessageBox         :: (title:string, message:string, buttonlist:MessageBoxButtons, type:MessageBoxType=cast(MessageBoxType)"info", attachtowindow:bool=true) -> (pressedbutton:int) !foreign lua "love.window.showMessageBox"
	export toPixels               :: (value:float) -> (pixelvalue:int--[[Correct?]]) !foreign lua "love.window.toPixels"
	export toPixels               :: (x,y:float) -> (px,py:int--[[Correct?]]) !foreign lua "love.window.toPixels"
	export updateMode             :: (width,height:int, settings:WindowFlags) -> (success:bool) !foreign lua "love.window.updateMode"
	export DisplayOrientation :: enum {
		LANDSCAPE         :: "landscape",
		LANDSCAPE_FLIPPED :: "landscapeflipped",
		PORTRAIT          :: "portrait",
		PORTRAIT_FLIPPED  :: "portraitflipped",
	}
	export getDisplayOrientation :: ()          -> (orientation:DisplayOrientation) !foreign lua "love.window.getDisplayOrientation"
	export getDisplayOrientation :: (index:int) -> (orientation:DisplayOrientation) !foreign lua "love.window.getDisplayOrientation"
	export FullscreenMode :: !foreign struct { width:int, height:int }
	export WindowFlags :: struct { fullscreen=false, fullscreentype=FullscreenType.DESKTOP, vsync=1, msaa=0, resizable=false, borderless=false, centered=true, display=1, minwidth=1, minheight=1, highdpi=false, x:int|none=nil, y:int|none=nil, usedpiscale=true, refreshrate=0 }
	export MessageBoxButtons :: struct { !value:string, enterbutton:int|none=nil, escapebutton:int|none=nil }
}
export font :: namespace {
	export HintingMode :: enum {
		NORMAL :: "normal",
		LIGHT  :: "light",
		MONO   :: "mono",
		NONE   :: "none",
	}

	export GlyphData :: !foreign struct { using Data }

	export Rasterizer :: !foreign struct {
		using Object,

		getAdvance :: (self:Rasterizer) -> (advance:int) !foreign method "getAdvance",
		getAscent  :: (self:Rasterizer) -> (ascent:int)  !foreign method "getAscent",
		getDescent :: (self:Rasterizer) -> (descent:int) !foreign method "getDescent",

		getHeight     :: (self:Rasterizer) -> (height:int)     !foreign method "getHeight",
		getLineHeight :: (self:Rasterizer) -> (lineHeight:int) !foreign method "getLineHeight", -- Is this actually a float?

		getGlyphData :: (self:Rasterizer, glyph:string) -> (glyphData:GlyphData) !foreign method "getGlyphData",
		getGlyphData :: (self:Rasterizer, glyph:int)    -> (glyphData:GlyphData) !foreign method "getGlyphData",

		getGlyphCount :: (self:Rasterizer) -> (count:int) !foreign method "getGlyphCount",

		hasGlyphs :: (self:Rasterizer, glyph,...:string) -> (hasGlyphs:bool) !foreign method "hasGlyphs",
		hasGlyphs :: (self:Rasterizer, glyph,...:int)    -> (hasGlyphs:bool) !foreign method "hasGlyphs",
	}

	-- Do these actually exist?
	-- export TrueTypeRasterizer :: !foreign struct { using Rasterizer }
	-- export BMFontRasterizer   :: !foreign struct { using Rasterizer }

	export newGlyphData :: (rasterizer:Rasterizer, glyph:int) -> (data:GlyphData) !foreign lua "love.font.newGlyphData"

	export newRasterizer         :: (filename:Filename|filesystem.FileData)    -> (rasterizer:Rasterizer) !foreign lua "love.font.newRasterizer"
	export newTrueTypeRasterizer :: (size:int, hintingMode:HintingMode)        -> (rasterizer:Rasterizer) !foreign lua "love.font.newTrueTypeRasterizer"
	export newBMFontRasterizer   :: (imageData:image.ImageData, glyphs:string) -> (rasterizer:Rasterizer) !foreign lua "love.font.newBMFontRasterizer"
}
export arg :: namespace {
	export parseGameArguments :: (rawArguments:[]string) -> (arguments:[]string) !foreign lua "love.arg.parseGameArguments"
}
