--[[============================================================
--=
--=  LÃ–VE bindings (love2d.org)
--=  love.math
--=
--=  Supported versions: 11.3
--=
--==============================================================

	...

	-- Structs:
	LoveBezierCurve
	LoveCompressedData
	LoveRandomGenerator
	LoveTransform

--============================================================]]

!import "love/basic"



----------------------------------------------------------------
-- Structs and enums.
----------------------------------------------------------------

-- BezierCurve.
export LoveBezierCurve :: struct { using LoveObject }

export loveGetControlPoint    :: (curve:LoveBezierCurve, index:int) -> (x,y:float) !foreign method "getControlPoint"
export loveSetControlPoint    :: (curve:LoveBezierCurve, index:int, x,y:float)     !foreign method "setControlPoint"
export loveInsertControlPoint :: (curve:LoveBezierCurve, x,y:float, i=-1)          !foreign method "insertControlPoint"
export loveRemoveControlPoint :: (curve:LoveBezierCurve, index:int)                !foreign method "removeControlPoint"

export loveEvaluate :: (curve:LoveBezierCurve, v:float) -> (x,y:float) !foreign method "evaluate"

export loveGetControlPointCount :: (curve:LoveBezierCurve) -> int !foreign method "getControlPointCount"
export loveGetDegree            :: (curve:LoveBezierCurve) -> int !foreign method "getDegree"

export loveGetDerivative :: (curve:LoveBezierCurve)                  -> LoveBezierCurve !foreign method "getDerivative"
export loveGetSegment    :: (curve:LoveBezierCurve, start,end:float) -> LoveBezierCurve !foreign method "getSegment"

-- coordinates = {x1,y1, x2,y2, ...}
export loveRender :: (curve:LoveBezierCurve,                  depth=5) -> (coordinates:[]float) !foreign method "render"
export loveRender :: (curve:LoveBezierCurve, start,end:float, depth=5) -> (coordinates:[]float) !foreign method "renderSegment"

export loveCurveRotate    :: (curve:LoveBezierCurve, angle:float, ox,oy=0.0) !foreign method "rotate"
export loveCurveScale     :: (curve:LoveBezierCurve, scale:float, ox,oy=0.0) !foreign method "scale"
export loveCurveTranslate :: (curve:LoveBezierCurve, dx,dy:float)            !foreign method "translate"

-- CompressedData. @Incomplete
export LoveCompressedData :: struct { using LoveObject }

-- RandomGenerator. @Incomplete
export LoveRandomGenerator :: struct { using LoveObject }

-- Transform. @Incomplete
export LoveTransform :: struct { using LoveObject }



----------------------------------------------------------------
-- Functions.
----------------------------------------------------------------

export loveBytesToColor :: (br,bg,bb:int)    -> (r,g,b:float)     !foreign lua "love and love.math and love.math.colorFromBytes"
export loveBytesToColor :: (br,bg,bb,ba:int) -> (r,g,b,a:float)   !foreign lua "love and love.math and love.math.colorFromBytes"
export loveColorToBytes :: (r,g,b:float)     -> (br,bg,bb:int)    !foreign lua "love and love.math and love.math.colorToBytes"
export loveColorToBytes :: (r,g,b,a:float)   -> (br,bg,bb,ba:int) !foreign lua "love and love.math and love.math.colorToBytes"

export loveGammaToLinear :: (gammaR,gammaG,gammaB:float) -> (linearR,linearG,linearB:float) !foreign lua "love and love.math and love.math.gammaToLinear"
export loveGammaToLinear :: (gammaRgb:[]float)           -> (linearR,linearG,linearB:float) !foreign lua "love and love.math and love.math.gammaToLinear"
export loveGammaToLinear :: (gammaComponent:float)       -> (linearComponent:float)         !foreign lua "love and love.math and love.math.gammaToLinear"
export loveLinearToGamma :: (linearR,linearG,linearB:float) -> (gammaR,gammaG,gammaB:float) !foreign lua "love and love.math and love.math.linearToGamma"
export loveLinearToGamma :: (linearRgb:[]float)             -> (gammaR,gammaG,gammaB:float) !foreign lua "love and love.math and love.math.linearToGamma"
export loveLinearToGamma :: (linearComponent:float)         -> (gammaComponent:float)       !foreign lua "love and love.math and love.math.gammaToLinear"

-- polygonVertices = {x1,y1, x2,y2, x3,y3, ...}
export loveIsConvex :: (polygonVertices:[]float)     -> bool !foreign lua "love and love.math and love.math.isConvex"
export loveIsConvex :: (x1,y1,x2,y2,x3,y3,...:float) -> bool !foreign lua "love and love.math and love.math.isConvex"

-- polygonVertices = {x1,y1, x2,y2, x3,y3, ...}
-- triangles       = {{x1,y1, x2,y2, x3,y3}, {x1,y1, x2,y2, x3,y3}, ...}
export loveTriangulate :: (polygonVertices:[]float)     -> (triangles:[][]float) !foreign lua "love and love.math and love.math.triangulate"
export loveTriangulate :: (x1,y1,x2,y2,x3,y3,...:float) -> (triangles:[][]float) !foreign lua "love and love.math and love.math.triangulate"

-- polygonVertices = {x1,y1, x2,y2, x3,y3, ...}
export loveNewBezierCurve :: (polygonVertices:[]float)     -> LoveBezierCurve !foreign lua "love and love.math and love.math.newBezierCurve"
export loveNewBezierCurve :: (x1,y1,x2,y2,x3,y3,...:float) -> LoveBezierCurve !foreign lua "love and love.math and love.math.newBezierCurve"

-- @Compiler @Incomplete: Make sy=sx work somehow and remove all extra overloads.
export loveNewTransform :: (                                                     ) -> LoveTransform !foreign lua "love and love.math and love.math.newTransform"
export loveNewTransform :: (x,y:float, r=0.0,   scale=1.0                        ) -> LoveTransform !foreign lua "love and love.math and love.math.newTransform"
export loveNewTransform :: (x,y:float, r:float, sx,sy:float, ox,oy=0.0, kx,ky=0.0) -> LoveTransform !foreign lua "love and love.math and love.math.newTransform"

export loveNoise :: (x:float)       -> (value:float) !foreign lua "love and love.math and love.math.noise" -- Simplex noise.
export loveNoise :: (x,y:float)     -> (value:float) !foreign lua "love and love.math and love.math.noise" -- Simplex noise.
export loveNoise :: (x,y,z:float)   -> (value:float) !foreign lua "love and love.math and love.math.noise" -- Perlin noise.
export loveNoise :: (x,y,z,w:float) -> (value:float) !foreign lua "love and love.math and love.math.noise" -- Perlin noise.

-- export loveRandom :: () !foreign lua "love and love.math and love.math.random"

export loveRandom :: (    high:int) -> int !foreign lua "love and love.math and love.math.random" -- Same as loveRandom(1, high)
export loveRandom :: (low,high:int) -> int !foreign lua "love and love.math and love.math.random"

export loveRandom :: (              ) -> float !foreign lua "love and love.math and love.math.random"
export loveRandom :: (    high:float) -> float { return high * loveRandom() }
export loveRandom :: (low,high:float) -> float { return low + (high-low) * loveRandom() }

export loveRandomNormal :: (standardDeviation=1.0, mean=0.0) -> float !foreign lua "love and love.math and love.math.randomNormal"

export loveGetRandomSeed :: () -> (seedLow32Bits,seedHigh32Bits:int) !foreign lua "love and love.math and love.math.getRandomSeed"
export loveSetRandomSeed :: (seed:int)                               !foreign lua "love and love.math and love.math.setRandomSeed" -- The number must be in range 0..(2^53-1)
export loveSetRandomSeed :: (seedLow32Bits,seedHigh32Bits:int)       !foreign lua "love and love.math and love.math.setRandomSeed" -- The numbers must be in range 0..(2^32-1)

export loveGetRandomState :: () -> string   !foreign lua "love and love.math and love.math.getRandomState"
export loveSetRandomState :: (state:string) !foreign lua "love and love.math and love.math.setRandomState"

export loveNewRandomGenerator :: ()                                 -> LoveRandomGenerator !foreign lua "love and love.math and love.math.newRandomGenerator"
export loveNewRandomGenerator :: (seed:int)                         -> LoveRandomGenerator !foreign lua "love and love.math and love.math.newRandomGenerator"
export loveNewRandomGenerator :: (seedLow32Bits,seedHigh32Bits:int) -> LoveRandomGenerator !foreign lua "love and love.math and love.math.newRandomGenerator"
