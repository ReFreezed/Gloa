--[[============================================================
--=
--=  LÖVE bindings (love2d.org)
--=
--=  Supported versions: 11.3
--=
--==============================================================

	LoveConfig
	LoveEvent
	LoveFullscreenType
	LoveKey
	LoveScancode

	loveClear
	loveCoordinateSystemReset
	loveCoordinateSystemRotate, loveCoordinateSystemScale, loveCoordinateSystemShear, loveCoordinateSystemTranslate
	loveDrawCircleFill, loveDrawCircleLine
	loveDrawLine
	loveDrawRectangleFill, loveDrawRectangleLine
	loveDrawText
	loveGetColor, loveSetColor
	loveGetLineWidth, loveSetLineWidth
	loveGetTime
	loveGetWindowDimensions
	loveGraphicsPushAll, loveGraphicsPushTransform, loveGraphicsPop
	loveGraphicsReset
	loveHasKeyRepeat, loveSetKeyRepeat
	loveHasTextInput, loveSetTextInput
	loveIsKeyDown, loveIsScancodeDown
	loveKeyToScancode, loveScancodeToKey
	loveParseArguments
	loveQuit, loveRestart
	loveReadFile, loveWriteFile
	loveSetAppDataFolderName
	loveSetEventHandler, loveSetConfigHandler

--============================================================]]

export loveParseArguments :: (argsRaw:[]string) -> (args:[]string) !foreign lua "love and love.arg and love.arg.parseGameArguments"

----------------------------------------------------------------
-- love.config
----------------------------------------------------------------

export LoveFullscreenType :: enum {
	DESKTOP    :: "desktop",    -- Windowed mode.
	FULLSCREEN :: "fullscreen", -- Borderless fullscreen.
	EXCLUSIVE  :: "exclusive",  -- Exclusive fullscreen.
}

export LoveConfig :: struct {
	identity:string|none  = nil,    -- The name of the save directory.
	appendidentity        = false,  -- Search files in source directory before save directory.
	version               = "11.3", -- The LÖVE version this game was made for.
	console               = false,  -- Attach a console. (Windows only.)
	accelerometerjoystick = true,   -- Enable the accelerometer on iOS and Android by exposing it as a Joystick.
	externalstorage       = false,  -- True to save files (and read from the save directory) in external storage on Android.
	gammacorrect          = false,  -- Enable gamma-correct rendering, when supported by the system.

	audio: struct {
		mic           = false, -- Request and use microphone capabilities in Android.
		mixwithsystem = true,  -- Keep background music playing when opening LÖVE. (iOS and Android only.)
	},

	window: struct {
		title            = "Untitled", -- The window title.
		icon:string|none = nil,        -- Filepath to an image to use as the window's icon.
		width            = 800,        -- The window width.
		height           = 600,        -- The window height.
		borderless       = false,      -- Remove all border visuals from the window.
		resizable        = false,      -- Let the window be user-resizable.
		minwidth         = 1,          -- Minimum window width if the window is resizable.
		minheight        = 1,          -- Minimum window height if the window is resizable.
		fullscreen       = false,      -- Enable fullscreen.
		fullscreentype   = LoveFullscreenType.DESKTOP,
		usedpiscale      = true,       -- Enable automatic DPI scaling.
		vsync            = 1,          -- Vertical sync mode.
		msaa             = 0,          -- The number of samples to use with multi-sampled antialiasing.
		depth:int|none   = nil,        -- The number of bits per sample in the depth buffer.
		stencil:int|none = nil,        -- The number of bits per sample in the stencil buffer.
		display          = 1,          -- Index of the monitor to show the window in.
		highdpi          = false,      -- Enable high-dpi mode for the window on a Retina display.
		x:int|none       = nil,        -- The x-coordinate of the window's position in the specified display.
		y:int|none       = nil,        -- The y-coordinate of the window's position in the specified display.
	},

	modules: struct {
		-- Enable/disable modules.
		audio    = true,
		data     = true,
		event    = true,
		font     = true,
		graphics = true,
		image    = true,
		joystick = true,
		keyboard = true,
		math     = true,
		mouse    = true,
		physics  = true,
		sound    = true,
		system   = true,
		thread   = true,
		timer    = true,
		touch    = true,
		video    = true,
		window   = true,
	},
}

----------------------------------------------------------------
-- love.audio.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.data.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.event.*
----------------------------------------------------------------

using export LoveEvent :: enum {
	-- General.
	DISPLAY_ROTATED   :: "displayrotated",
	DRAW              :: "draw",
	ERROR_HANDLER     :: "errorhandler",
	LOAD              :: "load",
	LOW_MEMORY        :: "lowmemory",
	QUIT              :: "quit",
	RUN               :: "run",
	THREAD_ERROR      :: "threaderror",
	UPDATE            :: "update",
	-- Window.
	DIRECTORY_DROPPED :: "directorydropped",
	FILE_DROPPED      :: "filedropped",
	FOCUS             :: "focus",
	MOUSE_FOCUS       :: "mousefocus",
	RESIZE            :: "resize",
	VISIBLE           :: "visible",
	-- Keyboard.
	KEY_PRESSED       :: "keypressed",
	KEY_RELEASED      :: "keyreleased",
	TEXT_EDITED       :: "textedited",
	TEXT_INPUT        :: "textinput",
	-- Mouse.
	MOUSE_MOVED       :: "mousemoved",
	MOUSE_PRESSED     :: "mousepressed",
	MOUSE_RELEASED    :: "mousereleased",
	WHEEL_MOVED       :: "wheelmoved",
	-- Joystick.
	GAMEPAD_AXIS      :: "gamepadaxis",
	GAMEPAD_PRESSED   :: "gamepadpressed",
	GAMEPAD_RELEASED  :: "gamepadreleased",
	JOYSTICK_ADDED    :: "joystickadded",
	JOYSTICK_AXIS     :: "joystickaxis",
	JOYSTICK_HAT      :: "joystickhat",
	JOYSTICK_PRESSED  :: "joystickpressed",
	JOYSTICK_RELEASED :: "joystickreleased",
	JOYSTICK_REMOVED  :: "joystickremoved",
	-- Touch.
	TOUCH_MOVED       :: "touchmoved",
	TOUCH_PRESSED     :: "touchpressed",
	TOUCH_RELEASED    :: "touchreleased",
	-- Other.
	CONFIG            :: "conf",
}

export LoveFilterMode :: enum {
	LINEAR  :: "linear",
	NEAREST :: "nearest",
}

local love:table : !foreign lua "love"

export loveSetEventHandler :: (event:LoveEvent, handler:any, catchErrorsInGloa=true) { -- @Compiler @Cleanup :RestrictAnyToTypeTag
	!import "basic"

	assert(getLuaType(handler) == LuaType.FUNCTION, "Handler is not a function.") -- @Cleanup: Remove this when :RestrictAnyToTypeTag is solved.

	if catchErrorsInGloa {
		-- Because LÖVE has it's own error handling that the user may not want we have
		-- to do some trickery to catch errors in Glóa before LÖVE sees them.
		local wrap :: (func:any) -> any !foreign compiler "wrapFunctionInGloaErrorHandler"
		handler = wrap(handler)
	}

	love[event] = handler
	if event == ERROR_HANDLER  love.errhand = handler
}

export loveSetConfigHandler :: (handler:(conf:LoveConfig)) {
	loveSetEventHandler(CONFIG, handler, false)
}

export loveRemoveEventHandler :: (event:LoveEvent) {
	love[event] = nil
	if event == ERROR_HANDLER  love.errhand = nil
}

export loveQuit :: (exitStatus=0) !foreign lua "love and love.event and love.event.quit"

local _loveRestart :: (restart:string) !foreign lua "love and love.event and love.event.quit"
export loveRestart :: () { _loveRestart("restart") }

----------------------------------------------------------------
-- love.filesystem.*
----------------------------------------------------------------

export loveSetAppDataFolderName :: (name:string) !foreign lua "love and love.filesystem and love.filesystem.setIdentity"

local _loveReadFile :: (path:string) -> string|none, int|string !foreign lua "love and love.filesystem and love.filesystem.read"
export loveReadFile :: (path:string) -> (success:bool, data:string, error:string) {
	local data, sizeOrErr = _loveReadFile(path)
	if data == nil  return false, "", cast(string) sizeOrErr
	return true, cast(string) data, ""
}

local _loveWriteFile :: (path:string, data:string) -> bool, none|string !foreign lua "love and love.filesystem and love.filesystem.write"
export loveWriteFile :: (path:string, data:string) -> (success:bool, error:string) {
	local ok, err = _loveWriteFile(path, data)
	if not ok  return false, cast(string) err
	return true, ""
}

----------------------------------------------------------------
-- love.graphics.*
----------------------------------------------------------------

-- Drawing.

export loveClear :: ()                   !foreign lua "love and love.graphics and love.graphics.clear" -- Same as loveClear(0,0,0,0)
export loveClear :: (r,g,b:float, a=1.0) !foreign lua "love and love.graphics and love.graphics.clear"

export loveDrawText :: (text:string, x,y=0.0,   r=0.0                                     ) !foreign lua "love and love.graphics and love.graphics.print"
export loveDrawText :: (text:string, x,y:float, r:float, sx:float                         ) { loveDrawText(text, x,y, r, sx,sx) }
export loveDrawText :: (text:string, x,y:float, r:float, sx,sy:float, ox,oy=0.0, kx,ky=0.0) !foreign lua "love and love.graphics and love.graphics.print"
-- @Compiler @Incomplete: Make sy:float=sx work somehow here below and remove the overloads here above.
-- export loveDrawText :: (text:string, x,y=0.0, r=0.0, sx=1.0,sy=sx, ox,oy=0.0, kx,ky=0.0) !foreign lua "love and love.graphics and love.graphics.print"

local _loveDrawRectangle :: (mode:string, x,y:float, w,h:float)                                      !foreign lua "love and love.graphics and love.graphics.rectangle"
local _loveDrawRectangle :: (mode:string, x,y:float, w,h:float, radiusX,radiusY:float)               !foreign lua "love and love.graphics and love.graphics.rectangle"
local _loveDrawRectangle :: (mode:string, x,y:float, w,h:float, radiusX,radiusY:float, segments:int) !foreign lua "love and love.graphics and love.graphics.rectangle"
export loveDrawRectangleFill :: (x,y:float, w,h:float)                                      { _loveDrawRectangle("fill", x,y, w,h) }
export loveDrawRectangleLine :: (x,y:float, w,h:float)                                      { _loveDrawRectangle("line", x,y, w,h) }
export loveDrawRectangleFill :: (x,y:float, w,h:float, radiusX,radiusY:float)               { _loveDrawRectangle("fill", x,y, w,h, radiusX,radiusY) }
export loveDrawRectangleLine :: (x,y:float, w,h:float, radiusX,radiusY:float)               { _loveDrawRectangle("line", x,y, w,h, radiusX,radiusY) }
export loveDrawRectangleFill :: (x,y:float, w,h:float, radiusX,radiusY:float, segments:int) { _loveDrawRectangle("fill", x,y, w,h, radiusX,radiusY, segments) }
export loveDrawRectangleLine :: (x,y:float, w,h:float, radiusX,radiusY:float, segments:int) { _loveDrawRectangle("line", x,y, w,h, radiusX,radiusY, segments) }

local _loveDrawCircle :: (mode:string, x,y:float, radius:float)               !foreign lua "love and love.graphics and love.graphics.circle"
local _loveDrawCircle :: (mode:string, x,y:float, radius:float, segments:int) !foreign lua "love and love.graphics and love.graphics.circle"
export loveDrawCircleFill :: (x,y:float, radius:float)               { _loveDrawCircle("fill", x,y, radius) }
export loveDrawCircleLine :: (x,y:float, radius:float)               { _loveDrawCircle("line", x,y, radius) }
export loveDrawCircleFill :: (x,y:float, radius:float, segments:int) { _loveDrawCircle("fill", x,y, radius, segments) }
export loveDrawCircleLine :: (x,y:float, radius:float, segments:int) { _loveDrawCircle("line", x,y, radius, segments) }

local _loveDrawEllipse :: (mode:string, x,y:float, radiusX,radiusY:float)               !foreign lua "love and love.graphics and love.graphics.ellipse"
local _loveDrawEllipse :: (mode:string, x,y:float, radiusX,radiusY:float, segments:int) !foreign lua "love and love.graphics and love.graphics.ellipse"
export loveDrawEllipseFill :: (x,y:float, radiusX,radiusY:float)               { _loveDrawEllipse("fill", x,y, radiusX,radiusY) }
export loveDrawEllipseLine :: (x,y:float, radiusX,radiusY:float)               { _loveDrawEllipse("line", x,y, radiusX,radiusY) }
export loveDrawEllipseFill :: (x,y:float, radiusX,radiusY:float, segments:int) { _loveDrawEllipse("fill", x,y, radiusX,radiusY, segments) }
export loveDrawEllipseLine :: (x,y:float, radiusX,radiusY:float, segments:int) { _loveDrawEllipse("line", x,y, radiusX,radiusY, segments) }

export loveDrawLine :: (x1,y1,x2,y2,...:float) !foreign lua "love and love.graphics and love.graphics.line"

-- Graphics state.

-- Font
	local LoveFont :: struct {
		-- These functions are abstract dummies as the LoveFont struct itself is foreign.
		getBaseline   = (font:LoveFont) -> int !foreign lua "nil",
		getAscent     = (font:LoveFont) -> int !foreign lua "nil",
		getDescent    = (font:LoveFont) -> int !foreign lua "nil",

		getFilter     = (font:LoveFont) -> (min,mag:LoveFilterMode, anisotropy:int) !foreign lua "nil",
		setFilter     = (font:LoveFont, min,mag:LoveFilterMode, anisotropy=1)       !foreign lua "nil",

		getWidth      = (font:LoveFont, text:string) -> int !foreign lua "nil",
		getHeight     = (font:LoveFont)              -> int !foreign lua "nil",
		getWrap       = (font:LoveFont, text:string, wrapLimit:int) -> (width:int, lines:[]string) !foreign lua "nil",

		getLineHeight = (font:LoveFont) -> float          !foreign lua "nil",
		setLineHeight = (font:LoveFont, lineHeight:float) !foreign lua "nil",

		getDPIScale   = (font:LoveFont) -> float !foreign lua "nil",
		hasGlyphs     = (font:LoveFont, x,...:string|int) -> bool !foreign lua "nil",
		setFallbacks  = (font:LoveFont, ...:LoveFont) !foreign lua "nil",
	}

	export loveGetBaseline   :: (font:LoveFont) -> int { return font.getBaseline!() }
	export loveGetAscent     :: (font:LoveFont) -> int { return font.getAscent!() }
	export loveGetDescent    :: (font:LoveFont) -> int { return font.getDescent!() }

	export loveGetDpiScale   :: (font:LoveFont) -> float { return font.getDPIScale!() }

	export loveGetFilter     :: (font:LoveFont) -> (min,mag:LoveFilterMode, anisotropy:int) { return font.getFilter!() }
	export loveSetFilter     :: (font:LoveFont, min,mag:LoveFilterMode, anisotropy=1)       { font.setFilter!(min, mag, anisotropy) }

	export loveGetWidth      :: (font:LoveFont, text:string) -> int { return font.getWidth!(text) }
	export loveGetHeight     :: (font:LoveFont)              -> int { return font.getHeight!() }

	export loveGetLineHeight :: (font:LoveFont) -> float          { return font.getLineHeight!() }
	export loveSetLineHeight :: (font:LoveFont, lineHeight:float) { font.setLineHeight!(lineHeight) }

	export loveGetWrap       :: (font:LoveFont, text:string, wrapLimit:int) -> (width:int, lines:[]string) { return font.getWrap!(text, wrapLimit) }

	export loveHasGlyphs     :: (font:LoveFont, text:string)            -> bool { return font.hasGlyphs!(text) }
	export loveHasGlyphs     :: (font:LoveFont, char1,char2,...:string) -> bool { return font.hasGlyphs!(char1, char2, ...) }
	export loveHasGlyphs     :: (font:LoveFont, codepoint,...:int)      -> bool { return font.hasGlyphs!(codepoint, ...) }

	export loveSetFallbacks  :: (font:LoveFont, ...:LoveFont) { font.setFallbacks!(...) }
--

local DEFAULT_FONT_SIZE :: 12
export loveGetFont    :: () -> LoveFont  !foreign lua "love and love.graphics and love.graphics.getFont" -- @Check: Can this return nil?
export loveSetFont    :: (font:LoveFont) !foreign lua "love and love.graphics and love.graphics.setFont"
export loveSetNewFont :: (                 size=DEFAULT_FONT_SIZE) -> LoveFont !foreign lua "love and love.graphics and love.graphics.setNewFont"
export loveSetNewFont :: (filename:string, size=DEFAULT_FONT_SIZE) -> LoveFont !foreign lua "love and love.graphics and love.graphics.setNewFont"
-- export loveSetNewFont :: (file:LoveFile,   size=DEFAULT_FONT_SIZE) -> LoveFont !foreign lua "love and love.graphics and love.graphics.setNewFont"
-- export loveSetNewFont :: (data:LoveData,   size=DEFAULT_FONT_SIZE) -> LoveFont !foreign lua "love and love.graphics and love.graphics.setNewFont"
-- export loveSetNewFont :: (rasterizer:LoveRasterizer)               -> LoveFont !foreign lua "love and love.graphics and love.graphics.setNewFont"

export loveGetBackgroundColor :: () -> (r,g,b,a:float) !foreign lua "love and love.graphics and love.graphics.getBackgroundColor"
export loveSetBackgroundColor :: (r,g,b:float, a=1.0)  !foreign lua "love and love.graphics and love.graphics.setBackgroundColor"

export LoveBlendMode :: enum {
	ALPHA    :: "alpha",
	REPLACE  :: "replace",
	SCREEN   :: "screen",
	ADD      :: "add",
	SUBTRACT :: "subtract",
	MULTIPLY :: "multiply",
	LIGHTEN  :: "lighten",
	DARKEN   :: "darken",
	PREMULTIPLIED :: "premultiplied",
}
export LoveBlendAlphaMode :: enum {
	ALPHAMULTIPLY :: "alphamultiply",
	PREMULTIPLIED :: "premultiplied",
}
export loveGetBlendMode :: () -> LoveBlendMode                                              !foreign lua "love and love.graphics and love.graphics.getBlendMode"
export loveSetBlendMode :: (mode:LoveBlendMode, alphaMode=LoveBlendAlphaMode.ALPHAMULTIPLY) !foreign lua "love and love.graphics and love.graphics.setBlendMode"

-- export LoveCanvasSetup :: struct {
-- 	!value:LoveCanvas,
-- 	stencil = false,
-- 	depth   = false,
-- 	depthstencil:LoveCanvas|none = nil,
-- }
-- export loveGetCanvas   :: () -> LoveCanvas|none                      !foreign lua "love and love.graphics and love.graphics.getCanvas"
-- export loveSetCanvas   :: (canvas:LoveCanvas, mipmap=1)              !foreign lua "love and love.graphics and love.graphics.setCanvas"
-- export loveSetCanvas   :: (canvas:LoveCanvas, slice:int, mipmap:int) !foreign lua "love and love.graphics and love.graphics.setCanvas"
-- export loveSetCanvas   :: (canvas1,canvas2,...:LoveCanvas)           !foreign lua "love and love.graphics and love.graphics.setCanvas"
-- export loveSetCanvas   :: (setup:LoveCanvasSetup)                    !foreign lua "love and love.graphics and love.graphics.setCanvas"
-- export loveSetNoCanvas :: ()                                         !foreign lua "love and love.graphics and love.graphics.setCanvas"

export loveGetColor :: () -> (r,g,b,a:float) !foreign lua "love and love.graphics and love.graphics.getColor"
export loveSetColor :: (r,g,b:float, a=1.0)  !foreign lua "love and love.graphics and love.graphics.setColor"

export loveGetColorMask   :: () -> (r,g,b,a:bool) !foreign lua "love and love.graphics and love.graphics.getColorMask"
export loveSetColorMask   :: (r,g,b,a:bool)       !foreign lua "love and love.graphics and love.graphics.setColorMask"
export loveResetColorMask :: ()                   !foreign lua "love and love.graphics and love.graphics.setColorMask"

export loveGetDefaultFilter :: () -> (min,mag:LoveFilterMode, anisotropy:int) !foreign lua "love and love.graphics and love.graphics.getDefaultFilter"
export loveSetDefaultFilter :: (min,mag:LoveFilterMode, anisotropy=1)         !foreign lua "love and love.graphics and love.graphics.setDefaultFilter"

export LoveLineJoin    :: enum { MITER::"miter", NONE::"none", BEVEL::"bevel" }
export loveGetLineJoin :: () -> LoveLineJoin  !foreign lua "love and love.graphics and love.graphics.getLineJoin"
export loveSetLineJoin :: (join:LoveLineJoin) !foreign lua "love and love.graphics and love.graphics.setLineJoin"

export LoveLineStyle    :: enum { ROUGH::"rough", SMOOTH::"smooth" }
export loveGetLineStyle :: () -> LoveLineStyle   !foreign lua "love and love.graphics and love.graphics.getLineStyle"
export loveSetLineStyle :: (style:LoveLineStyle) !foreign lua "love and love.graphics and love.graphics.setLineStyle"

export loveGetLineWidth :: () -> float !foreign lua "love and love.graphics and love.graphics.getLineWidth"
export loveSetLineWidth :: (w:float)   !foreign lua "love and love.graphics and love.graphics.setLineWidth"

-- export LoveShader :: { ??? }
-- export loveGetShader :: () -> LoveShader    !foreign lua "love and love.graphics and love.graphics.getShader"
-- export loveSetShader :: (shader:LoveShader) !foreign lua "love and love.graphics and love.graphics.setShader"

export loveGetPointSize :: () -> float  !foreign lua "love and love.graphics and love.graphics.getPointSize"
export loveSetPointSize :: (size:float) !foreign lua "love and love.graphics and love.graphics.setPointSize"

export loveGetScissor       :: () -> (x,y,w,h:float) !foreign lua "love and love.graphics and love.graphics.getScissor"
export loveSetScissor       :: (x,y,w,h:float)       !foreign lua "love and love.graphics and love.graphics.setScissor"
export loveIntersectScissor :: (x,y,w,h:float)       !foreign lua "love and love.graphics and love.graphics.intersectScissor"
export loveResetScissor     :: ()                    !foreign lua "love and love.graphics and love.graphics.setScissor"

export loveIsWireframe  :: () -> bool     !foreign lua "love and love.graphics and love.graphics.isWireframe"
export loveSetWireframe :: (enabled:bool) !foreign lua "love and love.graphics and love.graphics.setWireframe"

-- Coordinate system.

export loveCoordinateSystemRotate    :: (anlge:float) !foreign lua "love and love.graphics and love.graphics.rotate"
export loveCoordinateSystemScale     :: (sx,sy:float) !foreign lua "love and love.graphics and love.graphics.scale"
export loveCoordinateSystemScale     :: (scale:float) !foreign lua "love and love.graphics and love.graphics.scale"
export loveCoordinateSystemShear     :: (kx,ky:float) !foreign lua "love and love.graphics and love.graphics.shear"
export loveCoordinateSystemTranslate :: (dx,dy:float) !foreign lua "love and love.graphics and love.graphics.translate"

export loveCoordinateSystemReset :: () !foreign lua "love and love.graphics and love.graphics.origin"

local _loveGraphicsPush :: ()             !foreign lua "love and love.graphics and love.graphics.push"
local _loveGraphicsPush :: (stack:string) !foreign lua "love and love.graphics and love.graphics.push"
export loveGraphicsPushAll       :: () { _loveGraphicsPush("all") }
export loveGraphicsPushTransform :: () { _loveGraphicsPush()      }
export loveGraphicsPop           :: () !foreign lua "love and love.graphics and love.graphics.pop"
export loveGraphicsReset         :: () !foreign lua "love and love.graphics and love.graphics.reset"

export loveGlobalToScreen :: (globalX, globalY: float) -> (screenX, screenY: float) !foreign lua "love and love.graphics and love.graphics.transformPoint"
export loveScreenToGlobal :: (screenX, screenY: float) -> (globalX, globalY: float) !foreign lua "love and love.graphics and love.graphics.inverseTransformPoint"

-- Window.

export loveGetWindowDimensions :: () -> int, int !foreign lua "love and love.graphics and love.graphics.getDimensions"
export loveGetWindowWidth      :: () -> int      !foreign lua "love and love.graphics and love.graphics.getWidth"
export loveGetWindowHeight     :: () -> int      !foreign lua "love and love.graphics and love.graphics.getHeight"

----------------------------------------------------------------
-- love.image.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.joystick.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.keyboard.*
----------------------------------------------------------------

-- @Robustness: Use enums for keys and scancodes.
export LoveKey      :: string
export LoveScancode :: string

export loveKeyToScancode :: (key:LoveKey)           -> (scancode:LoveScancode) !foreign lua "love and love.keyboard and love.keyboard.getScancodeFromKey"
export loveScancodeToKey :: (scancode:LoveScancode) -> (key:LoveKey)           !foreign lua "love and love.keyboard and love.keyboard.getKeyFromScancode"

export loveHasKeyRepeat :: () -> (enabled:bool) !foreign lua "love and love.keyboard and love.keyboard.hasKeyRepeat"
export loveSetKeyRepeat :: (enabled:bool)       !foreign lua "love and love.keyboard and love.keyboard.setKeyRepeat"

export loveHasTextInput :: () -> (enabled:bool)        !foreign lua "love and love.keyboard and love.keyboard.hasTextInput"
export loveSetTextInput :: (enabled:bool)              !foreign lua "love and love.keyboard and love.keyboard.setTextInput"
export loveSetTextInput :: (enabled:bool, x,y,w,h:int) !foreign lua "love and love.keyboard and love.keyboard.setTextInput"

export loveIsKeyDown      :: (key,      ...: LoveKey)      -> bool !foreign lua "love and love.keyboard and love.keyboard.isDown"
export loveIsScancodeDown :: (scancode, ...: LoveScancode) -> bool !foreign lua "love and love.keyboard and love.keyboard.isScancodeDown"

----------------------------------------------------------------
-- love.math.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.mouse.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.physics.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.sound.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.system.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.thread.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.timer.*
----------------------------------------------------------------

export loveGetTime :: () -> float !foreign lua "love and love.timer and love.timer.getTime"

----------------------------------------------------------------
-- love.touch.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.video.*
----------------------------------------------------------------

----------------------------------------------------------------
-- love.window.*
----------------------------------------------------------------
