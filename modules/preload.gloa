--[[============================================================
--=
--=  GlÃ³a preload module
--=
--=  This module is imported automatically in every file and
--=  thus everything here is always available everywhere.
--=
--==============================================================

	getAllTypes, getTypeInfo

	Enums:
	TypeTag

	Structs:
	SourceCodeLocation
	TypeInfo, TypeInfoArray, TypeInfoCompound, TypeInfoEnum, TypeInfoFunction, TypeInfoStruct, TypeInfoVararg

--============================================================]]

export TypeTag :: enum {
	ANY         :: !compiler "typeTagAny",
	ARRAY       :: !compiler "typeTagArray",
	BOOL        :: !compiler "typeTagBool",
	COMPOUND    :: !compiler "typeTagCompound",
	ENUM        :: !compiler "typeTagEnum",
	FLOAT       :: !compiler "typeTagFloat",
	FUNCTION    :: !compiler "typeTagFunction",
	INT         :: !compiler "typeTagInt",
	NONE        :: !compiler "typeTagNone",
	STRING      :: !compiler "typeTagString",
	STRUCT      :: !compiler "typeTagStruct",
	TABLE       :: !compiler "typeTagTable",
	TYPE        :: !compiler "typeTagType",
	VARARG      :: !compiler "typeTagVararg",
	VOID        :: !compiler "typeTagVoid",
}

export TypeInfo :: !foreign struct {
	tag: TypeTag,
	id:  Type,
}

export TypeInfoArray :: !foreign struct {
	using TypeInfo,
	itemType: Type,
}
export TypeInfoVararg :: !foreign struct {
	using TypeInfo,
	itemType: Type,
}

export TypeInfoFunction :: !foreign struct {
	Argument :: !foreign struct {
		argumentType: Type,
	},

	using TypeInfo,
	argumentsIn:  []Argument,
	argumentsOut: []Argument,
}

export TypeInfoStruct :: !foreign struct {
	Kind :: enum {
		NORMAL :: 1,
		TABLE  :: 2,
		ARRAY  :: 3,
	},
	Member :: !foreign struct {
		name:       string,
		memberType: Type,
	},

	using TypeInfo,
	name:      string, -- May be empty.
	kind:      Kind,
	keyType:   Type,
	valueType: Type,
	members:   []Member,
}

export TypeInfoEnum :: !foreign struct {
	Member :: !foreign struct {
		name: string,
	},

	using TypeInfo,
	name:       string, -- May be empty.
	memberType: Type,
	members:    []Member,
}

export TypeInfoCompound :: !foreign struct {
	using TypeInfo,
	types: []Type,
}

export SourceCodeLocation :: !foreign struct {
	filePath:   string, -- Note: This will not be a real file path if the location was generated from a string (i.e. from !body_text).  @Compiler @UX: Change this fact.
	lineNumber: int,
	position:   int,    -- Byte position (after line ending normalization).  @Cleanup: Rename to filePosition.
}

-- Get a list of all types. During compilation this returns only the types available so far.
export getAllTypes :: () -> []Type !foreign compiler "getAllTypes"

-- Get info for a type.
export getTypeInfo :: (T:Type) -> TypeInfo !foreign compiler "getTypeInfo"
