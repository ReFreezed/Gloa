--[[============================================================
--=
--=  GlÃ³a I/O and filesystem module
--=
--==============================================================

	APP_PATH, APP_DIRECTORY
	stdin, stderr, stdout

	disableBuffering, enableBuffering, enableLineBuffering
	openFileForReading, openFileForWriting, closeFile
	readEntireFile
	readNumber, readRemaining, readLine, readBytes
	removeFile, renameFile, copyFile
	writeFile

--============================================================]]

export APP_PATH      : string : !foreign compiler "APP_PATH"
export APP_DIRECTORY : string : !foreign compiler "APP_DIRECTORY"

export STDIN  : File : !foreign lua "io.stdin"
export STDERR : File : !foreign lua "io.stderr"
export STDOUT : File : !foreign lua "io.stdout"

local File :: struct {
	-- These functions are abstract dummies because the File struct itself is actually foreign.
	read    = (file:File, what:string|int) -> string|float|none !foreign lua "nil",
	write   = (file:File, data:string) !foreign lua "nil",
	close   = (file:File) !foreign lua "nil",
	setvbuf = (file:File, mode:string, size:int|none) !foreign lua "nil",
	flush   = (file:File) !foreign lua "nil",
}

local _openFile :: (path:string, mode:string) -> File|none, none|string !foreign lua "io.open"

export closeFile :: (file:File) !foreign lua "io.close"

local openFile :: (path:string, mode:string) -> bool, File, string {
	local file, err = _openFile(path, mode)
	if file == nil  return false, NULL(File), cast(string) err
	return true, cast(File) file, ""
}
export openFileForReading :: (path:string) -> (success:bool, file:File, error:string) { return openFile(path, "rb") }
export openFileForWriting :: (path:string) -> (success:bool, file:File, error:string) { return openFile(path, "wb") }

export readNumber :: (file:File) -> (success:bool, number:float) {
	local data = file.read!("*n")
	if data == nil  return false, 0
	return true, cast(float) data
}
export readRemaining :: (file:File) -> (success:bool, data:string) {
	local data = file.read!("*a") -- (I think this always returns a string?)
	if data == nil  return false, ""
	return true, cast(string) data
}
export readLine :: (file:File) -> (success:bool, line:string) {
	local data = file.read!("*l")
	if data == nil  return false, ""
	return true, cast(string) data
}
export readBytes :: (file:File, maxBytes:int) -> (success:bool, data:string) {
	local data = file.read!(maxBytes)
	if data == nil  return false, ""
	return true, cast(string) data
}

export readEntireFile :: (path:string) -> (success:bool, data:string, error:string) {
	local ok, file, err = openFileForReading(path)
	if not ok  return false, "", err

	local data:string
	ok, data = readRemaining(file)
	closeFile(file)
	if not ok  return false, "", "Could not read from the file."

	return true, data, ""
}

export writeFile :: (path:string, data:string) -> (success:bool, error:string) {
	local ok, file, err = openFileForWriting(path)
	if not ok  return false, err

	file.write!(data)
	closeFile(file)
	return true, ""
}

export removeFile :: (path:string) -> (success:bool, error:string) {
	local _removeFile :: (path:string) -> bool|none, none|string !foreign lua "os.remove"
	local ok, err = _removeFile(path)
	if ok == nil  return false, cast(string) err
	return true, ""
}
export renameFile :: (oldPath:string, newPath:string) -> (success:bool, error:string) {
	local _renameFile :: (oldPath:string, newPath:string) -> bool|none, none|string !foreign lua "os.rename"
	local ok, err = _renameFile(oldPath, newPath)
	if ok == nil  return false, cast(string) err
	return true, ""
}
export copyFile :: (sourcePath:string, targetPath:string) -> (success:bool, error:string) {
	local ok, data, err = readEntireFile(sourcePath)
	if not ok  return false, err
	return writeFile(targetPath, data)
}

export disableBuffering    :: (file:File)           { file.setvbuf!("no",   nil) }
export enableBuffering     :: (file:File)           { file.setvbuf!("full", nil) }
export enableBuffering     :: (file:File, size:int) { file.setvbuf!("full", size) }
export enableLineBuffering :: (file:File)           { file.setvbuf!("line", nil) }
export enableLineBuffering :: (file:File, size:int) { file.setvbuf!("line", size) }

-- @Incomplete: os.tmpname
