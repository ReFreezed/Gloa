--[[============================================================
--=
--=  GlÃ³a basics module
--=
--==============================================================

	LUA_ENVIRONMENT
	LUA_VERSION_STRING

	LuaType

	error, assert
	format
	getLuaType
	print, printf
	stringToFloat, stringToInt
	toString

	concatinate
	insert, remove
	next
	pairs, ipairs
	unpack

--============================================================]]

export LUA_VERSION_STRING : string : !foreign lua "_VERSION"
export LUA_ENVIRONMENT    : table  : !foreign lua "_G"

export toString :: (value:any) -> string !foreign lua "tostring"

export format :: (s:string, ...:int|float|string) -> string !foreign lua "string.format"
export print  :: (...:any) !foreign lua "print"
export printf :: (s:string, ...:int|float|string) { print(format(s, ...)) }

-- We change these a bit to be more strict compared to Lua.
export error  :: (message:string, level:int=1) !foreign lua "error"
export assert :: (v:bool)                 !foreign lua "assert"
export assert :: (v:bool, message:string) !foreign lua "assert"

export errorf :: (           s:string, ...:int|float|string) { error(format(s, ...), 2) }
export errorf :: (level:int, s:string, ...:int|float|string) { error(format(s, ...), 1+level) }

export LuaType :: enum {
	BOOLEAN  :: "boolean",
	FUNCTION :: "function",
	NIL      :: "nil",
	NUMBER   :: "number",
	STRING   :: "string",
	TABLE    :: "table",
	THREAD   :: "thread",   -- Coroutine.
	USERDATA :: "userdata", -- C data.
}
export getLuaType :: (v:any) -> LuaType !foreign lua "type"

local tonumber :: (s:string, base:int) -> float|none !foreign lua "tonumber"

export stringToFloat :: (s:string) -> (success:bool, number:float) {
	local n = tonumber(s, 10)
	if n == nil  return false, 0
	return true, cast(float) n
}
-- Note: The base has to be between 2 and 36.
export stringToInt :: (s:string, base:int=10) -> (success:bool, number:int) {
	local n = tonumber(s, base)
	if n == nil  return false, 0
	return true, cast(int) cast(float) n -- Note: This will simply discard any decimals.
}

--
-- Arrays/tables (@Cleanup: Move some/all of these to their own module?)
--

local TableIterator :: (t:table,k:any)->(k:any,item:any)
export next:TableIterator : !foreign lua "next"

export pairs   :: (t:table)  -> (iter:TableIterator,                        t:table, init:any) !foreign lua      "pairs"
export ipairs  :: (arr:[]$T) -> (iter:(arr:[]T,i:int)->(i:int|none,item:T), arr:[]T, init:int) !foreign lua      "ipairs"
export ipairsr :: (arr:[]$T) -> (iter:(arr:[]T,i:int)->(i:int|none,item:T), arr:[]T, init:int) !foreign compiler "ipairsr" -- Reverse iteration of an array.

export insert :: (arr:[]$T, value:T)            !foreign lua "table.insert"
export insert :: (arr:[]$T, index:int, value:T) !foreign lua "table.insert"

export remove :: (arr:[]$T) -> (success:bool, removedItem:T) {
	local _remove :: (arr:[]T) -> T|none !foreign lua "table.remove"
	local item = _remove(arr)
	return (item ~= nil), cast(T)item
}
export remove :: (arr:[]$T, index:int) -> (success:bool, removedItem:T) {
	local _remove :: (arr:[]T, index:int) -> T|none !foreign lua "table.remove"
	local item = _remove(arr, index)
	return (item ~= nil), cast(T)item
}

export unpack :: (v:[]$T) -> (...:T) !foreign lua "unpack"

export concatinate :: (strings:[]string) -> string !foreign lua "table.concat"



--[[ OLD unrevised:
export collectGarbage :: (task:string, value:any=nil) !foreign lua "collectgarbage" -- @Incomplete: Split into multiple functions.
export select :: (what:int|string, ...:$T) -> (...:T) !foreign lua "select"

export pcall  :: (callback:(), ...:any)                 -> bool, string|none !foreign lua "pcall"
export xpcall :: (callback:(), errorCallback:(err:any)) -> bool, string|none !foreign lua "xpcall"

-- dofile
-- load
-- loadfile
-- loadstring

export require :: (moduleName:string) -> any !foreign lua "require"
-- module

-- getfenv
-- setfenv

-- getmetatable
-- setmetatable
-- rawequal
-- rawget
-- rawset

-- package.cpath
-- package.loaded
-- package.loaders
-- package.loadlib
-- package.path
-- package.preload
-- package.seeall
]]
