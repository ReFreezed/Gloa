--[[============================================================
--=
--=  Example program: Lövely Blaster
--=  by Marcus 'ReFreezed' Thunström
--=
--=  Requires LÖVE 11.3 to run!
--=
--============================================================]]

global DEV            :: true
global DISABLE_SOUNDS :: DEV and true

!import "basic"
!import "io"
!import "math"
!import "os"
!import "utils"

!import "love/audio"
!import "love/basic"
!import "love/event"
!import "love/graphics"
!import "love/keyboard"

!load "entities.gloa"
!load "levels.gloa"

!run {
	!import "compiler"
	compile("conf.gloa")
}



global LEVEL_WIDTH   :: 100 -- In meters or something similar.
global CAMERA_HEIGHT :: 75

global MIN_DISTANCE_TO_CAMERA_EDGE :: 3

global SpawnInstruction :: struct {
	timeRelative = 0.00,
	entity       = none,
	x            = 0.0,
	y            = 0.0,
}

global Level :: struct {
	time        = 0.00,
	timeSpeed   = 1.0,
	progression = 0.00,

	entities: []Entity,
	player: Player = NULL,

	cameraShake = 0.0,

	entitySpawnQueue: []SpawnInstruction = NULL,
	nextIndexToSpawn = 1,
	lastSpawnTime    = 0.00,

	lightsToDraw: []Light,
}

local currentLevel: Level    = NULL
local lightImage: LoveImage  = NULL



local Sound :: struct {
	source: LoveSource = NULL,
	volumeVariation: float,
	pitchVariation:  float,
}

local sounds: table
-- local sounds: struct { !key:string, !value:Sound } -- @Compiler @Incomplete: Structured hash tables.

local loadSounds :: () {
	local loadSound :: (name:string, path:string, loop:bool, volume,volumeVar:float, pitch,pitchVar:float) {
		!if DISABLE_SOUNDS  path = "sounds/silence.ogg"

		local source = loveNewSource(path, LoveSourceType.STATIC)

		loveSetVolume (source, volume)
		loveSetPitch  (source, pitch)
		loveSetLooping(source, loop)

		local sound: Sound = {source=source, volumeVariation=volumeVar, pitchVariation=pitchVar}
		sounds[name] = sound
	}

	loadSound("death",     "sounds/death.ogg",     false, 0.80,0.00, 1.00,0.00)
	loadSound("explosion", "sounds/explosion.ogg", false, 0.60,0.05, 1.00,0.06)
	loadSound("impact",    "sounds/impact.ogg",    false, 0.30,0.00, 1.00,0.06)
	loadSound("shot1",     "sounds/shot1.ogg",     false, 0.20,0.05, 0.80,0.03)
	loadSound("shot2",     "sounds/shot2.ogg",     false, 0.50,0.05, 1.00,0.03)
}

global playSound :: (name:string) {
	local sound = cast(Sound) sounds[name]
	if sound == NULL {
		writeLine(STDERR, format("Error: No sound '%s'.", name))
		return
	}
	local clone = loveCloneSource(sound.source)
	loveSetVolume(clone, loveGetVolume(clone)*getRandom(1-sound.volumeVariation, 1+sound.volumeVariation))
	loveSetPitch (clone, loveGetPitch (clone)*getRandom(1-sound.pitchVariation,  1+sound.pitchVariation ))
	lovePlay(clone)
}



local startLevel :: (levelId:int) {
	currentLevel        = {entitySpawnQueue=LEVEL1_SPAWN_QUEUE}

	local player        = newEntity(currentLevel, Player, LEVEL_WIDTH/2, .8*CAMERA_HEIGHT)
	currentLevel.player = player
	insert(currentLevel.entities, player)
}

local onLoad :: (args:[]string, argsRaw:[]string) {
	!if DEV {
		disableBuffering(STDOUT)
		disableBuffering(STDERR)
	}

	lightImage = loveNewImage("gfx/light.png")

	loadSounds()

	setRandomSeed(getTime())
	startLevel(1)
}



local onKeyPressed :: (key:LoveKey, scancode:LoveScancode, isRepeat:bool) {
	local player = currentLevel.player
	if key == {
		case "escape": loveQuit(0)
		case "f10": if loveIsKeyDown("lctrl","rctrl") loveRestart() else startLevel(1)
	}
	if scancode == {
		case "x": player.wantsToShoot = true
	}
	!if DEV {
		if key == {
		case "kp1": player.bulletMods.level    = 1
		case "kp2": player.bulletMods.level    = 2
		case "kp3": player.bulletMods.level    = 3
		case "kp4": player.bulletMods.movement = BulletMovement.LINEAR
		case "kp5": player.bulletMods.movement = BulletMovement.WAVE
		case "kp6": --
		case "kp7": player.bulletMods.pulsing  = not player.bulletMods.pulsing
		case "kp8": player.rearWeapon          = not player.rearWeapon
		case "kp9": --
		case "kp+":
			player.health = player.healthMax
			if player.isDestroyed {
				player.isDestroyed = false
				insert(currentLevel.entities, player)
			}
		}
	}
}



local uiTime = 0.00

local onUpdate :: (dt:float) {
	!if DEV {
		if loveIsKeyDown("lctrl","rctrl")
			dt *= if loveIsKeyDown("lshift","rshift") 1.0/80 else 1.0/5
		elseif loveIsKeyDown("<")
			dt *= if loveIsKeyDown("lshift","rshift") 1.0*20 else 1.0*5
	}

	uiTime                    = uiTime+dt
	currentLevel.time        += currentLevel.timeSpeed*dt
	currentLevel.progression += currentLevel.timeSpeed*dt

	currentLevel.cameraShake = max(currentLevel.cameraShake-dt/.60, 0)

	while true {
		local ent = currentLevel.entitySpawnQueue[currentLevel.nextIndexToSpawn]
		if ent == NULL or currentLevel.progression < currentLevel.lastSpawnTime + ent.timeRelative  break

		spawnNextEntity(currentLevel)
		currentLevel.lastSpawnTime = currentLevel.lastSpawnTime + ent.timeRelative
	}

	for currentLevel.entities  updateEntity(currentLevel, it, dt)

	for < currentLevel.entities {
		if it.isDestroyed  remove(currentLevel.entities, itIndex)
	}
}



local onDraw :: () {
	local ww, wh = loveGetWindowDimensions()
	local player = currentLevel.player
	local scale  = min(ww/LEVEL_WIDTH, wh/CAMERA_HEIGHT)

	loveGraphicsReset()
	loveClear(.1, .1, .1)

	loveCoordinateSystemTranslate(ww/2, wh/2)
	loveCoordinateSystemScale(scale)
	loveCoordinateSystemTranslate(-LEVEL_WIDTH/2, -CAMERA_HEIGHT/2)

	local viewX1, viewY1 = loveGlobalToScreen(0, 0)
	local viewX2, viewY2 = loveGlobalToScreen(LEVEL_WIDTH, CAMERA_HEIGHT)
	loveSetScissor(viewX1, viewY1, viewX2-viewX1, viewY2-viewY1)
	loveClear(.5, .05, .1)

	-- World.
	local shakeX = .6 * currentLevel.cameraShake * cos(currentLevel.time/.10*TAU)
	local shakeY = .4 * currentLevel.cameraShake * cos(currentLevel.time/.17*TAU)
	loveCoordinateSystemTranslate(shakeX, shakeY)

	for currentLevel.entities  drawEntity(currentLevel, it)

	do {
		local iw, ih = loveGetDimensions(lightImage)

		loveSetBlendMode(LoveBlendMode.ADD)
		for currentLevel.lightsToDraw {
			loveSetColor(1, 1, 1, it.opacity)
			loveDrawAnchored(lightImage, it.x,it.y, .5,.5, 0, it.radiusX/(iw/2),it.radiusY/(ih/2))
		}
		loveResetBlendMode()
	}

	currentLevel.lightsToDraw = {}
	loveCoordinateSystemTranslate(-shakeX, -shakeY)

	-- HUD.
	for i = 1, player.healthMax {
		if i > player.health
			loveSetColor(0, 0, 0)
		else
			loveSetColor(0, 1, 0)

		local RADIUS  :: 1
		local SPACING :: .5
		loveDrawCircleFill(SPACING+RADIUS + (i-1)*(SPACING+2*RADIUS), SPACING+RADIUS, RADIUS, 32)
	}

	!if DEV {
		if loveIsKeyDown("tab") {
			loveGraphicsReset()

			local font  = loveGetFont()
			local fontH = loveGetHeight(font)
			local y     = viewY2-fontH

			loveSetColor(1, 1, 1)
			loveDrawText(format("Entities: %d", #currentLevel.entities), viewX1, y) ; y -= fontH
		}
	}
}

global Light :: struct {
	x       = 0.0,
	y       = 0.0,
	radiusX = 0.0,
	radiusY = 0.0,
	opacity = 0.0,
}



local main :: () {
	using LoveEvent
	loveSetEventHandler(LOAD,        onLoad)
	loveSetEventHandler(KEY_PRESSED, onKeyPressed)
	loveSetEventHandler(UPDATE,      onUpdate)
	loveSetEventHandler(DRAW,        onDraw)
	loveRemoveEventHandler(ERROR_HANDLER) -- We want Glóa to handle all errors (for now, at least).
}


