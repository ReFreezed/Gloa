--[[============================================================
--=
--=  Example program: Lövely Blaster
--=  by Marcus 'ReFreezed' Thunström
--=
--=  Requires LÖVE 11.3 to run!
--=
--============================================================]]

export DEV            :: true
export DISABLE_SOUNDS :: DEV and true

export !import "basic"
export !import "io"
export !import "math"
export !import "os"
export !import "utils"

export !import "love/audio"
export !import "love/basic"
export !import "love/event"
export !import "love/graphics"
export !import "love/keyboard"
export !import "love/math"

export !self
export !load "entities"
export !load "enemyWaves"

!run {
	!import "compiler"
	compile("conf.gloa")
}



export LEVEL_WIDTH    :: 100 -- 1 unit ~ 1 meter
export CAMERA_HEIGHT  :: 75

export MIN_DISTANCE_TO_CAMERA_EDGE  :: 3

export STAR_DISTANCE_OUTSIDE_SCREEN :: .05 * CAMERA_HEIGHT



export fontHud:   LoveFont = NULL
export fontWorld: LoveFont = NULL

export lightImage: LoveImage = NULL

local currentLevel: Level = NULL



export Level :: struct {
	time        = 0.00,
	timeSpeed   = 1.0,
	progression = 0.00,

	entities: []Entity,
	player: Player = NULL,

	currentWave: EnemyWave = NULL,

	nextIndexToSpawn = 1,
	lastSpawnTime    = 0.00,
	completedWaves   = 0,

	difficulty     = 0,
	difficultyTime = -9999.00,

	score     = 0,
	scoreTime = -9999.00,

	stars: []Star,
	lightsToDraw: []Light,

	cameraShake = 0.0,
}

export SpawnInstruction :: struct {
	timeRelative = 0.00,
	entity       = none,
	x            = 0.0,
	y            = 0.0,
	data:table,
}

export EnemyWave :: struct {
	difficulty: int,
	outroTime: float,
	spawns: []SpawnInstruction,
}

export Light :: struct {
	x: float,
	y: float,

	radiusX: float,
	radiusY: float,

	r: float,
	g: float,
	b: float,
	a: float,
}



local Star :: struct {
	x: float,
	y: float,

	size:     float, -- 0..1
	distance: float, -- >0
}

local Sound :: struct {
	source: LoveSource = NULL,
	volumeVariation: float,
	pitchVariation:  float,
}



local sounds: struct { !key:string, !value:Sound }

local loadSounds :: () {
	local loadSound :: (name:string, path:string, volume,volumeVar:float, pitch,pitchVar:float, loop=false) {
		!if DISABLE_SOUNDS  path = "sounds/silence.ogg"

		local source = loveNewSource(path, LoveSourceType.STATIC)

		loveSetVolume (source, volume)
		loveSetPitch  (source, pitch)
		loveSetLooping(source, loop)

		local sound: Sound = {source=source, volumeVariation=volumeVar, pitchVariation=pitchVar}
		sounds[name] = sound
	}

	loadSound("death",     "sounds/death.ogg",     volume=0.80,volumeVar=0.00, pitch=1.00,pitchVar=0.00)
	loadSound("explosion", "sounds/explosion.ogg", volume=0.60,volumeVar=0.05, pitch=1.00,pitchVar=0.06)
	loadSound("impact",    "sounds/impact.ogg",    volume=0.30,volumeVar=0.00, pitch=1.00,pitchVar=0.06)
	loadSound("shot1",     "sounds/shot1.ogg",     volume=0.20,volumeVar=0.05, pitch=0.80,pitchVar=0.03)
	loadSound("shot2",     "sounds/shot2.ogg",     volume=0.50,volumeVar=0.05, pitch=1.00,pitchVar=0.03)
}

export playSound :: (name:string, volumeScale=1.0) {
	local sound = sounds[name]
	if sound == NULL {
		writeLine(STDERR, format("Error: No sound '%s'.", name))
		return
	}
	local clone = loveCloneSource(sound.source)
	loveSetVolume(clone, loveGetVolume(clone)*getRandom(1-sound.volumeVariation, 1+sound.volumeVariation)*volumeScale)
	loveSetPitch (clone, loveGetPitch (clone)*getRandom(1-sound.pitchVariation,  1+sound.pitchVariation))
	lovePlay(clone)
}



local startNewGame :: () {
	currentLevel        = {currentWave=getRandomWave(0)}

	local player        = newEntity(currentLevel, Player, LEVEL_WIDTH/2, .8*CAMERA_HEIGHT)
	currentLevel.player = player
	insert(currentLevel.entities, player)

	for 1, 500 {
		local star: Star = {
			x        = LEVEL_WIDTH*getRandom(),
			y        = getRandom(-STAR_DISTANCE_OUTSIDE_SCREEN, CAMERA_HEIGHT+STAR_DISTANCE_OUTSIDE_SCREEN),
			size     = getRandom()^1.4,
			distance = getRandom(.6, 1.5),
		}
		insert(currentLevel.stars, star)
	}
}

local onLoad :: (args:[]string, argsRaw:[]string) {
	!if DEV {
		disableBuffering(STDOUT)
		disableBuffering(STDERR)
	}

	fontHud   = loveNewFont(16)
	fontWorld = loveNewFont(32)

	lightImage = loveNewImage("gfx/light.png")

	loadSounds()

	setRandomSeed(getTime())
	startNewGame()
}



local onKeyPressed :: (key:LoveKey, scancode:LoveScancode, isRepeat:bool) {
	local player = currentLevel.player

	if key == {
		case "escape": loveQuit(0)
		case "r":      startNewGame()
		case "f10":    if loveIsKeyDown("lctrl","rctrl")  loveRestart()  else  startNewGame()
	}
	if scancode == {
		case "x": player.wantsToShoot = true
	}

	!if DEV {
		if key == {
		case "kp1": player.bulletMods.level    = 1
		case "kp2": player.bulletMods.level    = 2
		case "kp3": player.bulletMods.level    = 3
		case "kp4": player.bulletMods.movement = BulletMovement.LINEAR
		case "kp5": player.bulletMods.movement = BulletMovement.WAVE
		case "kp6": --
		case "kp7": player.bulletMods.pulsing  = not player.bulletMods.pulsing
		case "kp8": player.rearWeapon          = not player.rearWeapon
		case "kp9": player.sideWeapons         = not player.sideWeapons
		case "kp+":
			player.health = player.healthMax

			if player.isDestroyed {
				player.speedX       = 0
				player.speedY       = 0
				player.wantsToShoot = false

				player.isDestroyed  = false
				insert(currentLevel.entities, player)
			}
		}
	}
}



local uiTime = 0.00

local getRandomWave :: (difficultyMax:int) -> EnemyWave {
	local difficultyMin = min(1, difficultyMax)

	local i1 = #ENEMY_WAVES
	local i2 = i1

	for ENEMY_WAVES {
		if it.difficulty == difficultyMin {
			i1 = itIndex
			break
		}
	}
	for < ENEMY_WAVES {
		if it.difficulty == difficultyMax {
			i2 = itIndex
			break
		}
	}

	return ENEMY_WAVES[getRandom(i1, i2)]
}

local onUpdate :: (dt:float) {
	!if DEV {
		if loveIsKeyDown("lctrl","rctrl")
			dt *= loveIsKeyDown("lshift","rshift") ? 1.0/80 : 1.0/5
		elseif loveIsKeyDown"<"
			dt *= loveIsKeyDown("lshift","rshift") ? 1.0*20 : 1.0*5
	}

	uiTime                    = uiTime+dt
	currentLevel.time        += currentLevel.timeSpeed*dt
	currentLevel.progression += currentLevel.timeSpeed*dt

	currentLevel.cameraShake = max(currentLevel.cameraShake-dt/.60, 0)

	if not currentLevel.player.isDestroyed  while true {
		local ent = currentLevel.currentWave.spawns[currentLevel.nextIndexToSpawn]

		if ent == NULL {
			if currentLevel.progression < currentLevel.lastSpawnTime + currentLevel.currentWave.outroTime  break

			currentLevel.completedWaves += 1
			local newDifficulty          = DIFFICULTY_AT_WAVES[currentLevel.completedWaves]

			if newDifficulty ~= NULL {
				currentLevel.difficulty     = newDifficulty
				currentLevel.difficultyTime = currentLevel.time
			}

			local wave: EnemyWave = NULL
			while true {
				wave = getRandomWave(currentLevel.difficulty)
				if wave ~= currentLevel.currentWave  break
			}
			currentLevel.currentWave = wave

			currentLevel.progression      = 0
			currentLevel.nextIndexToSpawn = 1
			currentLevel.lastSpawnTime    = 0

			ent = currentLevel.currentWave.spawns[1]
		}

		if currentLevel.progression < currentLevel.lastSpawnTime + ent.timeRelative  break

		spawnNextEntity(currentLevel)
		currentLevel.lastSpawnTime += ent.timeRelative
	}

	for currentLevel.entities  updateEntity(currentLevel, it, dt)

	for < currentLevel.entities {
		if it.isDestroyed  remove(currentLevel.entities, itIndex)
	}

	for currentLevel.stars {
		it.y += dt / it.distance

		if it.y > CAMERA_HEIGHT+STAR_DISTANCE_OUTSIDE_SCREEN {
			it.x = LEVEL_WIDTH*getRandom()
			it.y = -STAR_DISTANCE_OUTSIDE_SCREEN
		}
	}
}



local onDraw :: () {
	local ww, wh    = loveGetWindowDimensions()
	local viewScale = min(ww/LEVEL_WIDTH, wh/CAMERA_HEIGHT)
	local player    = currentLevel.player

	loveGraphicsReset()
	loveClear(.1, .1, .1)

	loveCoordinateSystemTranslate(ww/2, wh/2)
	loveCoordinateSystemScale(viewScale)
	loveCoordinateSystemTranslate(-LEVEL_WIDTH/2, -CAMERA_HEIGHT/2)

	local viewX1, viewY1 = loveGlobalToScreen(0, 0)
	local viewX2, viewY2 = loveGlobalToScreen(LEVEL_WIDTH, CAMERA_HEIGHT)
	local viewWidth      = viewX2-viewX1
	local viewHeight     = viewY2-viewY1
	loveSetScissor(viewX1, viewY1, viewWidth, viewHeight)
	loveClear(.5, .05, .1)

	--
	-- World
	--

	local shakeX = .6 * currentLevel.cameraShake * cos(currentLevel.time/.10*TAU)
	local shakeY = .4 * currentLevel.cameraShake * cos(currentLevel.time/.17*TAU)
	loveCoordinateSystemTranslate(shakeX, shakeY)

	-- Stars.
	loveSetBlendMode(LoveBlendMode.ADD)
	for currentLevel.stars {
		loveSetColor(1, 1, 1, lerp(.1, .3, it.size))
		loveDrawAnchored(lightImage, it.x,it.y, .5,.5, 0, lerp(.01, .03, it.size))
	}
	loveResetBlendMode()

	-- Entities.
	loveSetFont(fontWorld)
	for currentLevel.entities  drawEntity(currentLevel, it)

	-- Lights.
	do {
		local iw, ih = loveGetDimensions(lightImage)

		loveSetBlendMode(LoveBlendMode.ADD)
		for currentLevel.lightsToDraw {
			loveSetColor(it.r, it.g, it.b, it.a)
			loveDrawAnchored(lightImage, it.x,it.y, .5,.5, 0, it.radiusX/(iw/2),it.radiusY/(ih/2))
		}
		loveResetBlendMode()

		currentLevel.lightsToDraw = {}
	}

	loveCoordinateSystemTranslate(-shakeX, -shakeY)

	--
	-- HUD
	--

	local EDGE_SPACING :: 5

	local getTextHighlight :: (timeReference:float, duration:float) -> float {
		local timePassed = currentLevel.time - timeReference
		local highlight  = max(1-timePassed/duration, 0) ^ 1.5
		return highlight
	}

	local font  = fontHud
	local fontH = loveGetHeight(font)

	loveGraphicsReset()
	loveCoordinateSystemTranslate(round(viewX1), round(viewY1))

	loveSetFont(font)

	-- Health.
	for i = 1, player.healthMax {
		if i > player.health
			loveSetColor(0, 0, 0)
		else
			loveSetColor(0, 1, 0)

		local RADIUS  :: 10
		local SPACING :: 5
		loveDrawCircleFill(SPACING+RADIUS + (i-1)*(SPACING+2*RADIUS), SPACING+RADIUS, RADIUS, 32)
	}

	-- Score.
	do {
		local highlight = getTextHighlight(currentLevel.scoreTime, .20)

		local text      = format("SCORE %d", currentLevel.score)
		local textScale = 1 + .1*highlight
		local textWidth = loveGetWidth(font, text) * textScale

		local r = lerp(1.0, 1.0, highlight)
		local g = lerp(0.8, 1.0, highlight)
		local b = lerp(0.5, 1.0, highlight)

		local HIGHLIGHT_MOVEMENT :: 3
		local x = (viewWidth - textWidth) // 2
		local y = EDGE_SPACING + HIGHLIGHT_MOVEMENT * highlight

		loveSetColor(r, g, b)
		loveDrawText(text, x, y, 0, textScale)
	}

	-- Difficulty.
	do {
		local highlight = getTextHighlight(currentLevel.difficultyTime, .70)

		local text      = format("DIFFICULTY %d", currentLevel.difficulty)
		local textScale = 1 + .5*highlight
		local textWidth = loveGetWidth(font, text) * textScale

		local r = lerp(1.0, 1.0, highlight)
		local g = lerp(0.8, 1.0, highlight)
		local b = lerp(0.5, 1.0, highlight)

		local HIGHLIGHT_MOVEMENT :: 10
		local x = round(viewWidth) - EDGE_SPACING - textWidth - HIGHLIGHT_MOVEMENT*highlight
		local y = EDGE_SPACING + HIGHLIGHT_MOVEMENT * highlight

		loveSetColor(r, g, b)
		loveDrawText(text, x, y, 0, textScale)
	}

	-- Restart prompt.
	if player.isDestroyed {
		local TEXT           :: "press <R> to restart"
		local TEXT_DELAY     :: 1.00
		local TEXT_FADE_TIME :: 1.50

		local timeSinceDeath = currentLevel.time - player.timeDamaged

		local x = ( viewWidth  - loveGetWidth(font, TEXT) ) // 2
		local y = ( viewHeight - loveGetHeight(font)      ) // 2
		local a = clamp01((timeSinceDeath-TEXT_DELAY) / TEXT_FADE_TIME)

		loveSetColor(1, 1, 1, a)
		loveDrawText(TEXT, x, y)
	}

	!if DEV {
		if loveIsKeyDown"tab" {
			local y = viewY2-fontH
			loveGraphicsReset()
			loveSetColor(1, 1, 1)
			loveDrawText(format("Entities: %d", #currentLevel.entities), viewX1, y) ; y -= fontH
		}
	}
}



local main :: () {
	using LoveEvent
	loveSetEventHandler(LOAD,        onLoad)
	loveSetEventHandler(KEY_PRESSED, onKeyPressed)
	loveSetEventHandler(UPDATE,      onUpdate)
	loveSetEventHandler(DRAW,        onDraw)
	loveRemoveEventHandler(ERROR_HANDLER) -- We want Glóa to handle all errors (for now, at least).
}


