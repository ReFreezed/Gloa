--[[============================================================
--=
--=  Entities
--=
--=-------------------------------------------------------------
--=
--=  Example program: Lövely Blaster
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]



global Entity :: struct {
	entityType = none,
	id:int,

	width     = 1.0,
	height    = 1.0,
	healthMax = 1,

	x:float,
	y:float,

	health = 1,

	timeSpawned = 0.00,
	timeDamaged = -9999.00,

	isDestroyed = false,
}

global BulletMovement :: enum {
	LINEAR :: 1,
	WAVE   :: 2,
}
global BulletMods :: struct {
	level    = 1,
	movement = BulletMovement.LINEAR,
	pulsing  = false, -- @Incomplete
}

global Player :: struct {
	using Entity,

	speedX = 0.0,
	speedY = 0.0,

	wantsToShoot   = false,
	weaponCooldown = 0.00,
	shootCount     = 0,

	bulletMods: BulletMods,
	rearWeapon = false,
}

local Enemy :: struct {
	using Entity,
}
global Carrier :: struct {
	using Enemy,
}
global Fly :: struct {
	Phase :: enum {
		ENTER :: 1,
		SHOOT :: 2,
		EXIT  :: 3,
	},
	using Enemy,

	phase = Phase.ENTER,

	targetX:float,
	targetY:float,

	weaponCooldown = 0.00,
	shootCount     = 0,
}
global isEnemy :: (ent:Entity) -> bool {
	local entityType = ent.entityType
	return entityType == Carrier or entityType == Fly
}

global Bullet :: struct {
	using Entity,

	shotByPlayer = false,
	mods: BulletMods,

	angleBase:float,
	angle:float,
}

global Fx :: struct {
	using Entity,
	timeTotal     = 1.00,
	timeRemaining = 1.00,
}
global Spark :: struct {
	using Fx,
	speed  = 0.0,
	angleX = 0.0,
	angleY = 0.0,
}
global Explosion :: struct {
	using Fx,
	radius = 1.0,
}

-- @Incomplete: Generate this enum through metaprogramming.
-- global EntityType :: enum {
-- 	PLAYER  :: Player,
-- 	CARRIER :: Carrier,
-- 	BULLET  :: Bullet,
-- 	-- ...
-- }



local lastEntityId = 0

global newEntity :: (level:Level, $T:type, initX,initY:float) -> T {
	!assert T ~= Entity
	-- !assert T has Entity -- @Incomplete: Somehow make sure Entity is part of the type.

	lastEntityId += 1

	local ent:T = {
		entityType  = T,
		id          = lastEntityId,
		x           = initX,
		y           = initY,
		timeSpawned = level.time,
	}

	!if T == Player {
		ent.width     = 1.5
		ent.height    = 1.5
		ent.healthMax = 3

	-- Enemies.

	} elseif T == Carrier {
		ent.width     = 3
		ent.height    = 5
		ent.healthMax = 10

	} elseif T == Fly {
		local targetX:float

		for try = 1, 50 {
			local ok = true
			targetX  = getRandom(1.0*MIN_DISTANCE_TO_CAMERA_EDGE, 1.0*LEVEL_WIDTH-MIN_DISTANCE_TO_CAMERA_EDGE)

			for level.entities {
				local x = if it.entityType == Fly then (cast(Fly)it).targetX else it.x

				if abs(targetX-x) < 5 and isEnemy(it) {
					ok = false
					break
				}
			}

			if ok  break
		}

		ent.x         = if targetX > LEVEL_WIDTH/2  0 else LEVEL_WIDTH
		ent.width     = 2
		ent.height    = 3
		ent.healthMax = 3

		ent.targetX   = targetX
		ent.targetY   = getRandom(.1*CAMERA_HEIGHT, .4*CAMERA_HEIGHT)

	} elseif T == Bullet {
		ent.width  = 1.4
		ent.height = 3

	-- Effects.

	} elseif T == Spark {
		local angle       = getRandom(TAU)
		ent.timeTotal     = lerp(.1, .3, getRandom()^2)
		ent.timeRemaining = ent.timeTotal
		ent.speed         = getRandom(25.0, 30.0)
		ent.angleX        = cos(angle)
		ent.angleY        = sin(angle)

	} elseif T == Explosion {
		ent.timeTotal     = 0.70
		ent.timeRemaining = ent.timeTotal
	}

	ent.health = ent.healthMax
	return ent
}

global spawnNextEntity :: (level:Level) {
	local instr             = level.entitySpawnQueue[level.nextIndexToSpawn]
	level.nextIndexToSpawn += 1

	local ent:Entity = NULL

	if instr.entity == {
		case Carrier:  ent = newEntity(level, Carrier, instr.x, instr.y)
		case Fly:      ent = newEntity(level, Fly,     instr.x, instr.y)
		case:          printf("Error: Unhandled entity type %s.", toString(instr.entity))
	}

	if ent ~= NULL {
		insert(level.entities, ent)
	}
}



global updateEntity :: (level:Level, ent:Entity, dt:float) {
	-- @Incomplete: Use EntityType and 'if !complete' here.
	if ent.entityType == {
	case Player:
		local player = cast(Player) ent

		local dirX, dirY = 0, 0
		if loveIsScancodeDown("left")   dirX -= 1
		if loveIsScancodeDown("right")  dirX += 1
		if loveIsScancodeDown("up")     dirY -= 1
		if loveIsScancodeDown("down")   dirY += 1

		local MAX_SPEED_X    :: 50.0
		local MAX_SPEED_Y    :: 40.0
		local ACCELERATION_X :: 1000
		local ACCELERATION_Y :: 1000

		player.speedX =
			if dirX == 0
			moveTowards(player.speedX, 0, ACCELERATION_X*dt)
			else clamp(player.speedX+dirX*ACCELERATION_X*dt, -MAX_SPEED_X, MAX_SPEED_X)

		player.speedY =
			if dirY == 0
			moveTowards(player.speedY, 0, ACCELERATION_Y*dt)
			else clamp(player.speedY+dirY*ACCELERATION_Y*dt, -MAX_SPEED_Y, MAX_SPEED_Y)

		player.x += player.speedX*dt
		player.y += player.speedY*dt

		if player.x < MIN_DISTANCE_TO_CAMERA_EDGE {
			player.x      = MIN_DISTANCE_TO_CAMERA_EDGE
			player.speedX = 0
		} elseif player.x > LEVEL_WIDTH-MIN_DISTANCE_TO_CAMERA_EDGE {
			player.x      = LEVEL_WIDTH-MIN_DISTANCE_TO_CAMERA_EDGE
			player.speedX = 0
		}
		if player.y < MIN_DISTANCE_TO_CAMERA_EDGE {
			player.y      = MIN_DISTANCE_TO_CAMERA_EDGE
			player.speedY = 0
		} elseif player.y > CAMERA_HEIGHT-MIN_DISTANCE_TO_CAMERA_EDGE {
			player.y      = CAMERA_HEIGHT-MIN_DISTANCE_TO_CAMERA_EDGE
			player.speedY = 0
		}

		-- @Incomplete: Collide with other entities.

		player.weaponCooldown -= dt

		if (player.wantsToShoot or loveIsScancodeDown("x")) and player.weaponCooldown <= 0 {
			player.weaponCooldown  = 1/15
			player.shootCount     += 1

			if player.bulletMods.level == {
			case 1:
				spawnBullet(level, player.x, player.y, -TAU/4, player.bulletMods, true)

			case 2:
				if player.shootCount%2 == 0
					spawnBullet(level, player.x, player.y, -TAU/4, player.bulletMods, true)
				else
					for spread = -1, 1  spawnBullet(level, player.x, player.y, -TAU/4+spread*(.04*TAU), player.bulletMods, true)

			case 3:
				if player.shootCount%2 == 0
					for spread = -1, 1  spawnBullet(level, player.x, player.y, -TAU/4+spread*(.06*TAU), player.bulletMods, true)
				else
					for spread = -1, 1  spawnBullet(level, player.x, player.y, -TAU/4+spread*(.03*TAU), player.bulletMods, true)
			}

			if player.rearWeapon {
				if player.shootCount%2 == 0  spawnBullet(level, player.x, player.y, TAU/4, player.bulletMods, true)
			}
		}

		player.wantsToShoot = false

	case Bullet:
		local bullet    = cast(Bullet) ent
		local deltaDist = (if bullet.shotByPlayer then 120 else 50) * dt
		local angle     = bullet.angleBase

		if bullet.mods.movement == BulletMovement.WAVE {
			local phase  = (level.time-bullet.timeSpawned)/0.30 + level.time/0.95
			angle       += .06*sin(phase*TAU)*TAU
		}
		bullet.angle = angle

		bullet.x += deltaDist * cos(angle)
		bullet.y += deltaDist * sin(angle)

		for level.entities {
			local areEntitiesOverlapping :: (ent1,ent2:Entity) -> bool {
				return
					abs(ent1.x-ent2.x) < (ent1.width  + ent2.width ) / 2 and
					abs(ent1.y-ent2.y) < (ent1.height + ent2.height) / 2
			}

			if ((not bullet.shotByPlayer and it.entityType == Player) or (bullet.shotByPlayer and isEnemy(it))) and areEntitiesOverlapping(bullet, it) {
				damage(level, it, 1, bullet.x, bullet.y)
				destroy(bullet)
				break
			}
		}

		if bullet.x < -50 or bullet.x > LEVEL_WIDTH+50 {
			destroy(bullet)
		} elseif bullet.angleBase > 0 {
			if bullet.y > CAMERA_HEIGHT+20  destroy(bullet)
		} else {
			if bullet.y < -20  destroy(bullet)
		}

	case Carrier:
		local carrier  = cast(Carrier) ent
		carrier.y     += 10*dt

		if carrier.y > CAMERA_HEIGHT+20  destroy(carrier)

	case Fly:
		local MOVE_SPEED :: 40.0

		local fly = cast(Fly) ent
		using fly.Phase

		if !complete fly.phase == {
		case ENTER:
			local angle = atan(fly.targetY-fly.y, fly.targetX-fly.x)

			fly.x = moveTowards(fly.x, fly.targetX, MOVE_SPEED*abs(cos(angle))*dt)
			fly.y = moveTowards(fly.y, fly.targetY, MOVE_SPEED*abs(sin(angle))*dt)

			if fly.x == fly.targetX and fly.y == fly.targetY {
				fly.phase          = SHOOT
				fly.weaponCooldown = .60
			}

		case SHOOT:
			fly.weaponCooldown -= dt

			if fly.shootCount < 5 {
				if fly.weaponCooldown <= 0 {
					fly.weaponCooldown  = 1/3
					fly.shootCount += 1
					spawnBullet(level, fly.x, fly.y, TAU/4, nil)
				}
			} else {
				if fly.weaponCooldown < -.50  fly.phase = EXIT
			}

		case EXIT:
			fly.y += MOVE_SPEED*dt
			if fly.y > CAMERA_HEIGHT+20  destroy(fly)
		}

	case Spark:
		local spark = cast(Spark) ent

		spark.x += spark.speed * spark.angleX * dt
		spark.y += spark.speed * spark.angleY * dt

		spark.timeRemaining -= dt
		if spark.timeRemaining <= 0  destroy(spark)

	case Explosion:
		local explosion          = cast(Explosion) ent
		explosion.timeRemaining -= dt
		if explosion.timeRemaining <= 0  destroy(explosion)
	}
}



global drawEntity :: (level:Level, ent:Entity) {
	local setColorWithEffects :: (damageEffect:float, r,g,b:float, a=1.0) {
		r = lerp(r, 1, damageEffect)
		g = lerp(g, 1, damageEffect)
		b = lerp(b, 1, damageEffect)
		loveSetColor(r, g, b, a)
	}

	local DAMAGE_EFFECT_TIME :: 0.10
	local damageEffect = clamp01(1-(level.time-ent.timeDamaged)/DAMAGE_EFFECT_TIME)

	if ent.entityType == {
	case Player:
		local SIZE_OUTER :: 2.2
		local SIZE_INNER :: .4*SIZE_OUTER
		local player = cast(Player) ent
		setColorWithEffects(damageEffect, 0, 0, 0)
		loveDrawRectangleFill(player.x-SIZE_OUTER/2, player.y-SIZE_OUTER/2, SIZE_OUTER, SIZE_OUTER)
		setColorWithEffects(damageEffect, 1, 1, 1)
		loveDrawRectangleFill(player.x-SIZE_INNER/2, player.y-SIZE_INNER/2, SIZE_INNER, SIZE_INNER)

	case Bullet:
		local bullet = cast(Bullet) ent
		if bullet.shotByPlayer
			setColorWithEffects(damageEffect, 1, 1, 1)
		else
			setColorWithEffects(damageEffect, 1, 0, 0)

		loveGraphicsPushTransform()
		loveCoordinateSystemTranslate(bullet.x, bullet.y)
		loveCoordinateSystemRotate(bullet.angle+TAU/4)
		loveDrawEllipseFill(0,0, .3,1.8, 24)
		loveGraphicsPop()

		drawLight(level, bullet.x,bullet.y, 4,6, .2)

	case Carrier:
		local SIZE_X, SIZE_Y :: 3, 5
		local carrier = cast(Carrier) ent
		local phase   = sin01((level.time-ent.timeSpawned)*TAU)
		local r       = lerp(0.80, 1.00, phase)
		local g       = lerp(0.40, 0.70, phase)
		local b       = lerp(0.95, 0.60, phase)
		setColorWithEffects(damageEffect, r, g, b)
		loveDrawRectangleFill(carrier.x-SIZE_X/2, carrier.y-SIZE_Y/2, SIZE_X, SIZE_Y)

	case Fly:
		local SIZE_X, SIZE_Y :: 2, 3
		local fly = cast(Fly) ent
		setColorWithEffects(damageEffect, 1, .9, .4)
		loveDrawRectangleFill(fly.x-SIZE_X/2, fly.y-SIZE_Y/2, SIZE_X, SIZE_Y)

	case Spark:
		local spark    = cast(Spark) ent
		local progress = 1 - spark.timeRemaining/spark.timeTotal
		local radius   = lerp(.4, .2, progress)
		local a        = 1 - progress^2
		loveSetColor(1, 1, 1, a)
		loveDrawCircleFill(spark.x, spark.y, radius, 5)
		drawLight(level, spark.x,spark.y, 4*radius, .5*a)

	case Explosion:
		local explosion = cast(Explosion) ent
		local progress  = 1 - explosion.timeRemaining/explosion.timeTotal
		local radius    = explosion.radius * lerp(.1, 1, progress^.4)
		local a         = .6 * (1 - sin(progress^2 * TAU/4))
		loveSetColor(1, 1, 1, a)
		loveSetBlendMode(LoveBlendMode.ADD)
		loveDrawCircleFill(explosion.x, explosion.y, radius, 32)
		loveResetBlendMode()
		drawLight(level, explosion.x,explosion.y, 4*radius, .8*a)
	}

	!if DEV {
		-- Collision box.
		if loveIsKeyDown("tab") {
			loveSetColor(0, 1, 0, .4)
			loveDrawRectangleFill(ent.x-ent.width/2, ent.y-ent.height/2, ent.width, ent.height)
		}
	}
}

local drawLight :: (level:Level, x,y:float, radius:float, opacity:float) {
	drawLight(level, x,y, radius,radius, opacity)
}
local drawLight :: (level:Level, x,y:float, radiusX,radiusY:float, opacity:float) {
	local light:Light = {x=x, y=y, radiusX=radiusX, radiusY=radiusY, opacity=opacity} -- @Speed
	insert(level.lightsToDraw, light)
}



global destroy :: (ent:Entity) {
	ent.isDestroyed = true
}



global damage :: (level:Level, ent:Entity, amount:int, damagePointX,damagePointY:float) {
	if ent.isDestroyed  return

	ent.timeDamaged  = level.time
	ent.health      -= amount

	local getRandomizedDamageEffectPosition :: (ent:Entity, damagePointX,damagePointY:float) -> (x,y:float) {
		return
			clamp(damagePointX, ent.x-.4*ent.width , ent.x+.4*ent.width ) + getRandom(-.1, .1),
			clamp(damagePointY, ent.y-.4*ent.height, ent.y+.4*ent.height) + getRandom(-.1, .1)
	}

	for 1, getRandom(5, 8) {
		local x, y  = getRandomizedDamageEffectPosition(ent, damagePointX,damagePointY)
		local spark = newEntity(level, Spark, x, y)
		insert(level.entities, spark)
	}

	level.cameraShake = max(level.cameraShake, .3)

	if ent.health > 0  return

	-- We're dead!

	for 1, 3 {
		local x                  = ent.x + ent.width  * getRandom(-.4, .4)
		local y                  = ent.y + ent.height * getRandom(-.4, .4)
		local explosion          = newEntity(level, Explosion, x, y)
		explosion.timeTotal     *= getRandom(.6, 1/.6)
		explosion.timeRemaining  = explosion.timeTotal
		explosion.radius         = getRandom(3.0, 12.0)
		insert(level.entities, explosion)
	}

	level.cameraShake = max(level.cameraShake, 1)
	destroy(ent)
}



global spawnBullet :: (level:Level, x,y:float, angle:float, modsToCopy:BulletMods|none, shotByPlayer=false) {
	local members :: !run type_info(BulletMods).members

	local bullet        = newEntity(level, Bullet, x, y)
	bullet.angleBase    = angle
	bullet.angle        = angle
	bullet.shotByPlayer = shotByPlayer

	if modsToCopy ~= nil {
		local mods = cast(table) bullet.mods
		for members {
			local name = it.name;
			mods[name] = (cast(table) cast(BulletMods) modsToCopy) [name] -- So much @Hack...
		}
	}

	insert(level.entities, bullet)
}


