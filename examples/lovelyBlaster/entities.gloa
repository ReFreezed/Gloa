--[[============================================================
--=
--=  Entities
--=
--=-------------------------------------------------------------
--=
--=  Example program: Lövely Blaster
--=  by Marcus 'ReFreezed' Thunström
--=
--============================================================]]



export Entity :: struct {
	entityType = none,
	id: int,

	width     = 1.0,
	height    = 1.0,
	healthMax = 1,

	x: float,
	y: float,

	health = 1,

	timeSpawned = 0.00,
	timeDamaged = -9999.00,

	isDestroyed = false,
}

export BulletMovement :: enum {
	LINEAR :: 1,
	WAVE   :: 2,
}
export BulletMods :: struct {
	level    = 1,
	movement = BulletMovement.LINEAR,
	pulsing  = false, -- @Incomplete
}

export Player :: struct {
	using Entity,

	speedX = 0.0,
	speedY = 0.0,

	wantsToShoot = false,
	weaponCooldown: float,
	shootCount: int,

	bulletMods: BulletMods,
	rearWeapon = false,
}

export Bullet :: struct {
	using Entity,

	shotByPlayer = false,
	mods: BulletMods,

	angleBase: float,
	angle: float,
}

local Enemy :: struct {
	using Entity,
}
export Carrier :: struct {
	using Enemy,
}
export Fly :: struct {
	using Enemy,

	Phase :: enum { ENTER, SHOOT, EXIT },
	phase = Phase.ENTER,

	targetX: float,
	targetY: float,

	weaponCooldown: float,
	shootCount: int,
}
export Heavy :: struct {
	using Enemy,

	Phase :: enum { ENTER, SHOOT, BEAM, EXIT },
	phase = Phase.ENTER,

	weaponCooldown: float,
	shootCount: int,
}
export Follower :: struct {
	using Enemy,

	path: []float,
	pathLength = 1.0,

	shootCount: int,
}
export isEnemy :: (ent:Entity) -> bool {
	local entityType = ent.entityType
	return entityType == Carrier or entityType == Fly or entityType == Heavy or entityType == Follower
}

export Fx :: struct {
	using Entity,
	timeTotal     = 1.00,
	timeRemaining = 1.00,
}
export Spark :: struct {
	using Fx,
	speed  = 0.0,
	angleX = 0.0,
	angleY = 0.0,
}
export Explosion :: struct {
	using Fx,
	radius = 1.0,
}

-- @Incomplete: Generate this enum through metaprogramming.
-- export EntityType :: enum {
-- 	PLAYER  :: Player,
-- 	BULLET  :: Bullet,
-- 	CARRIER :: Carrier,
-- 	-- ...
-- }



local lastEntityId = 0

export newEntity :: (level:Level, $T:type, initX,initY:float) -> T {
	!assert T ~= Entity
	-- !assert T has Entity -- @Incomplete: Somehow make sure Entity is part of the type.

	lastEntityId += 1

	local ent:T = {
		entityType  = T,
		id          = lastEntityId,
		x           = initX,
		y           = initY,
		timeSpawned = level.time,
	}

	!if T == Player {
		ent.width     = 1.5
		ent.height    = 1.5
		ent.healthMax = 3

	} elseif T == Bullet {
		ent.width  = 1.4
		ent.height = 3

	-- Enemies.

	} elseif T == Carrier {
		ent.width     = 3
		ent.height    = 5
		ent.healthMax = 10

	} elseif T == Fly {
		local targetX:float

		for try = 1, 50 {
			local ok = true
			targetX  = getRandom(1.0*MIN_DISTANCE_TO_CAMERA_EDGE, 1.0*LEVEL_WIDTH-MIN_DISTANCE_TO_CAMERA_EDGE)

			for level.entities {
				local x = it.entityType == Fly ? (cast(Fly)it).targetX : it.x

				if abs(targetX-x) < 5 and isEnemy(it) {
					ok = false
					break
				}
			}

			if ok  break
		}

		ent.x         = targetX > LEVEL_WIDTH/2 ? 0 : LEVEL_WIDTH
		ent.width     = 2
		ent.height    = 3
		ent.healthMax = 3

		ent.targetX   = targetX
		ent.targetY   = getRandom(.1*CAMERA_HEIGHT, .4*CAMERA_HEIGHT)

	} elseif T == Heavy {
		ent.width     = 7
		ent.height    = 5.5
		ent.healthMax = 20

	} elseif T == Follower {
		ent.width     = 1.6
		ent.height    = 2
		ent.healthMax = 2

	-- Effects.

	} elseif T == Spark {
		local angle       = getRandom(TAU)
		ent.timeTotal     = lerp(.1, .3, getRandom()^2)
		ent.timeRemaining = ent.timeTotal
		ent.speed         = getRandom(25.0, 30.0)
		ent.angleX        = cos(angle)
		ent.angleY        = sin(angle)

	} elseif T == Explosion {
		ent.timeTotal     = 0.70
		ent.timeRemaining = ent.timeTotal
	}

	ent.health = ent.healthMax
	return ent
}

export spawnNextEntity :: (level:Level) {
	local instr             = level.currentWave.spawns[level.nextIndexToSpawn]
	level.nextIndexToSpawn += 1

	local ent:Entity = NULL

	if instr.entity == {
		case Carrier:  ent = newEntity(level, Carrier,  instr.x, instr.y)
		case Fly:      ent = newEntity(level, Fly,      instr.x, instr.y)
		case Heavy:    ent = newEntity(level, Heavy,    instr.x, instr.y)
		case Follower: ent = newEntity(level, Follower, instr.x, instr.y)
		case:          printf("Error: Unhandled entity type %s.", toString(instr.entity))
	}

	if ent == NULL  return

	if ent.entityType == Follower {
		local follower  = cast(Follower) ent
		local curvePath = cast(Coords) instr.data.curve

		curvePath = {unpack(curvePath)}

		for i = 1, #curvePath, 2 {
			curvePath[i  ] *= LEVEL_WIDTH
			curvePath[i+1] *= CAMERA_HEIGHT
		}

		-- Convert the bezier curve into a path we easily can follow.

		local getPathLength :: (path:Coords) -> float {
			local length:float
			for i = 1, #path-2, 2 {
				length += distance(path[i],path[i+1], path[i+2],path[i+3])
			}
			return length
		}

		local getPointOnPath :: (path:Coords, dist:float) -> (x,y:float) {
			local coordCount = #path

			for i = 1, coordCount-2, 2 {
				local len = distance(path[i],path[i+1], path[i+2],path[i+3])

				if dist < len {
					local progress = dist/len
					return
						lerp(path[i  ], path[i+2], progress),
						lerp(path[i+1], path[i+3], progress)
				}

				dist -= len
			}

			return path[coordCount-1], path[coordCount]
		}

		local curve  = loveNewBezierCurve(curvePath)
		local path   = loveRender(curve, 5)
		local length = getPathLength(path)

		local APPROXIMATE_SEGMENT_LENGTH :: 3
		local pathSegments      = max(round(length/APPROXIMATE_SEGMENT_LENGTH), 1)
		local pathSegmentLength = length/pathSegments
		local pathToFollow: Coords

		for i = 0, pathSegments {
			local x, y = getPointOnPath(path, i*pathSegmentLength)
			insert(pathToFollow, x)
			insert(pathToFollow, y)
		}

		follower.path         = pathToFollow
		follower.pathLength   = length
	}

	insert(level.entities, ent)
}



export updateEntity :: (level:Level, ent:Entity, dt:float) {
	-- @Incomplete: Use EntityType and 'if !complete' here.
	if ent.entityType == {
	case Player:
		local player = cast(Player) ent

		local dirX, dirY = 0, 0
		if loveIsScancodeDown("left")   dirX -= 1
		if loveIsScancodeDown("right")  dirX += 1
		if loveIsScancodeDown("up")     dirY -= 1
		if loveIsScancodeDown("down")   dirY += 1

		local MAX_SPEED_X    :: 50.0
		local MAX_SPEED_Y    :: 40.0
		local ACCELERATION_X :: 1000
		local ACCELERATION_Y :: 1000

		player.speedX
			= dirX == 0
			? moveTowards(player.speedX, 0, ACCELERATION_X*dt)
			: clamp(player.speedX+dirX*ACCELERATION_X*dt, -MAX_SPEED_X, MAX_SPEED_X)

		player.speedY
			= dirY == 0
			? moveTowards(player.speedY, 0, ACCELERATION_Y*dt)
			: clamp(player.speedY+dirY*ACCELERATION_Y*dt, -MAX_SPEED_Y, MAX_SPEED_Y)

		player.x += player.speedX*dt
		player.y += player.speedY*dt

		if player.x < MIN_DISTANCE_TO_CAMERA_EDGE {
			player.x      = MIN_DISTANCE_TO_CAMERA_EDGE
			player.speedX = 0
		} elseif player.x > LEVEL_WIDTH-MIN_DISTANCE_TO_CAMERA_EDGE {
			player.x      = LEVEL_WIDTH-MIN_DISTANCE_TO_CAMERA_EDGE
			player.speedX = 0
		}
		if player.y < MIN_DISTANCE_TO_CAMERA_EDGE {
			player.y      = MIN_DISTANCE_TO_CAMERA_EDGE
			player.speedY = 0
		} elseif player.y > CAMERA_HEIGHT-MIN_DISTANCE_TO_CAMERA_EDGE {
			player.y      = CAMERA_HEIGHT-MIN_DISTANCE_TO_CAMERA_EDGE
			player.speedY = 0
		}

		-- @Incomplete: Collide with other entities.

		player.weaponCooldown -= dt

		if (player.wantsToShoot or loveIsScancodeDown("x")) and player.weaponCooldown <= 0 {
			player.weaponCooldown  = 1/15
			player.shootCount     += 1

			if player.bulletMods.level == {
			case 1:
				spawnBullet(level, player.x, player.y, -TAU/4, player.bulletMods, true)

			case 2:
				if player.shootCount%2 == 0
					spawnBullet(level, player.x, player.y, -TAU/4, player.bulletMods, true)
				else
					for spread = -1, 1  spawnBullet(level, player.x, player.y, -TAU/4+spread*(.04*TAU), player.bulletMods, true)

			case 3:
				if player.shootCount%2 == 0
					for spread = -1, 1  spawnBullet(level, player.x, player.y, -TAU/4+spread*(.06*TAU), player.bulletMods, true)
				else
					for spread = -1, 1  spawnBullet(level, player.x, player.y, -TAU/4+spread*(.03*TAU), player.bulletMods, true)
			}

			if player.rearWeapon {
				if player.shootCount%2 == 0  spawnBullet(level, player.x, player.y, TAU/4, player.bulletMods, true)
			}

			playSound("shot1")
		}

		player.wantsToShoot = false

	case Bullet:
		local bullet    = cast(Bullet) ent
		local deltaDist = (bullet.shotByPlayer ? 120 : 50) * dt
		local angle     = bullet.angleBase

		if bullet.mods.movement == BulletMovement.WAVE {
			local phase  = (level.time-bullet.timeSpawned)/0.30 + level.time/0.95
			angle       += .06*sin(phase*TAU)*TAU
		}
		bullet.angle = angle

		bullet.x += deltaDist * cos(angle)
		bullet.y += deltaDist * sin(angle)

		for level.entities {
			local areEntitiesOverlapping :: (ent1,ent2:Entity) -> bool {
				return
					abs(ent1.x-ent2.x) < (ent1.width  + ent2.width ) / 2 and
					abs(ent1.y-ent2.y) < (ent1.height + ent2.height) / 2
			}

			if ((not bullet.shotByPlayer and it.entityType == Player) or (bullet.shotByPlayer and isEnemy(it))) and areEntitiesOverlapping(bullet, it) {
				damage(level, it, 1, bullet.x, bullet.y)
				destroy(bullet)
				return
			}
		}

		if bullet.x < -50 or bullet.x > LEVEL_WIDTH+50 {
			destroy(bullet)
		} elseif bullet.angleBase > 0 {
			if bullet.y > CAMERA_HEIGHT+20  destroy(bullet)
		} else {
			if bullet.y < -20  destroy(bullet)
		}

	-- Enemies.

	case Carrier:
		local carrier  = cast(Carrier) ent
		carrier.y     += 10*dt

		if carrier.y > CAMERA_HEIGHT+20  destroy(carrier)

	case Fly:
		local MOVE_SPEED :: 40.0

		local fly = cast(Fly) ent
		using fly.Phase

		if !complete fly.phase == {
		case ENTER:
			local angle = atan(fly.targetY-fly.y, fly.targetX-fly.x)

			fly.x = moveTowards(fly.x, fly.targetX, MOVE_SPEED*abs(cos(angle))*dt)
			fly.y = moveTowards(fly.y, fly.targetY, MOVE_SPEED*abs(sin(angle))*dt)

			if fly.x == fly.targetX and fly.y == fly.targetY {
				fly.phase          = SHOOT
				fly.weaponCooldown = .60
			}

		case SHOOT:
			fly.weaponCooldown -= dt

			if fly.shootCount < 5 {
				if fly.weaponCooldown <= 0 {
					fly.weaponCooldown  = 1/3
					fly.shootCount     += 1
					spawnBullet(level, fly.x, fly.y, TAU/4, nil)
					playSound("shot2")
				}
			} else {
				if fly.weaponCooldown < -.50  fly.phase = EXIT
			}

		case EXIT:
			fly.y += MOVE_SPEED*dt
			if fly.y > CAMERA_HEIGHT+20  destroy(fly)
		}

	case Heavy:
		local MOVE_SPEED :: 15.0

		local heavy = cast(Heavy) ent
		using heavy.Phase

		if !complete heavy.phase == {
		case ENTER:
			heavy.y += MOVE_SPEED*dt

			if heavy.y >= .2*CAMERA_HEIGHT {
				heavy.phase          = SHOOT
				heavy.weaponCooldown = .60
			}

		case SHOOT:
			heavy.weaponCooldown -= dt

			if heavy.shootCount < 4 {
				if heavy.weaponCooldown <= 0 {
					heavy.weaponCooldown  = 1/3
					heavy.shootCount     += 1
					spawnBullet(level, heavy.x-3, heavy.y+3, TAU/4+.1*TAU, nil)
					spawnBullet(level, heavy.x-2, heavy.y+3, TAU/4,        nil)
					spawnBullet(level, heavy.x+2, heavy.y+3, TAU/4,        nil)
					spawnBullet(level, heavy.x+3, heavy.y+3, TAU/4-.1*TAU, nil)
					playSound("shot2")
				}
			} else {
				if heavy.weaponCooldown < -0.50 {
					heavy.phase      = BEAM
					heavy.shootCount = 0
				}
			}

		case BEAM:
			heavy.weaponCooldown -= dt

			if heavy.shootCount < 20 {
				if heavy.weaponCooldown <= 0 {
					heavy.weaponCooldown  = .06
					heavy.shootCount     += 1
					spawnBullet(level, heavy.x, heavy.y+3, TAU/4, nil) -- @Incomplete: Make this an actual beam.
					playSound("shot2")
				}
			} else {
				if heavy.weaponCooldown < -1.00  heavy.phase = EXIT
			}

		case EXIT:
			heavy.y += MOVE_SPEED*dt
			if heavy.y > CAMERA_HEIGHT+20  destroy(heavy)
		}

	case Follower:
		local SPEED :: 40.0 -- m/s

		local follower = cast(Follower) ent
		local progress = (level.time-follower.timeSpawned) / (follower.pathLength/SPEED)

		if progress >= 1 {
			destroy(follower)
			return
		}

		local coordCount    = #follower.path
		local pointCount    = coordCount // 2
		local pointProgress = progress * (pointCount-1)
		local indexLo: int  = 1+2*floor(pointProgress)
		local indexHi: int  = indexLo+2
		local _, fraction   = splitFraction(pointProgress)

		follower.x = lerp(follower.path[indexLo  ], follower.path[indexHi  ], fraction)
		follower.y = lerp(follower.path[indexLo+1], follower.path[indexHi+1], fraction)

		local DISTANCE_BEFORE_SHOOTING :: 1.5

		if follower.shootCount == 0 and abs(follower.x-level.player.x) < DISTANCE_BEFORE_SHOOTING {
			follower.shootCount += 1
			spawnBullet(level, follower.x,follower.y, TAU/4, nil)
		}

	-- Effects.

	case Spark:
		local spark = cast(Spark) ent

		spark.x += spark.speed * spark.angleX * dt
		spark.y += spark.speed * spark.angleY * dt

		spark.timeRemaining -= dt
		if spark.timeRemaining <= 0  destroy(spark)

	case Explosion:
		local explosion          = cast(Explosion) ent
		explosion.timeRemaining -= dt
		if explosion.timeRemaining <= 0  destroy(explosion)
	}
}



export drawEntity :: (level:Level, ent:Entity) {
	local setColorWithEffects :: (damageEffect:float, r,g,b:float, a=1.0) {
		r = lerp(r, 1, damageEffect)
		g = lerp(g, 1, damageEffect)
		b = lerp(b, 1, damageEffect)
		loveSetColor(r, g, b, a)
	}

	local DAMAGE_EFFECT_TIME :: 0.10
	local damageEffect = clamp01(1-(level.time-ent.timeDamaged)/DAMAGE_EFFECT_TIME)

	if ent.entityType == {
	case Player:
		local SIZE_OUTER :: 2.2
		local SIZE_INNER :: .4*SIZE_OUTER
		local player = cast(Player) ent
		setColorWithEffects(damageEffect, 0, 0, 0)
		loveDrawRectangleFill(player.x-SIZE_OUTER/2, player.y-SIZE_OUTER/2, SIZE_OUTER, SIZE_OUTER)
		setColorWithEffects(damageEffect, 1, 1, 1)
		loveDrawRectangleFill(player.x-SIZE_INNER/2, player.y-SIZE_INNER/2, SIZE_INNER, SIZE_INNER)

	case Bullet:
		local bullet = cast(Bullet) ent
		if bullet.shotByPlayer
			setColorWithEffects(damageEffect, 1, 1, 1)
		else
			setColorWithEffects(damageEffect, 1, 0, 0)

		loveGraphicsPushTransform()
		loveCoordinateSystemTranslate(bullet.x, bullet.y)
		loveCoordinateSystemRotate(bullet.angle+TAU/4)
		loveDrawEllipseFill(0,0, .3,1.8, 24)
		loveGraphicsPop()

		drawLight(level, bullet.x,bullet.y, 4,6, .2)

	-- Enemies.

	case Carrier:
		local carrier = cast(Carrier) ent
		local phase   = sin01((level.time-ent.timeSpawned)*TAU)
		local r       = lerp(0.80, 1.00, phase)
		local g       = lerp(0.40, 0.70, phase)
		local b       = lerp(0.95, 0.60, phase)
		setColorWithEffects(damageEffect, r, g, b)
		loveDrawRectangleFill(carrier.x-carrier.width/2, carrier.y-carrier.height/2, carrier.width, carrier.height)

	case Fly:
		local fly = cast(Fly) ent
		setColorWithEffects(damageEffect, 1, .9, .4)
		loveDrawRectangleFill(fly.x-fly.width/2, fly.y-fly.height/2, fly.width, fly.height)

	case Heavy:
		local heavy = cast(Heavy) ent
		setColorWithEffects(damageEffect, .6, .2, 1)
		loveDrawRectangleFill(heavy.x-heavy.width/2, heavy.y-heavy.height/2, heavy.width, heavy.height)

	case Follower:
		local follower = cast(Follower) ent
		setColorWithEffects(damageEffect, 1, .4, .1)
		loveDrawRectangleFill(follower.x-follower.width/2, follower.y-follower.height/2, follower.width, follower.height)

		!if DEV  if loveIsKeyDown("tab") {
			loveSetColor(1, .5, 0)
			loveSetLineWidth(.2)
			loveDrawLine(follower.path)
			loveSetLineWidth(1)
		}

	-- Effects.

	case Spark:
		local spark    = cast(Spark) ent
		local progress = 1 - spark.timeRemaining/spark.timeTotal
		local radius   = lerp(.4, .2, progress)
		local a        = 1 - progress^2
		loveSetColor(1, 1, 1, a)
		loveDrawCircleFill(spark.x, spark.y, radius, 5)
		drawLight(level, spark.x,spark.y, 4*radius, .5*a)

	case Explosion:
		local explosion = cast(Explosion) ent
		local progress  = 1 - explosion.timeRemaining/explosion.timeTotal
		local radius    = explosion.radius * lerp(.1, 1, progress^.4)
		local a         = .6 * (1 - sin(progress^2 * TAU/4))
		loveSetColor(1, 1, 1, a)
		loveSetBlendMode(LoveBlendMode.ADD)
		loveDrawCircleFill(explosion.x, explosion.y, radius, 32)
		loveResetBlendMode()
		drawLight(level, explosion.x,explosion.y, 4*radius, .8*a)
	}

	-- Collision box.
	!if DEV  if loveIsKeyDown("tab") {
		loveSetColor(0, 1, 0, .4)
		loveDrawRectangleFill(ent.x-ent.width/2, ent.y-ent.height/2, ent.width, ent.height)
	}
}

local drawLight :: (level:Level, x,y:float, radius:float, opacity:float) {
	drawLight(level, x,y, radius,radius, opacity)
}
local drawLight :: (level:Level, x,y:float, radiusX,radiusY:float, opacity:float) {
	local light:Light = {x=x, y=y, radiusX=radiusX, radiusY=radiusY, opacity=opacity} -- @Speed: Reuse tables.
	insert(level.lightsToDraw, light)
}



export destroy :: (ent:Entity) {
	ent.isDestroyed = true
}



export damage :: (level:Level, ent:Entity, amount:int, damagePointX,damagePointY:float) {
	if ent.isDestroyed  return

	ent.timeDamaged  = level.time
	ent.health      -= amount

	local getRandomizedDamageEffectPosition :: (ent:Entity, damagePointX,damagePointY:float) -> (x,y:float) {
		return
			clamp(damagePointX, ent.x-.4*ent.width , ent.x+.4*ent.width ) + getRandom(-.1, .1),
			clamp(damagePointY, ent.y-.4*ent.height, ent.y+.4*ent.height) + getRandom(-.1, .1)
	}

	for 1, getRandom(5, 8) {
		local x, y  = getRandomizedDamageEffectPosition(ent, damagePointX,damagePointY)
		local spark = newEntity(level, Spark, x, y)
		insert(level.entities, spark)
	}

	level.cameraShake = max(level.cameraShake, .3)

	if ent.health > 0 {
		playSound("impact")
		return
	}

	-- We're dead!
	local explosionScale = max(ent.width, ent.height) / 5
	local effectScale    = min(explosionScale, 1) -- Limit all effects except the explosion visuals (because explosions look cool!)

	if ent.entityType == Player {
		explosionScale = 1
		effectScale    = 1
		playSound("death")
	} else {
		playSound("explosion", lerp(effectScale, 1, .5))
	}

	for 1, 3 {
		local x                  = ent.x + ent.width  * getRandom(-.4, .4)
		local y                  = ent.y + ent.height * getRandom(-.4, .4)
		local explosion          = newEntity(level, Explosion, x, y)
		explosion.timeTotal     *= getRandom(.6, 1/.6)
		explosion.timeRemaining  = explosion.timeTotal
		explosion.radius         = getRandom(3.0, 12.0) * explosionScale
		insert(level.entities, explosion)
	}

	level.cameraShake = max(level.cameraShake, effectScale)
	destroy(ent)
}



export spawnBullet :: (level:Level, x,y:float, angle:float, modsToCopy:BulletMods|none, shotByPlayer=false) {
	local bullet        = newEntity(level, Bullet, x, y)
	bullet.angleBase    = angle
	bullet.angle        = angle
	bullet.shotByPlayer = shotByPlayer

	if modsToCopy ~= nil {
		local structInfo = cast(TypeInfoStruct) getTypeInfo(BulletMods)
		local mods       = cast(table) bullet.mods

		for structInfo.members {
			local name = it.name
			mods[name] = (cast(table) cast(BulletMods) modsToCopy) [name] -- So much @Hack...
		}
	}

	insert(level.entities, bullet)
}


