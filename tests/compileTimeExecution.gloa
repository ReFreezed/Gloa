--
-- Compile-time execution test.
--

local getInt :: (less=0) -> int {
	!import "basic"

	local insideInt  = globalInt
	insideInt       += 5-less
	outsideString    = "foo"

	print("What?", insideInt, outsideString)
	return globalInt
}

local  fileLocalInt = !run getInt(1)
global globalInt:int
local  outsideString = ""

!assert type_of(fileLocalInt) == int

local arr:[]int = !run ({0, 5*getInt()}) -- The parenthesis is only a parsing aid here.

local getIntArrayType :: () -> type {
	return type_of(arr)
}
local IntArray :: !run getIntArrayType()

local main :: () {
	!import "basic"
	print("outsideString = '"..outsideString.."'") -- Should be empty. (Variables in metaprograms don't affect the final output.)
	print(getInt(-10))
}

local valueAny      = !run cast(any) 5 -- The type of valueAny ends up being int. Is this fine?
local valueBool     = !run true
local valueInt      = !run 5
local valueNone     = !run nil
local valueFloat    = !run 3.14
local valueString   = !run "foo"
local valueTable    = !run cast(table) {a=7, !import "math".getRandom()}
local valueType     = !run int
local valueArray    = !run cast([]int) {}
-- local valueFunction = !run (){} -- @Incomplete
-- local valueStruct   = !run ... -- @Incomplete
-- local valueEnum     = !run ... -- @Incomplete
