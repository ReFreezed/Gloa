--
-- Basic test.
--

local SEVEN1 :: 1+2*3
local seven1  = SEVEN1

local TWO    :: 2
local SEVEN2 :: 1+TWO*3
local seven2  = SEVEN2

local noopRef = noop

local callTest = () {
	noop()
	performAdditions(2)
}

local performAdditions :: (a:int) -> int {
	local x = -(-1) + a * (2+1)
	local y:int -- Default value for ints is 0.
	return x+y
}

local noop :: () {}

global ANY     :: any
global typeVar1 = string
global typeVar2 = ANY

local one, two = "1", 2

local main :: () -> void {
	local a = 1
	local b = a

	local oneInTwoOut1 :: (a:int) -> int, int { return a, 2*a }
	local one1, two1, three1 : int = 5, oneInTwoOut1(99)

	local MySig :: (arg1:string, arg2,arg3:int) -> bool, string
	local myFunc1:MySig : (arg1:string, arg2,arg3:int) -> bool, string { return true, "foo" }
	local mySig1 = MySig
	local mySig2 = MySig
	local mySig3 = ()->void

	local testFuncReturningFunc :: () {
		local getDoubler :: () -> (n:int)->int {
			return (nStr:int) -> int {
				return 2*nStr
			}
		}
		local double = getDoubler()(5)
	}
	testFuncReturningFunc()

	local recursive :: () -> int { return recursive() }

	local arithmetic1 = 1+2+3
	local arithmetic2 = 1 + 2*3
	local arithmetic3 = 1 + 2 * 3 // 4^5 % 6
	local arithmetic4 = 4-2-1
	local arithmetic5 = 1 - -1
	local arithmetic6 = 4 - 2^2 - 1
	local arithmetic7 = 2^3^2 + 1
	local arithmetic8 = 1.0 / 2.0 / 3.0
	local arithmetic9 = 3 // 2

	do {
		local blockVar1 = 0
		do {
			local blockVar2 = 1
		}
		local blockVar2 = 2
	}
	local blockVar2 = 3

	!load "tests/basic.load.gloa"
	local six = triple(2)

	local codepointÆ = !char "Æ"
	local codepoint龠 = !char "龠"
	local nonsense:int = codepoint龠-codepointÆ

	local printString :: (s:string) -> void !foreign lua "print"
	printString("Hello, Lua!")

	local printAny :: (v:any) -> void !foreign lua "print"
	printAny("Hello, Lua!")
	printAny(123)

	local printStringOrInt :: (v:string|int) -> void !foreign lua "print"
	printStringOrInt("Hello, Lua!")
	printStringOrInt(123)

	local printStrings :: (...:string) -> void !foreign lua "print"
	printStrings("Hello, ", "Lua!")
	printStrings()
	local print :: (...:any) -> void !foreign lua "print"
	print("Hello", 123, true, "Lua!")
	print()

	local getValues :: () -> string, int { return "GET", 100 }
	print(true, getValues())

	local getVararg :: () -> (...:int) { return 1, 2, 3 }
	local takeThreeMaybe :: (x,y,z:int|nil) {}
	takeThreeMaybe(10, getVararg(), 30)
	takeThreeMaybe(10, 20, (getVararg()))

	local getAtLeastOne :: () -> (x:int, ...:int) { return 1, 2, 3 }
	local takeExactlyThree :: (x:int, y:int, z:int) {}
	takeExactlyThree(10, 20, (getAtLeastOne()))
	takeExactlyThree(10, getAtLeastOne(), 30)

	local takeAndReturnVararg :: (...:int) -> (...:int) {
		local a1, a2 = ...
		local b1, b2 = 1, ...
		local c1, c2 = 1, (...)
		local d1, d2 = ..., 2
		local e1, e2 = (...), 2
		local typeOfVararg = type_of(...) -- Should be int|nil.
		return ...
	}
	local x, y = takeAndReturnVararg(1, 2, 3)
	local typeOfX :: type_of(x) -- Should be int|nil.
	local typeOfY :: type_of(y) -- Should be int|nil.
	local takeOneIntMaybe :: (x:int|nil) {}
	takeOneIntMaybe(x)
	takeOneIntMaybe(y)
	takeAndReturnVararg(x, y, x, y)

	local flag = false or true
	if flag
		print("The flag is set!")
	else
		print("The flag is unset...")

	local tostring :: (v:any) -> string !foreign lua "tostring"
	local n = 3
	while n > 0 {
		print("While "..tostring(n))
		n = n-1
	}

	local Foo :: struct {
		status = -1;
	}
	local Thinger :: struct {
		WHAT :: "maybe ",
		name = "unnamed",
		flag = true,
		count:int,
		foo:Foo,
	}
	local thing:Thinger
	thing.name = "("..thing.name..")"
	thing["na".."me"] = thing.WHAT..Thinger.WHAT.."Rita"

	!import "test"
	local invisible :: () {} -- Should not collide with the one in the test module.
	testFunction()

	local EntityType :: enum {
		PLAYER  :: 0x01,
		MONSTER :: 0x02;
		BUTTON  :: 0x03,
		DOOR    :: 0x04
	}
	local ENTITY_TYPE_PLAYER = EntityType.PLAYER

	local MELEE_NAME :: "Knight"
	local ClassName :: enum string {
		MELEE  :: MELEE_NAME,
		RANGED :: "Archer",
		MAGIC  :: "Mage",
	}
	local myClass:ClassName = ClassName.MAGIC
	local ClassName2 :: ClassName
	local ClassName3 = type_of(myClass)
	print(ClassName.RANGED)

	testEnumLookups()

	local floatToCast = 5.9
	local castedToInt = cast(int)   floatToCast
	local uselessCast = cast(float) floatToCast
}

local testEnumLookups :: () {
	local print :: (...:any) -> void !foreign lua "print"
	print("Doing testEnumLookups.")

	local TypeEnum :: enum {
		STRING :: type_of(""),
		INT    :: int,
	}

	local IntTypeAsEnum1 :: TypeEnum.INT

	local StructReferencingEnum :: struct {
		_IntTypeAsEnum2 :: TypeEnum.INT,
		_IntTypeAsEnum3 :: IntTypeAsEnum1,
	}

	local IntTypeAsEnum2 :: StructReferencingEnum._IntTypeAsEnum2
	local IntTypeAsEnum3 :: StructReferencingEnum._IntTypeAsEnum3

	local myIntFromEnum1:IntTypeAsEnum1 = 0
	local myIntFromEnum2:IntTypeAsEnum2 = 0*0
	local myIntFromEnum3:IntTypeAsEnum3

	local IntTypeFromCast1 :: cast(type) TypeEnum.INT
	local IntTypeFromCast2 : type : cast(type) TypeEnum.INT

	local myIntFromCast1:IntTypeFromCast1 = 0
	local myIntFromCast2:IntTypeFromCast2 = 0

	local step1 :: cast(type) TypeEnum.INT
	local step2 : type : step1

	local IntEnum        :       : enum int { ONE::1 }
	local floatFromEnum1         = cast(float) IntEnum.ONE
	local floatFromEnum2 : float = cast(int)   IntEnum.ONE -- Implicit cast from int to float.
}
