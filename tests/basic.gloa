--
-- Basic test.
--

local SEVEN1 :: 1+2*3
local seven1  = SEVEN1

local TWO    :: 2
local SEVEN2 :: 1+TWO*3
local seven2  = SEVEN2

local noopRef = noop

local callTest = () {
	noop()
	performAdditions(2)
}

local performAdditions :: (a:int) -> int {
	local x = -(-1) + a * (2+1)
	local y:int -- Default value for ints is 0.
	return x+y
}

local noop :: () {}

export ANY     :: any
export typeVar1 = string
export typeVar2 = ANY

local one, two = "1", 2

local shadow = 0

local main :: _main -- Just a reference test.

local _main :: () -> void {
	local a = 1
	local b = a

	local myTable:table = {123, [3]=7, func=main, ["x.y"]=true}

	local oneInTwoOut1 :: (a:int) -> int, int { return a, 2*a }
	local one1, two1, three1 : int = 5, oneInTwoOut1(99)

	local MySig :: (arg1:string, arg2,arg3:int) -> bool, string
	local myFunc1:MySig : (arg1:string, arg2,arg3:int) -> bool, string { return true, "foo" }
	local mySig1 = MySig
	local mySig2 = MySig
	local mySig3 = ()->void

	local testFuncReturningFunc :: () {
		local getDoubler :: () -> (doubler:(n:int)->int) {
			return (n:int) -> int {
				return 2*n
			}
		}
		local double = getDoubler()(5)
		!import "basic"
		print("double", double)
		assert(double == 10)
	}
	testFuncReturningFunc()

	local recursive :: () -> int { return recursive() }

	local arithmetic1 = 1+2+3
	local arithmetic2 = 1 + 2*3
	local arithmetic3 = 1 + 2 * 3 // 4^5 % 6
	local arithmetic4 = 4-2-1
	local arithmetic5 = 1 - -1
	local arithmetic6 = 4 - 2^2 - 1
	local arithmetic7 = 2^3^2 + 1
	local arithmetic8 = 1.0 / 2.0 / 3.0
	local arithmetic9 = 3 // 2

	do {
		local blockVar1 = 0
		do {
			local blockVar2 = 1
		}
		local blockVar2 = 2
	}
	local blockVar2 = 3

	!load "basic.load.gloa"
	local six = triple(2)

	local codepointÆ = !char "Æ"
	local codepoint龠 = !char "龠"
	local nonsense:int = codepoint龠-codepointÆ

	local printString :: (s:string) !foreign lua "print"
	printString("Hello, Lua!")

	local printAny :: (v:any) !foreign lua "print"
	printAny("Hello, Lua!")
	printAny(123)

	local printStringOrInt :: (v:string|int) !foreign lua "print"
	printStringOrInt("Hello, Lua!")
	printStringOrInt(123)

	local printStrings :: (...:string) !foreign lua "print"
	printStrings("Hello, ", "Lua!")
	printStrings()
	local print :: (...:any) !foreign lua "print"
	print("Hello", 123, true, "Lua!")
	print()

	local getValues :: () -> string, int { return "GET", 100 }
	print(true, getValues())

	local getVararg :: () -> (...:int) { return 1, 2, 3 }
	local takeThreeMaybe :: (x,y,z:int|none) {}
	takeThreeMaybe(10, getVararg(), 30)
	takeThreeMaybe(10, 20, (getVararg()))

	local getAtLeastOne :: () -> (x:int, ...:int) { return 1, 2, 3 }
	local takeExactlyThree :: (x:int, y:int, z:int) {}
	takeExactlyThree(10, 20, (getAtLeastOne()))
	takeExactlyThree(10, getAtLeastOne(), 30)

	local takeAndReturnVararg :: (...:int) -> (...:int) {
		local a1, a2 = ...
		local b1, b2 = 1, ...
		local c1, c2 = 1, (...)
		local d1, d2 = ..., 2
		local e1, e2 = (...), 2
		local typeOfVararg = type_of(...) -- Should be int.
		if ... == nil {}
		return ...
	}
	local x, y = takeAndReturnVararg(1, 2, 3)
	local typeOfX :: type_of(x) -- Value should be int|none.
	local typeOfY :: type_of(y) -- Value should be int|none.
	local takeOneIntMaybe :: (x:int|none) {}
	takeOneIntMaybe(x)
	takeOneIntMaybe(y)
	if x ~= nil and y ~= nil {
		local x1 = cast(       int|none) x
		local y1 = cast(string|int|none) y
		local x2 = cast(int) x
		local y2 = cast(int) y
		takeAndReturnVararg(x2, y2, x2, y2)
	}

	local flag = false or true
	if flag
		print("The flag is set!")
	else
		print("The flag is unset...")

	local tostring :: (v:any) -> string !foreign lua "tostring"
	local n = 3
	while n > 0 {
		print("While "..tostring(n))
		n = n-1
	}

	local Foo :: struct {
		status = -1;
	}
	local Thinger :: struct {
		WHAT :: "maybe ",
		name = "unnamed",
		flag = true,
		count:int,
		foo:Foo,
	}
	local thing:Thinger
	thing.name = "("..thing.name..")"
	thing["na".."me"] = thing.WHAT..Thinger.WHAT.."Rita"

	!import "test"
	local invisible :: () {} -- Should not collide with the one in the test module.
	testFunction()

	local EntityType :: enum {
		PLAYER  :: 0x01,
		MONSTER :: 0x02;
		BUTTON  :: 0x03,
		DOOR    :: 0x04
	}
	local entityTypePlayer = EntityType.PLAYER

	local MELEE_NAME :: "Knight"
	local ClassName :: enum string {
		MELEE  :: MELEE_NAME,
		RANGED :: "Archer",
		MAGIC  :: "Mage",
	}
	local myClass:ClassName = ClassName.MAGIC
	local ClassName2 :: ClassName
	local ClassName3 = type_of(myClass)
	print(ClassName.RANGED)

	testEnumLookups()

	local floatToCast = 5.9
	local castedToInt = cast(int)   floatToCast
	local uselessCast = cast(float) floatToCast

	testUsing()
	testStructs()

	local shadow = "a" !shadow
	do {
		shadow = shadow.."b"
		local shadow = 1.0 !shadow
		shadow = shadow * 2.0
		do {
			shadow = shadow + 18.0
			local shadow = true !shadow
			shadow = not shadow
		}
	}

	local TableIterator :: (t:table, k:any) -> (k:any, item:any)
	local pairs :: (t:table) -> (iter:TableIterator, t:table, init:any) !foreign lua "pairs"
	local LUA_VERSION:string : !foreign lua "_VERSION"
	local luaEnv:table       = !foreign lua "_G"
	for k, v in pairs(luaEnv) {
		print(LUA_VERSION, "_G."..tostring(k), v)
	}

	local FOREIGN_STRING : string : !foreign lua "_VERSION"
	local FOREIGN_ALIAS :: FOREIGN_STRING
	local localString = FOREIGN_ALIAS.." test"
	print("localString", localString)

	local overloaded :: (n:int) {}
	local overloaded :: (s:string) {}
	overloaded(5)
	overloaded("foo")

	local optional :: (x:int, y:int=0, z:int=0) {
		local sum = x+y+z
	}
	optional(1, 2, 3)
	optional(1, 2)
	optional(1)

	local take2 :: (req:int, opt:int=0) {}
	local get1 :: () -> int { return 9 }
	local get2 :: () -> int, int { return 8, 9 }
	take2(get1())
	-- take2(get2()) -- Error! :DisallowListAsLastValueToFunctionWithOptionalArguments

	local assert :: (b:bool)              !foreign lua "assert"
	local assert :: (b:bool, message:any) !foreign lua "assert"

	assert(1   /  2   == .5)
	assert(1.0 /  2.0 == .5)
	assert(1   // 2   == 0)
	assert(1.0 // 2.0 == 0)
	local i1, f1, i2, f2 = 1, 1.0, 2, 2.0
	do { local v = i1 /  i2 ; assert(v == .5, v) }
	do { local v = f1 /  f2 ; assert(v == .5, v) }
	do { local v = i1 // i2 ; assert(v == 0,  v) }
	do { local v = f1 // f2 ; assert(v == 0,  v) }

	assert(cast(int) +.5 == 0)
	assert(cast(int) -.5 == 0)
	local half = .5
	do { local v = cast(int) +half ; assert(v == 0, v) }
	do { local v = cast(int) -half ; assert(v == 0, v) }

	do {
		local overload :: (n:int, v:any)    { print(n, "any") }
		local overload :: (n:int, f:float)  { print(n, "float") }
		local overload :: (n:int, i:int)    { print(n, "int") }
		local overload :: (n:int, s:string) { print(n, "string") }
		overload(11, 5)    -- int
		overload(12, "")   -- string
		overload(13, true) -- any
	}
	do {
		local overload :: (n:int, v:[]any)   { print(n, "any") }
		local overload :: (n:int, f:[]float) { print(n, "float") }
		local arrInt: []int    = {1, 2, 3}
		local arrStr: []string = {"a", "b"}
		local arrAny: []any    = {5, "", true}
		overload(21, arrInt) -- float
		overload(22, arrStr) -- any
		overload(23, arrAny) -- any
	}
	do {
		local overload :: (n:int, i:int, f:float) { print(n, "int,float") }
		local overload :: (n:int, f:float, i:int) { print(n, "float,int") }
		local overload :: (n:int, i1:int, i2:int) { print(n, "int,int") }
		overload(31, 1,   2) -- int,int
		overload(32, 1.0, 2) -- float,int
		overload(33, 1, 2.0) -- int,float
	}

	testBoolCasts()
	testStaticStuff()

	do {
		local n1 = 7
		local n2 = 9
		local func :: () -> int, int { return 1, 3 }
		n1, n2 += func()

		local n3 = 7
		local Inner :: struct { x:int }
		local Outer :: struct { i:Inner }
		local obj:Outer
		n3, obj.i.x //= 1+2, obj.i.x+1

		local n4 = 7
		n4 //= .5 + 1.5
		assert(n4 == 3)

		local s1,s2,s3,s4 = "a","b","c","d"
		s1 ..= s2..s3..s4
	}

	testPolymorphism()

	local argsWithInferredType :: (n1:int, f=0.0) {}
	argsWithInferredType(5, .1)

	local takeIntArray :: (arr:[]int) {}
	takeIntArray({1,2,3})

	local deepArray:[][]int = {{5}}

	local Deepest :: struct { m=0 }
	local Deeper  :: struct { deepest: Deepest }
	local Deep    :: struct { deeper:  Deeper }
	local deepStruct:Deep = {deeper={deepest={m=1}}}

	local indexVariable   = 7
	local deepTable:table = {[indexVariable]={"foo",{a=false}}}

	local millions = 37_000_000
	!assert 3700______0000 == 37000000

	do {
		!import "string"
		_              = replace("abba", "b", "h")
		local _, count = replace("abba", "b", "h")
		local _, _     = replace("abba", "b", "h")
		_              = replace("abba", "b", "h")
	}

	testDefer()

	local printFloats :: (...:float) {
		!import "basic"
		local arr:[]float = {5, ...}
		print(unpack(arr))
	}
	printFloats(6.12, 9, 200.1)

	do {
		local Object    :: !foreign struct {}
		local getObject :: () -> Object !foreign lua "function() return {foo=function()end} end"
		local obj       := getObject()

		local callFoo   :: (obj:Object) !foreign method "foo"
		callFoo(obj)

		local methodRef :: callFoo
		methodRef(obj)
	}

	print("End of main!")
}

local testEnumLookups :: () {
	local print :: (...:any) !foreign lua "print"
	print("Doing testEnumLookups.")

	local TypeEnum :: enum {
		STRING :: type_of(""),
		INT    :: int,
	}

	local IntTypeAsEnum1 :: TypeEnum.INT

	local StructReferencingEnum :: struct {
		_IntTypeAsEnum2 :: TypeEnum.INT,
		_IntTypeAsEnum3 :: IntTypeAsEnum1,
	}

	local IntTypeAsEnum2 :: StructReferencingEnum._IntTypeAsEnum2
	local IntTypeAsEnum3 :: StructReferencingEnum._IntTypeAsEnum3

	local myIntFromEnum1:IntTypeAsEnum1 = 0
	local myIntFromEnum2:IntTypeAsEnum2 = 0*0
	local myIntFromEnum3:IntTypeAsEnum3

	local IntTypeFromCast1 :: cast(type) TypeEnum.INT
	local IntTypeFromCast2 : type : cast(type) TypeEnum.INT

	local myIntFromCast1:IntTypeFromCast1 = 0
	local myIntFromCast2:IntTypeFromCast2 = 0

	local step1 :: cast(type) TypeEnum.INT
	local step2 : type : step1

	local IntEnum        :       : enum int { ONE::1 }
	local floatFromEnum1         = cast(float) IntEnum.ONE
	local floatFromEnum2 : float = cast(int)   IntEnum.ONE -- Implicit cast from int to float.

	local StructUsingEnum :: struct {
		someType = TypeEnum.INT,
	}
	local setType :: (instance:StructUsingEnum, theType:TypeEnum) {
		instance.someType = theType
	}
	local instanceUsingEnum:StructUsingEnum
	local strType = TypeEnum.STRING
	setType(instanceUsingEnum, strType)

	testArraysAndLoops()
}

local testUsing :: () {
	local print :: (...:any) !foreign lua "print"
	print("Doing testUsing.")

	do {
		local House :: struct {
			HAS_ROOF :: true,
			floors    = 1,
			rooms     = 1,
		}
		local smallHouse:House
		using smallHouse
		local canSeeSky :: not HAS_ROOF
		local moreFloors = floors+1
		rooms = 2
	}

	do {
		local Fish :: struct {
			CAN_SWIM :: true,
			length    = 1,
		}
		using Fish
		local canWalk = not CAN_SWIM
	}

	do {
		local Choice :: enum { A::"a", B::"b", C::"c" }
		using Choice
		local choiceA = A
	}

	do {
		using local Choice :: enum { A::"a", B::"b", C::"c" }
		local choiceA = A

		local SomeStruct :: struct { theChoice=Choice.A }
		local typeVar = SomeStruct

		local getChoice :: () -> type_of(SomeStruct.theChoice) {
			using Choice
			return C
		}
		local myChoice = getChoice()

		local usingArg :: (using some:SomeStruct) {
			theChoice = B
		}
		local mySome:SomeStruct
		usingArg(mySome)
	}

	do {
		local Vector1 :: struct { x:float }
		local Vector2 :: struct { using Vector1, y:float }
		local Vector3 :: struct { using Vector2, z:float }

		local vec1:Vector1
		local vec3:Vector3 = {x=-3, z=5.7}

		local takeVec1 :: (vec1:Vector1) {}
		local takeVec2 :: (vec2:Vector2) {}
		local takeVec3 :: (vec3:Vector3) {}
		takeVec3(vec3)
		takeVec2(vec3)
		takeVec1(vec3)
	}

	do {
		stuff.print("Hello???")
		do {
			using stuff.arithmetic
			local result = multiply(add(1, 5), 8)
		}
	}
	do {
		local basic :: !import "basic"
		using basic
		local s = toString(8)
	}
}

local stuff :: namespace {
	export print :: (...:any) !foreign lua "print"

	local _arithmetic :: namespace {
		export add      :: (x,y:int) -> int { return x+y }
		export multiply :: (x,y:int) -> int { return x*y }
	}
	export arithmetic :: _arithmetic
}

local testArraysAndLoops :: () {
	print("Doing testArraysAndLoops.")

	local print  :: (...:any) !foreign lua "print"
	local insert :: (arr:[]int, item:int) !foreign lua "table.insert"

	do {
		local ints : []int
		insert(ints, 5)
		local x      = ints[1]
		local length = #ints
		ints[1]      = 10
	}

	for i = 1, 3  print(i)

	local times = 5
	for 1, times, 2 {
		it = it*2
		print(it)
	}

	do {
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for        ints  print(itIndex, it*it)
		for n    : ints  print(itIndex, n*n)
		for n, i : ints  print(i,       n*n)
	}

	do {
		local inext :: (ints:[]int, i:int) -> int|none, int {
			-- Array lookups can be compared to nil.
			if ints[i+1] == nil  return nil, 0
			return i+1, ints[i+1]
		}
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for i, n in inext, ints, 0  print("inext", i, n*n)
	}
	do {
		local next :: (t:table, k:any) -> any, any !foreign lua "next"
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for k, v in next, ints, nil  print("next", k, cast(int)(v)^2) -- Note: Arrays are compatible with tables.
	}

	do {
		local IntArrayIterator :: (arr:[]int, i:int) -> (i:int|none, item:int)
		local ipairs :: (arr:[]int) -> (iter:IntArrayIterator, arr:[]int, init:int) !foreign lua "ipairs"
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for i, n in ipairs(ints)  print("ipairs", i, n*n)
	}

	do {
		local ints : []int = {10,20,30}
		for ints {
			print(it)
			if itIndex == 2  break
		}
		local printLength :: (arr:[]any) {
			print("Length:", #arr)
		}
		printLength({"a","b"})
	}

	for x = 1, 5 {
		for y = 1, 5 {
			if x == 5 and y > 2 {
				while true  break x
			}
			if x  == 6  break x
			if x+y > 5  break
			print(x, y)
		}
	}
}

local testStructs :: () {
	do {
		local Vector2 :: struct { x:float=.5; y:float }
		local myVec3a:Vector2
		local y = 1
		local myVec3b:Vector2 = {y=y}
	}
	do {
		local Indirect :: struct {
			Direct :: !foreign struct {},
			ok1: Direct|none = nil,
			ok2: Direct = !foreign lua "nil",
			ok3: Direct = NULL,
		}
		local indirect:Indirect
	}
	do {
		local TypeStrings :: struct { name:string, !key:type, !value:string }

		local intType = int
		local intName = "Integer"
		local typeNames: TypeStrings = { [intType]=intName }
		typeNames[TypeStrings] = "Struct: TypeStrings"
		typeNames.name = "Names of types"

		!import "basic"
		print("typeNames[int]         =", int,         typeNames[int])
		print("typeNames[TypeStrings] =", TypeStrings, typeNames[TypeStrings])
		print("typeNames.name         =", "",          typeNames.name)
	}
	do {
		local ParentWithMember :: struct { CONST::5 }
		local StructuredTable  :: struct { using ParentWithMember, !key:string, !value:int } -- Note: Static members are not inherited, making the key type valid.
	}
	do {
		-- Array contructors.
		local getInts1  :: () -> int, int    { return 11, 111 }
		local getInts2  :: () -> (...:int)   { return 22, 222 }
		local intAndStr :: () -> int, string { return 33, "3" }

		local arr1: []int = {1, getInts1()}
		local arr2: []int = {2, getInts2()}
		local arr3: []int = {3, (intAndStr())} -- Note the parenthesis.

		local tryVararg :: (...:int) {
			local arr: []int = {1, ...}
		}
		tryVararg()
	}
	do {
		!import "basic"

		local ArrayWithN :: struct (T:type) { !value:T, n=0 }
		local strings: ArrayWithN(string)

		strings[1] = "foo"     ; strings.n += 1
		insert(strings, "bar") ; strings.n += 1
		print("ArrayWithN", strings.n, unpack(strings))

		if strings  print("strings is not empty.")

		local stringArray = cast([]string) strings
	}
}

local testBoolCasts :: () {
	!import "basic" -- The module has the same name as this file - don't worry about it!
	print("Doing testBoolCasts.")

	do {
		local typeName, v1, v2 = "int", 1, 0
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v1), toString(v1))
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v2), toString(v2))
	}
	do {
		local typeName, v1, v2 = "float", 1.0, 0.0
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v1), toString(v1))
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v2), toString(v2))
	}
	do {
		local typeName, v1, v2 = "string", "foo", ""
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v1), toString(v1))
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v2), toString(v2))
	}
	do {
		local typeName, v1, v2 = "array", cast([]int){0}, cast([]int){}
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v1), toString(v1))
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v2), toString(v2))
	}

	for n1 = 0, 1  for n2 = 0, 1
		printf("%d and %d = %s", n1, n2, toString(n1 and n2))
	for n1 = 0, 1  for n2 = 0, 1
		printf("%d or  %d = %s", n1, n2, toString(n1 or  n2))

	do {
		local str:string
		if not str  print("The string is empty.")
	}

	do {
		local arr : []int : {}
		if 0   error("Empty int detected incorrectly.")
		if 0.0 error("Empty float detected incorrectly.")
		if ""  error("Empty string detected incorrectly.")
		if arr error("Empty array detected incorrectly.")
	}

	do {
		local isFemale  = true
		local strValue1 = "foo"
		local strValue2 = ""
		local name      = if isFemale "Peach" else "Berry"
		strValue1       = if strValue1 else "default"
		strValue2       = if strValue2 else "default"
		local nonsense  = if isFemale  else false
		local isMale    = if isFemale false else true
		print("name      "..name)
		print("strValue1 "..strValue1)
		print("strValue2 "..strValue2)
		print("nonsense  "..toString(nonsense))
		print("isMale    "..toString(isMale))
	}
	do {
		local name      = if true "Peach" else "Berry"
		local strValue1 = if "foo" else "default"
		local strValue2 = if ""    else "default"
		local nonsense  = if true  else false
		local isMale    = if true false else true
		print("name      "..name)
		print("strValue1 "..strValue1)
		print("strValue2 "..strValue2)
		print("nonsense  "..toString(nonsense))
		print("isMale    "..toString(isMale))
	}

	local takingVararg :: (...:int) -> int|none {
		local flag = false
		local x    = if flag ... else ...
		return x
	}
	print(takingVararg(1, 2))
}

local STRING_CONST :: "TEST"
!assert STRING_CONST

local NON_EMPTY_STRING :: "Tall mountain."
!if NON_EMPTY_STRING {
	local valueInFileScope = 5
} else {
	local valueInFileScope = "foo"
}

local SWITCH :: 2

!if SWITCH == 1
	local switchString :: "one"
elseif SWITCH == 2
	local switchString :: "two"
else
	local switchString :: "more"

!if SWITCH == 1 {
	local switchString2 :: "one"
} elseif SWITCH == 2 {
	local switchString2 :: "two"
} else {
	local switchString2 :: "more"
}

local testStaticStuff :: () {
	!import "basic"

	local STRING_CONST_2 :: "TEST"
	!assert STRING_CONST_2

	using local StructWithAssert :: struct {
		VALUE2 :: 3*VALUE1,
		VALUE1 :: 5,
		!assert VALUE2 > 10,
	}
	print("VALUE2", VALUE2)

	local FLAG :: false

	!if FLAG
		local value = 5
	elseif false
		local value = nope
	else
		local value = "foo"

	!if FLAG {
		local value2 = 5
	} elseif false {
		local value2 = nope
	} else {
		local value2 = "foo"
	}

	print(
		valueInFileScope, -- 5
		value,            -- foo
		value2,           -- foo
		switchString,     -- two
		switchString2     -- two
	)
}

local testPolymorphism :: (...:int) {
	do {
		!import "basic"
		print("Doing testPolymorphism.")
	}

	do {
		local insert :: (arr:[]$T, value:T) !foreign lua "table.insert"
		local ints: []int
		insert(ints, 5)
	}
	do {
		local poly :: (...:$T) {}
		local get  :: () -> (i:int, s:string, ...:int) { return 99, "" }
		poly(3.0)
		poly(...)
		poly(1, get(), ...)
		poly("")
		poly(true, false)
	}
	do {
		local poly :: (...:$T) {}
		local get  :: () -> (...:int) { return }
		poly(5, get())
		poly(get())
	}
	do {
		local poly :: (i:int|none, ...:$T) {}
		poly(..., "")
	}
	do {
		local poly :: (x:$T) {
			!assert T ~= int
			-- !print T
		}
		poly("")
		poly(1.0)
	}
	do {
		local polyType :: (x:$T) {
			!import "basic"
			!if T == int {
				!assert T == int
				print("Got int!", x)
			} else {
				!assert T ~= int
				print("Got something else!", x)
			}
		}
		polyType(5)
		polyType(cast(table){})
	}
	do {
		local outside :: (s:$T1) {
			local inside :: (s:$T2) {
				!assert T1 == string
				!assert T2 == T1
				!import "basic"
				print(s)
			}
			inside(s)
		}
		outside("Hello?")
	}
	do {
		!import "basic"

		local ObjectAndNumber :: struct (T:type, n=0) {
			object:T,
			number = n,
		}

		local strAndNum: ObjectAndNumber(string, 5)
		strAndNum.object  = "Bacon"
		strAndNum.number += 1

		assert(strAndNum.number == 6)
		assert(strAndNum.T == string)
		assert(strAndNum.n == 5)

		assert(ObjectAndNumber(string, 5) == type_of(strAndNum))
		assert(ObjectAndNumber(string, 5) == ObjectAndNumber(string, 5))
		assert(ObjectAndNumber(string, 0) == ObjectAndNumber(string))
		assert(ObjectAndNumber(string, 0) ~= ObjectAndNumber(string, 5))
	}
	do {
		local multipleNamesForOneType :: (a,b:$T) {}
		multipleNamesForOneType(1, 2)
	}
	do {
		local newArrayWithGarbage :: ($ItemType:type) -> []ItemType {
			local arr: []ItemType

			!if ItemType == int {
				!import "basic"
				insert(arr, 59)
			} elseif ItemType == string {
				!import "basic"
				arr[1] = "xyz"
			}

			return arr
		}

		local Vector2 :: struct { x:float, y:float }

		local arrInt = newArrayWithGarbage(int)
		local arrStr = newArrayWithGarbage(string)
		local arrVec = newArrayWithGarbage(Vector2)
	}
	do {
		local overloadedPoly :: () {}
		local overloadedPoly :: (x:$T) {}
		overloadedPoly()
		overloadedPoly(5)
	}
}

local testDefer :: () -> int {
	!import "basic"
	print("Doing testDefer.")

	if false  return 1
	defer print("A")

	do {
		defer {
			local B :: "B"
			print(B)
		}

		if false  return 2

		defer {
			local c = "C"
			print(c)
		}

		local c = 593

		for 1, 3 {
			defer print("for1 "..toString(it).." always")
			if it == 2  break
			defer print("for1 "..toString(it).." once")
		}

		for outer = 1, 3 {
			defer print("for2 outer"..toString(outer).." always")
			for middle = 1, 3 {
				if c {
					defer print("for2 middle"..toString(middle).." always")
					for inner = 1, 3 {
						defer print("for2 inner"..toString(inner).." always")
						if inner == 2  break outer
						defer print("for2 inner"..toString(inner).." once")
					}
					defer print("for2 middle"..toString(middle).." BAD")
				}
			}
			defer print("for2 outer"..toString(outer).." BAD")
		}
	}

	print("end")
	return 3
}
