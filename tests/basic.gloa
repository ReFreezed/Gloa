--
-- Basic test.
--

local SEVEN1 :: 1+2*3
local seven1  = SEVEN1

local TWO    :: 2
local SEVEN2 :: 1+TWO*3
local seven2  = SEVEN2

local noopRef = noop

local callTest = () {
	noop()
	performAdditions(2)
}

local performAdditions :: (a:int) -> int {
	local x = -(-1) + a * (2+1)
	local y:int -- Default value for ints is 0.
	return x+y
}

local noop :: () {}

export ANY     :: any
export typeVar1 = string
export typeVar2 = ANY

local one, two = "1", 2

local shadow = 0

local main :: _main -- Just a reference test.

local _main :: () -> void {
	-- [=[
	do {
		local a = 1
		local b = a
	}

	local myTable:table = {123, [3]=7, func=main, ["x.y"]=true}

	local oneInTwoOut1 :: (a:int) -> int, int { return a, 2*a }
	local one1, two1, three1 : int = 5, oneInTwoOut1(99)

	local MySig :: (arg1:string, arg2,arg3:int) -> bool, string
	local myFunc1:MySig : (arg1:string, arg2,arg3:int) -> bool, string { return true, "foo" }
	local mySig1 = MySig
	local mySig2 = MySig
	local mySig3 = ()->void

	local testFuncReturningFunc :: () {
		local getDoubler :: () -> (doubler:(n:int)->int) {
			return (n:int) -> int {
				return 2*n
			}
		}
		local double = getDoubler()(5)
		!import "basic"
		print("double", double)
		assert(double == 10)
	}
	testFuncReturningFunc()

	local recursive :: () -> int { return recursive() }

	local arithmetic1 = 1+2+3
	local arithmetic2 = 1 + 2*3
	local arithmetic3 = 1 + 2 * 3 // 4^5 % 6
	local arithmetic4 = 4-2-1
	local arithmetic5 = 1 - -1
	local arithmetic6 = 4 - 2^2 - 1
	local arithmetic7 = 2^3^2 + 1
	local arithmetic8 = 1.0 / 2.0 / 3.0
	local arithmetic9 = 3 // 2

	do {
		local blockVar1 = 0
		do {
			local blockVar2 = 1
		}
		local blockVar2 = 2
	}
	local blockVar2 = 3

	!load "basic.load"
	local six = triple(2)

	local codepointÆ = !char "Æ"
	local codepoint龠 = !char "龠"
	local nonsense:int = codepoint龠-codepointÆ

	do {
		local printString :: (s:string) !foreign lua "print"
		printString("Hello, Lua!")

		local printAny :: (v:any) !foreign lua "print"
		printAny("Hello, Lua!")
		printAny(123)

		local printStringOrInt :: (v:string|int) !foreign lua "print"
		printStringOrInt("Hello, Lua!")
		printStringOrInt(123)

		local printStrings :: (...:string) !foreign lua "print"
		printStrings("Hello, ", "Lua!")
		printStrings()
	}
	local print :: (...:any) !foreign lua "print"
	print("Hello", 123, true, "Lua!")
	print()

	local getValues :: () -> string, int { return "GET", 100 }
	print(true, getValues())

	local getVararg :: () -> (...:int) { return 1, 2, 3 }
	local takeThreeMaybe :: (x,y,z:int|none) {}
	takeThreeMaybe(10, getVararg(), 30)
	takeThreeMaybe(10, 20, (getVararg()))

	local getAtLeastOne :: () -> (x:int, ...:int) { return 1, 2, 3 }
	local takeExactlyThree :: (x:int, y:int, z:int) {}
	takeExactlyThree(10, 20, (getAtLeastOne()))
	takeExactlyThree(10, getAtLeastOne(), 30)

	local takeAndReturnVararg :: (...:int) -> (...:int) {
		local a1, a2 = ...
		local b1, b2 = 1, ...
		local c1, c2 = 1, (...)
		local d1, d2 = ..., 2
		local e1, e2 = (...), 2
		local typeOfVararg = type_of(...) -- Should be int.
		if ... == nil {}
		return ...
	}
	local x, y = takeAndReturnVararg(1, 2, 3)
	local typeOfX :: type_of(x) -- Value should be int|none.
	local typeOfY :: type_of(y) -- Value should be int|none.
	local takeOneIntMaybe :: (x:int|none) {}
	takeOneIntMaybe(x)
	takeOneIntMaybe(y)
	if x ~= nil and y ~= nil {
		local x1 = cast(       int|none) x
		local y1 = cast(string|int|none) y
		local x2 = cast(int) x
		local y2 = cast(int) y
		takeAndReturnVararg(x2, y2, x2, y2)
	}

	local flag = false or true
	if flag
		print("The flag is set!")
	else
		print("The flag is unset...")

	local toString :: (v:any) -> string !foreign lua "tostring"
	do {
		local n = 3
		while n > 0 {
			print("While "..toString(n))
			n = n-1
		}
	}

	local Foo :: struct {
		status = -1;
	}
	local Thinger :: struct {
		WHAT :: "maybe ",
		name = "unnamed",
		flag = true,
		count:int,
		foo:Foo,
	}
	local thing:Thinger
	thing.name = "("..thing.name..")"
	thing["na".."me"] = thing.WHAT..Thinger.WHAT.."Rita"

	!import "test"
	local invisible :: () {} -- Should not collide with the one in the test module.
	testFunction()

	local EntityType :: enum {
		PLAYER  :: 0x01,
		MONSTER :: 0x02;
		BUTTON  :: 0x03,
		DOOR    :: 0x04
	}
	local entityTypePlayer = EntityType.PLAYER

	local MELEE_NAME :: "Knight"
	local ClassName :: enum string {
		MELEE  :: MELEE_NAME,
		RANGED :: "Archer",
		MAGIC  :: "Mage",
	}
	local myClass:ClassName = ClassName.MAGIC
	local ClassName2 :: ClassName
	local ClassName3 = type_of(myClass)
	print(ClassName.RANGED)

	testEnumLookups()

	local floatToCast = 5.9
	local castedToInt = cast(int)   floatToCast
	local uselessCast = cast(float) floatToCast

	testUsing()
	testStructs()

	local shadow = "a" !shadow
	do {
		shadow = shadow.."b"
		local shadow = 1.0 !shadow
		shadow = shadow * 2.0
		do {
			shadow = shadow + 18.0
			local shadow = true !shadow
			shadow = not shadow
		}
	}

	local TableIterator :: (t:table, k:any) -> (k:any, item:any)
	local pairs :: (t:table) -> (iter:TableIterator, t:table, init:any) !foreign lua "pairs"
	local LUA_VERSION:string : !foreign lua "_VERSION"
	local luaEnv:table       = !foreign lua "_G"
	for k, v in pairs(luaEnv) {
		print(LUA_VERSION, "_G."..toString(k), v)
	}

	local FOREIGN_STRING : string : !foreign lua "_VERSION"
	local FOREIGN_ALIAS :: FOREIGN_STRING
	local localString = FOREIGN_ALIAS.." test"
	print("localString", localString)

	local overloaded :: (n:int) {}
	local overloaded :: (s:string) {}
	overloaded(5)
	overloaded("foo")

	local optional :: (x:int, y:int=0, z:int=0) {
		local sum = x+y+z
	}
	optional(1, 2, 3)
	optional(1, 2)
	optional(1)

	local take2 :: (req:int, opt:int=0) {}
	local get1 :: () -> int { return 9 }
	local get2 :: () -> int, int { return 8, 9 }
	take2(get1())
	-- take2(get2()) -- Error! :DisallowListAsLastValueToFunctionWithOptionalArguments

	local assert :: (b:bool)              !foreign lua "assert"
	local assert :: (b:bool, message:any) !foreign lua "assert"

	assert(1   /  2   == .5)
	assert(1.0 /  2.0 == .5)
	assert(1   // 2   == 0)
	assert(1.0 // 2.0 == 0)
	local i1, f1, i2, f2 = 1, 1.0, 2, 2.0
	do { local v = i1 /  i2 ; assert(v == .5, v) }
	do { local v = f1 /  f2 ; assert(v == .5, v) }
	do { local v = i1 // i2 ; assert(v == 0,  v) }
	do { local v = f1 // f2 ; assert(v == 0,  v) }

	assert(cast(int) +.5 == 0)
	assert(cast(int) -.5 == 0)
	local half = .5
	do { local v = cast(int) +half ; assert(v == 0, v) }
	do { local v = cast(int) -half ; assert(v == 0, v) }

	do {
		local overload :: (n:int, v:any)    { print(n, "any") }
		local overload :: (n:int, f:float)  { print(n, "float") }
		local overload :: (n:int, i:int)    { print(n, "int") }
		local overload :: (n:int, s:string) { print(n, "string") }
		overload(11, 5)    -- int
		overload(12, "")   -- string
		overload(13, true) -- any
	}
	do {
		local overload :: (n:int, v:[]any)   { print(n, "any") }
		local overload :: (n:int, f:[]float) { print(n, "float") }
		local arrInt: []int    = {1, 2, 3}
		local arrStr: []string = {"a", "b"}
		local arrAny: []any    = {5, "", true}
		overload(21, arrInt) -- float
		overload(22, arrStr) -- any
		overload(23, arrAny) -- any
	}
	do {
		local overload :: (n:int, i:int, f:float) { print(n, "int,float") }
		local overload :: (n:int, f:float, i:int) { print(n, "float,int") }
		local overload :: (n:int, i1:int, i2:int) { print(n, "int,int") }
		overload(31, 1,   2) -- int,int
		overload(32, 1.0, 2) -- float,int
		overload(33, 1, 2.0) -- int,float
	}
	do {
		!import "basic"
		local printValue  :: (n:int)    { printf("Number: %d", n) }
		local printValue  :: (s:string) { printf("String: %s", s) }
		local printString :: variant_of(printValue(""))
		local printInt    := variant_of(printValue(0))
		printString("foo")
		printInt(5)
	}
	do {
		!import "basic"
		local printValue  :: (v:$T) { printf("Type %d, value: %s", T, v) }
		local printString :: variant_of(printValue(""))
		local printInt    := variant_of(printValue(0))
		printString("foo")
		printInt(5)
	}

	testBoolCasts()
	testStaticStuff()

	do {
		local n1 = 7
		local n2 = 9
		local func :: () -> int, int { return 1, 3 }
		n1, n2 += func()

		local n3 = 7
		local Inner :: struct { x:int }
		local Outer :: struct { i:Inner }
		local obj:Outer
		n3, obj.i.x //= 1+2, obj.i.x+1

		local n4 = 7
		n4 //= .5 + 1.5
		assert(n4 == 3)

		local s1,s2,s3,s4 = "a","b","c","d"
		s1 ..= s2..s3..s4
	}

	testPolymorphism()

	local argsWithInferredType :: (n1:int, f=0.0) {}
	argsWithInferredType(5, .1)

	local takeIntArray :: (arr:[]int) {}
	takeIntArray({1,2,3})

	local deepArray:[][]int = {{5}}

	local Deepest :: struct { m=0 }
	local Deeper  :: struct { deepest: Deepest }
	local Deep    :: struct { deeper:  Deeper }
	local deepStruct:Deep = {deeper={deepest={m=1}}}

	local indexVariable   = 7
	local deepTable:table = {[indexVariable]={"foo",{a=false}}}

	local millions = 37_000_000
	!assert 3700______0000 == 37000000

	do {
		!import "string"
		_              = replace("abba", "b", "h")
		local _, count = replace("abba", "b", "h")
		local _, _     = replace("abba", "b", "h")
		_              = replace("abba", "b", "h")
	}

	testDefer()

	local printFloats :: (...:float) {
		!import "basic"
		local arr:[]float = {5, ...}
		print(unpack(arr))
	}
	printFloats(6.12, 9, 200.1)

	do {
		local Object    :: !foreign struct {}
		local getObject :: () -> Object !foreign lua "function() return {foo=function()end} end"
		local obj       := getObject()

		local callFoo   :: (obj:Object) !foreign method "foo"
		callFoo(obj)

		local methodRef :: callFoo
		methodRef(obj)
	}

	testConstantViews()

	do {
		local arr1 :: {1, 2, 3}
		local arr2 := {[ONE]=1, [2]=2, [3]=3}
		local ONE  :: 1
		!assert type_of(arr1) == []int
		!assert type_of(arr2) == []int

		!import "basic"
		print(unpack(arr1))
		print(unpack(arr2))
	}

	testStaticDeclarations()
	testCaptures()

	do {
		local a     := "a"
		local three := 3
		local aaa   := three * a
		local AAA   :: "a" * 3
		assert(aaa == AAA)
	}

	do {
		local func1 :: () {}
		local func2 :: () {}
		local func3 :: func1
		!assert func2 ~= func1
		!assert func3 == func1

		local E :: enum {A,B}
		local C :: E.A
		!assert C == E.A
		!assert C ~= E.B

		local Ns1 :: namespace {}
		local Ns2 :: namespace {}
		!assert Ns2 ~= Ns1
		!assert Ns1 ~= namespace {}
	}

	do {
		local func    :: (s:string) {}
		local getFunc :: (s:string) -> (func:(s:string)) { return func }
		func "Dog."
		getFunc "Dog?" "Dog!"
	}

	do {
		!import "basic"

		local countChar :: (s:string, $c:string) -> int !body_text {
			local body: []string

			insert(body, "!import 'string'\n")
			insert(body, "local count = 0\n")

			insert(body, [[
				for 1, #s {
					if getSubstring(s, it, it) == c {
						count += 1
					}
				}
			]])

			insert(body, "return count\n")

			return concatinate(body)
		}

		local count = countChar("abba", "a")
		printf("'a' in 'abba': %d", count)
		assert(count == 2)
	}

	do {
		local loc1 = !location()
		local loc2 = !location(main)

		!import "basic"
		printf("loc1 = %s:%d", loc1.filePath, loc1.lineNumber)
		printf("loc2 = %s:%d", loc2.filePath, loc2.lineNumber)
	}
	do {
		local polyFunc :: (x:$T) {}

		local Namespace :: namespace {
			export var = 123
		}

		local locations = {
			!location(polyFunc),
			!location(Namespace.var),
		}
	}
	do {
		local shout :: (loc = !caller_location) {
			!import "basic"
			printf("Shouting from %s:%d", loc.filePath, loc.lineNumber)
		}
		shout()
		shout(!location(main))
	}

	do local boolToInt = {
		(b:bool) -> int {
			if b  return 1  else  return 0
		},
		(b:bool) -> int {
			do  return b ? 1 : 0
		},
		(b:bool) -> int {
			while true  return b ? 1 : 0
		},
		(b:bool) -> int {
			for 1, 1  return b ? 1 : 0
		},
		(b:bool) -> int {
			if b == {
				case true:  return 1
				case false: return 0
			}
		},
	}

	do {
		!import "basic"
		local n = 2

		print()
		printf("What is %d?", n)

		if n == {}
		if n == {
			case 1: print("It is... 1!")
		}
		if n == {
			case:   print("It is... who knows!")
		}
		if n == {
			case 1: print("It is... 1!")
			case 2: print("It is... 2!")
		}
		if n == {
			case 1: !through
			case 2: print("It is... 1 or 2!")
		}
		if n == {
			case 1: !through
			case:   print("It is... who knows!")
		}
		if n == {
			case 1: print("It is... 1!")
			case 2: print("It is... 2!")
			case:   print("It is... neither 1 nor 2!")
		}
		if n == {
			case 1: !through
			case 2: print("It is... 1 or 2!")
			case:   print("It is... neither 1 nor 2!")
		}
		if n == {
			case 1: print("It is... 1!")
			case 2: !through
			case:   print("It is... not 1!")
		}
		if n == {
			case 1: !through
			case 2: !through
			case:   print("It is... who knows!")
		}
	}

	do {
		local str = "Hello"
		local i   = 6
		assert(str[3] == "l")
		assert(str[i] == "")

		local STRING :: "Hello"
		local INDEX: int : !foreign lua "0"
		assert(STRING[2]     == "e")
		assert(STRING[INDEX] == "")
	}

	do {
		!import "print"
		print()

		printNice(5.8)
		printNice("Hello, sailor!")
		printNice(true)
		printNice(nil)
		printNice(float)

		local t: table = {foo="bar", [true]=false}
		printNice(t)

		local arr1 = {-1.0, !import"math".HUGE, 0/0}
		local arr2 = {arr1, {5.8, 9.002}}
		printNice(arr1)
		printNice(arr2)

		local obj: struct { x=5.8, y=9.002 }
		printNice(obj)
	}

	!import"basic".print("\nImport+call on one line!")

	testNamedArguments()

	do {
		local printSomeInts :: (...:int) {
			print(...[1])
			print(...[2])
			print(...[3])
		}
		printSomeInts(5, 88)
	}

	--]=]
	do {
		!import "basic"
		print()
		print("End of main!")
	}
}

export exit :: (exitCode:int=0) !foreign lua "os.exit"

local testEnumLookups :: () {
	local print :: (...:any) !foreign lua "print"
	print("Doing testEnumLookups.")

	local TypeEnum :: enum {
		STRING :: type_of(""),
		INT    :: int,
	}

	local IntTypeAsEnum1 :: TypeEnum.INT

	local StructReferencingEnum :: struct {
		_IntTypeAsEnum2 :: TypeEnum.INT,
		_IntTypeAsEnum3 :: IntTypeAsEnum1,
	}

	local IntTypeAsEnum2 :: StructReferencingEnum._IntTypeAsEnum2
	local IntTypeAsEnum3 :: StructReferencingEnum._IntTypeAsEnum3

	local myIntFromEnum1:IntTypeAsEnum1 = 0
	local myIntFromEnum2:IntTypeAsEnum2 = 0*0
	local myIntFromEnum3:IntTypeAsEnum3

	local IntTypeFromCast1 :: cast(type) TypeEnum.INT
	local IntTypeFromCast2 : type : cast(type) TypeEnum.INT

	local myIntFromCast1:IntTypeFromCast1 = 0
	local myIntFromCast2:IntTypeFromCast2 = 0

	local step1 :: cast(type) TypeEnum.INT
	local step2 : type : step1

	local IntEnum        :       : enum int { ONE::1 }
	local floatFromEnum1         = cast(float) IntEnum.ONE
	local floatFromEnum2 : float = cast(int)   IntEnum.ONE -- Implicit cast from int to float.

	local StructUsingEnum :: struct {
		someType = TypeEnum.INT,
	}
	local setType :: (instance:StructUsingEnum, theType:TypeEnum) {
		instance.someType = theType
	}
	local instanceUsingEnum:StructUsingEnum
	local strType = TypeEnum.STRING
	setType(instanceUsingEnum, strType)

	testArraysAndLoops()
}

local testUsing :: () {
	local print :: (...:any) !foreign lua "print"
	print("Doing testUsing.")

	do {
		local House :: struct {
			HAS_ROOF :: true,
			floors    = 1,
			rooms     = 1,
		}
		local smallHouse:House
		using smallHouse
		local canSeeSky :: not HAS_ROOF
		local moreFloors = floors+1
		rooms = 2
	}

	do {
		local Fish :: struct {
			CAN_SWIM :: true,
			length    = 1,
		}
		using Fish
		local canWalk = not CAN_SWIM
	}

	do {
		local Choice :: enum { A::"a", B::"b", C::"c" }
		using Choice
		local choiceA = A
	}

	do {
		using local Choice :: enum { A::"a", B::"b", C::"c" }
		local choiceA = A

		local SomeStruct :: struct { theChoice=Choice.A }
		local typeVar = SomeStruct

		local getChoice :: () -> type_of(SomeStruct.theChoice) {
			using Choice
			return C
		}
		local myChoice = getChoice()

		local usingArg :: (using some:SomeStruct) {
			theChoice = B
		}
		local mySome:SomeStruct
		usingArg(mySome)
	}

	do {
		local Vector1 :: struct { x:float }
		local Vector2 :: struct { using Vector1, y:float }
		local Vector3 :: struct { using Vector2, z:float }

		local vec1:Vector1
		local vec3:Vector3 = {x=-3, z=5.7}

		local takeVec1 :: (vec1:Vector1) {}
		local takeVec2 :: (vec2:Vector2) {}
		local takeVec3 :: (vec3:Vector3) {}
		takeVec3(vec3)
		takeVec2(vec3)
		takeVec1(vec3)
	}

	do {
		stuff.print("Hello???")
		do {
			using stuff.arithmetic
			local result = multiply(add(1, 5), 8)
		}
	}
	do {
		local basic :: !import "basic"
		using basic
		local s = toString(8)
	}
}

local stuff :: namespace {
	export print :: (...:any) !foreign lua "print"

	local _arithmetic :: namespace {
		export add      :: (x,y:int) -> int { return x+y }
		export multiply :: (x,y:int) -> int { return x*y }
	}
	export arithmetic :: _arithmetic
}

local testArraysAndLoops :: () {
	print("Doing testArraysAndLoops.")

	local print  :: (...:any) !foreign lua "print"
	local insert :: (arr:[]int, item:int) !foreign lua "table.insert"

	do {
		local ints : []int
		insert(ints, 5)
		local x      = ints[1]
		local length = #ints
		ints[1]      = 10
	}

	for i = 1, 3  print(i)

	local times = 5
	for 1, times, 2 {
		it = it*2
		print(it)
	}

	do {
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for        ints  print(itIndex, it*it)
		for n    : ints  print(itIndex, n*n)
		for n, i : ints  print(i,       n*n)
	}

	do {
		local inext :: (ints:[]int, i:int) -> int|none, int {
			-- Array lookups can be compared to nil.
			if ints[i+1] == nil  return nil, 0
			return i+1, ints[i+1]
		}
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for i, n in inext, ints, 0  print("inext", i, n*n)
	}
	do {
		local next :: (t:table, k:any) -> any, any !foreign lua "next"
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for k, v in next, ints, nil  print("next", k, cast(int)(v)^2) -- Note: Arrays are compatible with tables.
	}

	do {
		local IntArrayIterator :: (arr:[]int, i:int) -> (i:int|none, item:int)
		local ipairs :: (arr:[]int) -> (iter:IntArrayIterator, arr:[]int, init:int) !foreign lua "ipairs"
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for i, n in ipairs(ints)  print("ipairs", i, n*n)
	}

	do {
		local ints : []int = {10,20,30}
		for ints {
			print(it)
			if itIndex == 2  break
		}
		local printLength :: (arr:[]any) {
			print("Length:", #arr)
		}
		printLength({"a","b"})
	}

	print("\nBreak:") -- Should give sequence: 11 12 13 14 21 22 23 31 32 41
	for x = 1, 5 {
		for y = 1, 5 {
			if x == 5 and y > 2 {
				while true  break(x)
			}
			if x  == 6  break(x)
			if x+y > 5  break
			print(x, y)
		}
	}
	print("\nContinue:") -- Should give sequence: 11 13 14 15 21 23 24 25 41 43 45 51 53 55
	for x = 1, 5 {
		if x == 3  continue

		for y = 1, 5 {
			if y == 2  continue

			if x > 3 and y == 4 {
				while true  continue(y)

				if     true  continue
				elseif true  continue
				else         continue

				if 0 == {
					case 1: continue
					case 2: continue
					case:   continue
				}

				!import "basic"
				assert(false)
			}

			print(x, y)
		}
	}

	do {
		local printEachInt :: (...:int) {
			for ...  print(itIndex, it)
		}
		local printEachReverse :: (...:any) {
			for < item, i: ...  print(i, item)
		}
		print()
		print("printEachInt...")
		printEachInt(1, 2, 3)
		print("printEachReverse...")
		printEachReverse(8, "food", true)
	}

	do {
		local Vector3 :: struct {
			x: float,
			y: float,
			z: float,

			!iterator :: (vec:Vector3, i:int) -> (i:int|none, v:float) {
				i += 1
				if i == 1  return 1, vec.x
				if i == 2  return 2, vec.y
				if i == 3  return 3, vec.z
				return nil, NULL
			},
		}
		local NamedVector3 :: struct {
			using Vector3,
			name = "",
		}

		local vec:   Vector3      = {x=5, y=84.2, z=-998}
		local named: NamedVector3 = {z=!import"math".HUGE, name="test"}

		print("vec:")
		for vec  print(itIndex, it)
		print("named:")
		for named  print(itIndex, it)
	}
}

local testStructs :: () {
	do {
		local Vector2 :: struct { x:float=.5; y:float }
		local myVec3a:Vector2
		local y = 1
		local myVec3b:Vector2 = {y=y}
	}
	do {
		local Indirect :: struct {
			Direct :: !foreign struct {},
			ok1: Direct|none = nil,
			ok2: Direct = !foreign lua "nil",
			ok3: Direct = NULL,
		}
		local indirect:Indirect
	}
	do {
		local TypeStrings :: struct { name:string, !key:type, !value:string }

		local intType = int
		local intName = "Integer"
		local typeNames: TypeStrings = { [intType]=intName }
		typeNames[TypeStrings] = "Struct: TypeStrings"
		typeNames.name = "Names of types"

		!import "basic"
		print("typeNames[int]         =", int,         typeNames[int])
		print("typeNames[TypeStrings] =", TypeStrings, typeNames[TypeStrings])
		print("typeNames.name         =", "",          typeNames.name)
	}
	do {
		-- Array contructors.
		local getInts1  :: () -> int, int    { return 11, 111 }
		local getInts2  :: () -> (...:int)   { return 22, 222 }
		local intAndStr :: () -> int, string { return 33, "3" }

		local arr1: []int = {1, getInts1()}
		local arr2: []int = {2, getInts2()}
		local arr3: []int = {3, (intAndStr())} -- Note the parenthesis.

		local tryVararg :: (...:int) {
			local arr: []int = {1, ...}
		}
		tryVararg()
	}
	do {
		!import "basic"

		local ArrayWithN :: struct (T:type) { !value:T, n=0 }
		local strings: ArrayWithN(string)

		strings[1] = "foo"     ; strings.n += 1
		insert(strings, "bar") ; strings.n += 1
		print("ArrayWithN", strings.n, unpack(strings))

		if strings  print("strings is not empty.")

		local stringArray = cast([]string) strings
	}
	do {
		local Base :: struct { CONST::5 }
		local Sub  :: struct { using Base }
		!assert Sub.CONST == 5
	}
	do {
		local Base :: struct { CONST::5 }
		local Sub  :: struct { using Base, CONST::-1 }
		!assert Sub.CONST == -1
	}
	do {
		!import "basic"
		!import "math"

		local ThingerBase :: struct {
			name = "",
			!call :: (i:int) -> bool {
				return false
			},
			!call :: () -> ThingerBase {
				local name = format("Random %d", getRandom(10000))
				return {name=name}
			},
		}

		local Thinger :: struct {
			size = 5,
			using ThingerBase,
		}

		local thing = Thinger()
		!assert type_of(thing) == ThingerBase
		print("thing.name = ", thing.name)

		assert(Thinger(57) == false)
	}
}

local testBoolCasts :: () {
	!import "basic" -- The module has the same name as this file - don't worry about it!
	print("Doing testBoolCasts.")

	do {
		local typeName, v1, v2 = "int", 1, 0
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v1), toString(v1))
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v2), toString(v2))
	}
	do {
		local typeName, v1, v2 = "float", 1.0, 0.0
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v1), toString(v1))
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v2), toString(v2))
	}
	do {
		local typeName, v1, v2 = "string", "foo", ""
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v1), toString(v1))
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v2), toString(v2))
	}
	do {
		local typeName, v1, v2 = "array", cast([]int){0}, cast([]int){}
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v1), toString(v1))
		printf("%-6s = %s  (%s)", typeName, toString(cast(bool)v2), toString(v2))
	}

	for n1 = 0, 1  for n2 = 0, 1
		printf("%d and %d = %s", n1, n2, toString(n1 and n2))
	for n1 = 0, 1  for n2 = 0, 1
		printf("%d or  %d = %s", n1, n2, toString(n1 or  n2))

	do {
		local str:string
		if not str  print("The string is empty.")
	}

	do {
		local arr : []int : {}
		if 0   error("Empty int detected incorrectly.")
		if 0.0 error("Empty float detected incorrectly.")
		if ""  error("Empty string detected incorrectly.")
		if arr error("Empty array detected incorrectly.")
	}

	do {
		local isFemale  = true
		local strValue1 = "foo"
		local strValue2 = ""
		local name      = isFemale  ? "Peach" : "Berry"
		strValue1       = strValue1 ?         : "default"
		strValue2       = strValue2 ?         : "default"
		local nonsense  = isFemale  ?         : false
		local isMale    = isFemale  ? false   : true
		print("name      "..name)
		print("strValue1 "..strValue1)
		print("strValue2 "..strValue2)
		print("nonsense  "..toString(nonsense))
		print("isMale    "..toString(isMale))
	}
	do {
		local name      = true  ? "Peach" : "Berry"
		local strValue1 = "foo" ?         : "default"
		local strValue2 = ""    ?         : "default"
		local nonsense  = true  ?         : false
		local isMale    = true  ? false   : true
		print("name      "..name)
		print("strValue1 "..strValue1)
		print("strValue2 "..strValue2)
		print("nonsense  "..toString(nonsense))
		print("isMale    "..toString(isMale))
	}
	do {
		!import "basic"
		local a = 2
		local b = a == 1 ? "one" :  a == 2 ? "two" : "many"
		local c = a == 1 ? "one" : (a == 2 ? "two" : "many")
		assert(b == "two")
		assert(b == c)
	}

	local takingVararg :: (...:int) -> int|none {
		local flag = false
		local x    = flag ? ... : ...
		return x
	}
	print(takingVararg(1, 2))
}

local STRING_CONST :: "TEST"
!assert STRING_CONST

local NON_EMPTY_STRING :: "Tall mountain."
!if NON_EMPTY_STRING {
	local valueInFileScope = 5
} else {
	local valueInFileScope = "foo"
}

local SWITCH :: 2

!if SWITCH == 1
	local switchString :: "one"
elseif SWITCH == 2
	local switchString :: "two"
else
	local switchString :: "more"

!if SWITCH == 1 {
	local switchString2 :: "one"
} elseif SWITCH == 2 {
	local switchString2 :: "two"
} else {
	local switchString2 :: "more"
}

local testStaticStuff :: () {
	!import "basic"

	local STRING_CONST_2 :: "TEST"
	!assert STRING_CONST_2

	using local StructWithAssert :: struct {
		VALUE2 :: 3*VALUE1,
		VALUE1 :: 5,
		!assert VALUE2 > 10,
	}
	print("VALUE2", VALUE2)

	local FLAG :: false

	!if FLAG
		local value = 5
	elseif false
		local value = nope
	else
		local value = "foo"

	!if FLAG {
		local value2 = 5
	} elseif false {
		local value2 = nope
	} else {
		local value2 = "foo"
	}

	print(
		valueInFileScope, -- 5
		value,            -- foo
		value2,           -- foo
		switchString,     -- two
		switchString2     -- two
	)
}

local testStaticDeclarations :: () {
	!import "basic"
	print("Doing testStaticDeclarations.")

	static counterOuter = 0

	local inc :: () {
		static counterInner = 0
		local  counterLocal = 0

		counterOuter += 1
		counterInner += 1
		counterLocal += 1

		printf("outer:%d inner:%d local:%d", counterOuter, counterInner, counterLocal)
	}

	for 1, 3  inc()

	local JustTesting :: namespace {
		local META_CONST :: 8
		local metaVar    := 2
		local fooLocal   := !run META_CONST + metaVar

		export fooExport :: () -> int {
			static fooStatic: int

			fooLocal  += 1
			fooStatic += fooLocal

			return fooStatic
		}
	}

	print(JustTesting.fooExport())
	print(JustTesting.fooExport())
	print(JustTesting.fooExport())
}

local testPolymorphism :: (...:int) {
	do {
		!import "basic"
		print("Doing testPolymorphism.")
	}

	do {
		local insert :: (arr:[]$T, value:T) !foreign lua "table.insert"
		local ints: []int
		insert(ints, 5)
	}
	do {
		local poly :: (...:$T) {}
		local get  :: () -> (i:int, s:string, ...:int) { return 99, "" }
		poly(3.0)
		poly(...)
		poly(1, get(), ...)
		poly("")
		poly(true, false)
	}
	do {
		local poly :: (...:$T) {}
		local get  :: () -> (...:int) { return void }
		poly(5, get())
		poly(get())
	}
	do {
		local poly :: (i:int|none, ...:$T) {}
		poly(..., "")
	}
	do {
		local poly :: (x:$T) {
			!assert T ~= int
			-- !print T
		}
		poly("")
		poly(1.0)
	}
	do {
		local polyType :: (x:$T) {
			!import "basic"
			!if T == int {
				!assert T == int
				print("Got int!", x)
			} else {
				!assert T ~= int
				print("Got something else!", x)
			}
		}
		polyType(5)
		polyType(cast(table){})
	}
	do {
		local outside :: (s:$T1) {
			local inside :: (s:$T2) {
				!assert T1 == string
				!assert T2 == T1
				!import "basic"
				print(s)
			}
			inside(s)
		}
		outside("Hello?")
	}
	do {
		!import "basic"

		local ObjectAndNumber :: struct (T:type, n=0) {
			object:T,
			number = n,
		}

		local strAndNum: ObjectAndNumber(string, 5)
		strAndNum.object  = "Bacon"
		strAndNum.number += 1

		assert(strAndNum.number == 6)
		assert(strAndNum.T == string)
		assert(strAndNum.n == 5)

		assert(ObjectAndNumber(string, 5) == type_of(strAndNum))
		assert(ObjectAndNumber(string, 5) == ObjectAndNumber(string, 5))
		assert(ObjectAndNumber(string, 0) == ObjectAndNumber(string))
		assert(ObjectAndNumber(string, 0) ~= ObjectAndNumber(string, 5))
	}
	do {
		local multipleNamesForOneType :: (a,b:$T) {}
		multipleNamesForOneType(1, 2)
	}
	do {
		local newArrayWithGarbage :: ($ItemType:type) -> []ItemType {
			local arr: []ItemType

			!if ItemType == int {
				!import "basic"
				insert(arr, 59)
			} elseif ItemType == string {
				!import "basic"
				arr[1] = "xyz"
			}

			return arr
		}

		local Vector2 :: struct { x:float, y:float }

		local arrInt = newArrayWithGarbage(int)
		local arrStr = newArrayWithGarbage(string)
		local arrVec = newArrayWithGarbage(Vector2)
	}
	do {
		local overloadedPoly :: () {}
		local overloadedPoly :: (x:$T) {}
		overloadedPoly()
		overloadedPoly(5)
	}
	do {
		!import "basic"
		local Pair :: struct (L:type, R:type) {
			l: L = NULL,
			r: R = NULL,
		}
		local isPairSymmetric :: (pair: Pair($L, $R)) -> bool {
			return L == R
		}
		local isPairPairSymmetric :: (pair: Pair($L, Pair($R,R))) -> bool {
			return L == Pair(R, R)
		}
		local pair1: Pair(int, int)
		local pair2: Pair(int, string)
		local pair3: Pair(Pair(int,int), Pair(int,int))
		local pair4: Pair(int, Pair(int,int))
		assert(    isPairSymmetric(pair1))
		assert(not isPairSymmetric(pair2))
		assert(    isPairSymmetric(pair3))
		assert(not isPairSymmetric(pair4))
		assert(    isPairPairSymmetric(pair3))
		assert(not isPairPairSymmetric(pair4))
	}
	do {
		local JustN :: struct (N:int) {}
		local testJustN :: (n: JustN($N)) {
			!assert N == n.N
			!import "basic"
			printf("N = %d", N)
		}
		local n: JustN(5)
		testJustN(n)
	}
}

local testDefer :: () -> int {
	!import "basic"
	print("Doing testDefer.")

	if false  return 1
	defer print("A")

	do {
		defer {
			local B :: "B"
			print(B)
		}

		if false  return 2

		defer {
			local c = "C"
			print(c)
		}

		local c = 593

		for 1, 3 {
			defer print("for1 "..toString(it).." always")
			if it == 2  break
			defer print("for1 "..toString(it).." once")
		}

		for outer = 1, 3 {
			defer print("for2 outer"..toString(outer).." always")
			for middle = 1, 3 {
				if c {
					defer print("for2 middle"..toString(middle).." always")
					for inner = 1, 3 {
						defer print("for2 inner"..toString(inner).." always")
						if inner == 2  break(outer)
						defer print("for2 inner"..toString(inner).." once")
					}
					defer print("for2 middle"..toString(middle).." BAD")
				}
			}
			defer print("for2 outer"..toString(outer).." BAD")
		}
	}

	print("end")

	while true {
		local foo = 0
		defer {
			local bar = 0
			while true  break
		}
		break
	}

	return 3
}

local testConstantViews :: () {
	!import "basic"
	print("Doing testConstantViews.")

	local A: struct{x:struct{y:int}} : {x={y=5}}
	local AX :: A.x

	local x  = AX
	local ax = A.x

	local added    = x.y   + ax.y
	local oneMore1 = AX.y  + 1
	local oneMore2 = A.x.y + 1
}

local testCaptures :: () {
	!import "basic"
	print("Doing testCaptures.")

	do {
		local VALUES :: {57, 83, 149}
		local i = 0

		local valueIterator = [i] (_1,_2:none) -> int|none {
			i += 1
			return VALUES[i]
		}

		for v in valueIterator, nil, nil {
			print("v = "..toString(v))
		}
	}

	do {
		local everyOther :: (arr:[]$T) -> ((_1,_2:none)->T|none), none, none {
			local i = -1
			return
				[arr, i] (_1,_2:none) -> T|none {
					i += 2
					return arr[i]
				},
				nil, nil
		}

		for number in everyOther({10, 20, 30, 40, 50}) {
			printf("number = %d", number)
		}
		for letter in everyOther({"a","b","c","d","e"}) {
			print("letter = "..letter)
		}
	}
}

local testNamedArguments :: () {
	!import "basic"
	print("\nDoing testNamedArguments.")

	do {
		local required :: (f:float, s:string) {
			static n = 0
			n += 1
			printf("%d: f=%.2f, s='%s'", n, f, s)
		}
		local optional :: (f=.0, s="default") {
			required(f, s)
		}
		print()
		required(9.75, "Something!")
		required(9.75, s="Something!")
		required(f=9.75, s="Something!")
		required(s="Something!", f=9.75)
		optional()
		optional(f=9.75)
		optional(s="Something!")
	}

	do {
		local abc :: (a:int, b:int, c="incorrect") !foreign lua [[
			function(a, b, c)
				c = (c or "default")
				assert(c ~= "incorrect")
				print(("a=%d b=%d c='%s'"):format(a, b, c))
			end
		]]
		print()
		abc(11, c="C", b=22)
		abc(b=22, a=11)
	}

	do {
		local arr: []int

		insert(array=arr, value=11)
		insert(index=1, value=22, arr)

		print()
		print(unpack(arr))

		assert(arr[1] == 22)
		assert(arr[2] == 11)
	}
	do {
		local func :: (n:int)         { printf("func1 1=%d", n) }
		local func :: (s:string, n=0) { printf("func2 1='%s' 2=%d", s, n) }

		print()
		func(n=5)        -- 1
		func("foo")      -- 2
		func(s="foo")    -- 2
		func(n=5, "bar") -- 2
	}
	do {
		local Struct :: struct {
			!call :: (n:int)         { printf("call1 1=%d", n) },
			!call :: (s:string, n=0) { printf("call2 1='%s' 2=%d", s, n) },
		}

		print()
		Struct(n=5)        -- 1
		Struct("foo")      -- 2
		Struct(s="foo")    -- 2
		Struct(n=5, "bar") -- 2
	}

	do {
		local Blargh :: struct (n:int, s:string) {}

		local a: Blargh(5, "bar")
		local b: Blargh(s="bar", 5)
		local c: Blargh(s="DOG", n=5)

		assert(type_of(a) == type_of(b))
		assert(type_of(a) ~= type_of(c))
	}

	do {
		local take2 :: (a:int, b="default") { print("ab", a, b) }
		local get2  :: () -> int, string { return 123, "nope" }
		print()
		take2(a=get2()) -- Uses only the first returned value.
	}
}
