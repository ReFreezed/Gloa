--
-- Basic test.
--

local SEVEN1 :: 1+2*3
local seven1  = SEVEN1

local TWO    :: 2
local SEVEN2 :: 1+TWO*3
local seven2  = SEVEN2

local noopRef = noop

local callTest = () {
	noop()
	performAdditions(2)
}

local performAdditions :: (a:int) -> int {
	local x = -(-1) + a * (2+1)
	local y:int -- Default value for ints is 0.
	return x+y
}

local noop :: () {}

global ANY     :: any
global typeVar1 = string
global typeVar2 = ANY

local one, two = "1", 2

local shadow = 0

local main :: () -> void {
	local a = 1
	local b = a

	local myTable:table = {123, [3]=7, func=main, ["x.y"]=true}

	local oneInTwoOut1 :: (a:int) -> int, int { return a, 2*a }
	local one1, two1, three1 : int = 5, oneInTwoOut1(99)

	local MySig :: (arg1:string, arg2,arg3:int) -> bool, string
	local myFunc1:MySig : (arg1:string, arg2,arg3:int) -> bool, string { return true, "foo" }
	local mySig1 = MySig
	local mySig2 = MySig
	local mySig3 = ()->void

	local testFuncReturningFunc :: () {
		local getDoubler :: () -> (n:int)->int {
			return (nStr:int) -> int {
				return 2*nStr
			}
		}
		local double = getDoubler()(5)
	}
	testFuncReturningFunc()

	local recursive :: () -> int { return recursive() }

	local arithmetic1 = 1+2+3
	local arithmetic2 = 1 + 2*3
	local arithmetic3 = 1 + 2 * 3 // 4^5 % 6
	local arithmetic4 = 4-2-1
	local arithmetic5 = 1 - -1
	local arithmetic6 = 4 - 2^2 - 1
	local arithmetic7 = 2^3^2 + 1
	local arithmetic8 = 1.0 / 2.0 / 3.0
	local arithmetic9 = 3 // 2

	do {
		local blockVar1 = 0
		do {
			local blockVar2 = 1
		}
		local blockVar2 = 2
	}
	local blockVar2 = 3

	!load "basic.load.gloa"
	local six = triple(2)

	local codepointÆ = !char "Æ"
	local codepoint龠 = !char "龠"
	local nonsense:int = codepoint龠-codepointÆ

	local printString :: (s:string) !foreign lua "print"
	printString("Hello, Lua!")

	local printAny :: (v:any) !foreign lua "print"
	printAny("Hello, Lua!")
	printAny(123)

	local printStringOrInt :: (v:string|int) !foreign lua "print"
	printStringOrInt("Hello, Lua!")
	printStringOrInt(123)

	local printStrings :: (...:string) !foreign lua "print"
	printStrings("Hello, ", "Lua!")
	printStrings()
	local print :: (...:any) !foreign lua "print"
	print("Hello", 123, true, "Lua!")
	print()

	local getValues :: () -> string, int { return "GET", 100 }
	print(true, getValues())

	local getVararg :: () -> (...:int) { return 1, 2, 3 }
	local takeThreeMaybe :: (x,y,z:int|nil) {}
	takeThreeMaybe(10, getVararg(), 30)
	takeThreeMaybe(10, 20, (getVararg()))

	local getAtLeastOne :: () -> (x:int, ...:int) { return 1, 2, 3 }
	local takeExactlyThree :: (x:int, y:int, z:int) {}
	takeExactlyThree(10, 20, (getAtLeastOne()))
	takeExactlyThree(10, getAtLeastOne(), 30)

	local takeAndReturnVararg :: (...:int) -> (...:int) {
		local a1, a2 = ...
		local b1, b2 = 1, ...
		local c1, c2 = 1, (...)
		local d1, d2 = ..., 2
		local e1, e2 = (...), 2
		local typeOfVararg = type_of(...) -- Should be int.
		if ... == nil {}
		return ...
	}
	local x, y = takeAndReturnVararg(1, 2, 3)
	local typeOfX :: type_of(x) -- Value should be int|nil.
	local typeOfY :: type_of(y) -- Value should be int|nil.
	local takeOneIntMaybe :: (x:int|nil) {}
	takeOneIntMaybe(x)
	takeOneIntMaybe(y)
	if x ~= nil and y ~= nil {
		local dummy1 :        int|nil = 0
		local dummy2 : string|int|nil = ""
		local x1 = cast(type_of(dummy1)) x
		local y1 = cast(type_of(dummy2)) y
		local x2 = cast(int) x
		local y2 = cast(int) y
		takeAndReturnVararg(x2, y2, x2, y2)
	}

	local flag = false or true
	if flag
		print("The flag is set!")
	else
		print("The flag is unset...")

	local tostring :: (v:any) -> string !foreign lua "tostring"
	local n = 3
	while n > 0 {
		print("While "..tostring(n))
		n = n-1
	}

	local Foo :: struct {
		status = -1;
	}
	local Thinger :: struct {
		WHAT :: "maybe ",
		name = "unnamed",
		flag = true,
		count:int,
		foo:Foo,
	}
	local thing:Thinger
	thing.name = "("..thing.name..")"
	thing["na".."me"] = thing.WHAT..Thinger.WHAT.."Rita"

	!import "test"
	local invisible :: () {} -- Should not collide with the one in the test module.
	testFunction()

	local EntityType :: enum {
		PLAYER  :: 0x01,
		MONSTER :: 0x02;
		BUTTON  :: 0x03,
		DOOR    :: 0x04
	}
	local ENTITY_TYPE_PLAYER = EntityType.PLAYER

	local MELEE_NAME :: "Knight"
	local ClassName :: enum string {
		MELEE  :: MELEE_NAME,
		RANGED :: "Archer",
		MAGIC  :: "Mage",
	}
	local myClass:ClassName = ClassName.MAGIC
	local ClassName2 :: ClassName
	local ClassName3 = type_of(myClass)
	print(ClassName.RANGED)

	testEnumLookups()

	local floatToCast = 5.9
	local castedToInt = cast(int)   floatToCast
	local uselessCast = cast(float) floatToCast

	testUsing()
	testStructs()

	local shadow = "a" !shadow
	do {
		shadow = shadow.."b"
		local shadow = 1.0 !shadow
		shadow = shadow * 2.0
		do {
			shadow = shadow + 18.0
			local shadow = true !shadow
			shadow = not shadow
		}
	}

	local TableIterator :: (t:table, k:any) -> (k:any, item:any)
	local pairs :: (t:table) -> (iter:TableIterator, t:table, init:any) !foreign lua "pairs"
	local LUA_VERSION:string : !foreign lua "_VERSION"
	local luaEnv:table       = !foreign lua "_G"
	for k, v in pairs(luaEnv) {
		print(LUA_VERSION, "_G."..tostring(k), v)
	}

	local FOREIGN_STRING : string : !foreign lua "_VERSION"
	local FOREIGN_ALIAS :: FOREIGN_STRING
	local localString = FOREIGN_ALIAS.." test"
	print("localString", localString)

	local overloaded :: (n:int) {}
	local overloaded :: (s:string) {}
	overloaded(5)
	overloaded("foo")

	local optional :: (x:int, y:int=0, z:int=0) {
		local sum = x+y+z
	}
	optional(1, 2, 3)
	optional(1, 2)
	optional(1)

	local take2 :: (req:int, opt:int=0) {}
	local get1 :: () -> int { return 9 }
	local get2 :: () -> int, int { return 8, 9 }
	take2(get1())
	-- take2(get2()) -- Error! :DisallowListAsLastValueToFunctionWithOptionalArguments

	local assert :: (b:bool)              !foreign lua "assert"
	local assert :: (b:bool, message:any) !foreign lua "assert"

	assert(1   /  2   == .5)
	assert(1.0 /  2.0 == .5)
	assert(1   // 2   == 0)
	assert(1.0 // 2.0 == 0)
	local i1, f1, i2, f2 = 1, 1.0, 2, 2.0
	do { local v = i1 /  i2 ; assert(v == .5, v) }
	do { local v = f1 /  f2 ; assert(v == .5, v) }
	do { local v = i1 // i2 ; assert(v == 0,  v) }
	do { local v = f1 // f2 ; assert(v == 0,  v) }

	assert(cast(int) +.5 == 0)
	assert(cast(int) -.5 == 0)
	local half = .5
	do { local v = cast(int) +half ; assert(v == 0, v) }
	do { local v = cast(int) -half ; assert(v == 0, v) }

	print("End of main!")
}

local testEnumLookups :: () {
	local print :: (...:any) !foreign lua "print"
	print("Doing testEnumLookups.")

	local TypeEnum :: enum {
		STRING :: type_of(""),
		INT    :: int,
	}

	local IntTypeAsEnum1 :: TypeEnum.INT

	local StructReferencingEnum :: struct {
		_IntTypeAsEnum2 :: TypeEnum.INT,
		_IntTypeAsEnum3 :: IntTypeAsEnum1,
	}

	local IntTypeAsEnum2 :: StructReferencingEnum._IntTypeAsEnum2
	local IntTypeAsEnum3 :: StructReferencingEnum._IntTypeAsEnum3

	local myIntFromEnum1:IntTypeAsEnum1 = 0
	local myIntFromEnum2:IntTypeAsEnum2 = 0*0
	local myIntFromEnum3:IntTypeAsEnum3

	local IntTypeFromCast1 :: cast(type) TypeEnum.INT
	local IntTypeFromCast2 : type : cast(type) TypeEnum.INT

	local myIntFromCast1:IntTypeFromCast1 = 0
	local myIntFromCast2:IntTypeFromCast2 = 0

	local step1 :: cast(type) TypeEnum.INT
	local step2 : type : step1

	local IntEnum        :       : enum int { ONE::1 }
	local floatFromEnum1         = cast(float) IntEnum.ONE
	local floatFromEnum2 : float = cast(int)   IntEnum.ONE -- Implicit cast from int to float.

	local StructUsingEnum :: struct {
		someType = TypeEnum.INT,
	}
	local setType :: (instance:StructUsingEnum, theType:TypeEnum) {
		instance.someType = theType
	}
	local instanceUsingEnum:StructUsingEnum
	local strType = TypeEnum.STRING
	setType(instanceUsingEnum, strType)

	testArraysAndLoops()
}

local testUsing :: () {
	local print :: (...:any) !foreign lua "print"
	print("Doing testUsing.")

	do {
		local House :: struct {
			HAS_ROOF :: true,
			floors    = 1,
			rooms     = 1,
		}
		local smallHouse:House
		using smallHouse
		local canSeeSky :: not HAS_ROOF
		local moreFloors = floors+1
		rooms = 2
	}

	do {
		local Fish :: struct {
			CAN_SWIM :: true,
			length    = 1,
		}
		using Fish
		local canWalk = not CAN_SWIM
	}

	do {
		local Choice :: enum { A::"a", B::"b", C::"c" }
		using Choice
		local choiceA = A
	}

	do {
		using local Choice :: enum { A::"a", B::"b", C::"c" }
		local choiceA = A

		local SomeStruct :: struct { theChoice=Choice.A }
		local typeVar = SomeStruct

		local getChoice :: () -> type_of(SomeStruct.theChoice) {
			using Choice
			return C
		}
		local myChoice = getChoice()

		local usingArg :: (using some:SomeStruct) {
			theChoice = B
		}
		local mySome:SomeStruct
		usingArg(mySome)
	}
}

local testArraysAndLoops :: () {
	print("Doing testArraysAndLoops.")

	local print  :: (...:any) !foreign lua "print"
	local insert :: (arr:[]int, item:int) !foreign lua "table.insert"

	do {
		local ints : []int
		insert(ints, 5)
		local x      = ints[1]
		local length = #ints
		ints[1]      = 10
	}

	for i = 1, 3  print(i)

	local times = 5
	for 1, times, 2 {
		it = it*2
		print(it)
	}

	do {
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for        ints  print(itIndex, it*it)
		for n    : ints  print(itIndex, n*n)
		for n, i : ints  print(i,       n*n)
	}

	do {
		local inext :: (ints:[]int, i:int) -> int|nil, int {
			-- Array lookups can be compared to nil.
			if ints[i+1] == nil  return nil, 0
			return i+1, ints[i+1]
		}
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for i, n in inext, ints, 0  print("inext", i, n*n)
	}
	do {
		local next :: (t:table, k:any) -> any, any !foreign lua "next"
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for k, v in next, ints, nil  print("next", k, cast(int)(v)^2) -- Note: Arrays are compatible with tables.
	}

	do {
		local IntArrayIterator :: (arr:[]int, i:int) -> (i:int|nil, item:int)
		local ipairs :: (arr:[]int) -> (iter:IntArrayIterator, arr:[]int, init:int) !foreign lua "ipairs"
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for i, n in ipairs(ints)  print("ipairs", i, n*n)
	}

	do {
		local ints : []int = {10,20,30}
		for ints {
			print(it)
			if itIndex == 2  break
		}
		local printLength :: (arr:[]any) {
			print("Length:", #arr)
		}
		printLength({"a","b"})
	}
}

local testStructs :: () {
	local Vector2 :: struct { x:float=.5; y:float }
	local myVec3a:Vector2
	local y = 1
	local myVec3b:Vector2 = {y=y}
}
