--
-- Parsing tests.
--



-- Things that should work.
--------------------------------

local n = 1+2*3+4           -- 1+(2*3)+4
local n = a+i < b/2+1       -- (a+i) < ((b/2)+1)
local n = 5+x^2*8           -- 5+((x^2)*8)
local n = a < y and y <= z  -- (a < y) and (y <= z)
local n = -x^2              -- -(x^2)
local n = x^y^z             -- x^(y^z)

local str = "a\nb\tc" .. 1+2 .. 4

local flag = true
local null = nil

local t1 = {a=5, ["hello"]=nil, [true]=false, nil}
local t2 = {[{1+-2}]=true and false; [(b)]=((5))}
local t3 = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }

local v = func(5, "hello")
local v = bar({a=true}) + bat("?")

local a          = 5
local b :        : false
local c : any    = nil
local d : string = "hello"
local e : Thing
local f : Poly(int, !type Other(bool), bad(""))
local g : type_of(d)
local h :        : type_of(g)

local arr : [] int = {1,2,3}
local arr : [] [] Thing( [] int, bool )

local v = func(5, hello) + "aaaa"

local sig :: ()
local sig :: (a:float) -> void
local sig :: (a:float, b:Groot) -> bool, Tree

local func :: (b:Bar(Dog,Cat(int,int)), n:float=-1) -> (ok:bool, thing:Thing) {
	local x:float = 2;
	local y       = 85;
}

local sig :: (a, b: bool, x: any)
local sig :: (a, b: []int = nil)

!import "math"
!load   "src/foo.gloa"
global ioLib :: !import "io"

local importsAndLoads :: () {
	!import "math"
	!load   "src/foo.gloa"
	local ioLib :: !import "io"
}

local io1, io2 :: !import "io", !import "io"

local Entity :: struct {
	entityType: string,
	id:         Id,
	x:float    = 0.0,
	y          = 0.0;
	WHAT_IS_3 :: 1+2,
}

local Empty :: struct {}

local Dummy:type : struct (a,b:int=0) { a:int }

local EntityType :: enum {
	PLAYER  :: 0x01,
	MONSTER :: 0x02;
	BUTTON  :: 0x03,
	DOOR    :: 0x04
}

local MELEE_NAME :: "Knight"
local ClassName:type : enum string {
	MELEE  :: MELEE_NAME,
	RANGED :: "Archer",
	MAGIC  :: "Mage",
}

local sig : (a:float, b:Groot)
local funcReturningFunc :: () -> (func:(n:int)->string) {}
local Bool, sig :: (() -> bool), (n:int)->string
local Bool, sig :: (() -> bool), ()->string
local sig, Bool :: (() -> (n:int)->string), bool
local sig, Bool :: (() -> ()->string), bool
local sig, Bool :: (() -> ()->void), bool
local sig       ::  () -> ()->void , bool -- Note: void cannot be followed by anything else in a function signature, so 'bool' here is part of the return values for the first signature.

local x, Struct :: 1, struct {}

local main :: () {
	local a: int
	a, b += 5, 7+-6
	s ..= "a".."b"

	local n = cast(float) ("6") + 5

	local hëllô_日本語 = 한국어_ٱلْعَرَبِيَّة

	local len = #t

	func()
	func(6, 7)
	func("bar")
	func({})("bar")()
	func() ; (obj).x = 6
	func() ; (a and b).x = 6

	if x  func()
	if x and y {
		local n = dirt()
		n += grass()
	}

	if x  local f = 7
	if x  func()

	if      x  a()
	elseif  y  b()
	else if z  c()
	else       d()

	local x = 5
	while x > 0  x -= 1
	while x > 0  local i:int
	while x > 0  { x -= 1 }

	for 1, 3       print(it)
	for arr        print(itIndex, it)
	for v: arr     print(itIndex, v)
	for v, i: arr  print(i, v)
	for i = 1, 3              print(i)
	for i = 3, 1, -1          print(i)
	for i, v in ipairs(arr)   print(i, v)
	for k, v in next, t, nil  print(k, v)
	for v1, v2, v3: obj                print(i, v)
	for v1, v2, v3 in myIterator, obj  print(v1, v2, v3)

	local v1 = t1.t2[i].k
	local v2 = obj.k1.m1(m1Arg)(fArg).k2.m2(m2Arg).k3
	local v3 = obj.k1.m1!(m1Arg)(fArg).k2.m2!(m2Arg).k3
	local v4 = (t).k

	t.m()
	t.m!()
	obj.k1.m1(m1Arg)(fArg).k2.m2(m2Arg)
	obj.k1.m1!(m1Arg)(fArg).k2.m2!(m2Arg)

	t.n = 99
	t[1] = 99
	t.s, t.b = "foo", true
	f(arg).k, t[k] += 1, 2
	t[k], f(arg).k = 2, 1
	a, b = f(arg)
	a, b = (f(arg))

	local a:int   = f()
	local a, b    = f()
	local a, b    = (f())
	local a, b, c = 100, f()
	local a,b:int : 1,2

	local var:float|nil = 0
	local func :: (a:int, b:int|nil=nil) -> (a:int, b:int|nil) {}
	local sig  :: (a, b: int|[]string|nil)
	local func :: (a:int=nil) {} -- 'a:int=nil' desugars into 'a:int|nil=nil'.

	defer file.close!()
	defer { file.close!() ; print("yo") }

	-- These work if we got out args.
	local func :: () -> int {
		do return 1, func()
		do return 2, (func())
	}

	-- Ambiguity for return!
	if x return
	func()

	-- Ambiguity for break/continue!
	for 1, 5
		if it < 3
			print(it)
		else
			break
	func()

	-- Ambiguity for break/continue!
	for v: arr {
		if x continue
		func1()
		if y break v
		func2()
	}

	local func :: (a:string, ...:int) {
		local x, y, z: int = 5, ...
		local x, y, z: int = 5, (...)
	}
	local a, b : int = func()

	local func :: (a, b: int = 5) {}
}



-- Things that should result in an error.
--------------------------------

local syntaxErrors :: () {
	-- ; -- Empty statement (warning).

	-- f!()
	-- t.(m)!()
	-- t.m!()!()
	-- f()!()
	-- local v = f!()
	-- local v = t.m!()!()
	-- local v = t.(m)!()
	-- local v = f()!()
	-- local v = (f)!()

	-- t.(k)
	-- local v = t.(k)

	-- obj.k1.m1 (m1Arg)(fArg).k2.m2 (m2Arg).k3 -- Not a full statement.
	-- obj.k1.m1!(m1Arg)(fArg).k2.m2!(m2Arg).k3 -- Not a full statement.

	-- x, f()(aaa) = a, b -- Cannot "set" a call.

	-- local func :: () -> (i:int=5) {} -- Out args cannot have default values (yet?).

	-- local a:int|string : 5 -- Constants can only have one type.

	-- local a:555     -- Ints are not types.
	-- local a:555 = 8 -- Ints are not types.
}

-- ; -- Empty statement (warning).

-- !import 5

local illegalStatements :: () {
	-- local var:float|nil -- Must have values if multiple types are specified.
	-- local var : float|nil : 0 -- Constants must be of a single type.

	-- local func :: (...:int, b:bool) {} -- Vararg must be last.
	-- local func :: (..., x: int)     {} -- Vararg must be last.

	-- a          = x, y    -- Too many values.
	-- f().k, a   = x, y, z -- Too many values.
	-- local a, b = 1, 2, 3 -- Too many values.

	-- for 1, 10, 1, 5  func(it)  -- Too many parameters.
	-- for v: obj, obj2  func(it) -- Too many values.

	-- local x, y, x = 1, 2, 3            -- Duplicate name.
	-- local func :: (x,y:int, x:float=5) -- Duplicate name.
	-- for k, v, k: obj  func(v)          -- Duplicate name.
	-- for k, k in pairs(t)  func(k)      -- Duplicate name.

	-- func() ; (var) = 6 -- Could work, but looks weird!
}

-- local Enum :: enum { A:int:1 } -- Wrong place for type.
-- local Enum :: enum { A:int   } -- Wrong place for type.
-- local Enum :: enum { A=5     } -- Must be constant.
-- local Enum :: enum {         } -- No members.
-- local Enum :: enum table  { A::{} } -- Illegal type.
-- local Enum :: enum MyType { A::{} } -- Illegal type. (Maybe this should be ok if MyType==int or similar.)

-- local func :: (...:int=5) {} -- Varargs cannot have default values (yet?).

-- -- @Incomplete: Move these to type tests
-- local foo : int : !import "bar" -- Imports don't have any user-specifyable type. (Beware of 'type_of(!import"bar")'!)
-- local foo = !import "bar" -- Imports must be constant.



-- Incomplete stuff.
--------------------------------

local incomplete :: () {
	-- local x = ()() -- Should be an error. The compiler thinks this is a call on an expression (that results in a function signature). May solve itself once we resolve types. (Yeah, move to type tests. @Incomplete)

	-- func() ; (func)() -- Works, but looks weird! Should be an error.
	-- func() ; (func())() -- Works, but looks weird! Should be an error.
}


