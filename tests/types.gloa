--
-- Type inference tests.
--
-- * Simple declarations
-- * Functions
-- * Structs and enums
-- * Operations
-- * Blocks
-- * Multiple files
-- * Lists of things
-- * Using
-- * Arrays and loops
-- * Misc
--



-- [[ Simple declarations.
--------------------------------

local myNum1 : float
local myNum2 :      : 10
local myNum3 : int  : 20
local myNum4        = myNum2
local myNum5 : int  = myNum2
local myTyp1 :      : int
local myTyp2 : type : int

local MyType1 :: int
local MyType2 :: MyType1
local myVar1:MyType1 = 555
local myVar2:MyType2 = 555

local myInt1 = -100
local myInt2 : type_of(myInt1)
local myInt3 : type_of(myInt2) = (3+4)*2

local messyInt1 :: 5
local messyType :: type_of(messyInt1)
local messyInt2:messyType = 10

local double11, double12 : int
local double21, double22                     = 1, 2
local double31, double32 : int               = 1, 2
local double41, double42 : type_of(double22) = 1, 2

local NilType :: !type nil -- Note: The nil type is only really useful in compound types, where !type is not needed.
local iCanOnlyBeNil : NilType = nil

-- @Incomplete:
-- local StringOrNil :: !type string|nil
-- local maybeString:StringOrNil = nil

local testTable :: () {
	local k       = "a%/"
	local t:table = {[k]=false} -- Keys can be non-constant for tables, unlike for structs and arrays.
}

--====== Things that should result in an error. ======--

-- local bad:int  = "foo" -- Type/value type mismatch.
-- local bad:type = 50    -- Type/value type mismatch.
-- local bad : type_of(myInt1) = "nope" -- Type/value type mismatch.

-- local badVar:BadType3 = 99 -- The int 5 is not a type.
-- local BadType3 :: BadType2
-- local BadType2 :: BadType1
-- local BadType1 :: 5

-- local myVar1 :: string -- Redeclaration.

-- local bad:badType           -- Undeclared type/identifier.
-- local bad:badType(5, int)   -- Undeclared type/identifier.
-- local bad = badVar          -- Undeclared identifier.
-- local bad = badFunc()       -- Undeclared identifier.
-- local bad : type_of(badVar) -- Undeclared identifier.

-- local circularA :: circularB -- Circular dependency. @UX: Better error message.
-- local circularB :: circularA

-- local var =  5
-- local bad :: var -- Value is not constant.

-- local bad1 :: bad2 -- (Test that the error message is good.)
-- local bad2 :: nope

-- local bad2 :: nope -- (Test that the error message is good.)
-- local bad1 :: bad2

-- @Incomplete:
-- local Compound :: !type string|nil
-- local bad:Compound : "" -- Constants cannot be compound types.

local testDeclarations :: () {
	-- local bad :: 0
	-- bad = 5 -- Assignment target is constant. @UX: Better error message.

	-- local bad = type_of(testDeclarations()) -- Cannot get the type of function calls.
}
--]]



-- [[ Functions.
--------------------------------

local theMain :: () -> void {}

local testFunctions :: () {
	local oneInTwoOut1 :: (a:int) -> int, int { return a, 2*a }
	local one1, two1, three1 : int = 5, oneInTwoOut1(99)

	local oneInTwoOut2 :: (a:int) -> int, string { return a, "foo" }
	local one2, two2, three2 = 5, oneInTwoOut2(99)

	local mySig :: (arg1:string, arg2,arg3:int) -> bool, string
	local myFunc1:mySig : (arg1:string, arg2,arg3:int) -> bool, string { return true, "foo" }

	local myFunc : (arg1:string,arg2,arg3:int)->bool,string : (arg1:string, arg2,arg3:int) -> bool, string { return true, "" }

	local testFuncReturningFunc :: () {
		local funcReturningFunc :: () -> (n:int)->string {
			return (n:int) -> string {
				return "foo"
			}
		}
		local theString = funcReturningFunc()(5)
	}

	local getTwo    :: () -> int, int      { return 1, 2 }
	local getThree1 :: () -> int, int, int { return 1, getTwo() }
	local getThree2 :: () -> int, int, int { return 1, getTwo(), 3 }
	local getThree3 :: () -> int, int, int { return 1, 2, (getTwo()) }

	local recursive :: () -> int { return recursive() }

	local first :: () {}
	local same  :: first

	local someFunc1 :: () -> void {}
	local someFunc2 : type_of(someFunc1) = someFunc1
}

--====== Things that should result in an error. ======--

-- local func :: () -> int { return 5 }
-- local bad  =  func() -- Not a constant expression in declarative scope.

-- @Incomplete:
-- global bad :: (x:int=x) {}
-- global bad :: (x:int, y:int=x) {} -- Should this be an error or a feature?
-- global bad :: (x:int=y, y:int=0) {}

local funcErrors :: () {
	-- local oneInNoneOut :: (a:int) { return }
	-- local x, y, z : int = 5, oneInNoneOut(99) -- Nothing for y (nor z).

	-- local oneInOneOut :: (a:int) -> int { return a }
	-- local x, y, z : int = 5, oneInOneOut(99) -- Nothing for z.

	-- local func :: (a:int) -> int, string { return a, "foo" }
	-- local x, y, z : int = 5, func(99) -- Type mismatch for 'z'.

	-- local sig :: (arg1:string, arg2:int) -> bool, string
	-- local func:sig : (arg1:string, arg2,arg3:int) -> bool, string {} -- Incorrect function signature.

	-- local sig :: (arg1:string, arg2,arg3:string) -> bool, string
	-- local func : sig : (arg1:string, arg2,arg3:int) -> bool, string {} -- Incorrect function signature.

	-- local mySig :: (a:int,b:nope)  -- Undeclared identifier.
	-- local mySig :: (a:int) -> nope -- Undeclared identifier.

	-- local func :: () -> () {}
	-- local bad  =  func() -- No return arguments.

	-- local func :: () -> (n:int)->string {}
	-- local bad  =  func()(5)() -- Trying to call a string.

	-- local func :: () -> ()->string {
	-- 	return ()->string { return bad } -- Undeclared identifier.
	-- }

	-- local func :: () {}
	-- local bad  :: () -> int { return func() } -- Too few values.

	-- local func :: () -> int { return 1 }
	-- local bad  :: () -> int, int { return func() } -- Too few values.

	-- local func :: () {}
	-- local bad  :: () -> int { return (func()) } -- No resulting value in parenthesis.

	-- local func :: () -> int, int { return 1, 2 }
	-- local bad  :: () -> int, int { return 1, func() } -- Too many values.

	-- local func :: () -> string, int { return "", 2 }
	-- local bad  :: () -> int, int, int { return 1, func() } -- Returning wrong type.

	-- local func :: () -> int, string { return 1, "" }
	-- local bad  :: () -> int, int, int { return 1, func() } -- Returning wrong type.

	-- local func :: (a:int) -> int { return a }
	-- local bad  =  func() -- Missing args.

	-- local func :: (a:int) -> int { return a }
	-- local bad  =  func(1, 2) -- Too many args.

	-- local func :: (a:int) -> int { return a }
	-- local bad  =  func("nope") -- Wrong type.

	-- local Bad  :: struct {}
	-- local func :: (a:Bad) -> int { return a } -- Wrong type.

	-- local func : () -> int
	-- func = () -> int { return func() } -- func is not constant, thus invisible in the body. @UX: Improve error message.

	-- local func :: () {}
	-- func(func()) -- Function returns nothing. (Could work here, but it would be very confusing!)
}
--]]



-- [[ Structs and enums.
--------------------------------

local MyStruct1 :: struct {
	m1     = 0,
	m2:int,
	m3:int = 10,
	-- m4 :: () { local m2 = true }, -- @Incomplete: Make this work.
}
local m1 = 4

local MyStruct2 :: struct { a:IntAlias }
local IntAlias  :: int

local MyVecType :: struct { x:int; y:int, z:int }
local myVec1:MyVecType

local EntityType :: enum {
	PLAYER  :: 0x01,
	MONSTER :: 0x02;
	BUTTON  :: 0x03,
	DOOR    :: 0x04
}
local ENTITY_TYPE_PLAYER = EntityType.PLAYER

local MELEE_NAME :: "Knight"
local ClassName :: enum string {
	MELEE  :: MELEE_NAME,
	RANGED :: "Archer",
	MAGIC  :: "Mage",
}
local myClass:ClassName = ClassName.MAGIC

local Vector3 :: struct { x:int; y:int, z:int }
local myVec3:Vector3

-- @Incomplete: Using 'self' type for a member.
-- local Foo :: struct { a:Foo }

local noCollision :: 5
local StructFreeOfCollisions :: struct { noCollision="" }

local StructWithOne :: struct { ONE::1 }
local one :: cast(int) StructWithOne.ONE

local testStructs :: () {
	local Vector2 :: struct { x:float=.5; y:float }
	local myVec3a:Vector2
	local y = 1
	local myVec3b:Vector2 = {y=y}
}

local testEnumLookups :: () {
	local TypeEnum :: enum {
		STRING :: type_of(""),
		INT    :: int,
	}

	local IntTypeAsEnum1 :: TypeEnum.INT

	local StructReferencingEnum :: struct {
		_IntTypeAsEnum2 :: TypeEnum.INT,
		_IntTypeAsEnum3 :: IntTypeAsEnum1,
	}

	local IntTypeAsEnum2 :: StructReferencingEnum._IntTypeAsEnum2
	local IntTypeAsEnum3 :: StructReferencingEnum._IntTypeAsEnum3

	local myIntFromEnum1:IntTypeAsEnum1 = 0
	local myIntFromEnum2:IntTypeAsEnum2 = 0
	local myIntFromEnum3:IntTypeAsEnum3 = 0

	local IntTypeFromCast1 :: cast(type) TypeEnum.INT
	local IntTypeFromCast2 : type : cast(type) TypeEnum.INT

	local myIntFromCast1:IntTypeFromCast1 = 0
	local myIntFromCast2:IntTypeFromCast2 = 0

	local step1 :: cast(type) TypeEnum.INT
	local step2 : type : step1

	local IntEnum        :       : enum int { ONE::1 }
	local floatFromEnum1         = cast(float) IntEnum.ONE
	local floatFromEnum2 : float = cast(int)   IntEnum.ONE -- Implicit cast from int to float.

	-- @Incomplete: Handle implicit casts everywhere.
	-- local FloatEnum :: enum float { ONE::1 } -- 1 should get to float here.
	-- local one = cast(int) FloatEnum.ONE
}

--====== Things that should result in an error. ======--

-- local bad :: struct {a:nope} -- Undeclared type/identifier.

-- local myVec2:MyVecType = MyVecType -- Type/value type mismatch.

-- local bad :: 5
-- local Struct :: struct {
-- 	bad :: "", -- Redeclaration (because the member is constant).
-- }

-- local bad = 5
-- local Struct :: struct {
-- 	bad :: "", -- Redeclaration (because the member is constant). @UX: Improve error message. The message is reversed!
-- }

-- local var :: int
-- local Struct :: struct {
-- 	var  = "",
-- 	bad :: var, -- Name confusion. @UX: Improve error message.
-- }

-- local Struct :: struct {
-- 	circMemB :: circMemA, -- Circular dependency. @UX: Better error message. This is awful!
-- 	circMemA :: circMemB,
-- }

-- local Enum :: enum { INT::int }
-- local bad:type : Enum.INT -- Type mismatch. (This would work with an explicit cast.)

-- local func :: () {
-- 	local Struct :: struct { m="" }
-- 	local var:type = Struct
-- 	local bad      = var.m -- Cannot lookup type variables.
-- }

-- local func :: () {
-- 	local Struct :: struct { m="" }
-- 	local k        = "m"
-- 	local o:Struct = {[k]="foo"} -- Key is not constant.
-- }
--]]



-- [[ Operations.
--------------------------------

local unary = -5
local True  = not not true

local binary = 1+2*3

local divNum = 3/8
local divInt = 6.8 // 3.11

local advanced = 1 + 2 * 3 // 4^5 % 6

local lessInt = 5 < 1
local lessStr = "foo" < "bar"
local equal   = ("foo" == "bar") ~= false or false

local EIGHT : int : cast(int) (2.0 ^ 2.0) * 2
local TAU   :     : 3.14 * cast(type_of(5.0)) (EIGHT // 4)

local testOperations :: () {
	-- @Incomplete: Casting compound types.
	-- local dummy:int|nil = 0
	-- local Dummy :: type_of(dummy)
	-- -- local Dummy :: !type int|nil -- @Incomplete: Handle pipes here.
	-- local getCompound :: () -> Dummy { return 5 }
	-- -- local getCompound :: () -> int|nil { return 5 } -- @Incomplete: Handle pipes here.
	-- local x      = cast(int) getCompound()
	-- local xMaybe = cast(Dummy) x
	-- -- local xMaybe = cast(int|nil) x -- @Incomplete: Handle pipes here.

	local Foo :: struct {
		status = -1;
	}
	local Thinger :: struct {
		WHAT :: "maybe ",
		name = "unnamed",
		flag = true,
		count:int,
		foo:Foo,
	}
	local thing:Thinger
	thing.name = "("..thing.name..")"
	thing["na".."me"] = thing.WHAT..Thinger.WHAT.."Rita"
}

--====== Things that should result in an error. ======--

-- local bad = "nope" + "nooope"

-- local bad  = ""
-- local nope = -bad

-- local bad = cast(int) "nope"

local operationErrors :: () {
	-- local Struct :: struct {}
	-- local obj:Struct
	-- obj.bad = 5 -- Not a member.

	-- local Struct :: struct {}
	-- local obj:Struct
	-- obj["a b c"] = 5 -- Not a member.

	-- local Struct :: struct {m=""}
	-- local obj:Struct
	-- obj.m = 5 -- Type mismatch.

	-- local Struct :: struct {BAD::"bad"}
	-- local obj:Struct
	-- obj.BAD = "" -- Assigning value to constant.

	-- local Struct :: struct {BAD::"bad"}
	-- local obj:Struct
	-- obj[obj.BAD] = "foo" -- Not a member.

	-- local x     :    int|nil = 0 !shadow
	-- local dummy : string|nil = ""
	-- local bad = cast(type_of(dummy)) x -- Cannot cast from int|nil to string|nil.
}
--]]



-- [[ Blocks.
--------------------------------

local testBlocks :: () {
	local answer:int = 42
	answer = answer+1

	testBlocks()

	local returnArg :: (a:int) -> int { return a }
	returnArg(5)

	-- Lexical visibility.
	do {
		do {
			local blockVar = 1
		}
		local blockVar = 2
	}
	local blockVar = 3

	inner()
	local inner :: () {} -- Constants have higher visibility than dynamic variables.

	local flag = false or true
	if flag {
		local success = true
	}

	local n = 3
	while n > 0 {
		n = n-1
	}
}

--====== Things that should result in an error. ======--

local blockErrors :: () {
	-- local bad:int = bad -- Undeclared identifier. @UX: Better error message.

	-- bad = 5 -- Undeclared identifier.
	-- local bad:int

	-- blockErrors()() -- Trying to call void.
	-- local bad = blockErrors() -- No return value.

	-- local func :: (a:int) -> int { return a }
	-- func("nope") -- Wrong type.

	-- local func :: () -> int { return 5 }
	-- local var  =  func()
	-- local bad  :: 2*var -- Not a constant expression.

	-- local func :: () -> int { return 5 }
	-- local bad  :: func() -- Calls are not constant.

	-- if blockErrors() {} -- Function returns nothing.
}
--]]



-- [[ Multiple files.
--------------------------------

!load "types.load.gloa"

global myGlobalFunc :: () {}

local useImportedNamespace :: () {
	funcInOtherFile(5)
}

local testModules1 :: () {
	testFunction()
	!import "test"
}
local testModules2 :: () {
	local lib :: !import "test"
	lib.testFunction()
}
local testModules3 :: () {
	lib2.testFunction()
	local lib2 :: lib1
	local lib1 :: !import "test"
}
local testModulesNon :: () {
	local testFunction :: () {}
	testFunction()
}

--====== Things that should result in an error. ======--

-- !load "types.errorGlobal.gloa"
-- local other :: () {} -- Global defined in other file.

-- !load "types.errorLocal.gloa"
-- global other :: () {} -- Shadowed in other file.

-- local bad:type_of( !import "test" ) -- Namespaces don't have a type.

-- local lib :: !import "test"
-- local bad:type_of(foo) -- Namespaces don't have a type.

-- local func :: () {
-- 	local lib :: !import "test"
-- 	lib.invisible() -- Identifier not visible outside namespace.
-- }

-- local func :: () {
-- 	lib.bad() -- (Test that the error message is good.)
-- 	local lib :: !import "test"
-- 	local bad :: () {}
-- }

-- local func :: () {
-- 	local lib :: !import "test"
-- 	lib.bad() -- (Test that the error message is good.)
-- }
-- global bad :: () {}

-- export bad = 0 -- Only modules can export.

-- local bad = !import "test" -- Imports must be constant.

-- local bad = !load "types.load.gloa" -- !load must be a full statement.
--]]



-- [[ Lists of things.
--------------------------------

local testLists :: () {
	local printString :: (s:string) !foreign lua "print"
	printString("Hello, Lua!")

	local printAny :: (v:any) !foreign lua "print"
	printAny("Hello, Lua!")
	printAny(123)

	local maybeInt1        : int|nil                   = 0
	local maybeInt2        : type_of(maybeInt1)        = 0
	local maybeIntOrString : type_of(maybeInt1)|string = ""

	local printStringOrInt :: (v:string|int) !foreign lua "print"
	printStringOrInt("Hello, Lua!")
	printStringOrInt(123)

	local printStrings :: (...:string) !foreign lua "print"
	printStrings("Hello, ", "Lua!")
	printStrings()
	local print :: (...:any) !foreign lua "print"
	print("Hello", 123, true, "Lua!")
	print()

	local getValues :: () -> string, int { return "GET", 100 }
	print(true, getValues())

	local getVararg :: () -> (...:int) { return 1, 2, 3 }
	local takeThreeMaybe :: (x,y,z:int|nil) {}
	takeThreeMaybe(10, getVararg(), 30)
	takeThreeMaybe(10, 20, (getVararg()))

	local getAtLeastOne :: () -> (x:int, ...:int) { return 1, 2, 3 }
	local takeExactlyThree :: (x:int, y:int, z:int) {}
	takeExactlyThree(10, 20, (getAtLeastOne()))
	takeExactlyThree(10, getAtLeastOne(), 30)

	local takeAndReturnVararg :: (...:int) -> (...:int) {
		local a1, a2 = ...
		local b1, b2 = 1, ...
		local c1, c2 = 1, (...)
		local d1, d2 = ..., 2
		local e1, e2 = (...), 2
		local typeOfVararg = type_of(...) -- Should be int.
		if ... == nil {}
		return ...
	}
	local x, y = takeAndReturnVararg(1, 2, 3)
	local typeOfX :: type_of(x) -- Value should be int|nil.
	local typeOfY :: type_of(y) -- Value should be int|nil.
	local takeOneIntMaybe :: (x:int|nil) {}
	takeOneIntMaybe(x)
	takeOneIntMaybe(y)
	if x ~= nil and y ~= nil {
		local dummy1 :        int|nil = 0
		local dummy2 : string|int|nil = ""
		local x1 = cast(type_of(dummy1)) x
		local y1 = cast(type_of(dummy2)) y
		local x2 = cast(int) x
		local y2 = cast(int) y
		takeAndReturnVararg(x2, y2, x2, y2)
	}

	-- @Incomplete: Make this work (or disallow this specific compound type).
	-- local negateNumber : int|float = 0
	-- negateNumber = -negateNumber
}

--====== Things that should result in an error. ======--

-- local bad:int|string|int = 0 -- Duplicate type.

-- local INT :: int
-- local bad:int|INT = 0 -- Duplicate type.

-- local bad:int|nil -- Missing required value.

local listErrors :: () {
	-- local a   : bool|int       = true
	-- local bad : type_of(a)|int = 0 -- Duplicate type 'int'.

	-- local a   : bool|int       = true
	-- local bad : int|type_of(a) = 0 -- Duplicate type 'int'.

	-- local a   :   bool|int            = true
	-- local b   : string|int            = 0
	-- local bad : type_of(a)|type_of(b) = "" -- Duplicate type 'int'.

	-- local print :: (...:string) !foreign lua "print"
	-- local func  :: () {}
	-- print("a", func()) -- Nothing returned.

	-- local print :: (...:string) !foreign lua "print"
	-- local func  :: () -> string, int { return "GET", 100 }
	-- print("a", func()) -- Type mismatch of 2nd returned value.

	-- local func :: (...:int) {
	-- 	local bad1, bad2 = (...) -- No value for 'bad2'.
	-- }

	-- local x : int|any = 0 -- Cannot include 'any' in compound types. That's useless as 'any' is essentially a compound type that includes all other types!

	-- local func :: (...:int) {
	-- 	local bad = -... -- Vararg value can be nil.
	-- }

	-- local func :: (...:int) {
	-- 	local bad = ...+1 -- Vararg value can be nil.
	-- }
}

local callVsReturnErrors :: () -> bool, int, string {
	-- local func :: () -> int, int { return 1, 1 }
	-- do return true, func() -- Type mismatch for value 3 (call value 2).

	-- local func :: (b:bool, ...:int) {}
	-- local bad  :: () -> int, string { return 1, "" }
	-- func(true, bad()) -- Type mismatch for argument 3 (call value 2).

	-- local func :: (x:int, y:int, z:int) {}
	-- local bad  :: () -> (...:int) { return 1, 2, 3 }
	-- func(0, bad()) -- Non-vararg function cannot take varargs.

	-- local bad  :: () -> (...:int) { return 1, 2 }
	-- local func :: (x:int, y:int) {}
	-- func(10, (bad())) -- Returned vararg gets adjusted to int|nil which func() does not accept.
}
--]]



-- [[ Using.
--------------------------------

local testUsing :: () {
	do {
		local House :: struct {
			HAS_ROOF :: true,
			floors    = 1,
			rooms     = 1,
		}
		local smallHouse:House
		using smallHouse
		local canSeeSky :: not HAS_ROOF
		local moreFloors = floors+1
		rooms = 2
	}

	do {
		local Fish :: struct {
			CAN_SWIM :: true,
			length    = 1,
		}
		using Fish
		local canWalk = not CAN_SWIM
	}

	do {
		local Choice :: enum { A::"a", B::"b", C::"c" }
		using Choice
		local choiceA = A
	}

	do {
		using local Choice :: enum { A::"a", B::"b", C::"c" }
		local choiceA = A

		local SomeStruct :: struct { theChoice=Choice.A }
		local typeVar = SomeStruct

		local getChoice :: () -> type_of(SomeStruct.theChoice) {
			using Choice
			return C
		}
		local myChoice = getChoice()

		local usingArg :: (using some:SomeStruct) {
			theChoice = B
		}
		local mySome:SomeStruct
		usingArg(mySome)
	}
}

--====== Things that should result in an error. ======--

local usingErrors :: () {
	-- do {
	-- 	local Struct :: struct { foo=1 }
	-- 	using Struct
	-- 	local bad = foo -- Undeclared identifier.
	-- }

	-- do {
	-- 	using Struct
	-- 	local Struct :: struct {}
	-- 	using Struct -- Duplicate using in the scope.
	-- }

	-- do {
	-- 	local Struct :: struct { bad::true }
	-- 	using Struct
	-- 	bad = 76 -- Cannot assign to struct member.
	-- }

	-- do {
	-- 	local Enum :: enum { bad::true }
	-- 	using Enum
	-- 	bad = 76 -- Cannot assign to enum member.
	-- }

	-- local Struct :: struct {}
	-- local func :: () -> (using bad:Struct) { return bad } -- Cannot 'using' output arguments.

	-- local func :: (using ...:int) -> () {} -- Cannot 'using' varargs.
}
--]]




-- [[ Arrays and loops.
--------------------------------

local testArraysAndLoops :: () {
	local print  :: (...:any) !foreign lua "print"
	local insert :: (arr:[]int, item:int) !foreign lua "table.insert"

	do {
		local ints : []int
		insert(ints, 5)
		local x      = ints[1]
		local length = #ints
		ints[1]      = 10
	}

	for i = 1, 3  print(i)

	local times = 5
	for 1, times, 2 {
		it = it*2
		print(it)
	}

	do {
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for        ints  print(itIndex, it*it)
		for n    : ints  print(itIndex, n*n)
		for n, i : ints  print(i,       n*n)
	}

	do {
		local inext :: (ints:[]int, i:int) -> int|nil, int {
			-- Array lookups can be compared to nil.
			if ints[i+1] == nil  return nil, 0
			return i+1, ints[i+1]
		}
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for i, n in inext, ints, 0  print("inext", i, n*n)
	}
	do {
		local next :: (t:table, k:any) -> any, any !foreign lua "next"
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for k, v in next, ints, nil  print("next", k, cast(int)(v)^2) -- Note: Arrays are compatible with tables.
	}

	do {
		local IntArrayIterator :: (arr:[]int, i:int) -> (i:int|nil, item:int)
		local ipairs :: (arr:[]int) -> (iter:IntArrayIterator, arr:[]int, init:int) !foreign lua "ipairs"
		local ints : []int
		insert(ints, 10)
		insert(ints, 20)
		for i, n in ipairs(ints)  print("ipairs", i, n*n)
	}

	do {
		local ints : []int = {10,20,30}
		for ints {
			print(it)
			if itIndex == 2  break
		}
		local printLength :: (arr:[]any) {
			print("Length:", #arr)
		}
		printLength({"a","b"})
	}
}

--====== Things that should result in an error. ======--

local arrayAndLoopErrors :: () {
	-- local arr : [][]int
	-- arr[1] = "" -- Type mismatch.

	-- local arr : []int
	-- local bad = arr[1][2] -- Trying to index an int.

	-- for bad = 1, bad {} -- Undeclared identifier.

	-- local arr : []int
	-- local bad :: () {} -- Iterator is missing arguments.
	-- for i, n in bad, arr, 0 {}

	-- local arr : []int
	-- local bad :: (arr:float, i:bool) {} -- Iterator returns nothing.
	-- for i, n in bad, arr, 0 {}

	-- local arr : []int
	-- local bad :: (arr:float, i:bool) -> int {} -- First returned value must include nil.
	-- for i, n in bad, arr, 0 {}

	-- local arr : []int
	-- local bad :: (arr:float, i:bool) -> nil {} -- Interators must return compound type as first value.
	-- for i, n in bad, arr, 0 {}

	-- local arr : []int
	-- local func :: (arr:float, i:bool) -> int|nil {}
	-- for i, n in func, arr, 0 {} -- Too many names for iterator.

	-- local arr : []int
	-- local func :: (arr:float, i:bool) -> int|nil, int {}
	-- for i in func, arr, 0 {} -- Too few names for iterator.

	-- local bad : []int
	-- local func :: (arr:float, i:bool) -> int|nil, int {}
	-- for i, n in func, bad, 0 {} -- Type mismatch for state.

	-- local arr : []int
	-- local func :: (arr:[]int, i:bool) -> int|nil, int {}
	-- for i, n in func, arr, 0 {} -- Type mismatch for control value.

	-- local bad : []nil -- Arrays cannot contain nil.

	-- local i            = 1
	-- local arr:[]string = {[i]="foo"} -- Index is not constant.
}
--]]




-- [[ Misc.
--------------------------------

local testMisc :: () {
	local print    :: (...:any) !foreign lua "print"
	local tostring :: (v:any) -> string !foreign lua "tostring"

	local codepointX = !char "X"
	local codepoint龠 = !char "龠"
	local nonsense:int = codepoint龠-codepointX

	local TableIterator :: (t:table, k:any) -> (k:any, item:any)
	local pairs :: (t:table) -> (iter:TableIterator, t:table, init:any) !foreign lua "pairs"
	local LUA_VERSION:string : !foreign lua "_VERSION"
	local luaEnv:table       = !foreign lua "_G"
	for k, v in pairs(luaEnv) {
		print("_G."..tostring(k), v)
	}

	local FOREIGN_STRING : string : !foreign lua "_VERSION"
	local FOREIGN_ALIAS :: FOREIGN_STRING
	local localString = FOREIGN_ALIAS.." test"
	print("localString", localString)
}

local shadowed1:int
local shadowed2:int
local testShadow :: (shadowed1:int=1 !shadow, x:int=2) {
	local shadowed2:int = 5 !shadow
}

-- @Incomplete: Make this work.
-- local  LOCAL_STRING :: ""
-- global fileScopeShadowingGlobal = LOCAL_STRING
-- local  fileScopeShadowingGlobal = 1 !shadow

--====== Things that should result in an error. ======--

-- local bad:int
-- local func :: () {
-- 	local bad:int : 5 !shadow -- Constants cannot be shadows.
-- }

-- local func :: () {
-- 	local bad:int
-- 	local bad:int !shadow -- Shadows don't work in the scope they're in.
-- }

-- local func :: (bad:int) {
-- 	local bad:int !shadow -- Shadows don't work in the scope they're in. (Function bodies sometimes count as the same scope as the arguments.)
-- }

-- local bad = !foreign lua "_G" -- Types of foreigns cannot be inferred.

-- local BAD:string : ""..!foreign lua "_VERSION" -- No compile-time operations on foreign values.

local miscErrors :: () {
	-- ...
}
--]]


