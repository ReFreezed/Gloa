--
-- Type inference tests.
--



-- [[ Simple declarations.
--------------------------------

local myNum1 : float
local myNum2 :      : 10
local myNum3 : int  : 20
local myNum4        = myNum2
local myNum5 : int  = myNum2
local myTyp1 :      : int
local myTyp2 : type : int

local MyType1 :: int
local MyType2 :: MyType1
local myVar1:MyType1 = 555
local myVar2:MyType2 = 555

local myInt1 = -100
local myInt2 : type_of(myInt1)
local myInt3 : type_of(myInt2) = (3+4)*2

local messyInt1 :: 5
local messyType :: type_of(messyInt1)
local messyInt2:messyType = 10

local double11, double12 : int
local double21, double22                     = 1, 2
local double31, double32 : int               = 1, 2
local double41, double42 : type_of(double22) = 1, 2

local NilType :: !type nil -- Note: The nil type is only really useful in compound types, where !type is not needed.
local iCanOnlyBeNil : NilType = nil

-- @Incomplete:
-- local StringOrNil :: !type string|nil
-- local maybeString:StringOrNil = nil

--====== Things that should result in an error. ======--

-- local bad:int  = "foo" -- Type/value type mismatch.
-- local bad:type = 50    -- Type/value type mismatch.
-- local bad : type_of(myInt1) = "nope" -- Type/value type mismatch.

-- local badVar:BadType3 = 99 -- The int 5 is not a type.
-- local BadType3 :: BadType2
-- local BadType2 :: BadType1
-- local BadType1 :: 5

-- local myVar1 :: string -- Redeclaration.

-- local bad:badType           -- Undeclared type/identifier.
-- local bad:badType(5, int)   -- Undeclared type/identifier.
-- local bad = badVar          -- Undeclared identifier.
-- local bad = badFunc()       -- Undeclared identifier.
-- local bad : type_of(badVar) -- Undeclared identifier.

-- local circularA :: circularB -- Circular dependency. @UX: Better error message.
-- local circularB :: circularA

-- local var =  5
-- local bad :: var -- Value is not const.

-- local bad1 :: bad2 -- (Test that the error message is good.)
-- local bad2 :: nope

-- local bad2 :: nope -- (Test that the error message is good.)
-- local bad1 :: bad2

-- @Incomplete:
-- local Compound :: !type string|nil
-- local bad:Compound : "" -- Constants cannot be compound types.
--]]



-- [[ Functions.
--------------------------------

local theMain :: () -> void {}

local funcTest :: () -> void {
	local oneInTwoOut1 :: (a:int) -> int, int { return a, 2*a }
	local one1, two1, three1 : int = 5, oneInTwoOut1(99)

	local oneInTwoOut2 :: (a:int) -> int, string { return a, "foo" }
	local one2, two2, three2 = 5, oneInTwoOut2(99)

	local mySig :: (arg1:string, arg2,arg3:int) -> bool, string
	local myFunc1:mySig : (arg1:string, arg2,arg3:int) -> bool, string { return true, "foo" }

	local myFunc : (arg1:string,arg2,arg3:int)->bool,string : (arg1:string, arg2,arg3:int) -> bool, string { return true, "" }

	local testFuncReturningFunc :: () {
		local funcReturningFunc :: () -> (n:int)->string {
			return (n:int) -> string {
				return "foo"
			}
		}
		local theString = funcReturningFunc()(5)
	}

	local getTwo    :: () -> int, int      { return 1, 2 }
	local getThree1 :: () -> int, int, int { return 1, getTwo() }
	local getThree2 :: () -> int, int, int { return 1, getTwo(), 3 }
	local getThree3 :: () -> int, int, int { return 1, 2, (getTwo()) }

	local recursive :: () -> int { return recursive() }

	local first :: () {}
	local same  :: first

	local someFunc1 :: () -> void {}
	local someFunc2 : type_of(someFunc1) = someFunc1
}

--====== Things that should result in an error. ======--

-- local func :: () -> int { return 5 }
-- local bad  =  func() -- Not a constant expression in declarative scope.

local funcErrors :: () {
	-- local oneInNoneOut :: (a:int) { return }
	-- local x, y, z : int = 5, oneInNoneOut(99) -- Nothing for y (nor z).

	-- local oneInOneOut :: (a:int) -> int { return a }
	-- local x, y, z : int = 5, oneInOneOut(99) -- Nothing for z.

	-- local func :: (a:int) -> int, string { return a, "foo" }
	-- local x, y, z : int = 5, func(99) -- Type mismatch for 'z'.

	-- local sig :: (arg1:string, arg2:int) -> bool, string
	-- local func:sig : (arg1:string, arg2,arg3:int) -> bool, string {} -- Incorrect function signature.

	-- local sig :: (arg1:string, arg2,arg3:string) -> bool, string
	-- local func : sig : (arg1:string, arg2,arg3:int) -> bool, string {} -- Incorrect function signature.

	-- local mySig :: (a:int,b:nope)  -- Undeclared identifier.
	-- local mySig :: (a:int) -> nope -- Undeclared identifier.

	-- local func :: () -> () {}
	-- local bad  =  func() -- No return arguments.

	-- local func :: () -> (n:int)->string {}
	-- local bad  =  func()(5)() -- Trying to call a string.

	-- local func :: () -> ()->string {
	-- 	return ()->string { return bad } -- Undeclared identifier.
	-- }

	-- local func :: () {}
	-- local bad  :: () -> int { return func() } -- Too few values.

	-- local func :: () -> int { return 1 }
	-- local bad  :: () -> int, int { return func() } -- Too few values.

	-- local func :: () {}
	-- local bad  :: () -> int { return (func()) } -- No resulting value in parenthesis.

	-- local func :: () -> int, int { return 1, 2 }
	-- local bad  :: () -> int, int { return 1, func() } -- Too many values.

	-- local func :: () -> string, int { return "", 2 }
	-- local bad  :: () -> int, int, int { return 1, func() } -- Returning wrong type.

	-- local func :: () -> int, string { return 1, "" }
	-- local bad  :: () -> int, int, int { return 1, func() } -- Returning wrong type.

	-- local func :: (a:int) -> int { return a }
	-- local bad  =  func() -- Missing args.

	-- local func :: (a:int) -> int { return a }
	-- local bad  =  func(1, 2) -- Too many args.

	-- local func :: (a:int) -> int { return a }
	-- local bad  =  func("nope") -- Wrong type.

	-- local Bad  :: struct {}
	-- local func :: (a:Bad) -> int { return a } -- Wrong type.

	-- local func : () -> int
	-- func = () -> int { return func() } -- func is not const, thus invisible in the body. @UX: Improve error message.

	-- local func :: () {}
	-- func(func()) -- Function returns nothing. (Could work here, but looks weird!)
}
--]]



-- [[ Structs and enums.
--------------------------------

local MyStruct1 :: struct {
	m1     = 0,
	m2:int,
	m3:int = 10,
	-- m4 :: () { local m2 = true }, -- @Incomplete: Make this work.
}
local m1 = 4

local MyStruct2 :: struct { a:IntAlias }
local IntAlias  :: int

local MyVecType :: struct { x:int; y:int, z:int }
local myVec1:MyVecType

local EntityType :: enum {
	PLAYER  :: 0x01,
	MONSTER :: 0x02;
	BUTTON  :: 0x03,
	DOOR    :: 0x04
}

local MELEE_NAME :: "Knight"
local ClassName :: enum string {
	MELEE  :: MELEE_NAME,
	RANGED :: "Archer",
	MAGIC  :: "Mage",
}
local myClass:ClassName

-- @Incomplete: Struct initialization.
-- local Vector3 :: struct { x:int; y:int, z:int }
-- local myVec3:Vector3 = {x=1}

-- @Incomplete: Using 'self' type for a member.
-- local Foo :: struct { a:Foo }

--====== Things that should result in an error. ======--

-- local bad :: struct {a:nope} -- Undeclared type/identifier.

-- local myVec2:MyVecType = MyVecType -- Type/value type mismatch.
--]]



-- [[ Operations.
--------------------------------

local unary = -5
local True  = not not true

local binary = 1+2*3

local divNum = 3/8
local divInt = 6.8 // 3.11

local advanced = 1 + 2 * 3 // 4^5 % 6

local lessInt = 5 < 1
local lessStr = "foo" < "bar"
local equal   = ("foo" == "bar") ~= false or false

local EIGHT : int : cast(int) (2.0 ^ 2.0) * 2
local TAU   :     : 3.14 * cast(type_of(5.0)) (EIGHT // 4)

-- @Incomplete: Look-ups.

local testCasts :: () {
	-- @Incomplete: Casting compound types.
	-- local dummy:int|nil = 0
	-- local Dummy :: type_of(dummy)
	-- -- local Dummy :: !type int|nil -- @Incomplete: Handle pipes here.
	-- local getCompound :: () -> Dummy { return 5 }
	-- -- local getCompound :: () -> int|nil { return 5 } -- @Incomplete: Handle pipes here.
	-- local x      = cast(int) getCompound()
	-- local xMaybe = cast(Dummy) x
	-- -- local xMaybe = cast(int|nil) x -- @Incomplete: Handle pipes here.
}

--====== Things that should result in an error. ======--

-- local bad = "nope" + "nooope"

-- local bad  = ""
-- local nope = -bad

-- local bad = cast(int) "nope"
--]]



-- [[ Blocks.
--------------------------------

local blocks :: () {
	local answer:int = 42
	answer = answer+1

	blocks()

	local returnArg :: (a:int) -> int { return a }
	returnArg(5)

	-- Lexical visibility.
	do {
		do {
			local blockVar = 1
		}
		local blockVar = 2
	}
	local blockVar = 3

	inner()
	local inner :: () {} -- Constants have higher visibility than dynamic variables.
}

--====== Things that should result in an error. ======--

local blockErrors :: () {
	-- local bad:int = bad -- Undeclared identifier. @UX: Better error message.

	-- bad = 5 -- Undeclared identifier.
	-- local bad:int

	-- blockErrors()() -- Trying to call void.
	-- local bad = blockErrors() -- No return value.

	-- local func :: (a:int) -> int { return a }
	-- func("nope") -- Wrong type.

	-- local func :: () -> int { return 5 }
	-- local var  =  func()
	-- local bad  :: 2*var -- Not a constant expression.

	-- local func :: () -> int { return 5 }
	-- local bad  :: func() -- Calls are not constant.
}
--]]



-- [[ Multiple files.
--------------------------------

!load "tests/types.load.gloa"

global myGlobalFunc :: () {}

local useImportedNamespace :: () {
	funcInOtherFile(5)
}

-- @Incomplete: Module namespace references.
-- local lib :: !import "test"

--====== Things that should result in an error. ======--

-- !load "tests/types.errorGlobal.gloa"
-- local other :: () {} -- Global defined in other file.

-- !load "tests/types.errorLocal.gloa"
-- global other :: () {} -- Shadowed in other file.

-- @Incomplete
-- local bad:type_of( !import "test" ) -- Namespaces don't have a type.

-- @Incomplete
-- local foo :: !import "test"
-- local bad:type_of(foo) -- Namespaces don't have a type.
--]]



-- [[ Lists of things.
--------------------------------

local lists :: () {
	local printString :: (s:string) -> void !foreign lua "print"
	printString("Hello, Lua!")

	local printAny :: (v:*) -> void !foreign lua "print"
	printAny("Hello, Lua!")
	printAny(123)

	local maybeInt1        : int|nil                   = 0
	local maybeInt2        : type_of(maybeInt1)        = 0
	local maybeIntOrString : type_of(maybeInt1)|string = ""

	local printStringOrInt :: (v:string|int) -> void !foreign lua "print"
	printStringOrInt("Hello, Lua!")
	printStringOrInt(123)

	local printStrings :: (...:string) -> void !foreign lua "print"
	printStrings("Hello, ", "Lua!")
	printStrings()
	local print :: (...:*) -> void !foreign lua "print"
	print("Hello", 123, true, "Lua!")
	print()

	local getValues :: () -> string, int { return "GET", 100 }
	print(true, getValues())

	local getVararg :: () -> (...:int) { return 1, 2, 3 }
	local takeThreeMaybe :: (x,y,z:int|nil) {}
	takeThreeMaybe(10, getVararg(), 30)
	takeThreeMaybe(10, 20, (getVararg()))

	local getAtLeastOne :: () -> (x:int, ...:int) { return 1, 2, 3 }
	local takeExactlyThree :: (x:int, y:int, z:int) {}
	takeExactlyThree(10, 20, (getAtLeastOne()))
	takeExactlyThree(10, getAtLeastOne(), 30)

	local takeAndReturnVararg :: (...:int) -> (...:int) {
		local a1, a2 = ...
		local b1, b2 = 1, ...
		local c1, c2 = 1, (...)
		local d1, d2 = ..., 2
		local e1, e2 = (...), 2
		local typeOfVararg = type_of(...) -- Should be int|nil.
		return ...
	}
	local x, y = takeAndReturnVararg(1, 2, 3)
	local typeOfX :: type_of(x) -- Should be int|nil.
	local typeOfY :: type_of(y) -- Should be int|nil.
	local takeOneIntMaybe :: (x:int|nil) {}
	takeOneIntMaybe(x)
	takeOneIntMaybe(y)
	takeAndReturnVararg(x, y, x, y)
}

--====== Things that should result in an error. ======--

-- local bad:int|string|int = 0 -- Duplicate type.

-- local INT :: int
-- local bad:int|INT = 0 -- Duplicate type.

-- local bad:int|nil -- Missing required value.

local listErrors :: () {
	-- local a   : bool|int       = true
	-- local bad : type_of(a)|int = 0 -- Duplicate type 'int'.

	-- local a   : bool|int       = true
	-- local bad : int|type_of(a) = 0 -- Duplicate type 'int'.

	-- local a   :   bool|int            = true
	-- local b   : string|int            = 0
	-- local bad : type_of(a)|type_of(b) = "" -- Duplicate type 'int'.

	-- local print :: (...:string) -> void !foreign lua "print"
	-- local func  :: () {}
	-- print("a", func()) -- Nothing returned.

	-- local print :: (...:string) -> void !foreign lua "print"
	-- local func  :: () -> string, int { return "GET", 100 }
	-- print("a", func()) -- Type mismatch of 2nd returned value.

	-- local func :: (...:int) {
	-- 	local bad1, bad2 = (...) -- No value for 'bad2'.
	-- }
}

local varargAndReturnErrors :: () -> bool, int, string {
	-- local func :: () -> int, int { return 1, 1 }
	-- do return true, func() -- Type mismatch for value 3 (call value 2).

	-- local func :: (b:bool, ...:int) {}
	-- local bad  :: () -> int, string { return 1, "" }
	-- func(true, bad()) -- Type mismatch for argument 3 (call value 2).

	-- local func :: (x:int, y:int, z:int) {}
	-- local bad  :: () -> (...:int) { return 1, 2, 3 }
	-- func(0, bad()) -- Non-vararg function cannot take varargs.

	-- local bad  :: () -> (...:int) { return 1, 2 }
	-- local func :: (x:int, y:int) {}
	-- func(10, (bad())) -- Returned vararg gets adjusted to int|nil which func() does not accept.
}
--]]



-- [[ Misc.
--------------------------------

local misc :: () {
	local codepointX = !char "X"
	local codepoint龠 = !char "龠"
	local nonsense:int = codepoint龠-codepointX
}

local shadowed1:int
local shadowed2:int
local testShadow :: (shadowed1:int=1 !shadow, x:int=2) {
	local shadowed2:int = 5 !shadow
}

--====== Things that should result in an error. ======--

-- local bad:int
-- local func :: () {
-- 	local bad:int : 5 !shadow -- Constants cannot be shadows.
-- }

-- local func :: () {
-- 	local bad:int
-- 	local bad:int !shadow -- Shadows don't work in the scope they're in.
-- }

-- local func :: (bad:int) {
-- 	local bad:int !shadow -- Shadows don't work in the scope they're in. (Function bodies sometimes count as the same scope as the arguments.)
-- }
--]]


