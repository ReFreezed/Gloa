--
-- Type test.
--



-- [[ Simple declarations.
--------------------------------

local myNum1      = 10
local myNum2:int  = 20
local myNum3      = myNum2
local myNum4:int  = myNum1
local myTyp1      = int
local myTyp2:type = int

local MyType1 :: int
local MyType2 :: MyType1
local myVar1:MyType1 = 555
local myVar2:MyType2 = 555

local myInt1 = 100
local myInt2 : typeOf(myInt1)
local myInt3 : typeOf(myInt2) = 7

local double11, double12 : int
local double21, double22                    = 1, 2
local double31, double32 : int              = 1, 2
local double41, double42 : typeOf(double22) = 1, 2

---- Things that should result in an error.

-- local bad:int  = "foo" -- Type/value type mismatch.
-- local bad:type = 50    -- Type/value type mismatch.
-- local bad : typeOf(myInt1) = "nope" -- Type/value type mismatch.

-- local badVar:BadType3 = 99 -- The int 5 is not a type.
-- local BadType3 :: BadType2
-- local BadType2 :: BadType1
-- local BadType1 :: 5

-- local myVar1 :: string -- Redeclaration.

-- local bad:badType -- Undefined type/identifier.
-- local bad:badType(5, int) -- Undefined type/identifier.
-- local bad = badVar -- Undefined identifier.
-- local bad = badFunc() -- Undefined identifier.
-- local bad : typeOf(badVar) -- Undefined identifier.

-- local a:b -- Circular dependency.
-- local b:a
--]]



-- [[ Functions.
--------------------------------

local main :: () -> void {}

local oneInTwoOut1 :: (a:int) -> int, int { return a, 2*a }
local one1, two1, three1 : int = 5, oneInTwoOut1(99)

local oneInTwoOut2 :: (a:int) -> int, string { return a, 2*a }
local one2, two2, three2 = 5, oneInTwoOut2(99)

local mySig :: (arg1:string, arg2,arg3:int) -> bool, string
local myFunc1:mySig : (arg1:string, arg2,arg3:int) -> bool, string {}

local myFunc2 : (arg1:string,arg2,arg3:int)->bool,string : (arg1:string, arg2,arg3:int) -> bool, string {}

local funcReturningFunc :: () -> (n:int)->string {}
local theString :: funcReturningFunc()(5)

---- Things that should result in an error.

-- local oneInNoneOut :: (a:int) { return }
-- local x, y, z : int = 5, oneInNoneOut(99) -- Nothing for y (nor z).

-- local oneInOneOut :: (a:int) -> int { return a }
-- local x, y, z : int = 5, oneInOneOut(99) -- Nothing for z.

-- local func :: (a:int) -> int, string { return a, "foo" }
-- local x, y, z : int = 5, func(99) -- Type mismatch for 'z'.

-- local mySig2 :: (arg1:string, arg2:int) -> bool, string
-- local myFunc2:mySig2 : (arg1:string, arg2,arg3:int) -> bool, string {}

-- local mySig3 :: (arg1:string, arg2,arg3:string) -> bool, string
-- local myFunc3:mySig3 : (arg1:string, arg2,arg3:int) -> bool, string {}

-- local mySig :: (a:int,b:nope) -- Undefined identifier.

-- local func :: () -> () {}
-- local bad  =  func() -- No return arguments.

-- local func :: () -> (n:int)->string {}
-- local bad  =  func(5)()() -- Trying to call a string.

-- @Incomplete:
-- local func :: (a:int) -> int { return a }
-- local bad  =  func() -- Missing intput args for func().
--]]



-- [[ Structs and enums.
--------------------------------

local MyStruct1 :: struct {
	m1     = 0,
	m2:int,
	m3:int = 10,
}

local MyStruct2 :: struct { a:IntAlias }
local IntAlias  :: int

local MyVecType :: struct { x:int; y:int, z:int }
local myVec1:MyVecType

local EntityType :: enum {
	PLAYER  :: 0x01,
	MONSTER :: 0x02;
	BUTTON  :: 0x03,
	DOOR    :: 0x04
}

local MELEE_NAME :: "Knight"
local ClassName :: enum string {
-- local ClassName : type : enum string {
	MELEE  :: MELEE_NAME,
	RANGED :: "Archer",
	MAGIC  :: "Mage",
}
local myClass:ClassName

-- @Incomplete: Struct initialization.
-- local Vector3 :: struct { x:int; y:int, z:int }
-- local myVec3:Vector3 = {x=1}

---- Things that should result in an error.

-- local bad :: struct {a:nope} -- Undefined identifier.

-- local myVec2:MyVecType = MyVecType -- Type/value type mismatch.
--]]


